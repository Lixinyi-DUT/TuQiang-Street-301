<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/2/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-no-feminism-on-zhihu" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/Introduction/no-feminism-on-zhihu/">新年展望：不再在知乎谈任何女性权益问题</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/Introduction/no-feminism-on-zhihu/" class="article-date"><time datetime="2019-02-14T07:17:05.154Z" itemprop="datePublished">2019-02-14</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Introduction/">Introduction</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Es gibt keine Wahrheit außerhalb der Liebe.</p>
</blockquote>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/undefined/block.png" alt="放到“申诉”按钮上显示的是“不可申诉”"></p>
<p>立一个flag：再在简体中文网络社区谈论任何女权或感情问题就出女装照片。</p>
<p>&lt;!-- more --&gt;</p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Warning</h4>
<p>这是我最后一次公开发表相关话题内容。全文<strong>不会</strong>给出任何事实论据，数据，例证或推理演绎，只会随心所欲的表达零散的观点，能理解自然可以理解，不能理解或认为有错误也没有任何反驳的必要，浪费了你宝贵的时间我很抱歉，就当看了一些荒唐无趣的冷笑话吧。</p>
</div></p>
<p>简汉网，尤其是知乎这样自我审查严格的地方，不是适合讨论女性权益话题的地方，甚至把话说的再危险一点，简体中文网络社区所依托的现实环境就并不欢迎任何人去关注和追求真实的本质的权利，知乎只是现实的一个投射。</p>
<p>所谓对女性权益的关注和争论，最终还是落到了异性恋婚恋分赃的一亩三分地。看上去知乎好像对这类话题很开明，知乎用户们也积极的参与着这样的讨价还价，甚至还骗自己去说这就是自己为自己性别在争取利益的方式。所谓“高端”社区的官方运营团队自己提出了一个婊点满满的提问：<a href="https://www.zhihu.com/question/58896903/answer/304443087" target="_blank" rel="noopener">现在的男生为什么不追求女生？</a></p>
<blockquote>
<p>知乎推出来的地铁广告，但是知乎上却没有与广告一模一样的提问，我是填补这一空白的。今天是2017年4月23日。
（问题日志）</p>
</blockquote>
<p>利用男性用户们的婚恋焦虑来提高社区热度，拿着这些恋爱挫折来控诉当代女性的“地位过高”对自己的压迫。同样可以看到知乎大部分女性哭惨也只是在哭一些婚恋中鸡毛蒜皮的小事，比如移情别恋，比如男性看脸的择偶观，比如根本不该存在的生育权扯皮，比如根本不该存在的婆媳矛盾……</p>
<p>我把这些东西通通称为没有啃到肉的小打小闹，并不是说这些被控诉的人的做法是没有问题的，但显然不该是今天这样疯狂的遮掩了其他本质问题的热度。</p>
<p>真正涉及权利和权力的社会运动，NGO因为众所周知的原因无法在这片土地上生长，自然也很难去为改善部分女性的生活现状做出什么实事。网络社区更是神经紧绷地不允许相关讨论。</p>
<p>和政治关系不大的，切实能改善女性生活的，比如Women in STEM或者具体说Girls Who Code这样的项目，尽管有大量的前辈已经投入了这些活动并推行，但在流量为王的社区里还是溅不起一丝水花，快速的被淹没在了“该不该给女友买包”“老婆不是处女怎么办”&quot;该不该要彩礼&quot;这类无聊的垃圾话题中。用户自己喜欢被喂垃圾，甚至为了心安理得的吃垃圾还编造了各种各样正义的理由（比如<a href="https://www.zhihu.com/question/290907784" target="_blank" rel="noopener">为什么那么多女生喜欢晒自己的腿、胸、脸等和自己努力无关的东西？她们不尴尬吗？</a>问题下所有为关注/输出色情擦边球低质量内容的辩护），然后持续的关注垃圾内容而忽略了真正该关注的信息，最后竟然莫名其妙的反怼为什么女权主义者不去帮助女性在其他领域发展而总是在婚恋问题上发言（<a href="https://zhuanlan.zhihu.com/p/53422679" target="_blank" rel="noopener">“女权主义者”的一个卑劣之处</a>）&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。真是完美的逻辑闭环。</p>
<p>《1984》与《美丽新世界》并存于这个世界。知乎公敌咪蒙在《独唱团》时期也是一个理想主义的作家，在看清楚当下的创作环境后，决定写一些<strong>安全</strong>的，群众喜欢看的<strong>话题</strong>，注意我没有说是群众喜欢看的观点或内容，实际上知乎/微博大部分用户非常讨厌她的观点，但还坚持关注和讨论她的“作品”，正是因为她关于婚恋内容的作品非常挠大众的痛点，而她在公众号上其他方面如人际/社会新闻/政治方面的观点明明更加恶劣低质的多，却很少有人去注意。咪蒙至少还曾经为“理想”活过，大部分人一开始就浑浑噩噩的在垃圾话题上无脑的吸食着和咪蒙立场内容一致或相反的鸦片度日。</p>
<p>讨论也好，行动也好，都是带着镣铐起舞。有意义的方向不安全，没有关注度，于是双方不断被逼退到安全流行却没有营养的婚恋鸡毛蒜皮的撕扯上，劝退了不屑或不擅长这些话题的用户，然后乐此不疲的互相喂垃圾互相比烂。</p>
<p>当一个少女惴惴不安的来到这样的社区，或者询问现实中身边的亲友长辈，怎样对看待一些社会上的性别不平等问题，多半会得到这样一个具有中国传统文化特色的回答</p>
<p>“做好你自己的事，好好读书，好好工作，主动担负起家庭责任，多为社会创造价值，少去折腾那些虚头巴脑的东西，多干实事，这样别人自然会尊重你，不会歧视你，当个好女孩，就能收获美满的婚姻幸福一生。”</p>
<p>先不说把诉求狭隘化解读的概念性问题，只谈实际操作的困难：大家都是在这个社会环境中成长的，各自心知肚明中国是怎样的文化环境：希望别人成为不给自己添麻烦的安静的供养者，却不会真正的去欣赏内向而勤劳的人，不会给他们过多的实质性的回馈。善于表达自己的诉求，善于利用他人心理缺陷的人，哪怕只是虚张声势，也比木讷踏实的“老实人”更容易获得实际利益。要求女性去以更强大的能力去适应旧性别分工体系下的性别角色，闭口不谈结构性问题的解决，只会让她们更多的造血来默默供养这个体系，证明这个体系不作任何修正依然可以很好运行，要不要修正全靠良心了。另外，这样心口不一的文化特色也完美在知乎的社区文化上体现了，官方和大部分用户嘴上都是声称着想看“干货”，崇拜知识，却对持续产出干货的答主并没有足够的尊重和关注，也并不会真正去吸收消化干货，只是想给自己一个“热爱知识”的虚假高端人设，身体很诚实的去为无聊的垃圾话题提供了流量。海外华裔们哭诉着自己明明是安分勤劳的模范移民，为何待遇远逊于其他懒惰但会哭闹会运动会表达的族群？厌恶外向文化，希望别人主动来体谅自己的痛苦，那么别人只会心怀侥幸的觉得不管你也没有问题，你看你这不挺好的吗？</p>
<p>所以这个问题如果问我怎么回答，我也只能回答我不知道，我也很绝望。当前这个环境下如果戴着镣铐可以起舞那也不错了，更可怕的是因为长期的被圈养开始习得性无助，把内卷当成新常态来规训新的一代，一些有意义的历史因为不可描述的原因被淡忘，然后获得一个简单的，不痛苦的，安全的，没有任何纵深的世界观。我很反感无聊的“求生欲”游戏，我反对它的立场是因为我认为任何性别任何关系的成年人之间都不应该以故意给对方制造困难为乐，这是在浪费双方的生命，我在一定程度上认同<a href="https://www.zhihu.com/question/266045183/answer/337792896" target="_blank" rel="noopener">男生的求生欲很强是一种什么样的表现？</a>回答的大部分内容，但如果假设这位答主是真诚的思考“求生欲”文化而非故意面向流量的煽动情绪写作，那么最后一段体现出来的问题就已经非常严重了：</p>
<blockquote>
<p>我再说更难听的一句话，这个国家男女不平等，应该追根溯源到每对情侣恋爱的时候，光在工作、婚姻中去平权，完全是治标不治本的蠢事，很多男女不平等，在他们恋爱期间就埋下了种子，长成了大树，始于一次次让他无奈又必须完成的、你觉得超甜的小游戏。</p>
</blockquote>
<p>在长期自我阉割的文化中，一个受过不错的高等教育的人，已经开始倒置因果，经过思考得出女性在恋爱期间的“作”是才是不平等的根源的结论，甚至还推广出这个国家的男女不平等是因为每对情侣相处时的“作”积累出来的，工作和婚姻中平等的权利变成了标，恋爱中相处的这种无聊的小事反而成了本……我不想再在这里强调到底什么是因什么是果，如果你到现在还认同他的这段说辞，那也确实没有再看下去的必要了。我也无意于批判这位答主个人，我只是觉得很失望，也很可怕，这样下去，很多能“啃到肉”的议题逐渐会成为无人敢或者愿意去触碰的禁忌，把它们的存在视为理所当然，一步步框死“可以公开讨论的内容”，把话题限制在没有价值的细枝末节上，甚至让人天真的认为在这些琐事上做到了恪守规范还能反向撼动某些上层建筑……</p>
<p>所以，我觉得在这样的环境，这样的讨论氛围下，去探讨任何稍有feminism意味的问题都会不可避免的堕落滑向细碎无趣，毫无逻辑的异性恋婚恋讨价还价，参与的越多，恶化越严重，本文就是我全部的立场，在我想法改变之前所有强行要求我在相关议题下发表评论者我只会拿出本文。同样，怎样去强调“做好自己”也都不会撼动某些扭曲现状的存在，只是教你如何通过麻木来缓解痛苦，通过自我欺骗假设自己已经生活在一个公正昌明的时代，信仰着“努力就会有回报”这样的公正世界假说来锻炼作为韭菜的自我修养。</p>
<p>同样，我也不会在任何公开社区在任何人的感情问题上指点江山，包括我自己的。我不认为我一个规划看Type Systems都综述拖了大半年的人，有任何资格去谈自己能为所谓的爱付出什么，只有自我感动式的空想，那么我的任何感情都不存在价值，不值得被表达。同样，我也认为对于主体性残缺的人，生存在当下的文化环境，也很难真正互相产生所谓的爱，不妨各自都直白一点，不要再躲在这个名号下互相迫真自演了。</p>
<p>虽然今天是2月14日，虽然我在开头引用了Pascal那句“除了爱以外没有真理”，但实际上我能给出唯一的建议只是：不要陷落于任何他人的叙事，对任何他人的叙事都保持警惕，包括“爱情”神话本身，包括本文，尽早构造出属于自己的叙事。</p>
<p>数学和物理工作者喜欢谈“品味”，文学工作者喜欢谈“立意”和“格局”，我曾经在最后祝福我自以为深爱过的人时候也借助了这种叙事：</p>
<blockquote>
<p>请你去追求真正美丽自由的东西吧！</p>
</blockquote>
<p>我虽然不知道他是否真正理解过我这句话的意思。我今天同样用在这里，我希望每个认真读到这里的人也开始有意识的强迫自己去接触一些真正自由美丽的东西，不要满足于互相喂垃圾还一边问为什么这么多垃圾，主动去消化吸收一些富有灵性的东西，尽管它们有时是艰涩且反直觉的，主动去做一些有价值的工作而不是无聊的内卷，勇敢的输出表达自我的叙事。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;此文作者从知乎动态上推断并没有任何编程背景，也并不关注任何行业内动态，大部分时间都花在研究狭义的婚恋关系上，从很多回答如&lt;a href=&quot;https://www.zhihu.com/question/56776247/answer/573144007&quot;&gt;做男人好还是做女人好？&lt;/a&gt;把Goldbach conjecture当成“有意义”的数学问题这种行为来看，很可能连number theroy根本就没入门。固然术业有专攻，不管他是否真的关注过编程界，是否有基本的业内常识判断能力，我们不能随意剥夺别人上网发表观点的资格，他愿意关注什么也都是他的自由，但我认为一个根本没有任何编程背景的人依靠脑补指责“没有女权主义者帮助女性学习编程，都只是在帮她们争取作为妻子和女朋友的福利”，这种行为就很可笑。&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/Introduction/no-feminism-on-zhihu/" data-id="cjuh9fxge005mu0w3beeho97v" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-123" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-123/">LeetCode Weekly Contest 123</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-123/" class="article-date"><time datetime="2019-02-10T08:22:05.047Z" itemprop="datePublished">2019-02-10</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-123</p>
<p>&lt;!-- more --&gt;</p>
<h2>Add to Array-Form of Integer</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-123/problems/add-to-array-form-of-integer/</p>
<blockquote>
<p>For a non-negative integer <code>X</code>, the <em>array-form of <code>X</code></em> is an array of its digits in left to right order.  For example, if <code>X = 1231</code>, then the array form is <code>[1,2,3,1]</code>.</p>
</blockquote>
<blockquote>
<p>Given the array-form <code>A</code> of a non-negative integer <code>X</code>, return the array-form of the integer <code>X+K</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,0,0], K = 34</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Explanation: 1200 + 34 = 1234</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,4], K = 181</span><br><span class="line">Output: [4,5,5]</span><br><span class="line">Explanation: 274 + 181 = 455</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,1,5], K = 806</span><br><span class="line">Output: [1,0,2,1]</span><br><span class="line">Explanation: 215 + 806 = 1021</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">Output: [1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Explanation: 9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>：</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 9</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
<li>If <code>A.length &gt; 1</code>, then <code>A[0] != 0</code></li>
</ol>
<p>字符串和数字间的转换，不多说了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToArrayForm</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = <span class="string">''</span>.join(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> A)</span><br><span class="line">        res = int(n) + K</span><br><span class="line">        <span class="keyword">return</span> [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> str(res)]</span><br></pre></td></tr></table></figure></p>
<h2>Satisfiability of Equality Equations</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-123/problems/satisfiability-of-equality-equations/</p>
<blockquote>
<p>Given an array equations of strings that represent relationships between variables, each string <code>equations[i]</code> has length <code>4</code> and takes one of two different forms: <code>&quot;a==b&quot;</code> or <code>&quot;a!=b&quot;</code>.  Here, <code>a</code> and <code>b</code> are lowercase letters (not necessarily different) that represent one-letter variable names.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We could assign a = 1 and b = 1 to satisfy both equations.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> and <code>equations[i][3]</code> are lowercase letters</li>
<li><code>equations[i][1]</code> is either <code>'='</code> or <code>'!'</code></li>
<li><code>equations[i][2]</code> is <code>'='</code></li>
</ol>
<p>用union find把有<code>==</code>关系的变量合并起来，再检查满足<code>!=</code>关系的变量是否在同一个连通分支：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span><span class="params">(self, equations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type equations: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        parent = list(range(<span class="number">26</span>))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">while</span> parent[y] != y:</span><br><span class="line">                y = parent[y]</span><br><span class="line">            parent[x] = y</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            x, y = find(x), find(y)</span><br><span class="line">            parent[y] = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> eq <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> eq[<span class="number">1</span>] == <span class="string">'='</span>:</span><br><span class="line">                union(int(ord(eq[<span class="number">0</span>]) - ord(<span class="string">'a'</span>)), int(ord(eq[<span class="number">3</span>]) - ord(<span class="string">'a'</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ineq <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> ineq[<span class="number">1</span>] == <span class="string">'!'</span>:</span><br><span class="line">                <span class="keyword">if</span> find(int(ord(ineq[<span class="number">0</span>]) - ord(<span class="string">'a'</span>))) == find(int(ord(ineq[<span class="number">3</span>]) - ord(<span class="string">'a'</span>))):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Broken Calculator</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-123/problems/broken-calculator/</p>
<blockquote>
<p>On a broken calculator that has a number showing on its display, we can perform two operations:</p>
</blockquote>
<ul>
<li><strong>Double</strong>: Multiply the number on the display by 2, or;</li>
<li><strong>Decrement</strong>: Subtract 1 from the number on the display.</li>
</ul>
<blockquote>
<p>Initially, the calculator is displaying the number <code>X</code>.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of operations needed to display the number <code>Y</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 2, Y = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Use double operation and then decrement operation &#123;2 -&gt; 4 -&gt; 3&#125;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 5, Y = 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Use decrement and then double &#123;5 -&gt; 4 -&gt; 8&#125;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 3, Y = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:  Use double, decrement and double &#123;3 -&gt; 6 -&gt; 5 -&gt; 10&#125;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 1024, Y = 1</span><br><span class="line">Output: 1023</span><br><span class="line">Explanation: Use decrement operations 1023 times.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= X &lt;= 10^9</code></li>
<li><code>1 &lt;= Y &lt;= 10^9</code></li>
</ol>
<p>先找到一个<code>n</code>使得<code>2^(n-1)*X &lt; Y &lt;= 2^n*X</code>，然后考虑<code>n</code>次翻倍操作后如何减到<code>Y</code>，众所周知，对翻倍的最终结果减去<code>2*x</code>相当于在最后一次翻倍前先做<code>x</code>次减1再翻倍，越早做的减1操作反映到最终结果的影响越大，在第一次翻倍前<code>x</code>次减1会在最后成为<code>-x*2^n</code>，因此对于<code>2^n*X-Y</code>只要考虑最少能拆成多少个<code>2^i</code>并且有<code>i&lt;=n</code>：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brokenCalc</span><span class="params">(self, X, Y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type X: int</span></span><br><span class="line"><span class="string">        :type Y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Z, n = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> X * Z &lt; Y:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            Z = <span class="number">1</span> &lt;&lt; n</span><br><span class="line"></span><br><span class="line">        res, rem = n, X * Z - Y</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            Z = <span class="number">1</span> &lt;&lt; n</span><br><span class="line">            <span class="keyword">if</span> rem &gt;= Z:</span><br><span class="line">                res += rem / Z</span><br><span class="line">                rem %= Z</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Subarrays with K Different Integers</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-123/problems/subarrays-with-k-different-integers/</p>
<blockquote>
<p>Given an array <code>A</code> of positive integers, call a (contiguous, not necessarily distinct) subarray of <code>A</code> good if the number of different integers in that subarray is exactly <code>K</code>.</p>
</blockquote>
<blockquote>
<p>(For example, <code>[1,2,3,1,2]</code> has <code>3</code> different integers: <code>1</code>, <code>2</code>, and <code>3</code>.)</p>
</blockquote>
<blockquote>
<p>Return the number of good subarrays of <code>A</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,1,2,3], K = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,1,3,4], K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>1 &lt;= A[i] &lt;= A.length</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ol>
<p>我一开始用动态规划<code>o(n^2)</code>找从第<code>i</code>元素到当前位置组成的子数组共有多少个不同的数，并存放在<code>dp[i]</code>：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        pre = [<span class="number">0</span>] * n</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            pre[i] = d.get(num, <span class="number">-1</span>)</span><br><span class="line">            d[num] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            k = pre[i] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k, i + <span class="number">1</span>):</span><br><span class="line">                dp[j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j] == K:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>不出所料的TLE了，最后参考了<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window" target="_blank" rel="noopener">[Java/C++/Python] Sliding Window</a>的做法：</p>
<p>先定义一个<code>at_most_k</code>函数来计算所有<strong>至多</strong>有<code>k</code>个不同元素的子数组的个数：用<code>count</code>计数目前窗口（最长子数组）中每个元素出现的次数，当<code>i</code>增大即不断向后遍历添加元素使得不同元素数量超过<code>k</code>时，子数组的起始位置<code>start</code>开始向后前进，直至子数组中的不同元素减到<code>k</code>。每次<code>i</code>增大时，会增加<code>i-start+1</code>个以<code>i</code>位置结尾的新的子数组。</p>
<p>最后返回<code>at_most_k(K)-at_most_k(K-1)</code>为正好有<code>K</code>个不同元素的子数组的数量。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysWithKDistinct</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">at_most_k</span><span class="params">(K)</span>:</span></span><br><span class="line">            n = len(A)</span><br><span class="line">            start = res = <span class="number">0</span></span><br><span class="line">            count = collections.Counter()</span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> count[num] == <span class="number">0</span>:</span><br><span class="line">                    K -= <span class="number">1</span></span><br><span class="line">                count[num] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> K &lt; <span class="number">0</span>:</span><br><span class="line">                    count[A[start]] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> count[A[start]] == <span class="number">0</span>:</span><br><span class="line">                        K += <span class="number">1</span></span><br><span class="line">                    start += <span class="number">1</span></span><br><span class="line">                res += i - start + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> at_most_k(K) - at_most_k(K - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-123/" data-id="cjuh9fx78001ru0w3ag5c40ge" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-122" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-122/">LeetCode Weekly Contest 122</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-122/" class="article-date"><time datetime="2019-02-03T09:46:13.862Z" itemprop="datePublished">2019-02-03</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>提前祝春节快乐，又是咸鱼的一年，唉。</p>
<p>https://leetcode.com/contest/weekly-contest-122</p>
<p>&lt;!-- more --&gt;</p>
<h2>Sum of Even Numbers After Queries</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/</p>
<blockquote>
<p>We have an array <code>A</code> of integers, and an array <code>queries</code> of queries.</p>
</blockquote>
<blockquote>
<p>For the <code>i</code>-th query <code>val = queries[i][0], index = queries[i][1]</code>, we add val to <code>A[index]</code>.  Then, the answer to the <code>i</code>-th query is the sum of the even values of <code>A</code>.</p>
</blockquote>
<blockquote>
<p><em>(Here, the given <code>index = queries[i][1]</code> is a 0-based index, and each query permanently modifies the array <code>A</code>.)</em></p>
</blockquote>
<blockquote>
<p>Return the answer to all queries.  Your <code>answer</code> array should have <code>answer[i]</code> as the answer to the <code>i</code>-th query.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation:</span><br><span class="line">At the beginning, the array is [1,2,3,4].</span><br><span class="line">After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>1 &lt;= queries.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li>
<li><code>0 &lt;= queries[i][1] &lt; A.length</code></li>
</ol>
<p>只要检查<code>queries</code>的<code>index</code>部分对应的<code>A</code>数值是否会因为增加<code>val</code>改动，然后根据这种变化去改变偶数数值的和：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumEvenAfterQueries</span><span class="params">(self, A, queries)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type queries: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sum(i <span class="keyword">for</span> i <span class="keyword">in</span> A <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> val, i <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                s -= A[i]</span><br><span class="line">            A[i] += val</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                s += A[i]</span><br><span class="line">            res.append(s)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Smallest String Starting From Leaf</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-122/problems/smallest-string-starting-from-leaf/</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, each node has a value from <code>0</code> to <code>25</code> representing the letters <code>'a'</code> to <code>'z'</code>: a value of 0 represents <code>'a'</code>, a value of <code>1</code> represents <code>'b'</code>, and so on.</p>
</blockquote>
<blockquote>
<p>Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.</p>
</blockquote>
<blockquote>
<p><em>(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, <code>&quot;ab&quot;</code> is lexicographically smaller than <code>&quot;aba&quot;</code>.  A leaf of a node is a node that has no children.)</em></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/30/tree1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,3,4,3,4]</span><br><span class="line">Output: &quot;dba&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/30/tree2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [25,1,3,1,3,0,2]</span><br><span class="line">Output: &quot;adz&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/01/tree3.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,null,1,0,null,0]</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given tree will be between <code>1</code> and <code>1000.</code></li>
<li>Each node in the tree will have a value between <code>0</code> and <code>25</code>.</li>
</ol>
<p>太典型的递归问题了，对任意结点找左子树构造的字符串和右子树构造的字符串中更小的，作为这个结点代表的字符串。写递归过程中可能需要注意的是，要求字符串从叶结点开始，因此当遇到只有一个子结点的情况，必须沿用这个子结点一路构造上来的字符串而不能从当前结点开始作为新字符串的开头。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestFromLeaf</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        lstr, rstr = self.smallestFromLeaf(</span><br><span class="line">            root.left), self.smallestFromLeaf(root.right)</span><br><span class="line">        cur = chr(ord(<span class="string">'a'</span>) + root.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lstr:</span><br><span class="line">            <span class="keyword">return</span> rstr + cur</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rstr:</span><br><span class="line">            <span class="keyword">return</span> lstr + cur</span><br><span class="line">        <span class="keyword">return</span> min(lstr + cur, rstr + cur)</span><br></pre></td></tr></table></figure></p>
<h2>Interval List Intersections</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-122/problems/interval-list-intersections/</p>
<blockquote>
<p>Given two lists of <strong>closed</strong> intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
</blockquote>
<blockquote>
<p>Return the intersection of these two interval lists.</p>
</blockquote>
<blockquote>
<p><em>(Formally, a closed interval <code>[a, b]</code> (with <code>a &lt;= b</code>) denotes the set of real numbers <code>x</code> with <code>a &lt;= x &lt;= b</code>.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</em></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]</span><br><span class="line">Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</span><br><span class="line">Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt; 1000</code></li>
<li><code>0 &lt;= B.length &lt; 1000</code></li>
<li><code>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></li>
</ol>
<p>反正只需要对两个区间集运算，并不复杂，当成对两个区间做运算也可以，假设有<code>a</code>，<code>b</code>两个区间且<code>a</code>的左端点较小：</p>
<ol>
<li><code>b</code>的左端点大于<code>a</code>的右端点，那么两个区间没有交区间，<code>a</code>太小，应该由下一个<code>a</code>来开始比较</li>
<li><code>b</code>的右端点大于<code>a</code>的右端点，两个区间的交集为<code>[a.end,b.start]</code>，<code>b</code>应该去掉<code>a.end</code>左边部分然后开始进入下一轮比较</li>
<li><code>b</code>的右端点小于<code>a</code>的左端点，交集为<code>b</code>（包含于<code>a</code>），<code>a</code>去掉<code>b.end</code>左边的部分开始下一轮运算</li>
</ol>
<p>直至两个区间集有一个为耗尽，此时不再会有交集。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intervalIntersection</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[Interval]</span></span><br><span class="line"><span class="string">        :type B: List[Interval]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> A <span class="keyword">and</span> B:</span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">0</span>].start &gt; B[<span class="number">0</span>].start:</span><br><span class="line">                A, B = B, A</span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">0</span>].end &lt; B[<span class="number">0</span>].start:</span><br><span class="line">                A.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">0</span>].end &lt; B[<span class="number">0</span>].end:</span><br><span class="line">                res.append(Interval(B[<span class="number">0</span>].start, A[<span class="number">0</span>].end))</span><br><span class="line">                B[<span class="number">0</span>].start = A[<span class="number">0</span>].end</span><br><span class="line">                A.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(B[<span class="number">0</span>])</span><br><span class="line">                A[<span class="number">0</span>].start = B[<span class="number">0</span>].end</span><br><span class="line">                B.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Vertical Order Traversal of a Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-122/problems/vertical-order-traversal-of-a-binary-tree/</p>
<blockquote>
<p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
</blockquote>
<blockquote>
<p>For each node at position <code>(X, Y)</code>, its left and right children respectively will be at positions <code>(X-1, Y-1)</code> and <code>(X+1, Y-1)</code>.</p>
</blockquote>
<blockquote>
<p>Running a vertical line from <code>X = -infinity</code> to <code>X = +infinity</code>, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing <code>Y</code> coordinates).</p>
</blockquote>
<blockquote>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
</blockquote>
<blockquote>
<p>Return an list of non-empty reports in order of <code>X</code> coordinate.  Every report will have a list of values of nodes.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/31/tree2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The tree will have between <code>1</code> and <code>1000</code> nodes.</li>
<li>Each node's value will be between <code>0</code> and <code>1000</code>.</li>
</ol>
<p>问题是不难，按照坐标规则，BFS把每个结点的值归位，然后遍历坐标返回结果。这里考虑树最多有<code>1000</code>个结点，应该需要<code>1000*1000</code>的数组来应对极端情况，当然这么做会遇到罕见的MLE，实际上用<code>100*100</code>也已经足够了，测试集没有超过这个范围。更好的做法是用字典而不是数组去记录每个坐标上的结点，懒得写了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verticalTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pos = [[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line">        q = [(root, <span class="number">50</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node, x, y <span class="keyword">in</span> q:</span><br><span class="line">            pos[x][y].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append((node.left, x - <span class="number">1</span>, y + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append((node.right, x + <span class="number">1</span>, y + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> pos:</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">if</span> y:</span><br><span class="line">                    temp += sorted(y)</span><br><span class="line">            <span class="keyword">if</span> temp:</span><br><span class="line">                res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-122/" data-id="cjuh9fx6u001pu0w3epgatshd" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-121" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-121/">LeetCode Weekly Contest 121</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-121/" class="article-date"><time datetime="2019-01-27T08:32:28.566Z" itemprop="datePublished">2019-01-27</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-121</p>
<p>&lt;!-- more --&gt;</p>
<h2>String Without AAA or BBB</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/</p>
<blockquote>
<p>Given two integers <code>A</code> and <code>B</code>, return <strong>any</strong> string <code>S</code> such that:</p>
</blockquote>
<blockquote>
<p><code>S</code> has length <code>A + B</code> and contains exactly <code>A</code> <code>'a'</code> letters, and exactly <code>B</code> <code>'b'</code> letters;
The substring <code>'aaa'</code> does not occur in <code>S</code>;
The substring <code>'bbb'</code> does not occur in <code>S</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 1, B = 2</span><br><span class="line">Output: &quot;abb&quot;</span><br><span class="line">Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 4, B = 1</span><br><span class="line">Output: &quot;aabaa&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A &lt;= 100</code></li>
<li><code>0 &lt;= B &lt;= 100</code></li>
<li>It is guaranteed such an S exists for the given <code>A</code> and <code>B</code>.</li>
</ol>
<p>假设<code>A&gt;B</code>（相反时直接对称代换<code>a</code>和<code>b</code>处理即可），那么保证有解极限情况为<code>aabaab...aabaa</code>，也就是<code>A=2B+2</code>，也包括<code>A=2B+1</code>或<code>A=2B</code>尽可能有效使用所有<code>b</code>，即连续<code>B</code>个<code>aab</code>后面接着<code>0-2</code>个<code>a</code>可以满足要求。当<code>A&lt;2B</code>时，可以通过混合使用<code>aab</code>和<code>ab</code>来平衡，那么一共会用到<code>A-B</code>个<code>aab</code>和<code>2B-A</code>个<code>ab</code>可以用完所有字符。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strWithout3a3b</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: int</span></span><br><span class="line"><span class="string">        :type B: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a, b = <span class="string">'a'</span>, <span class="string">'b'</span></span><br><span class="line">        <span class="keyword">if</span> A &lt; B:</span><br><span class="line">            A, B = B, A</span><br><span class="line">            a, b = b, a</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> A &gt; <span class="number">2</span> * B:</span><br><span class="line">            <span class="keyword">return</span> (a + a + b) * B + a * (A - <span class="number">2</span> * B)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (a + a + b) * (A - B) + (a + b) * (<span class="number">2</span> * B - A)</span><br></pre></td></tr></table></figure></p>
<h2>Time Based Key-Value Store</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-121/problems/time-based-key-value-store/</p>
<blockquote>
<p>Create a timebased key-value store class <code>TimeMap</code>, that supports two operations.</p>
</blockquote>
<ol>
<li><code>set(string key, string value, int timestamp)</code></li>
</ol>
<ul>
<li>Stores the <code>key</code> and <code>value</code>, along with the given <code>timestamp</code>.</li>
</ul>
<ol start="2">
<li><code>get(string key, int timestamp)</code></li>
</ol>
<ul>
<li>Returns a value such that <code>set(key, value, timestamp_prev)</code> was called previously, with <code>timestamp_prev &lt;= timestamp</code>.</li>
<li>If there are multiple such values, it returns the one with the largest <code>timestamp_prev</code>.</li>
<li>If there are no values, it returns the empty string (<code>&quot;&quot;</code>).</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]</span><br><span class="line">Output: [null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]</span><br><span class="line">Explanation:   </span><br><span class="line">TimeMap kv;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1   </span><br><span class="line">kv.get(&quot;foo&quot;, 1);  // output &quot;bar&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 3); // output &quot;bar&quot; since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie &quot;bar&quot;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4);   </span><br><span class="line">kv.get(&quot;foo&quot;, 4); // output &quot;bar2&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 5); //output &quot;bar2&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]</span><br><span class="line">Output: [null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>All key/value strings are lowercase.</li>
<li>All key/value strings have length in the range <code>[1, 100]</code></li>
<li>The <code>timestamps</code> for all <code>TimeMap.set</code> operations are strictly increasing.</li>
<li><code>1 &lt;= timestamp &lt;= 10^7</code></li>
<li><code>TimeMap.set</code> and <code>TimeMap.get</code> functions will be called a total of <code>120000</code> times (combined) per test case.</li>
</ol>
<p>每次调用<code>TimeMap.set</code>用的<code>timestamps</code>都保持严格的升序，因此在进行增加记录时可以天然的维护一个升序列表。因为按照<code>key</code>分类，所以每个<code>key</code>都需要维护对应关系的<code>record</code>和<code>times</code>列表，前者保存记录值，后者保存该记录值对应的<code>timestamps</code>，当调用<code>TimeMap.get</code>时可以通过在<code>times</code>进行二分查找找到该时间之前最近的记录所在的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.records = collections.defaultdict(list)</span><br><span class="line">        self.times = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value, timestamp)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: str</span></span><br><span class="line"><span class="string">        :type value: str</span></span><br><span class="line"><span class="string">        :type timestamp: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.records[key].append(value)</span><br><span class="line">        self.times[key].append(timestamp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, timestamp)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type key: str</span></span><br><span class="line"><span class="string">        :type timestamp: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.records[key]:</span><br><span class="line">            pos = bisect.bisect(self.times[key], timestamp)</span><br><span class="line">            <span class="keyword">if</span> pos &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> self.records[key][pos - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TimeMap()</span></span><br><span class="line"><span class="comment"># obj.set(key,value,timestamp)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get(key,timestamp)</span></span><br></pre></td></tr></table></figure></p>
<h2>Minimum Cost For Tickets</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-121/problems/minimum-cost-for-tickets/</p>
<blockquote>
<p>In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array <code>days</code>.  Each day is an integer from <code>1</code> to <code>365</code>.</p>
</blockquote>
<blockquote>
<p>Train tickets are sold in 3 different ways:</p>
</blockquote>
<ul>
<li>a 1-day pass is sold for <code>costs[0]</code> dollars;</li>
<li>a 7-day pass is sold for <code>costs[1]</code> dollars;</li>
<li>a 30-day pass is sold for <code>costs[2]</code> dollars.</li>
</ul>
<blockquote>
<p>The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of dollars you need to travel every day in the given list of <code>days</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation:</span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.</span><br><span class="line">On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.</span><br><span class="line">On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.</span><br><span class="line">In total you spent $11 and covered all the days of your travel.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation:</span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.</span><br><span class="line">On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.</span><br><span class="line">In total you spent $17 and covered all the days of your travel.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= days.length &lt;= 365</code></li>
<li><code>1 &lt;= days[i] &lt;= 365</code></li>
<li><code>days</code> is in strictly increasing order.</li>
<li><code>costs.length == 3</code></li>
<li><code>1 &lt;= costs[i] &lt;= 1000</code></li>
</ol>
<p>比较常见的动态规划思路<code>dp[i][j]</code>用来表示保证了第<code>A[i]</code>天在旅途时，还可以用<code>j</code>天持续在旅途的开销，如果<code>A[i+1]&lt;=A[i]+j</code>那么就说明第<code>A[i+1]</code>天的问题已经在<code>A[i]</code>天得到了一种解决，不需要另外再购票也可行，更新<code>dp[i+1][A[i]+j-A[i+1]]=min(dp[i+1][A[i]+j-A[i+1]],dp[i][j])</code>即可。如果找不到这样的<code>j</code>，那么只能通过重新购票保证自己的旅行计划，那么按照三种购票方法分别计算一下新增的开销以及可以再续上几天。</p>
<p>当然我个人不太喜欢用数组写这类动态规划问题（你可以看见下一题本来也应该用数组的，但我实在不喜欢用），虽然程序编写效率和某些具体实现上用数组的运行时效果更好，但我还是倾向于写成稀疏的字典，直觉上实在无法接受<code>j</code>的取值是稠密的这一假设，见谅吧。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span><span class="params">(self, days, costs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type days: List[int]</span></span><br><span class="line"><span class="string">        :type costs: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(days)</span><br><span class="line">        dp = &#123;<span class="number">0</span>: costs[<span class="number">0</span>], <span class="number">6</span>: costs[<span class="number">1</span>], <span class="number">29</span>: costs[<span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            temp = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> pre, c <span class="keyword">in</span> dp.items():</span><br><span class="line">                <span class="keyword">if</span> days[i - <span class="number">1</span>] + pre &gt;= days[i]:</span><br><span class="line">                    temp[days[i - <span class="number">1</span>] + pre - days[i]</span><br><span class="line">                         ] = min(temp.get(days[i - <span class="number">1</span>] + pre - days[i], c), c)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp[<span class="number">0</span>] = min(temp.get(<span class="number">0</span>, c + costs[<span class="number">0</span>]), c + costs[<span class="number">0</span>])</span><br><span class="line">                    temp[<span class="number">6</span>] = min(temp.get(<span class="number">6</span>, c + costs[<span class="number">1</span>]), c + costs[<span class="number">1</span>])</span><br><span class="line">                    temp[<span class="number">29</span>] = min(temp.get(<span class="number">29</span>, c + costs[<span class="number">2</span>]), c + costs[<span class="number">2</span>])</span><br><span class="line">            dp = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(dp.values())</span><br></pre></td></tr></table></figure></p>
<h2>Triples with Bitwise AND Equal To Zero</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-121/problems/triples-with-bitwise-and-equal-to-zero/</p>
<blockquote>
<p>Given an array of integers <code>A</code>, find the number of triples of indices (i, j, k) such that:</p>
</blockquote>
<ul>
<li><code>0 &lt;= i &lt; A.length</code></li>
<li><code>0 &lt;= j &lt; A.length</code></li>
<li><code>0 &lt;= k &lt; A.length</code></li>
<li><code>A[i] &amp; A[j] &amp; A[k] == 0</code>, where <code>&amp;</code> represents the bitwise-AND operator.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,3]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: We could choose the following i, j, k triples:</span><br><span class="line">(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1</span><br><span class="line">(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2</span><br><span class="line">(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1</span><br><span class="line">(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3</span><br><span class="line">(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1</span><br><span class="line">(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2</span><br><span class="line">(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1</span><br><span class="line">(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3</span><br><span class="line">(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2</span><br><span class="line">(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2</span><br><span class="line">(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1</span><br><span class="line">(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>0 &lt;= A[i] &lt; 2^16</code></li>
</ol>
<p>这题（包含测试集）设计的不太好，直接三重循环暴力搜索可以通过，用动态规划也没有明显的性能提高。</p>
<p>一般的动态规划思路：<code>dp[i]</code>表示<code>&amp;</code>运算结果为<code>i</code>的组合共有多少种，每一轮更新增加一个新的运算数，对<code>A</code>遍历让<code>dp[i&amp;A[j]]</code>的计数增加，或者用第一轮的<code>dp1</code>直接<code>dp_new[i&amp;j]+=dp_old[i]*dp1[j]</code>。不过这里只有三轮，所以用前面的<code>dp1</code>性能不是很划算，如果有多轮运算，还可以参考快速幂计算的方法来折叠优化。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriplets</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp1 = collections.Counter(A)</span><br><span class="line"></span><br><span class="line">        dp2 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> k1, v1 <span class="keyword">in</span> dp1.items():</span><br><span class="line">            <span class="keyword">for</span> k2, v2 <span class="keyword">in</span> dp1.items():</span><br><span class="line">                dp2[k1 &amp; k2] = dp2.get(k1 &amp; k2, <span class="number">0</span>) + v1 * v2</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k1, v1 <span class="keyword">in</span> dp2.items():</span><br><span class="line">            <span class="keyword">for</span> k2, v2 <span class="keyword">in</span> dp1.items():</span><br><span class="line">                <span class="keyword">if</span> k1 &amp; k2 == <span class="number">0</span>:</span><br><span class="line">                    res += v1 * v2</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-121/" data-id="cjuh9fx6g001nu0w3e4795jdh" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-type-system" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/TAPL/type-system/">零基础开始读类型系统（Cardelli的type systems小结）</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/TAPL/type-system/" class="article-date"><time datetime="2019-01-26T09:42:47.241Z" itemprop="datePublished">2019-01-26</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TAPL/">TAPL</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在找<a href="https://www.cis.upenn.edu/~bcpierce/tapl/" target="_blank" rel="noopener">TAPL</a>相关材料时，被豆瓣网友推荐先去读一下Luca Cardelli的这篇Type Systems&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;只有41页的小册子，当时粗略看了一下这个summary感觉很简洁易读，就放在阅读材料调查计划里差不多拖了一年没看，这两天因为一些原因找到不错的机会静下心来断断续续的读完了，观感上来说确实是让人读起来有瘾的东西，没有特别痛苦的内容，基本上是符合直觉的。对于状态良好的，有一定编程语言使用经验的，对符号逻辑有基本了解，但对编程语言类型系统没有系统性认知的人来说，原文预计需要大约一个下午的时间读完，请有相关计划的读者做好相应的规划。
&lt;!-- more --&gt;</p>
<p>我在这里粗浅的总结一下从中的收获，以及阅读中可能遇到的理解问题和解决方法。</p>
<h2>结构概述</h2>
<p>全文主要讨论的问题可以直接看Page 2开头部分，把每个部分的主要内容都提前交代了。</p>
<ol>
<li><strong>Introduction</strong>: 解释了一些类型系统的基本概念名词，主要在于介绍类型系统设计的目的和几个评价标准，目前几种编程语言又是如何通过不同的实现达到相应的安全和效率目的。总之这部分可以看的稍微快一点，很综述性的东西。</li>
<li><strong>The language of type systems</strong>: 开始正式定义一种符号语言来描述编程语言中的类型系统，包括类型系统的基本规则，推理运算的表达，试图用这种符号语言讨论类型系统在上面提到的需要解决的问题。</li>
<li><strong>First-order Type Systems</strong>：用这种规范的语言开始描述第一个类型系统$F_1$，暂不探讨1st-order和2nd-order的差异，从最简单的，函数式的编程语言开始一步步定义了常见的类型，导出规则，作为后面几种类型系统的基础。</li>
<li><strong>First-order Type Systems for Imperative Languages</strong>：在上面的基础上引入声明和命令这些语法，并给出了它们在类型系统中的相应规则。<s><em>在文章中不是很重要的内容。</em></s></li>
<li><strong>Second-order Type Systems</strong>：在$F_1$的基础上，开始描述一种<strong>将类型作为类型的参数</strong>构造新类型的类型系统$F_2$及新类型的相关导出规则。</li>
<li><strong>Subtyping</strong>： 引入子类型规则，简单的构造了在前面两种类型系统基础上实现子类关系后的$F_{1&lt;:}$和$F_{2&lt;:}$。</li>
<li><strong>Equivalence</strong>: 最简的解释了类型之间等价关系是什么，以及几个判断的例子，<s><em>在文章中不是很重要的内容。</em></s></li>
<li><strong>Type inference</strong>：演示了在上面这些类型系统中简单的类型推断规则的使用（是的，只是最简模型的方法，甚至不能算的上是算法），提及一些现有类型推断和重构中存在的难点。</li>
<li><strong>Summary and Research Issues</strong>：文章常见的结论和展望部分，不多废话了，因为这篇文章比较老所以前景性的东西也没有必要认真看待，不过倒是提及了类型系统和数学的类型论（type theory）方向之间的关系，有兴趣的可以自行去nLab或者别的地方学一下类型论。</li>
</ol>
<p>后面的术语定义表和参考文献部分没有特别新奇特别值得注意的内容，但是我<strong>建议</strong>第一次读这篇文章时，初遇其中概念，理解模糊时可以快速查一下Page 37开始的Defining Terms部分，相比正文的解释，它对概念的描述更简洁直观。当然，顺序阅读到这里时，也可以快速读一下检验自己的理解是否准确清晰。</p>
<h2>概念&amp;推算的理解</h2>
<p>阅读中可能会遇到一些理解上的困难，比如Page 21-22所做的Encoding of Divergence and Recursion via Recursive Types和Encoding the Untyped $\lambda$-calculus via Recursive Types部分我也真没怎么明白，和下文也没有什么关系，就直接跳过去了。</p>
<p>造成这种困扰很可能是因为全文的符号公式系统都是为了简洁而作出这样的呈现，与主流的符号系统存在一些细小的差异，而篇幅所限又不可能作出过于详细的解释和说明。</p>
<p>所以遇到不理解的地方，可以先查文章结尾部分的Defining Terms，如果还是得不到解答，去找TAPL相关内容（符号使用上更加直观）或检索相应关键词找相关的讲义和课件。这些尝试都失败以后，不妨放心的跳过去，反正很多内容和下文的关系也没有想象的那么大。</p>
<p>我在这里给出一些我阅读时纠结过的东西，以及最后对它们的结论，都是比较细节的东西，不保证完全的正确性，只希望思考过程能对以后看到的这里的人有所帮助。</p>
<h3>背景</h3>
<p>类型系统相应的背景概念，对应Page 1-9，怎样的类型系统是安全的，编程语言的类型系统怎么分类，这些用文字阐述的东西，有相应编程经验应该不难出现理解问题。这部分如果有困难，直接按照名词去Defining Terms读最简的定义强行记忆。</p>
<p>值得一说的是，全文规避了一些如强弱类型这样无论在文章还是现实中都不怎么重要的概念之争，就是不希望你还浪费时间在考据这样无聊的定义上。能理解就理解，不能理解就假装自己知道了，编程经验上来了以后看这些东西都不算事。</p>
<h3>Union Types</h3>
<p>$F_1$的大部分基础类型没什么特别需要注意的，可能到union type开始会感觉有点陌生，前面的product type可以对应到常见的序对(pair)结构来理解，而union type如果没有相应的使用经验可能一下子想不起来。容易联想到C/C++的union structure，虽然二者有相似的地方（共有同一空间）但概念上并不是等价的东西，请忘掉它。使用过Standard ML或者Haskell就会容易理解公式系统中$A_1+A_2$这样的“加法”操作实际上等同<code>|</code>，用伪代码表示为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def type A = A1 | A2</span><br></pre></td></tr></table></figure></p>
<p>新的类型$A$实例化后的变量可以是一个$A_1$，或者是一个$A_2$类型的变量，都可以赋值给$A$类型的变量，两种类型都是$A$的“可能性”。使用时可以通过<code>case</code>关键字来确定具体的类型进行不同的操作，这一点上有点类似于我们通常说的多态（事实上Standard ML也确实是把它作为多态来实现的）。</p>
<p>如果不去考虑$A$是通过类型来定义的，也可以类比为C/C++的enum structure，不同的是union type所“枚举”的是类型，而enum枚举的是变量值，但在使用时一个变量只会有一种类型或值，只是它是来自定义中枚举的所有可能性之一。</p>
<p>union type很基础，后面也常用到，所以能理解尽量还是理解一下。它也通常和product type相对出现，几乎所有类型规则也都能找到对应关系，同理它们的推广record type和variant type，包括后面子类关系规则，建议把它们对照着看方便理解。当然<code>inLeft</code>和<code>inRight</code>这些构造方法定义的很模糊，不太友好，后面的用法也和这里不太一致，所以这里细节不要太深究了。</p>
<h3>Recursive Types</h3>
<p>虽然递归定义类型我们经常用（比如链表，二叉树）但抽象出符号语言还是一时难以习惯，毕竟之前可能没接触过$\mu$算子。</p>
<p>这里我个人建议可以稍微去读一下TAPL Chapter 20，或者其他材料&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;的文字解说和符号描述。</p>
<p>$\mu$算子与$\lambda$算子有相似之处。假设需要通过一个类型$X$递归构造出新的类型，可以使用函数$\lambda X.T$，$T$中出现过$X$，但$T$ <strong>在形式上</strong> 不完全等同于$X$，如果有某个$X^*$可以使得$X^*=[\lambda X.T]X^*$这个等式（右边也可以更正式的写为$[X^*/X]T$，表示将$T$中所有出现的$X$都替换为$X^*$，相似的表达还有TAPL的$[X \mapsto X^*]T$）成立，那么这个$X^*$就是该函数的一个不动点，表示为$X^*:=\mu X.T$，当然以上只是我个人给出的<strong>不严谨</strong>的解释，一般来说直接用$\mu X.T$来表示这个recursive type来表示就可以了。</p>
<p>文章提到的作用于recursive type的两个操作<code>fold</code>和<code>unfold</code>的定义可能有点费解，其实这也涉及上面那个不严谨的表达$X$到底和$T$是不是等价类型？如果是，能否把$T$中出现的$X$都用这个等式的（特）解$\mu X.T$替换掉？</p>
<p>讨论recursive type类型是否相等那一般就是说isorecursive和equi-recursive了，而那两个操作还是在讨论isorecursive,不展开更抽象的概念描述了，直接去看它们做了什么。</p>
<p>对于一个$\mu X.T$的<code>unfold</code>操作定义为把$\mu X.T$类型展开成$[\mu X.T/X]T$，即直接把不动点代入$T$展开一层，它的逆过程<code>fold</code>相应的把$[\mu X.T/X]T$折叠到$\mu X.T$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/fold-unfold.png" alt="TAPL的替换标记稍有不同"></p>
<p>如果还是不理解这个操作可以想想一般的Y combinator，或者直接不用这套语言体系，说一下<code>fold</code>和<code>unfold</code>更广泛的使用场景：有一个函数$f$在$x$点取到$x=f(x)$即我们通常说的$x$是不动点，<code>unfold</code>就是把这个特定的不动点放到函数中再展开为$f(x)$，<code>fold</code>就是把$f(x)$折叠回$x$，上面的recursive type也是这个规则的特例。</p>
<p>用recursive type来描述类型的例子可以看我上面给的材料里面给出的二叉树，自然数列表，甚至自然数类型本身。回到文章中后面给出的一个用于检验理解的实例，构造list
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/list.png" alt="">
推算检验的难点在于各类操作符的省略很严重（比如<code>inLeft</code>，<code>inRight</code>，<code>fold</code>，<code>unfold</code>的下标都没有标明，实际上前两者视情况构造，后两个是$List_A$，也就是第一行那个$\mu$表达式），相比文章前半部分事无巨细的导出演绎，这里开始省略了很多作者认为不重要的内容，连文字说明都没有给出，而且对我这么笨的人来说直接算<code>fold</code>是很困难的，所以只能想象成<code>unfold</code>的逆过程开始看：</p>
<p>把$nil_A$作为参数<code>unfold</code>出来，$$[nil_A/X](unit+(A\times X))=unit+(A \times nil_A)$$应该是在形式上与$nil_A$“同构”的（我前面说了不讨论isorecursive，所以这里可以简单理解为形式上等价），所以构造时选择用$InLeft\text{ }unit$构造了一个$unit+(A \times nil_A)$类型的值$unit$作为空列表。当然这里的$InLeft$应该被看作按照参数$x:X$构造出任意右半部分的构造器，构造结果可以被当成$x:X+top$，$top$为任意类型。</p>
<p>当然正向思考也可以说这里有一个$unit:unit+T$可以成为$X=unit+(A\times X)$的解，<code>fold</code>回去可以找到推断出$T$的具体类型，但这个union type其实也不怎么重要，最终结果$unit+T$一定与$List_A$同构，反正它的值也已经确定为$unit$了（这是前文关于系统中空类型的规定，我们只是试图根据规定构造的更自然一些），这个<code>fold</code>的结果就作为$nil_A$了。</p>
<p>$cons_A$前面那堆curry先不看，没什么影响，直接仿照前面正向推断看<code>fold</code>的参数：$\langle hd,tl \rangle:A \times list_A$被$InRight$构造成了一个$\langle hd,tl \rangle:unit+A \times list_A$，注意可以直接推断出这里union type的另一部分也就是$inRight$的下标就是$unit$按照<code>fold</code>规则，整个变量的类型从$unit+A \times list_A$直接折叠到了$list_A$，得到的就是$\langle hd,tl \rangle:list_A$</p>
<p>后面的<code>listCase</code>不难理解，不多说了。TAPL 20.2给出了相似的实现自然数链表NatList的例子，相对来说符号描述上更友好一些，也可以参照着它的例子来理解：</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/NatList.png" alt="TAPL Page 278"></p>
<h3>Existential Types</h3>
<p>$F_2$引入了“全称量词”（universally quantifier type），关于这个可以由类型来特例化的类型，原文说明的很清楚详细了，通过这样的描述可以很直观的感受到高阶的性质。</p>
<p>之后新引入的“存在量词”一开始接触可能有点困难，毕竟全文没有正面给出关于它的准确定义，但回过去读一遍它的例子BoolInterface可以理解<code>pack</code>的具体工作：
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/existential_type.png" alt=""></p>
<p>如果用类型变量$X$定义的$M:A$被用一个类型$B$可以实例化为$[B/X]M:[B/X]A$，那么我们可以存在一个$X=B$可以实现$M:A$这样的抽象，并把这一个特殊的实现用<code>pack</code>打包封装起来作为一个表达式，不用知道具体的实现（$X=B$）只要了解有这样一个$X$类型可以让实例化后的$M$是$A$类型，这里的$M$和$A$都是一种的抽象，我们所有可以从打包后的结果看出来的只有“存在一个具体的$X$，以及一种具体的实现方法，可以实现它”，因此它的类型可以被表达为$\exists X.A$</p>
<p>这个思想类似于抽象接口，隐藏了类型的具体实现，来看它的例子，假设我们需要实现一个BoolInterface，这个接口实际上是一个record type，需要规定<code>true</code>,<code>false</code>和<code>cond</code>这些域的类型信息，但它们的类型仍然是抽象的，需要“传入”一个具体的Bool类型来实例化它们的类型，从而确定整个record的类型
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/boolinterface.png" alt="">
这里选择把Bool类型实例化成unit+unit并给出一种实现方法，注意with后面的语句就是上文的$M$，还是以Bool为类型变量参数在构造一个record实例，当然具体的构造方法并不重要，没有细究的必要，打包结果BoolModule就是BoolInterface类的一个被实现的实例。
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/boolmodule.png" alt="">
回到前面的Val Open假设：如果$M$是一个已经完成打包的$\exists X.A$类型的表达式，$N$是一个使用了参数：类型变量$X$和用$X$定义的$A$类型的一个实例$x$的表达式，并且$N$的最终类型为$B$（注意这个$B$和前文<code>pack</code>使用的$B$没有任何联系，如果这里困惑可以把$B$换成别的符号），<code>open</code>操作把$M$封装时用到的那个特定的$X$（也就是前文<code>pack</code>的$B$）和$x:A$的真正实现（前文<code>pack</code>的$[B/X]M:[B/X]A$）作为“实参”直接传入$N$，当然，全程你依然对这个特定的$X$一无所知，却可以使用它来计算$N$生成一个$B$类型的结果，这也是接口和模块要求的对于实现细节的遮蔽。</p>
<p>对于BoolModule来说，<code>open</code>的具体实例为
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/open.png" alt="">
在<code>boolOp.cond(Nat)(boolOp.true)(1)(0)</code>中，<code>boolOp</code>被约束到了前文<code>with</code>后面的那个record type的值，这个语句里面虽然没有显式的出现<code>Bool</code>类型，但如果出现<code>Bool</code>也是被约束到unit+unit来进行整个语句的求值。这个语句最后的返回结果是自然数1。</p>
<p>这里想明白以后后面关于existential type的意义描述也就不难理解了，不再展开多谈。关于它的定义，性质，用法可以见TAPL Chapter 24的详细叙述，以及type theory也有数学上定义的existential type，老实说，这些延伸材料关于existential type的部分我都没细看，给不出特别有效的指导建议，只是感觉和在原文里的讨论形式上差别很大。</p>
<h3>Subtyping &amp; Type inference</h3>
<p>我没有任何说这两个东西不重要的意思，相反它们非常重要。只是相比前面基础概念的定义，并没有多少构造性的东西，只要前面的理解没有问题，直接往后读这两块还是非常顺利的，没有提及太深刻的东西，trivial的问题也没展开说明直接跳过了，重点在于规则的应用。</p>
<p>subtype关系的规则大部分是符合直觉的，比如record的长度规则，可以联想OOP的继承关系，子类比父类有更多的域；再比如variant的长度规则相反，子类所拥有的“可能性”越少，长度越低。</p>
<p>讨论函数类型之间的子类关系时，需要考虑它们的参数类型和返回结果类型。这里就用到了covariant和contravariant的说法，文章中倒是给出了这两个名词的解释：与整个函数类型的子类关系变化方向一致的是covariant，返回类型上就是遵循这个规则；而与函数类型的子类关系变化方向相反的就是contravariant，参数则遵循这个规定。我也曾经随手写过一个<a href="https://www.zhihu.com/pin/1065382072121683968" target="_blank" rel="noopener">知乎想法评论</a>给出过我的理解：</p>
<blockquote>
<p>反正一句话的事
function subtyping is contravariant in arguments and covariant in results.
一个提供更多信息的函数应该输入更少信息并返回更多信息。</p>
</blockquote>
<p>文中也给出了一个总结，总是出现在第奇数个箭头左边的类型是函数类型的contravariant，文章给出的例子是
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X-&gt;Unit</span><br><span class="line">(Unit-&gt;X)-&gt;Unit</span><br></pre></td></tr></table></figure></p>
<p>的$X$都是整个类型的contravariant，而两次contravariant又等同于covariant所以
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unit-&gt;X</span><br><span class="line">(X-&gt;Unit)-&gt;X</span><br></pre></td></tr></table></figure></p>
<p>的$X$又是covariant</p>
<p>这个结论用起来可能需要注意的地方是$\to$本来就是右结合的，上面两个例子用括号规避了麻烦的讨论让例子更简单，直接从左往右数$\to$是第几个就行了，但没有括号提升优先级的时候，你就得从右往左数了。</p>
<p>Type inference部分也没有特别不好理解的地方，给出的所谓的几个算法虽然很抽象的概括了它需要完成的工作，但并没有涉及非常实际具体的做法，所以也没什么难点可谈，真实的type inference可能遇到的问题（比如不收敛）读原文的文字材料的叙述就能了解个大概了。</p>
<p>细节上可能有纠结的是$F_{2&lt;:}$的算法Table 37没说清楚<code>Expose</code>操作的意义</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/type-system/expose.png" alt="">
这里<code>Expose</code>是寻找类型$X$在类型系统中最高的一个supertype，下面使用<code>Expose</code>的场景也是在函数调用$M N$和高阶类型实例化$M A$时寻找$M$的类型在系统中的最大supertype，即$M$的参数的最小subtype-&gt;返回结果的最大supertype，这样就要求实参$N$的类型只能是这个最小的类型$A$才能进行推导，这样的强制<code>Expose</code>保证了函数调用的安全性（其他地方的<code>Type</code>没有这样的强制所以不保证给出符合推断的最小类型），在符合这样的调用后才会得到与返回类型一致的结果，但这里的$B$不是那个结果，只是最模糊的一个supertype，毕竟$F_{2&lt;:}$严格来说并不是一个完备的算法，只能小心翼翼保证产生的推断结果“没有错误”而并不完全准确。</p>
<h2>尾声</h2>
<p>我写的东西大部分是细节理解上的讨论，只是为了防止有同样困惑的人纠结于此浪费时间，并不能取代文章本身的阅读。类型系统是计算机科学最优雅美丽的东西之一，精彩的论述还需要认真通读全文。</p>
<blockquote>
<p>祝你早日找到住在计算机内的神灵。</p>
</blockquote>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Cardelli, Luca. &lt;a href=&quot;http://lucacardelli.name/papers/typesystems.pdf&quot;&gt;&quot;Type systems.&quot;&lt;/a&gt; &lt;em&gt;ACM Computing Surveys&lt;/em&gt; 28.1 (1996): 263-264.&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://www.cs.cornell.edu/courses/cs4110/2012fa/lectures/lecture27.pdf&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/TAPL/type-system/" data-id="cjuh9fxgw005yu0w3scv09seo" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-120" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-120/">LeetCode Weekly Contest 120</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-120/" class="article-date"><time datetime="2019-01-20T10:31:50.549Z" itemprop="datePublished">2019-01-20</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-120</p>
<p>&lt;!-- more --&gt;</p>
<h2>Squares of a Sorted Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-120/problems/squares-of-a-sorted-array/</p>
<blockquote>
<p>Given an array of integers <code>A</code> sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> is sorted in non-decreasing order.</li>
</ol>
<p>虽然<code>A</code>已经排好了序，不过懒得多写还是直接</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sorted(x * x <span class="keyword">for</span> x <span class="keyword">in</span> A)</span><br></pre></td></tr></table></figure></p>
<p>也能通过。</p>
<h2>Longest Turbulent Subarray</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-120/problems/longest-turbulent-subarray/</p>
<blockquote>
<p>A subarray <code>A[i], A[i+1], ..., A[j]</code> of <code>A</code> is said to be turbulent if and only if:</p>
</blockquote>
<ul>
<li>For <code>i &lt;= k &lt; j</code>, <code>A[k] &gt; A[k+1]</code> when <code>k</code> is odd, and <code>A[k] &lt; A[k+1]</code> when <code>k</code> is even;</li>
<li><strong>OR</strong>, for <code>i &lt;= k &lt; j</code>, <code>A[k] &gt; A[k+1]</code> when <code>k</code> is even, and <code>A[k] &lt; A[k+1]</code> when <code>k</code> is odd.</li>
</ul>
<blockquote>
<p>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</p>
</blockquote>
<blockquote>
<p>Return the <strong>length</strong> of a maximum size turbulent subarray of A.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,4,2,10,7,8,8,1,9]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,8,12,16]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [100]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
</ol>
<p>先计算出<code>A</code>相邻元素之间的差值序列<code>diff</code>，然后寻找<code>diff</code>中长度最大的正负互相交替的子序列。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxTurbulenceSize</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        diff = [A[i + <span class="number">1</span>] - A[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        temp = <span class="number">0</span> <span class="keyword">if</span> diff[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> diff[i] * diff[i + <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = max(res, temp + <span class="number">1</span>)</span><br><span class="line">                temp = <span class="number">0</span> <span class="keyword">if</span> diff[i + <span class="number">1</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        res = max(res, temp + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Distribute Coins in Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-120/problems/distribute-coins-in-binary-tree/</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree with <code>N</code> nodes, each <code>node</code> in the tree has <code>node.val</code> coins, and there are <code>N</code> coins total.</p>
</blockquote>
<blockquote>
<p>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)</p>
</blockquote>
<blockquote>
<p>Return the number of moves required to make every node have exactly one coin.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/18/tree1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,0,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/18/tree2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,3,0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/18/tree3.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/18/tree4.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,null,3]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1&lt;= N &lt;= 100</code></li>
<li><code>0 &lt;= node.val &lt;= N</code></li>
</ol>
<p>这题默认的最少次数的移动，因此需要后序遍历从比较低的位置开始调整硬币的分布。后序遍历中，当子结点上的硬币数不为1时，可以从父结点拿走缺少的硬币，或者向父结点交出多余的，暂时不用考虑父结点上的硬币数，经过这样的移动可以使得父结点上的硬币数临时为负，再向上处理时来调整这个结点上的硬币数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCoins</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_order_dfs</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                post_order_dfs(r.left)</span><br><span class="line">                <span class="keyword">if</span> r.left.val != <span class="number">1</span>:</span><br><span class="line">                    self.res += abs(<span class="number">1</span> - r.left.val)</span><br><span class="line">                    r.val, r.left.val = r.val + r.left.val - <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                post_order_dfs(r.right)</span><br><span class="line">                <span class="keyword">if</span> r.right.val != <span class="number">1</span>:</span><br><span class="line">                    self.res += abs(<span class="number">1</span> - r.right.val)</span><br><span class="line">                    r.val, r.right.val = r.val + r.right.val - <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        post_order_dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></p>
<h2>Unique Paths III</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-120/problems/unique-paths-iii/</p>
<blockquote>
<p>On a 2-dimensional <code>grid</code>, there are 4 types of squares:</p>
</blockquote>
<ul>
<li><code>1</code> represents the starting square.  There is exactly one starting square.</li>
<li><code>2</code> represents the ending square.  There is exactly one ending square.</li>
<li><code>0</code> represents empty squares we can walk over.</li>
<li><code>-1</code> represents obstacles that we cannot walk over.</li>
</ul>
<blockquote>
<p>Return the number of 4-directional walks from the starting square to the ending square, that <strong>walk over every non-obstacle square exactly once</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths:</span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: We have the following four paths:</span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</span><br><span class="line">2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">There is no path that walks over every empty square exactly once.</span><br><span class="line">Note that the starting and ending square can be anywhere in the grid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length * grid[0].length &lt;= 20</code></li>
</ol>
<p>不需要太考虑算法，直接DFS就可以了。遍历到<code>2</code>且计数发现已经遍历完所有非<code>-1</code>的位置表示找到了一条路径。向邻结点遍历时需要在计数上增加一个已经遍历的<code>-1</code>结点，并把该结点的<code>seen</code>设置为已经访问过，从这个结点开始的DFS结束后，再把<code>seen</code>设置为未访问状态。</p>
<p>当然，开始的位置（<code>1</code>）还是需要遍历找到。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        seen = [[<span class="number">0</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y, left)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y] == <span class="number">2</span> <span class="keyword">and</span> left == <span class="number">0</span>:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i, j <span class="keyword">in</span> [(x + <span class="number">1</span>, y), (x - <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; m <span class="keyword">and</span> grid[i][j] != <span class="number">-1</span> <span class="keyword">and</span> seen[i][j] == <span class="number">0</span>:</span><br><span class="line">                        seen[i][j] = <span class="number">1</span></span><br><span class="line">                        dfs(i, j, left - <span class="number">1</span>)</span><br><span class="line">                        seen[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    start = i, j</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        x, y = start</span><br><span class="line">        seen[x][y] = <span class="number">1</span></span><br><span class="line">        dfs(x, y, left + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-120/" data-id="cjuh9fx6b001lu0w3phy3ird7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-lexical-addressing" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/lexical-addressing/">词法寻址</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/lexical-addressing/" class="article-date"><time datetime="2019-01-15T15:31:57.702Z" itemprop="datePublished">2019-01-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>词法寻址是Scheme这样使用词法作用域（lexical scope）即函数被调用时以函数被定义时的环境来求值的语言的编译器过程中最常见的优化之一，这部分内容对应SICP原书<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-35.html#%25_sec_5.5.6" target="_blank" rel="noopener">5.5.6  Lexical Addressing</a>部分，你可以看到原书只是大致提了一下优化的背景和思路，具体如何做都放在习题里面了，需要自己尝试着去写实现，MIT 6.001等公开的资料更是完全没有提及。所以我参考了SchemeWiki社区给出的一些解决方案来完整实现一下这部分内容的细节描述。当然更多资源和深入的关于词法寻址的讨论可以参考其他资料&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，我在这里不再多谈。</p>
<p>&lt;!-- more --&gt;</p>
<h2>问题背景</h2>
<p>众所周知，Scheme在实现函数调用（包括<code>let</code>表达式这个lambda的语法糖）时是把形参与调用时的实参一一绑定成一个帧（frame），然后扩展到函数被定义时的环境。</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/lexical-addressing/frame_enclosing.png?inline=false" alt="Newton迭代法求平方根的变量环境模型图，帧的划分不完全准确，但可以看到函数sqrt-iter和good-enough?调用时会把形参和实参绑定成新的帧并指向被扩展的环境E2"></p>
<p>对变量进行寻址时使用<code>lookup-variable-value</code>一帧一帧找第一个该变量的绑定。</p>
<p>假设帧（frame），环境（env）都是沿用<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%25_sec_4.1.3" target="_blank" rel="noopener">The Metacircular Evaluator</a>中规定的结构，即环境为多个帧按照绑定的优先级顺序构成的列表：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">enclosing-environment</span> env) (<span class="name"><span class="builtin-name">cdr</span></span> env))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-frame</span> env) (<span class="name"><span class="builtin-name">car</span></span> env))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> the-empty-environment '())</span><br></pre></td></tr></table></figure></p>
<p>而每个帧又是由一个变量列表<code>variables</code>和值列表<code>values</code>组成的对，相同索引位置的变量和值形成一对绑定：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-frame</span> variables values)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> variables values))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">frame-variables</span> frame) (<span class="name"><span class="builtin-name">car</span></span> frame))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">frame-values</span> frame) (<span class="name"><span class="builtin-name">cdr</span></span> frame))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-binding-to-frame!</span> var val frame)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-car!</span></span> frame (<span class="name"><span class="builtin-name">cons</span></span> var (<span class="name"><span class="builtin-name">car</span></span> frame)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-cdr!</span></span> frame (<span class="name"><span class="builtin-name">cons</span></span> val (<span class="name"><span class="builtin-name">cdr</span></span> frame))))</span><br></pre></td></tr></table></figure></p>
<p>所以<code>lookup-variable-value</code>一帧一帧逐个对查找变量是否在环境中的过程表示为：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lookup-variable-value</span> var env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">env-loop</span> env)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">scan</span> vars vals)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">null?</span></span> vars)</span><br><span class="line">             (<span class="name">env-loop</span> (<span class="name">enclosing-environment</span> env)))</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> var (<span class="name"><span class="builtin-name">car</span></span> vars))</span><br><span class="line">             (<span class="name"><span class="builtin-name">car</span></span> vals))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">scan</span> (<span class="name"><span class="builtin-name">cdr</span></span> vars) (<span class="name"><span class="builtin-name">cdr</span></span> vals)))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> env the-empty-environment)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Unbound variable"</span> var)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">frame</span> (<span class="name">first-frame</span> env)))</span><br><span class="line">          (<span class="name">scan</span> (<span class="name">frame-variables</span> frame)</span><br><span class="line">                (<span class="name">frame-values</span> frame)))))</span><br><span class="line">  (<span class="name">env-loop</span> env))</span><br></pre></td></tr></table></figure></p>
<p>那么有一个突出的问题就是当编译器对一个包含多层定义的表达式求值时，会遇到使用的求值环境中包含多个帧嵌套的情况，用上述的<code>lookup-variable-value</code>对环境中的变量寻址时需要找很多帧很多变量才能找到第一个匹配的变量名。比如考虑
&lt;a name=example&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">x</span> <span class="number">3</span>) (<span class="name">y</span> <span class="number">4</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (a b c d e)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">y</span> (<span class="name"><span class="builtin-name">*</span></span> a b x))</span><br><span class="line">          (<span class="name">z</span> (<span class="name"><span class="builtin-name">+</span></span> c d x)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> x y z))))</span><br></pre></td></tr></table></figure></p>
<p>或者它的等效展开
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (x y)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (a b c d e)</span><br><span class="line">     ((<span class="name"><span class="builtin-name">lambda</span></span> (y z) (<span class="name"><span class="builtin-name">*</span></span> x y z))</span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> a b x)</span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> c d x))))</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>然而，没有相应优化的编译器对lambda表达式的函数体部分进行编译过程为：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-lambda-body</span> exp proc-entry)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">formals</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)))</span><br><span class="line">    (<span class="name">append-instruction-sequences</span></span><br><span class="line">     (<span class="name">make-instruction-sequence</span> '(env proc argl) '(env)</span><br><span class="line">      `(,proc-entry</span><br><span class="line">        (assign env (op compiled-procedure-env) (reg proc))</span><br><span class="line">        (assign env</span><br><span class="line">                (op extend-environment)</span><br><span class="line">                (const ,formals)</span><br><span class="line">                (reg argl)</span><br><span class="line">                (reg env))))</span><br><span class="line">     (<span class="name">compile-sequence</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>) <span class="symbol">'val</span> <span class="symbol">'return</span>))))</span><br></pre></td></tr></table></figure></p>
<p>所生产的机器指令代码并未考虑函数体中出现的变量应该如何在新环境中被寻址，因此每次运行时执行指令都需要使用<code>lookup-variable-value</code>操作对变量从头开始找绑定，可能需要经过很“深”的遍历，如上文的<code>(* x y z)</code>的三个变量，<code>x</code>会出现在被<code>lookup-variable-value</code>查找的第3帧的第1个变量的位置。多次调用一个函数时，虽然每个变量在环境中的位置已经<strong>固定</strong>了，还是需要一板一眼按顺序去寻址，如此冗余的寻址操作带来很大的开销。</p>
<p>词法寻址将编译结果中对变量的寻址用<strong>一个固定的值</strong>表示，即该变量在环境中的位置，每次执行寻址时只需要根据这个位置再去环境中取出相应的值，经过这样的优化后，不必再做笨重的遍历了。</p>
<h2>索引寻址</h2>
<p>为了实现上述机制，需要重新定义一个在环境<code>env</code>中寻址的函数<code>lexical-address-lookup</code>，不同于前面直接传入变量名的<code>lookup-variable-value</code>，新的寻址函数用一个词法地址（lexical address）参数来代表需要被寻址的变量。词法地址有两个部分，第一部分<code>addr-frame</code>表示变量所在的帧在环境中的序号，即寻址需要遍历多少帧，第二部分<code>addr-offset</code>表示变量在相应帧中的序号，在该帧的位置。当该位置的变量值为<code>*unassigned*</code>时表示变量未被初始化。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lexical-address</span> addr-frame addr-offset)</span><br><span class="line"> (<span class="name"><span class="builtin-name">cons</span></span> addr-frame addr-offset))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">addr-frame</span> address) (<span class="name"><span class="builtin-name">car</span></span> address))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">addr-offset</span> address) (<span class="name"><span class="builtin-name">cdr</span></span> address))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lexical-address-lookup</span> env address)</span><br><span class="line"> (<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">frame</span> (<span class="name"><span class="builtin-name">list-ref</span></span> env (<span class="name">addr-frame</span> address)))</span><br><span class="line">        (<span class="name">value</span> (<span class="name"><span class="builtin-name">list-ref</span></span> (<span class="name">frame-values</span> frame) (<span class="name">addr-offset</span> address))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> value <span class="symbol">'*unassigned*</span>)</span><br><span class="line">      (<span class="name">error</span> <span class="string">"the variable is unassigned -- LEXICAL-ADDRESS-LOOKUP"</span></span><br><span class="line">             address)))</span><br><span class="line">      value)</span><br></pre></td></tr></table></figure></p>
<p>相似的，我们也可以以这个方式定义一个赋值过程：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lexical-address-set!</span> env address value)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">frame</span> (<span class="name">addr-frame</span> address))</span><br><span class="line">        (<span class="name">offset</span> (<span class="name">addr-offset</span> address)))</span><br><span class="line">   (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-value!</span> f pos)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> f <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">set-car!</span></span> f value)</span><br><span class="line">        (<span class="name">set-value!</span> (<span class="name"><span class="builtin-name">cdr</span></span> f (<span class="name"><span class="builtin-name">-</span></span> pos <span class="number">1</span>)))))</span><br><span class="line">   (<span class="name">set-value!</span> frame offset value)))</span><br></pre></td></tr></table></figure></p>
<p>直接通过词法地址来改变变量在环境中的值绑定。</p>
<h2>编译时环境</h2>
<p>为了能够在每个lambda表达式编译时维护准确的词法地址，还需要定义一种被称为编译时环境（compile-time environment）的数据结构，来追踪每个变量会在真实的求值环境中处于哪一帧的哪一个位置。不同于运行时求值环境，编译时环境只需要按照函数的嵌套顺序将形参按照正确的顺序扩展变量，使它保持和真实求值环境的变量部分一致即可，不需要在编译期关注这些变量具体的值。</p>
<p>比如前文提到的<a href="#example">例子</a>中<code>(* x y z)</code>的编译时环境为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">y</span> z) (<span class="name">a</span> b c d e) (<span class="name">x</span> y))</span><br></pre></td></tr></table></figure></p>
<p>通过在这个环境中寻址，就可以在编译期间直接找到变量在环境中的位置。</p>
<p>这样编译器<code>compile</code>需要传入一个额外的参数编译时环境<code>ct-env</code>来生成优化的机器指令代码。顶层<code>compile</code>被传入一个空的编译时环境，当处理lambda表达式时用<code>compile-lambda-body</code>把过程的形参扩展到当前的编译时环境。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-lambda-body</span> exp proc-entry ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">formals</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)))</span><br><span class="line">    (<span class="name">append-instruction-sequences</span></span><br><span class="line">      (<span class="name">make-instruction-sequence</span> '(env proc argl) '(env)</span><br><span class="line">        `(,proc-entry</span><br><span class="line">          (assign env (op compiled-procedure-env) (reg proc))</span><br><span class="line">          (assign env</span><br><span class="line">                  (op extend-environment)</span><br><span class="line">                  (const ,formals)</span><br><span class="line">                  (reg argl)</span><br><span class="line">                  (reg env))))</span><br><span class="line">      (<span class="name">compile-sequence</span></span><br><span class="line">        (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">        <span class="symbol">'val</span> <span class="symbol">'return</span></span><br><span class="line">        (<span class="name">extend-ct-env</span> ct-env formals))))) <span class="comment">;modified here, extend formal list to ct-env</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">extend-ct-env</span> env frame)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> frame env))</span><br></pre></td></tr></table></figure></p>
<p>相比优化前的lambda表达式处理，这是增加了一步在函数体中通过参数传递了编译时环境。而这个编译时环境的用法在于我们可以通过这个预处理的编译时环境，找到需要被编译的变量在环境中的地址，定义一个<code>find-variable</code>来完成变量<code>var</code>在<code>ct-env</code>的定位，返回它的词法地址，即帧数和变量数组成的序对，如果没有找到就返回<code>'not-found</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">find-variable</span> var ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search-variable</span> v l n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">null?</span></span> l) false)</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> v (<span class="name"><span class="builtin-name">car</span></span> l)) n)</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">search-variable</span> v (<span class="name"><span class="builtin-name">cdr</span></span> l) (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>)))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search-frame</span> frames f)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> frames)</span><br><span class="line">        <span class="symbol">'not-found</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">o</span> (<span class="name">search-variable</span> var (<span class="name"><span class="builtin-name">car</span></span> frames) <span class="number">0</span>)))</span><br><span class="line">             (<span class="name"><span class="builtin-name">if</span></span> o</span><br><span class="line">                 (<span class="name"><span class="builtin-name">cons</span></span> f o)</span><br><span class="line">                 (<span class="name">search-frame</span> (<span class="name"><span class="builtin-name">cdr</span></span> frames) (<span class="name"><span class="builtin-name">+</span></span> f <span class="number">1</span>))))))</span><br><span class="line">  (<span class="name">search-frame</span> ct-env <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p>
<p>借助<code>find-variable</code>，在对变量表达式和赋值表达式编译时，可以先对所需变量定位得到词法地址，再生成直接去这个词法地址在环境中的位置进行读写，也就是我们上面定义完成的<code>lexical-address-lookup</code>和<code>lexical-address-set!</code>作为原始操作指令生成可直接执行的代码。</p>
<p>有一种情况需要特殊注意，排除源语言代码编写出错的情况，在编译期间，对一个变量的编译过程中如果在编译时环境中用<code>find-variable</code>返回<code>'not found</code>，那么说明变量现在还没有被放入绑定环境，但这个变量却可以提前使用，那么说明它是一个全局变量，可以用<code>get-global-environment</code>命令查找。而且全局变量也并不适合用词法地址来定位，因为它们一直在被交互地定义和重定义着，不适应这样静态的方法。</p>
<p>对变量表达式求值编译为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-variable</span> exp target linkage ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">lexical-addr</span> (<span class="name">find-variable</span> exp ct-env)))</span><br><span class="line">    (<span class="name">end-with-linkage</span></span><br><span class="line">    linkage</span><br><span class="line">    (<span class="name">make-instruction-sequence</span></span><br><span class="line">     '(env) (<span class="name"><span class="builtin-name">list</span></span> target)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> <span class="symbol">'not-found</span> lexical-addr)</span><br><span class="line">         `((assign ,target</span><br><span class="line">                   (op get-global-environment)</span><br><span class="line">                   (const ,exp)</span><br><span class="line">                   (reg env)))</span><br><span class="line">         `((assign ,target</span><br><span class="line">                   (op lexical-address-lookup)</span><br><span class="line">                   (const ,lexical-addr)</span><br><span class="line">                   (reg env))))))))</span><br></pre></td></tr></table></figure></p>
<p>赋值操作的编译过程为：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-assignment</span> exp target linkage ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">assignment-variable</span> exp))</span><br><span class="line">        (<span class="name">get-value-code</span></span><br><span class="line">         (<span class="name">compile</span> (<span class="name">assignment-value</span> exp) <span class="symbol">'val</span> <span class="symbol">'next</span> ct-env)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">lexical-addr</span> (<span class="name">find-variable</span> var ct-env)))</span><br><span class="line">      (<span class="name">end-with-linkage</span></span><br><span class="line">       linkage</span><br><span class="line">       (<span class="name">preserving</span></span><br><span class="line">        '(env)</span><br><span class="line">        get-value-code</span><br><span class="line">        (<span class="name">make-instruction-sequence</span></span><br><span class="line">         '(env val) (<span class="name"><span class="builtin-name">list</span></span> target)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> lexical-addr <span class="symbol">'not-found</span>)</span><br><span class="line">             `((perform (op set-variable-value!)</span><br><span class="line">                        (const ,var)</span><br><span class="line">                        (reg val)</span><br><span class="line">                        (reg env))</span><br><span class="line">               (assign ,target (const ok)))</span><br><span class="line">             `((perform (op lexical-address-set!)</span><br><span class="line">                        (const ,lexical-addr)</span><br><span class="line">                        (reg val)</span><br><span class="line">                        (reg env))</span><br><span class="line">               (assign ,target (const ok))))))))))</span><br></pre></td></tr></table></figure></p>
<h2>内部定义</h2>
<p>我在<a href="http://notebook.xyli.me/SICP/local-bindings-and-internal-definitions/#internal-define">局部绑定和内部定义</a>一文中详细解释过内部<code>define</code>命令应该如何被求值，因为无法使用全局环境但需要保持“同时定义”的假象来完成变量直接的顺序或递归定义，所以一般做法是先对整个body部分扫描一遍找到所有内部定义语句，并把被内部定义的变量初始化为<code>'*unassigned*</code>扩展当当前环境，再按照语句的定义顺序把这些变量绑定到真正的变量值。即把
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">&lt;vars&gt;</span></span><br><span class="line">  (define u &lt;e1&gt;)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> v &lt;e2&gt;)</span><br><span class="line">  &lt;e3&gt;)</span><br></pre></td></tr></table></figure></p>
<p>当作
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">&lt;vars&gt;</span></span><br><span class="line">  (let ((u '*unassigned*)</span><br><span class="line">        (<span class="name">v</span> <span class="symbol">'*unassigned*</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> u &lt;e1&gt;)</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> v &lt;e2&gt;)</span><br><span class="line">    &lt;e3&gt;))</span><br></pre></td></tr></table></figure></p>
<p>来处理。扫描出这些内部定义变量转换为<code>let</code>表达式和一系列赋值操作的过程<code>scan-out-defines</code>可以实现为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">scan-out-defines</span> body)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">append</span></span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> x) y (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) (<span class="name"><span class="builtin-name">append</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> x) y))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">definitions</span></span><br><span class="line">           (<span class="name">filter</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                     (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">pair?</span></span> x) (<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) <span class="symbol">'define</span>))) body))</span><br><span class="line">         (<span class="name">non-definitions</span></span><br><span class="line">          (<span class="name">filter</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                    (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">pair?</span></span> x))</span><br><span class="line">                        (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) <span class="symbol">'define</span>)))) body))</span><br><span class="line">         (<span class="name">let-vars</span> (<span class="name"><span class="builtin-name">map</span></span> definition-variable definitions))</span><br><span class="line">         (<span class="name">let-vals</span> (<span class="name"><span class="builtin-name">map</span></span> definition-value definitions))</span><br><span class="line">         (<span class="name">let-bindings</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">list</span></span> x '<span class="symbol">'*unassigned*</span>)) let-vars))</span><br><span class="line">         (<span class="name">assignments</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (x y) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'set!</span> x y)) let-vars let-vals)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> let-bindings)</span><br><span class="line">        body</span><br><span class="line">        (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">make-let</span> let-bindings (<span class="name"><span class="builtin-name">append</span></span> assignments non-definitions))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-let</span> bindings body)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'let</span> (<span class="name"><span class="builtin-name">cons</span></span> bindings body)))</span><br></pre></td></tr></table></figure></p>
<p>那么编译带有内部绑定的lambda表达式的函数体部分时，只需要把函数体部分用<code>scan-out-defines</code>转换成相应的<code>let</code>表达式：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-lambda-body</span> exp proc-entry ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">formals</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)))</span><br><span class="line">    (<span class="name">append-instruction-sequences</span></span><br><span class="line">      (<span class="name">make-instruction-sequence</span> '(env proc argl) '(env)</span><br><span class="line">        `(,proc-entry</span><br><span class="line">          (assign env (op compiled-procedure-env) (reg proc))</span><br><span class="line">          (assign env</span><br><span class="line">                  (op extend-environment)</span><br><span class="line">                  (const ,formals)</span><br><span class="line">                  (reg argl)</span><br><span class="line">                  (reg env))))</span><br><span class="line">      (<span class="name">compile-sequence</span></span><br><span class="line">        (<span class="name">scan-out-defines</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>)) <span class="comment">;just modified here; translate lambda-body into correct let expression.</span></span><br><span class="line">        <span class="symbol">'val</span> <span class="symbol">'return</span></span><br><span class="line">        (<span class="name">extend-ct-env</span> ct-env formals)))))</span><br></pre></td></tr></table></figure></p>
<h2>尾声</h2>
<p>到此为止，词法寻址的实现基本完成。</p>
<p>有人可能观察到了编译时环境的维护除了辅助词法寻址以外还有别的用处，比如在搭载了open-coding的编译器中，虽然把一些简单的原始操作（如<code>+-*\</code>）直接处理为编译器的保留字可以省略对运算符的求值计算，但相应的也限制了程序的灵活编写，无法对这些运算符按照编写者的需求重载。如传入六个参数计算线性组合的过程
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">linear-combine</span> + * a b x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> a x) (<span class="name"><span class="builtin-name">*</span></span> b y)))</span><br></pre></td></tr></table></figure></p>
<p>无论以怎样的实参调用它，函数体的<code>+</code>和<code>*</code>始终会被当成原始的四则运算操作，当我们已经定义好的矩阵加法和乘法运算，想用这个函数来算矩阵的线性组合时会发现无法使用。</p>
<p>而有了编译时环境的帮助，就可以先在编译时环境中检查环境中是否有关于运算符的定义，如果没有再考虑open-coding的，结合两种优化可以极大提高效率。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">overwrite?</span> operator ct-env)</span><br><span class="line"> (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">r</span> (<span class="name">find-variable</span> operator ct-env)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">eq?</span></span> r <span class="symbol">'not-found</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">open-code?</span> exp ct-env)</span><br><span class="line"> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">memq</span></span> (<span class="name"><span class="builtin-name">car</span></span> exp) '(+ - * /))</span><br><span class="line">      (<span class="name">overwrite?</span> (<span class="name"><span class="builtin-name">car</span></span> exp) ct-env)))</span><br></pre></td></tr></table></figure></p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://course.ccs.neu.edu/cs7400/lectures/lecture04.pdf NEU的Principles of Programming Languages关于词法寻址部分的讲义，注意它还提到了可以参考&lt;a href=&quot;https://mitpress.mit.edu/books/essentials-programming-languages-third-edition&quot;&gt;EOPL&lt;/a&gt;3.6-3.8，但EOPL第三版已经没有3.8小节了，3.6描述了编译器如何用环境地址中的索引替代掉真正的变量名。3.7给出了词法寻址的具体实现。&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/lexical-addressing/" data-id="cjuh9fxfz005cu0w33240uvz5" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译器/">编译器</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-119" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-119/">LeetCode Weekly Contest 119</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-119/" class="article-date"><time datetime="2019-01-13T12:24:23.180Z" itemprop="datePublished">2019-01-13</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-119</p>
<p>&lt;!-- more --&gt;</p>
<h2>K Closest Points to Origin</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-119/problems/k-closest-points-to-origin/</p>
<blockquote>
<p>We have a list of <code>points</code> on the plane.  Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>
</blockquote>
<blockquote>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
</blockquote>
<blockquote>
<p>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,3],[-2,2]], K = 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation:</span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[3,3],[5,-1],[-2,4]], K = 2</span><br><span class="line">Output: [[3,3],[-2,4]]</span><br><span class="line">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
<p>没什么好说的</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span><span class="params">(self, points, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nsmallest(K, points, key=<span class="keyword">lambda</span> (x, y): x * x + y * y)</span><br></pre></td></tr></table></figure></p>
<h2>Largest Perimeter Triangle</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-119/problems/largest-perimeter-triangle/</p>
<blockquote>
<p>Given an array <code>A</code> of positive lengths, return the largest perimeter of a triangle with <strong>non-zero area</strong>, formed from 3 of these lengths.</p>
</blockquote>
<blockquote>
<p>If it is impossible to form any triangle of non-zero area, return <code>0</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,4]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,6,2,3]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
<p>按边长从大到小记三条边分别为<code>a</code>,<code>b</code>,<code>c</code>，需要满足<code>a-b&lt;c</code>，在固定<code>a</code>和<code>b</code>的情况下，为了使边长最长且满足条件只需要检查小于等于<code>b</code>的最大<code>c</code>是否符合要求，因此在排序后<code>b</code>和<code>c</code>必然连续。如果存在一个<code>a&gt;=d&gt;=b</code>，一定有<code>d&gt;a-b</code>，那么<code>c</code>就不是使周长最大的边了，所以当<code>a</code>和<code>b</code>间存在元素时，不需要再去检查<code>c</code>。因此这三条边在排序后的数组中一定连续。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestPerimeter</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        A.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i] - A[i + <span class="number">1</span>] &lt; A[i + <span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">return</span> A[i] + A[i + <span class="number">1</span>] + A[i + <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2>Subarray Sums Divisible by K</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-119/problems/subarray-sums-divisible-by-k/</p>
<blockquote>
<p>Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by <code>K</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,5,0,-2,-3,1], K = 5</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: There are 7 subarrays with a sum divisible by K = 5:</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>2 &lt;= K &lt;= 10000</code></li>
</ol>
<p>以<code>i</code>下标结尾可以取<code>i+1</code>个子数组，它们的和模<code>K</code>的余数出现的次数可以记录在一个数组<code>rem</code>中，让<code>rem[k]</code>表示和余<code>k</code>的数组共有多少个。当我们把子数组扩展到以<code>i+1</code>结尾时，<code>rem[k]</code>平移到了<code>rem[(k+A[i+1])%K]</code>，考虑到可以用空数组<code>[]+[A[i+1]]</code>来生成新数组，因此在平移前<code>rem[0]</code>需要再增加1。每轮平移完成后<code>rem[0]</code>被加到最终结果。</p>
<p>当然实现时移动数组很麻烦，所以可以用指针<code>p</code>来表示开始读取<code>rem</code>时下标<code>0</code>对应的位置，每轮平移只修改<code>p</code>的值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysDivByK</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        rem = [<span class="number">0</span>] * K</span><br><span class="line">        res = p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            rem[p] += <span class="number">1</span></span><br><span class="line">            p = (p + A[i]) % K</span><br><span class="line">            res += rem[p]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Odd Even Jump</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-119/problems/odd-even-jump/</p>
<blockquote>
<p>You are given an integer array <code>A</code>.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.</p>
</blockquote>
<blockquote>
<p>You may from index <code>i</code> jump forward to index <code>j</code> (with <code>i &lt; j</code>) in the following way:</p>
</blockquote>
<ul>
<li>During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that <code>A[i] &lt;= A[j]</code> and <code>A[j]</code> is the smallest possible value.  If there are multiple such indexes <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>
<li>During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that <code>A[i] &gt;= A[j]</code> and <code>A[j]</code> is the largest possible value.  If there are multiple such indexes <code>j</code>, you can only jump to the <strong>smallest</strong> such index <code>j</code>.</li>
<li>(It may be the case that for some index <code>i</code>, there are no legal jumps.)</li>
</ul>
<blockquote>
<p>A starting index is <em>good</em> if, starting from that index, you can reach the end of the array (index <code>A.length - 1</code>) by jumping some number of times (possibly 0 or more than once.)</p>
</blockquote>
<blockquote>
<p>Return the number of good starting indexes.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,13,12,14,15]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can&apos;t jump any more.</span><br><span class="line">From starting index i = 1 and i = 2, we can jump to i = 3, then we can&apos;t jump any more.</span><br><span class="line">From starting index i = 3, we can jump to i = 4, so we&apos;ve reached the end.</span><br><span class="line">From starting index i = 4, we&apos;ve reached the end already.</span><br><span class="line">In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:</span><br><span class="line"></span><br><span class="line">During our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0].</span><br><span class="line"></span><br><span class="line">During our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1].  A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3.</span><br><span class="line"></span><br><span class="line">During our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2].</span><br><span class="line"></span><br><span class="line">We can&apos;t jump from i = 3 to i = 4, so the starting index i = 0 is not good.</span><br><span class="line"></span><br><span class="line">In a similar manner, we can deduce that:</span><br><span class="line">From starting index i = 1, we jump to i = 4, so we reach the end.</span><br><span class="line">From starting index i = 2, we jump to i = 3, and then we can&apos;t jump anymore.</span><br><span class="line">From starting index i = 3, we jump to i = 4, so we reach the end.</span><br><span class="line">From starting index i = 4, we are already at the end.</span><br><span class="line">In total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,3,4,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We can reach the end from starting indexes 1, 2, and 4.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= A[i] &lt; 100000</code></li>
</ol>
<p>注意读题理解规则，我读错好几次了。</p>
<ul>
<li>奇数跳：跳到右边大于等于当前值的最小值，如果有多个，取最近的。也就是跳到右边“略”大于自己的位置。</li>
<li>偶数跳：跳到右边小于等于当前值的最小值，如果有多个，取最近的。也就是跳到右边“略”小于自己的位置。</li>
</ul>
<p>如果当前位置在<code>i</code>，怎样找下一跳（奇数/偶数）落脚的位置？也就是找右边比自己略大或略小的位置，这里用了类似以前单调栈的办法，以找右边略大值位置为例，先对<code>A</code>按照元素大小为主顺序，索引值为辅助顺序排序，然后开始压栈：如果当前值的索引大于栈顶元素的索引值（即当前值在栈顶元素右边），那么弹出栈顶元素，这个被弹出的元素的奇数跳落脚点就是当前索引，可以记录下来，我这里用的是记录栈顶元素到<code>larger[i]</code>列表中，表示<code>i</code>是在这些元素右边且稍大于它们的值，奇数跳达到<code>i</code>的可能是<code>larger[i]</code>的所有下标。接下来再把当前遍历到的下标<code>i</code>压入栈中。遍历结束后还留在栈内的就是无法通过奇数跳跳到别的位置的值。</p>
<p>到达一个值<code>i</code>可能通过奇数跳或者偶数跳，如果是通过奇数跳，那么有一种特殊的情况就是只跳了一步，那么上一个位置<code>larger[i]</code>就是可能的起点，或者经历过偶数跳来到的地方（临时位置），把这些临时位置<code>larger[i]</code>作为偶数跳的结果再放入队列；如果通过偶数跳来到<code>i</code>，那么上一跳必然是通过奇数跳到达的，回溯到上一跳的所有可能情况<code>smaller[i]</code>作为奇数跳的结果再放入队列。最后直至找不到前一跳的可能结果。</p>
<p><code>n-1</code>可以跳过奇数跳也可以通过偶数跳到达，因此初始化时需要把两种情况都放入队列。另外也可以通过0跳在<code>n-1</code>位置直接到达，计算结果时注意把计数初始化为1。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenJumps</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        <span class="comment"># A[i] is the smllest A[i]&gt;=A[j] for j in larger[i] and j&gt;i</span></span><br><span class="line">        larger = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># A[i] is the largest A[i]&lt;=A[j] for j in larger[i] and j&gt;i</span></span><br><span class="line">        smaller = collections.defaultdict(list)</span><br><span class="line">        s = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x, i) <span class="keyword">in</span> sorted([(A[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[<span class="number">-1</span>] &lt; i:</span><br><span class="line">                larger[i].append(s.pop())</span><br><span class="line">            s.append(i)</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> (x, i) <span class="keyword">in</span> sorted([(-A[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]):</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[<span class="number">-1</span>] &lt; i:</span><br><span class="line">                smaller[i].append(s.pop())</span><br><span class="line">            s.append(i)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># jumper</span></span><br><span class="line">        q = [(n - <span class="number">1</span>, <span class="number">1</span>), (n - <span class="number">1</span>, <span class="number">-1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> q:</span><br><span class="line">            <span class="comment"># reached by odd jumps, A[i] is the smallest element in A[x:] and A[x]&gt;=A[i]</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="number">1</span>:</span><br><span class="line">                res += len(larger[i])</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> larger[i]:</span><br><span class="line">                    q.append((x, <span class="number">-1</span>))</span><br><span class="line">            <span class="comment"># reached by even jumps, A[i] is the largest element in A[x:] and A[x]&lt;=A[i]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> smaller[i]:</span><br><span class="line">                    q.append((x, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-119/" data-id="cjuh9fx67001ju0w331ofvdsy" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-118" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-118/">LeetCode Weekly Contest 118</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-118/" class="article-date"><time datetime="2019-01-06T09:34:36.571Z" itemprop="datePublished">2019-01-06</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新年快乐！</p>
<p>https://leetcode.com/contest/weekly-contest-118</p>
<p>&lt;!-- more --&gt;</p>
<h2>Powerful Integers</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-118/problems/powerful-integers/</p>
<blockquote>
<p>Given two non-negative integers <code>x</code> and <code>y</code>, an integer is powerful if it is equal to <code>x^i + y^j</code> for some integers <code>i &gt;= 0</code> and <code>j &gt;= 0</code>.</p>
</blockquote>
<blockquote>
<p>Return a list of all <em>powerful</em> integers that have value less than or equal to <code>bound</code>.</p>
</blockquote>
<blockquote>
<p>You may return the answer in any order.  In your answer, each value should occur at most once.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 2, y = 3, bound = 10</span><br><span class="line">Output: [2,3,4,5,7,9,10]</span><br><span class="line">Explanation:</span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 3, y = 5, bound = 15</span><br><span class="line">Output: [2,4,6,8,10,14]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= x &lt;= 100</code></li>
<li><code>1 &lt;= y &lt;= 100</code></li>
<li><code>0 &lt;= bound &lt;= 10^6</code></li>
</ol>
<p>没什么好说的，暴力搜索，注意处理一下底数为1的情况</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">powerfulIntegers</span><span class="params">(self, x, y, bound)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :type bound: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = set()</span><br><span class="line">        cur_x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur_x &lt;= bound:</span><br><span class="line">            cur_y = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cur_x + cur_y &lt;= bound:</span><br><span class="line">                res.add(cur_x + cur_y)</span><br><span class="line">                <span class="keyword">if</span> y == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur_y *= y</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur_x *= x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br></pre></td></tr></table></figure></p>
<h2>Pancake Sorting</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-118/problems/pancake-sorting/</p>
<blockquote>
<p>Given an array <code>A</code>, we can perform a pancake flip: We choose some positive integer <code>k &lt;= A.length</code>, then reverse the order of the first k elements of <code>A</code>.  We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array <code>A</code>.</p>
</blockquote>
<blockquote>
<p>Return the k-values corresponding to a sequence of pancake flips that sort A.  Any valid answer that sorts the array within <code>10 * A.length</code> flips will be judged as correct.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,4,1]</span><br><span class="line">Output: [4,2,4,3]</span><br><span class="line">Explanation:</span><br><span class="line">We perform 4 pancake flips, with k values 4, 2, 4, and 3.</span><br><span class="line">Starting state: A = [3, 2, 4, 1]</span><br><span class="line">After 1st flip (k=4): A = [1, 4, 2, 3]</span><br><span class="line">After 2nd flip (k=2): A = [4, 1, 2, 3]</span><br><span class="line">After 3rd flip (k=4): A = [3, 2, 1, 4]</span><br><span class="line">After 4th flip (k=3): A = [1, 2, 3, 4], which is sorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The input is already sorted, so there is no need to flip anything.</span><br><span class="line">Note that other answers, such as [3, 3], would also be accepted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>A[i]</code> is a permutation of <code>[1, 2, ..., A.length]</code></li>
</ol>
<p>只要求返回一种可行的翻转顺序，不限制操作数，那么只需要用最简单无脑的方法生成一个可行解：</p>
<p>从<code>k=A.length</code>开始，找到第<code>k</code>大的数（即前<code>k</code>个数的最大值<code>k</code>，因为这实际上也是一个排列）并放回到正确的位置，然后再在排前<code>k-1</code>个数的顺序……</p>
<p>假设现在需要排的第<code>k</code>大的数出现第<code>pos</code>位，那么需要先对前<code>pos</code>个数进行一次翻转，使得<code>pos</code>位的<code>k</code>位于数组第一位，然后对前<code>k</code>个数再进行一次翻转，使得原本在第一位的<code>k</code>被翻转到第<code>k</code>位。</p>
<p>这样一来，在最坏的输入下，每个数需要被翻转2次就可以回到正确的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pancakeSort</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        k = len(A)</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            pos = A.index(k, <span class="number">0</span>, k)</span><br><span class="line">            <span class="keyword">if</span> pos != k - <span class="number">1</span>:</span><br><span class="line">                res.append(pos + <span class="number">1</span>)</span><br><span class="line">                A[:pos + <span class="number">1</span>] = A[pos::<span class="number">-1</span>]</span><br><span class="line">                res.append(k)</span><br><span class="line">                A[:k] = A[k - <span class="number">1</span>::<span class="number">-1</span>]</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Flip Binary Tree To Match Preorder Traversal</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-118/problems/flip-binary-tree-to-match-preorder-traversal/</p>
<blockquote>
<p>Given a binary tree with <code>N</code> nodes, each node has a different value from <code>{1, ..., N}</code>.</p>
</blockquote>
<blockquote>
<p>A node in this binary tree can be flipped by swapping the left child and the right child of that node.</p>
</blockquote>
<blockquote>
<p>Consider the sequence of <code>N</code> values reported by a preorder traversal starting from the root.  Call such a sequence of <code>N</code> values the voyage of the tree.</p>
</blockquote>
<blockquote>
<p>(Recall that a preorder traversal of a node means we report the current node's value, then preorder-traverse the left child, then preorder-traverse the right child.)</p>
</blockquote>
<blockquote>
<p>Our goal is to flip <strong>the least number</strong> of nodes in the tree so that the voyage of the tree matches the <code>voyage</code> we are given.</p>
</blockquote>
<blockquote>
<p>If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.</p>
</blockquote>
<blockquote>
<p>If we cannot do so, then return the list <code>[-1]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/02/1219-01.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2], voyage = [2,1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/02/1219-02.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,3,2]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/01/02/1219-02.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,2,3]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 100</code></li>
</ol>
<p>对二叉树进行先序BFS，如果当前结点<code>r</code>的值等于<code>voyage</code>目前第一个元素，则从<code>voyage</code>中弹出该元素，否则返回<code>[-1]</code>。然后检查<code>r</code>的左右子结点，因为所有结点值都是唯一的，所以只要有一个的值等于<code>voyage</code>的第一个元素，就把它作为下一个访问的结点，并把另一个结点压入栈中，如果是右子结点符合，而左子结点非空却不符合，那么说明需要对<code>r</code>进行翻转。如果<code>r</code>有子结点但没有值符合的子结点，那么先序遍历的下一个值必然不符合，无法通过翻转得到<code>voyage</code>，返回<code>[-1]</code>。对于压入栈中的空结点，遍历到时直接弹出即可。清空访问栈后如果<code>voyage</code>也被清空则说明可以通过上述的翻转操作得到结果，否则不能。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipMatchVoyage</span><span class="params">(self, root, voyage)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type voyage: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            r = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> voyage:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">-1</span>]</span><br><span class="line">            cur = voyage.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> r.val == cur:</span><br><span class="line">                <span class="keyword">if</span> r.left <span class="keyword">and</span> voyage <span class="keyword">and</span> r.left.val == voyage[<span class="number">0</span>]:</span><br><span class="line">                    stack.append(r.right)</span><br><span class="line">                    stack.append(r.left)</span><br><span class="line">                <span class="keyword">elif</span> r.right <span class="keyword">and</span> voyage <span class="keyword">and</span> r.right.val == voyage[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> r.left:</span><br><span class="line">                        res.append(r.val)</span><br><span class="line">                        stack.append(r.left)</span><br><span class="line">                    stack.append(r.right)</span><br><span class="line">                <span class="keyword">elif</span> r.left <span class="keyword">or</span> r.right:</span><br><span class="line">                    <span class="keyword">return</span> [<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">and</span> <span class="keyword">not</span> voyage:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2>Equal Rational Numbers</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-118/problems/equal-rational-numbers/</p>
<blockquote>
<p>Given two strings <code>S</code> and <code>T</code>, each of which represents a non-negative rational number, return <strong>True</strong> if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.</p>
</blockquote>
<blockquote>
<p>In general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. The number will be represented in one of the following three ways:</p>
</blockquote>
<ul>
<li><code>&lt;IntegerPart&gt;</code> (e.g. 0, 12, 123)</li>
<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;</code>  (e.g. 0.5, 1., 2.12, 2.0001)</li>
<li><code>&lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</code> (e.g. 0.1(6), 0.9(9), 0.00(1212))</li>
</ul>
<blockquote>
<p>The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example:</p>
</blockquote>
<blockquote>
<p>1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)</p>
</blockquote>
<blockquote>
<p>Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0.(52)&quot;, T = &quot;0.5(25)&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">Because &quot;0.(52)&quot; represents 0.52525252..., and &quot;0.5(25)&quot; represents 0.52525252525..... , the strings represent the same number.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0.1666(6)&quot;, T = &quot;0.166(66)&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0.9(9)&quot;, T = &quot;1.&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">&quot;0.9(9)&quot; represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]</span><br><span class="line">&quot;1.&quot; represents the number 1, which is formed correctly: (IntegerPart) = &quot;1&quot; and (NonRepeatingPart) = &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Each part consists only of digits.</li>
<li>The <code>&lt;IntegerPart&gt;</code> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)</li>
<li><code>1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4</code></li>
<li><code>0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4</code></li>
<li><code>1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4</code></li>
</ol>
<p>我实在太懒了，不想动脑子。直接把字符串转换成小数位长度足够的浮点数，然后比较两个浮点数数值是否足够接近。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRationalEqual</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rational_to_float</span><span class="params">(s)</span>:</span></span><br><span class="line">            start, end = s.find(<span class="string">'('</span>), s.find(<span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">if</span> start &gt; <span class="number">-1</span>:</span><br><span class="line">                s = s[:start] + s[start + <span class="number">1</span>:end] * <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> float(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> abs(rational_to_float(S) - rational_to_float(T)) &lt;= <span class="number">.000000001</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-118/" data-id="cjuh9fx5y001hu0w3ra69z8c2" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-117" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-117/">LeetCode Weekly Contest 117</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-117/" class="article-date"><time datetime="2018-12-30T14:45:10.065Z" itemprop="datePublished">2018-12-30</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-117</p>
<p>&lt;!-- more --&gt;</p>
<h2>Univalued Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-117/problems/univalued-binary-tree/</p>
<blockquote>
<p>A binary tree is univalued if every node in the tree has the same value.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the given tree is univalued.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,1,1,null,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2,5,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>
<li>Each node's value will be an integer in the range <code>[0, 99]</code>.</li>
</ol>
<p>BFS遍历所有值，找到与根结点不同的返回<code>false</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        v = root.val</span><br><span class="line">        q = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> i.val != v:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> i.left:</span><br><span class="line">                q.append(i.left)</span><br><span class="line">            <span class="keyword">if</span> i.right:</span><br><span class="line">                q.append(i.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Numbers With Same Consecutive Differences</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-117/problems/numbers-with-same-consecutive-differences/</p>
<blockquote>
<p>Return all <strong>non-negative</strong> integers of length <code>N</code> such that the absolute difference between every two consecutive digits is <code>K</code>.</p>
</blockquote>
<blockquote>
<p>Note that <strong>every</strong> number in the answer <strong>must not</strong> have leading zeros <strong>except</strong> for the number <code>0</code> itself. For example, <code>01</code> has one leading zero and is invalid, but <code>0</code> is valid.</p>
</blockquote>
<blockquote>
<p>You may return the answer in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, K = 7</span><br><span class="line">Output: [181,292,707,818,929]</span><br><span class="line">Explanation: Note that 070 is not a valid number, because it has leading zeroes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 9</code></li>
<li><code>0 &lt;= K &lt;= 9</code></li>
</ol>
<p>当<code>N=1</code>时，无论<code>K</code>取多少，连续位之间的绝对差为<code>K</code>始终成立，因此0-9所有个位数都成立。<code>N</code>每增加1，需要对<code>N-1</code>时成立的所有结果，添加满足连续位差值的最后一位，该位取值如果还在0-9之间则放入新的结果中，如果第一位为0则不需要考虑，直接舍弃。需要注意如果<code>K=0</code>时只需要考虑一种添加末位的情况，避免重复计数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numsSameConsecDiff</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = list(range(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            new_res = []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">if</span> n / <span class="number">10</span>**(i - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= n % <span class="number">10</span> - K &lt;= <span class="number">9</span>:</span><br><span class="line">                        new_res.append(n * <span class="number">10</span> + n % <span class="number">10</span> - K)</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= n % <span class="number">10</span> + K &lt;= <span class="number">9</span> <span class="keyword">and</span> K &gt; <span class="number">0</span>:</span><br><span class="line">                        new_res.append(n * <span class="number">10</span> + n % <span class="number">10</span> + K)</span><br><span class="line">            res = list(new_res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Vowel Spellchecker</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-117/problems/vowel-spellchecker/</p>
<blockquote>
<p>Given a <code>wordlist</code>, we want to implement a spellchecker that converts a query word into a correct word.</p>
</blockquote>
<blockquote>
<p>For a given <code>query</code> word, the spell checker handles two categories of spelling mistakes:</p>
</blockquote>
<ul>
<li>Capitalization: If the query matches a word in the wordlist (<strong>case-insensitive</strong>), then the query word is returned with the same case as the case in the wordlist.
<ul>
<li>Example: <code>wordlist = [&quot;yellow&quot;]</code>, <code>query = &quot;YellOw&quot;</code>: <code>correct = &quot;yellow&quot;</code></li>
<li>Example: <code>wordlist = [&quot;Yellow&quot;]</code>, <code>query = &quot;yellow&quot;</code>: <code>correct = &quot;Yellow&quot;</code></li>
<li>Example: <code>wordlist = [&quot;yellow&quot;]</code>, <code>query = &quot;yellow&quot;</code>: <code>correct = &quot;yellow&quot;</code></li>
</ul>
</li>
<li>Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (<strong>case-insensitive</strong>), then the query word is returned with the same case as the match in the wordlist.
<ul>
<li>Example: <code>wordlist = [&quot;YellOw&quot;]</code>, <code>query = &quot;yollow&quot;:</code> correct = <code>&quot;YellOw&quot;</code></li>
<li>Example: <code>wordlist = [&quot;YellOw&quot;]</code>, <code>query = &quot;yeellow&quot;</code>: correct = <code>&quot;&quot;</code> (no match)</li>
<li>Example: <code>wordlist = [&quot;YellOw&quot;]</code>, <code>query = &quot;yllw&quot;</code>: correct = <code>&quot;&quot;</code> (no match)</li>
</ul>
</li>
</ul>
<blockquote>
<p>In addition, the spell checker operates under the following precedence rules:</p>
</blockquote>
<ul>
<li>When the query exactly matches a word in the wordlist (<strong>case-sensitive</strong>), you should return the same word back.</li>
<li>When the query matches a word up to capitlization, you should return the first such match in the wordlist.</li>
<li>When the query matches a word up to vowel errors, you should return the first such match in the wordlist.</li>
<li>If the query has no matches in the wordlist, you should return the empty string.</li>
</ul>
<blockquote>
<p>Given some <code>queries</code>, return a list of words <code>answer</code>, where <code>answer[i]</code> is the correct word for <code>query = queries[i]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: wordlist = [&quot;KiTe&quot;,&quot;kite&quot;,&quot;hare&quot;,&quot;Hare&quot;], queries = [&quot;kite&quot;,&quot;Kite&quot;,&quot;KiTe&quot;,&quot;Hare&quot;,&quot;HARE&quot;,&quot;Hear&quot;,&quot;hear&quot;,&quot;keti&quot;,&quot;keet&quot;,&quot;keto&quot;]</span><br><span class="line">Output: [&quot;kite&quot;,&quot;KiTe&quot;,&quot;KiTe&quot;,&quot;Hare&quot;,&quot;hare&quot;,&quot;&quot;,&quot;&quot;,&quot;KiTe&quot;,&quot;&quot;,&quot;KiTe&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= wordlist.length &lt;= 5000</code></li>
<li><code>1 &lt;= queries.length &lt;= 5000</code></li>
<li><code>1 &lt;= wordlist[i].length &lt;= 7</code></li>
<li><code>1 &lt;= queries[i].length &lt;= 7</code></li>
<li>All strings in <code>wordlist</code> and <code>queries</code> consist only of <strong>english</strong> letters.</li>
</ol>
<p>注意匹配的优先顺序，先找完全一致的，再找大小写不一致的里面最先出现的，最后找大小写不敏感且元音可以替代的里面最先出现的。因此可以建立3个hash表（dict）来一次匹配，第一次存放完全相同的词，第二个存放所有字母小写的词中最先出现的原词，第三个存放把元音位置改为通配符<code>‘*’</code>的小写单词匹配中最先出现的，注意这里用倒序遍历<code>wordlist</code>就是为了保证每个记录的值是最先出现的原词。对于<code>queries</code>出现的所有词都顺序寻找是否在这3个字典中出现过，第一次找到返回的值就是结果，如果都找不到返回<code>&quot;&quot;</code>。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spellchecker</span><span class="params">(self, wordlist, queries)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type wordlist: List[str]</span></span><br><span class="line"><span class="string">        :type queries: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        exact_words = &#123;w: w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist&#125;</span><br><span class="line">        caps = &#123;w.lower(): w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist[::<span class="number">-1</span>]&#125;</span><br><span class="line">        delete_vowels = &#123;re.sub(<span class="string">"[aeiou]"</span>, <span class="string">"*"</span>, w.lower()): w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist[::<span class="number">-1</span>]&#125;</span><br><span class="line">        <span class="keyword">return</span> [exact_words.get(w) <span class="keyword">or</span> caps.get(w.lower()) <span class="keyword">or</span> delete_vowels.get(re.sub(<span class="string">"[aeiou]"</span>, <span class="string">"*"</span>, w.lower())) <span class="keyword">or</span> <span class="string">""</span> <span class="keyword">for</span> w <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure></p>
<h2>Binary Tree Cameras</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-117/problems/binary-tree-cameras/</p>
<blockquote>
<p>Given a binary tree, we install cameras on the nodes of the tree.</p>
</blockquote>
<blockquote>
<p>Each camera at a node can monitor <strong>its parent, itself, and its immediate children</strong>.</p>
</blockquote>
<blockquote>
<p>Calculate the minimum number of cameras needed to monitor all nodes of the tree.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,0,null,0,0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: One camera is enough to monitor all nodes if placed as shown.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,0,null,0,null,0,null,null,0]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given tree will be in the range <code>[1, 1000]</code>.</li>
<li><strong>Every</strong> node has value 0.</li>
</ol>
<p>从底层开始向上安装摄像头，可以保证需要的数量最少。</p>
<p>每个结点一共可能有3个状态：装了摄像头（<code>2</code>），没装摄像头但已经被其他结点的监控范围覆盖（<code>1</code>），没装摄像头且没被监控覆盖（<code>0</code>）。空结点属于没<code>1</code>的情况，实际上是不需要被监控。然后从下往上确定每个结点的状态</p>
<ul>
<li>如果一个结点的两个子结点有一个还没被监控覆盖，那么这个结点就需要装上摄像头，成为<code>2</code></li>
<li>如果两个子结点有一个装有摄像头，另一个也不需要再装摄像头来覆盖（<code>1</code>或<code>2</code>），那么该结点已经被监控覆盖，标记为<code>1</code></li>
<li>如果两个子结点都已经被它们的子结点的摄像头覆盖监控了，那么当前结点不需要装监控来向下覆盖，但也没被覆盖，标记为<code>0</code></li>
</ul>
<p>用DFS可以完成以上顺序的遍历，最后检查根结点是否已经被覆盖，如果没有则还需要在根结点上安装一个摄像头。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span>  <span class="comment"># 1: no need 2: has a camera 0: no camera</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            l, r = dfs(root.left), dfs(root.right)</span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">or</span> r == <span class="number">0</span>:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> l == <span class="number">2</span> <span class="keyword">or</span> r == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dfs(root) == <span class="number">0</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-117/" data-id="cjuh9fx5k001fu0w3u6bn7mb6" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
