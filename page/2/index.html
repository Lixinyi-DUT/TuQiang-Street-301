<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/2/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-94" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-94/">LeetCode Weekly Contest 94</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-94/" class="article-date"><time datetime="2018-07-22T05:51:23.969Z" itemprop="datePublished">2018-07-22</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-94/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Leaf-Similar Trees</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/leaf-similar-trees/</p>
<blockquote>
<p>Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a <em>leaf value</em> sequence.
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="">
For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>
</blockquote>
<blockquote>
<p>Two binary trees are considered leaf-similar if their leaf value sequence is the same.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Both of the given trees will have between <code>1</code> and <code>100</code> nodes.</li>
</ol>
<p>遍历（保证遍历顺序是左支在右支之前就可以了）树得到叶结点指序列，比较两个序列是否相等。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leafSimilar</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">leaf_sequence</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> root.left) <span class="keyword">and</span> (<span class="keyword">not</span> root.right):</span><br><span class="line">                 <span class="keyword">return</span> [root.val]</span><br><span class="line">            <span class="keyword">return</span> leaf_sequence(root.left)+leaf_sequence(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leaf_sequence(root1)==leaf_sequence(root2)</span><br></pre></td></tr></table></figure></p>
<h2>Walking Robot Simulation</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/walking-robot-simulation/</p>
<blockquote>
<p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:</p>
</blockquote>
<ul>
<li><code>-2</code>: turn left 90 degrees</li>
<li><code>-1</code>: turn right 90 degrees</li>
<li><code>1 &lt;= x &lt;= 9</code>: move forward x units
Some of the grid squares are obstacles.</li>
</ul>
<blockquote>
<p>The i-th obstacle is at grid point <code>(obstacles[i][0], obstacles[i][1])</code></p>
</blockquote>
<blockquote>
<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>
</blockquote>
<blockquote>
<p>Return the <strong>square</strong> of the maximum Euclidean distance that the robot will be from the origin.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,3], obstacles = []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: robot will go to (3, 4)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= commands.length &lt;= 10000</code></li>
<li><code>0 &lt;= obstacles.length &lt;= 10000</code></li>
<li><code>-30000 &lt;= obstacle[i][0] &lt;= 30000</code></li>
<li><code>-30000 &lt;= obstacle[i][1] &lt;= 30000</code></li>
<li>The answer is guaranteed to be less than <code>2 ^ 31</code>.</li>
</ol>
<p>顺时针排一下四个方向，左转就是前一个方向，右转则是后一个。要求返回的是移动过程中离原点最大距离的平方（我看例子给的结果实际上并不是Euclidean距离的平方，实际上就是距离的平方），而不是最终点与原点之间距离的平方。另外注意一下可能会多次在<code>obstacles</code>中寻值，可以转换成<code>set</code>或者<code>dict</code>之类的hash表避免过大的时间开销。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands, obstacles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type commands: List[int]</span></span><br><span class="line"><span class="string">        :type obstacles: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        direction=[(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>)]</span><br><span class="line">        ob=set([(x,y) <span class="keyword">for</span> [x,y] <span class="keyword">in</span> obstacles])</span><br><span class="line">        d=<span class="number">0</span></span><br><span class="line">        pos=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dist=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> c==<span class="number">-2</span>:</span><br><span class="line">                d=(d+<span class="number">3</span>)%<span class="number">4</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="number">-1</span>:</span><br><span class="line">                d=(d+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(c):</span><br><span class="line">                    pos[<span class="number">0</span>]+=direction[d][<span class="number">0</span>]</span><br><span class="line">                    pos[<span class="number">1</span>]+=direction[d][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> (pos[<span class="number">0</span>],pos[<span class="number">1</span>]) <span class="keyword">in</span> ob:</span><br><span class="line">                        pos[<span class="number">0</span>]-=direction[d][<span class="number">0</span>]</span><br><span class="line">                        pos[<span class="number">1</span>]-=direction[d][<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                dist=max(dist,pos[<span class="number">0</span>]*pos[<span class="number">0</span>]+pos[<span class="number">1</span>]*pos[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure></p>
<h2>Koko Eating Bananas</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/koko-eating-bananas/</p>
<blockquote>
<p>Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.</p>
</blockquote>
<blockquote>
<p>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.</p>
</blockquote>
<blockquote>
<p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.</p>
</blockquote>
<blockquote>
<p>Return the minimum integer K such that she can eat all the bananas within H hours.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [3,6,7,11], H = 8</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 5</span><br><span class="line">Output: 30</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 6</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= piles.length &lt;= 10^4</code></li>
<li><code>piles.length &lt;= H &lt;= 10^9</code></li>
<li><code>1 &lt;= piles[i] &lt;= 10^9</code></li>
</ol>
<p>找到满足<code>sum(ceil(piles[i]/K))&lt;=H</code>的最小<code>K</code>，显然这个至少要从<code>ceil(sum(piles)/H)</code>开始找这个<code>K</code>值，不过比较奇怪的是contest现场时我没多想直接从这里一个个向后找整数竟然也能AC</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k=int(math.ceil(<span class="number">1.0</span>*sum(piles)/H))</span><br><span class="line">        <span class="keyword">while</span> sum([math.ceil(<span class="number">1.0</span>*i/k) <span class="keyword">for</span> i <span class="keyword">in</span> piles])&gt;H:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure></p>
<p>看其他人的做法是在<code>[ceil(sum(piles)/H),max(piles)]</code>范围内用<code>bisect</code>二分搜索找到使得<code>sum(ceil(piles[i]/K))&lt;=H</code>的位置，这样会高效的多。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r=(sum(piles)+H<span class="number">-1</span>)/H,max(piles)</span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            m=(l+r)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> sum((p+m<span class="number">-1</span>)/m <span class="keyword">for</span> p <span class="keyword">in</span> piles) &gt; H:</span><br><span class="line">                l=m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r=m</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure></p>
<p>但不知道为什么看提交的runtime反而明显被拖慢了，大概test cases实在选的太糟糕了，它们的结果都是接近起点的值。</p>
<h2>Length of Longest Fibonacci Subsequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/length-of-longest-fibonacci-subsequence/</p>
<blockquote>
<p>A sequence <code>X_1, X_2, ..., X_n</code> is <em>fibonacci-like</em> if:</p>
</blockquote>
<ul>
<li><code>n &gt;= 3</code></li>
<li><code>X_i + X_{i+1} = X_{i+2}</code> for all <code>i + 2 &lt;= n</code>
Given a <strong>strictly increasing</strong> array <code>A</code> of positive integers forming a sequence, find the <strong>length</strong> of the longest fibonacci-like subsequence of <code>A</code>.  If one does not exist, return 0.</li>
</ul>
<blockquote>
<p>(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from <code>A</code>, without changing the order of the remaining elements.  For example, <code>[3, 5, 8]</code> is a subsequence of <code>[3, 4, 5, 6, 7, 8]</code>.)
s
<strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7,8]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The longest subsequence that is fibonacci-like: [1,2,3,5,8].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,7,11,12,14,18]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The longest subsequence that is fibonacci-like:</span><br><span class="line">[1,11,12], [3,11,14] or [7,11,18].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[0] &lt; A[1] &lt; ... &lt; A[A.length - 1] &lt;= 10^9</code></li>
<li><em>(The time limit has been reduced by 50% for submissions in Java, C, and C++.)</em></li>
</ol>
<p>我用的方法比较直接，找到任意满足<code>A[i]+A[j]</code>也在<code>A</code>的初始对<code>(A[i],A[j])</code>然后找出这个对开始能构造出的最长的序列，找到所有对分别对应的最长序列的长度即为结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums=set(A)</span><br><span class="line">        maxnum=A[<span class="number">-1</span>]</span><br><span class="line">        maxlen=<span class="number">0</span></span><br><span class="line">        q=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j]&gt;maxnum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j] <span class="keyword">in</span> nums:</span><br><span class="line">                    q.append((A[j],A[i]+A[j]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x,y) <span class="keyword">in</span> q:</span><br><span class="line">            l=<span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> x+y <span class="keyword">in</span> nums:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure></p>
<p>当然这肯定不是最好的方法，这些序列肯定会有部分重叠，因此考虑动态规划或许是<a href="https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/discuss/152476/Java-DP-with-explanation-O(n2)-time-O(n2)space" target="_blank" rel="noopener">更好的解法</a></p>
<p>我也试着写了一个不重复计算子序列的方法，但运行时间上没有太大的提升</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums=set(A)</span><br><span class="line">        maxnum=A[<span class="number">-1</span>]</span><br><span class="line">        d=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j]&gt;maxnum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j] <span class="keyword">in</span> nums:</span><br><span class="line">                    d[(A[i],A[j])]=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> d: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x,y) <span class="keyword">in</span> sorted(d.keys(),reverse=<span class="keyword">True</span>):</span><br><span class="line">            <span class="keyword">if</span> (y,x+y) <span class="keyword">in</span> d:</span><br><span class="line">                d[(x,y)]=<span class="number">1</span>+d[(y,x+y)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(d.values())</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-94/" data-id="cjm54ylmr002ofkw3x61189e3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-93" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-93/">LeetCode Weekly Contest 93</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-93/" class="article-date"><time datetime="2018-07-15T06:29:48.592Z" itemprop="datePublished">2018-07-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>转型LeetCode养老玩家，这几周都是周赛现场只做三题就不想继续水题直接去做饭了，年龄大了以后专注力陡降。不过放心，题解还是会把四题都写完的。</p>
<p>https://leetcode.com/contest/weekly-contest-93</p>
<p>&lt;!-- more --&gt;</p>
<h2>Binary Gap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/binary-gap/</p>
<blockquote>
<p>Given a positive integer <code>N</code>, find and return the longest distance between two consecutive 1's in the binary representation of <code>N</code>.</p>
</blockquote>
<blockquote>
<p>If there aren't two consecutive 1's, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: 22</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">22 in binary is 0b10110.</span><br><span class="line">In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.</span><br><span class="line">The first consecutive pair of 1&apos;s have distance 2.</span><br><span class="line">The second consecutive pair of 1&apos;s have distance 1.</span><br><span class="line">The answer is the largest of these two distances, which is 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">5 in binary is 0b101.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">6 in binary is 0b110.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">8 in binary is 0b1000.</span><br><span class="line">There aren&apos;t any consecutive pairs of 1&apos;s in the binary representation of 8, so we return 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>找到二进制串中每个<code>1</code>的位置，计算相邻<code>1</code>之间的间隔找到最大值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryGap</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s=bin(N)[<span class="number">2</span>:]</span><br><span class="line">        ones=[i <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(s) <span class="keyword">if</span> c==<span class="string">'1'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(ones)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max([ones[i]-ones[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(ones))])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2>Reordered Power of 2</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/reordered-power-of-2/</p>
<blockquote>
<p>Starting with a positive integer <code>N</code>, we reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if we can do this in a way such that the resulting number is a power of 2.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 24</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 46</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>假设<code>N</code>是一个<code>n</code>位数，找到所有<code>n</code>位数（<code>10^(n-1)</code>-<code>10^n-1</code>）中最小的2的幂<code>2^x</code>和最大的2的幂<code>2^y</code>，对<code>[x,y]</code>中每个数算2的幂，并取出所有位的数字对比是否有和<code>N</code>的所有位一致的</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderedPowerOf2</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        digits=list(str(N))</span><br><span class="line">        digits.sort()</span><br><span class="line">        n=len(digits)</span><br><span class="line">        max_num=<span class="number">10</span>**n<span class="number">-1</span></span><br><span class="line">        min_num=<span class="number">10</span>**(n<span class="number">-1</span>)</span><br><span class="line">        lower_exponent=len(bin(min_num)[<span class="number">2</span>:])<span class="number">-1</span></span><br><span class="line">        upper_exponent=len(bin(max_num)[<span class="number">2</span>:])<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lower_exponent,upper_exponent+<span class="number">1</span>):</span><br><span class="line">            target=sorted(list(str(<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">            <span class="keyword">if</span> target==digits:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2>Advantage Shuffle</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/advantage-shuffle/</p>
<blockquote>
<p>Given two arrays <code>A</code> and <code>B</code> of equal size, the advantage of <code>A</code> with respect to <code>B</code> is the number of indices i for which <code>A[i] &gt; B[i]</code>.</p>
</blockquote>
<blockquote>
<p>Return <strong>any</strong> permutation of <code>A</code> that maximizes its advantage with respect to <code>B</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,11,15], B = [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [12,24,8,32], B = [13,25,32,11]</span><br><span class="line">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = B.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= B[i] &lt;= 10^9</code></li>
</ol>
<p>有点像田忌赛马，安排一下让优胜的回合最多。对<code>A</code>和<code>B</code>都先升序排序，依次对每个<code>B[i]</code>都找到最小的<code>A[j]</code>使得<code>A[j]&gt;B[i]</code>然后把<code>A[j]</code>放在<code>B[i]</code>对应的原位置，这样安排上了以后，当<code>A</code>的元素都开始小于等于<code>B[i]</code>时，对于<code>B[i:]</code>的所有元素对应位置任意放置<code>A</code>中还没有被安排的元素，整个过程就被安排的明明白白了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advantageCount</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(A)</span><br><span class="line">        A.sort()</span><br><span class="line">        res=[<span class="number">-1</span>]*N</span><br><span class="line">        posB=sorted(range(N),key=<span class="keyword">lambda</span> i:B[i])</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> posB:</span><br><span class="line">            <span class="keyword">while</span> j&lt;len(A) <span class="keyword">and</span> B[i]&gt;=A[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;=len(A): <span class="keyword">break</span></span><br><span class="line">            res[i]=A.pop(j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> res[i]&lt;<span class="number">0</span>:</span><br><span class="line">                res[i]=A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Number of Refueling Stops</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/minimum-number-of-refueling-stops/</p>
<blockquote>
<p>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.</p>
</blockquote>
<blockquote>
<p>Along the way, there are gas stations.  Each <code>station[i]</code> represents a gas station that is <code>station[i][0]</code> miles east of the starting position, and has s<code>tation[i][1]</code> liters of gas.</p>
</blockquote>
<blockquote>
<p>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.</p>
</blockquote>
<blockquote>
<p>When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p>
</blockquote>
<blockquote>
<p>What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.</p>
</blockquote>
<blockquote>
<p>Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 1, startFuel = 1, stations = []</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can reach the target without refueling.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 100, startFuel = 1, stations = [[10,100]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: We can&apos;t reach the target (or even the first gas station).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">We start with 10 liters of fuel.</span><br><span class="line">We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.</span><br><span class="line">Then, we drive from position 10 to position 60 (expending 50 liters of fuel),</span><br><span class="line">and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.</span><br><span class="line">We made 2 refueling stops along the way, so we return 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= target, startFuel, stations[i][1] &lt;= 10^9</code></li>
<li><code>0 &lt;= stations.length &lt;= 500</code></li>
<li><code>0 &lt; stations[0][0] &lt; stations[1][0] &lt; ... &lt; stations[stations.length-1][0] &lt; target</code></li>
</ol>
<p>这个问题类似于背包问题，可以用动态规划求解。</p>
<p>用<code>dp[n]</code>表示在<code>n</code>个站加油后能达到的最大距离。到达第<code>i</code>站时，如果有<code>j&lt;=i</code>且<code>dp[j]&gt;=stations[i][0]</code>，那么经过<code>j+1</code>次加油后可能的最大行驶距离可能就是在第<code>i</code>站之前经过<code>j</code>次加油并在此进行加油的距离，即<code>dp[j+1]=max(d[j+1],d[j]+stations[i][1])</code>，注意从最大的<code>j</code>开始更新<code>d[j+1]</code>的值以防因为到达<code>i</code>使得<code>d[j]</code>发生更新从而使得<code>d[j+1]</code>计算了两次在第<code>i</code>站的加油。最后找到使得<code>d[j]&gt;=target</code>的最小<code>j</code>值作为返回结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target, startFuel, stations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type startFuel: int</span></span><br><span class="line"><span class="string">        :type stations: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(stations)</span><br><span class="line">        dp=[<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=startFuel</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j]&gt;=stations[i][<span class="number">0</span>]:</span><br><span class="line">                    dp[j+<span class="number">1</span>]=max(dp[j+<span class="number">1</span>],dp[j]+stations[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,dist <span class="keyword">in</span> enumerate(dp):</span><br><span class="line">            <span class="keyword">if</span> dist&gt;=target: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-93/" data-id="cjm54ylnh002yfkw3ecpgd6ne" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-92" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-92/">LeetCode Weekly Contest 92</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-92/" class="article-date"><time datetime="2018-07-08T07:05:33.249Z" itemprop="datePublished">2018-07-08</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>俗话说码如其人，我突然发现我长得丑还隐藏着巨大的优势，不用花太多时间把代码特意写的优雅，能用就行，反正别人看见我长那么丑，代码也写的那么丑就没什么好奇怪的了（比如最后一题，真的懒得想优雅的解法了，能过就行）。相反美人们写的东西就要承载更多期待了。不多说了，辛苦你们阅读我丑陋的解法了：</p>
<p>https://leetcode.com/contest/weekly-contest-92</p>
<p>&lt;!-- more --&gt;</p>
<h2>Transpose Matrix</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/transpose-matrix/</p>
<blockquote>
<p>Given a matrix <code>A</code>, return the transpose of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6]]</span><br><span class="line">Output: [[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[0].length &lt;= 1000</code></li>
</ol>
<p>把每列元素重新组成行就是转置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> [[A[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[<span class="number">0</span>]))]</span><br></pre></td></tr></table></figure></p>
<h2>Smallest Subtree with all the Deepest Nodes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/smallest-subtree-with-all-the-deepest-nodes/</p>
<blockquote>
<p>Given a binary tree rooted at <code>root</code>, the depth of each node is the shortest distance to the root.</p>
</blockquote>
<blockquote>
<p>A node is deepest if it has the largest depth possible.</p>
</blockquote>
<blockquote>
<p>Return the node with the largest depth such that it contains all the deepest nodes in it's subtree.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line">Output: [2,7,4]</span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">We return the node with value 2, colored in yellow in the diagram.</span><br><span class="line">The nodes colored in blue are the deepest nodes of the tree.</span><br><span class="line">The input &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; is a serialization of the given tree.</span><br><span class="line">The output &quot;[2, 7, 4]&quot; is a serialization of the subtree rooted at the node with value 2.</span><br><span class="line">Both the input and output have TreeNode type.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the tree will be between <code>1</code> and <code>500</code>.</li>
</ol>
<p>这样的最小子树满足两个条件</p>
<ol>
<li>它的左右子树的高度相同</li>
<li>它的高度与它父结点所表示的树只相差1</li>
</ol>
<p>可以先遍历一次整个树算出每个子树的高度，再进行BFS找到第一个同时满足这两个条件的子树。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        height=&#123;<span class="keyword">None</span>:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            height[r]=<span class="number">1</span>+max(depth(r.left),depth(r.right))</span><br><span class="line">            <span class="keyword">return</span> height[r]</span><br><span class="line"></span><br><span class="line">        q=[root]</span><br><span class="line">        d=depth(root)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> height[r.left]==height[r.right]:</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            <span class="keyword">if</span> r.left <span class="keyword">and</span> height[r.left]==height[r]<span class="number">-1</span>: q.append(r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right <span class="keyword">and</span> height[r.right]==height[r]<span class="number">-1</span>: q.append(r.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2>Prime Palindrome</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/prime-palindrome/</p>
<blockquote>
<p>Find the smallest prime palindrome greater than or equal to <code>N</code>.</p>
</blockquote>
<blockquote>
<p>Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.</p>
</blockquote>
<blockquote>
<p>For example, 2,3,5,7,11 and 13 are primes.</p>
</blockquote>
<blockquote>
<p>Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.</p>
</blockquote>
<blockquote>
<p>For example, 12321 is a palindrome.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 11</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 13</span><br><span class="line">Output: 101</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^8</code></li>
<li>The answer is guaranteed to exist and be less than <code>2 * 10^8</code>.</li>
</ol>
<p>我的做法比较朴素，先找到大于等于<code>N</code>的第一个palindrome，检查是否是质数，如果不是则找到大于这个palindrome的下一个palindrome</p>
<p>找到大于等于某个<code>n</code>的palindrome方法如下：</p>
<ol>
<li>对于低位（对称的右半部分），如果该位值大于对称位的值，则向前进位，该位置为0</li>
<li>把低位置为和对称位相等的值</li>
</ol>
<p>注意下边界情况比如<code>N=1</code>时应该返回2</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primePalindrome</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">            i=<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> i*i&lt;=n:</span><br><span class="line">                <span class="keyword">if</span> n%i==<span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">palind</span><span class="params">(n)</span>:</span></span><br><span class="line">            x=str(n)</span><br><span class="line">            l=len(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l/<span class="number">2</span>)):</span><br><span class="line">                <span class="keyword">if</span> int(x[<span class="number">-1</span>-i])&gt;int(x[i]):</span><br><span class="line">                    <span class="keyword">return</span> palind(n+(<span class="number">10</span>-int(x[<span class="number">-1</span>-i]))*(<span class="number">10</span>**i))</span><br><span class="line">            x=list(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l/<span class="number">2</span>)):</span><br><span class="line">                x[<span class="number">-1</span>-i]=x[i]</span><br><span class="line">            <span class="keyword">return</span> int(<span class="string">''</span>.join(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        t=palind(N)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_prime(t):</span><br><span class="line">            t=palind(t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure></p>
<h2>Shortest Path to Get All Keys</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/shortest-path-to-get-all-keys/</p>
<blockquote>
<p>We are given a 2-dimensional <code>grid</code>. <code>&quot;.&quot;</code> is an empty cell, <code>&quot;#&quot;</code> is a wall, <code>&quot;@&quot;</code> is the starting point, (<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, ...) are keys, and (<code>&quot;A&quot;</code>, <code>&quot;B&quot;</code>, ...) are locks.</p>
</blockquote>
<blockquote>
<p>We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.</p>
</blockquote>
<blockquote>
<p>For some 1 &lt;= K &lt;= 6, there is exactly one lowercase and one uppercase letter of the first <code>K</code> letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.</p>
</blockquote>
<blockquote>
<p>Return the lowest number of moves to acquire all keys.  If it's impossible, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;@.a.#&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length &lt;= 30</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 30</code></li>
<li><code>grid[i][j]</code> contains only <code>'.'</code>, <code>'#'</code>, <code>'@'</code>, <code>'a'-'f'</code> and <code>'A'-'F'</code>
The number of keys is in <code>[1, 6]</code>.  Each key has a different letter and opens exactly one lock.</li>
</ol>
<p>有点像<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-87/##-Shortest-Path-Visiting-All-Nodes">Shortest Path Visiting All Nodes</a>引入一个<code>K</code>位二进制数<code>state</code>表示<code>K</code>个钥匙的访问状态，因为是简单的网格图，用BFS第一次在状态<code>state</code>下访问到坐标<code>(x,y)</code>时的所经历的路径长度就是<code>(x,y,state)</code>的最小值，因此只要对四个方向不断进行BFS，捡到钥匙的时候更新<code>state</code>，遇到锁时检查<code>state</code>能否满足开锁条件继续遍历，第一次把状态更新到获得所有钥匙时的路径长度即为最短路径长度。当然在BFS之前需要先扫描一下整个网格找到起点位置和钥匙数量。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathAllKeys</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n,m=len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        start=(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        keys=<span class="number">0</span></span><br><span class="line">        visited=set()</span><br><span class="line">        d=[(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">'@'</span>:</span><br><span class="line">                    visited.add((i,j,<span class="number">0</span>))</span><br><span class="line">                    start=(i,j)</span><br><span class="line">                <span class="keyword">elif</span> <span class="string">'A'</span>&lt;=grid[i][j]&lt;=<span class="string">'F'</span>:</span><br><span class="line">                    keys+=<span class="number">1</span>        </span><br><span class="line">        complete=(<span class="number">1</span>&lt;&lt;keys)<span class="number">-1</span></span><br><span class="line">        q=[(start,<span class="number">0</span>,<span class="number">0</span>)] <span class="comment">#((x,y),steps,state)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ((i,j),s,state) <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> d:</span><br><span class="line">                x,y=i+dx,j+dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;m:</span><br><span class="line">                    temp_state=state</span><br><span class="line">                    <span class="keyword">if</span> grid[x][y]==<span class="string">'#'</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="string">'a'</span>&lt;=grid[x][y]&lt;=<span class="string">'f'</span>:</span><br><span class="line">                        temp_state=state|(<span class="number">1</span>&lt;&lt;ord(grid[x][y])-ord(<span class="string">'a'</span>))</span><br><span class="line">                        <span class="keyword">if</span> temp_state==complete:</span><br><span class="line">                            <span class="keyword">return</span> s+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="string">'A'</span>&lt;=grid[x][y]&lt;=<span class="string">'F'</span>:</span><br><span class="line">                        <span class="keyword">if</span> state &amp; (<span class="number">1</span>&lt;&lt;ord(grid[x][y])-ord(<span class="string">'A'</span>)) ==<span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (x,y,temp_state) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((x,y,temp_state))</span><br><span class="line">                        q.append(((x,y),s+<span class="number">1</span>,temp_state))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-92/" data-id="cjm54ylmh002kfkw3lazxgomo" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-91" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-91/">LeetCode Weekly Contest 91</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-91/" class="article-date"><time datetime="2018-07-01T03:45:38.636Z" itemprop="datePublished">2018-07-01</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-91</p>
<p>&lt;!-- more --&gt;</p>
<h2>Lemonade Change</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/lemonade-change/</p>
<blockquote>
<p>At a lemonade stand, each lemonade costs <code>$5</code>.</p>
</blockquote>
<blockquote>
<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by <code>bills</code>).</p>
</blockquote>
<blockquote>
<p>Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>
</blockquote>
<blockquote>
<p>Note that you don't have any change in hand at first.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if you can provide every customer with correct change.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,10,20]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">From the first 3 customers, we collect three $5 bills in order.</span><br><span class="line">From the fourth customer, we collect a $10 bill and give back a $5.</span><br><span class="line">From the fifth customer, we give a $10 bill and a $5 bill.</span><br><span class="line">Since all customers got correct change, we output true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,10]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10,10,20]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">From the first two customers in order, we collect two $5 bills.</span><br><span class="line">For the next two customers in order, we collect a $10 bill and give back a $5 bill.</span><br><span class="line">For the last customer, we can&apos;t give change of $15 back because we only have two $10 bills.</span><br><span class="line">Since not every customer received correct change, the answer is false.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= bills.length &lt;= 10000</code></li>
<li><code>bills[i]</code> will be either <code>5</code>, <code>10</code>, or <code>20</code>.</li>
</ol>
<p>收到<code>10</code>时检查之前有没有收到至少一个<code>5</code>并找出，收到<code>20</code>时检查之前有没有收到<code>[10,5]</code>(优先)或者<code>[5,5,5]</code>并找出。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span><span class="params">(self, bills)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        income=[]</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="keyword">if</span> b==<span class="number">5</span>:</span><br><span class="line">                income.append(b)</span><br><span class="line">            <span class="keyword">elif</span> b==<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                    income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                    income.append(b)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                    income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> income:</span><br><span class="line">                        income.pop(income.index(<span class="number">10</span>))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                            income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                                income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>All Nodes Distance K in Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/all-nodes-distance-k-in-binary-tree/</p>
<blockquote>
<p>We are given a binary tree (with root node <code>root</code>), a <code>target</code> node, and an integer value K.</p>
</blockquote>
<blockquote>
<p>Return a list of the values of all nodes that have a distance <code>K</code> from the <code>target</code> node.  The answer can be returned in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span><br><span class="line">Output: [7,4,1]</span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class="line">have values 7, 4, and 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note that the inputs &quot;root&quot; and &quot;target&quot; are actually TreeNodes.</span><br><span class="line">The descriptions of the inputs above are just serializations of these objects.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The given tree is non-empty and has at most <code>K</code> nodes.</li>
<li>Each node in the tree has unique values <code>0 &lt;= node.val &lt;= 500</code>.</li>
<li>The <code>target</code> node is a node in the tree.</li>
<li><code>0 &lt;= K &lt;= 1000.</code></li>
</ol>
<p>先进行一次后序遍历，找到根结点与<code>target</code>的距离，同时从根到<code>target</code>的路径上每一个结点到<code>target</code>的距离，再从根结点进行一次先序遍历，计算每个在后序遍历中没有被计算到<code>target</code>的距离，找到满足<code>=K</code>的所有结点。注意当<code>K=0</code>时直接返回<code>target.val</code>即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root, target, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> K==<span class="number">0</span>: <span class="keyword">return</span> [target.val]</span><br><span class="line">        d=&#123;target:<span class="number">0</span>&#125;</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> r==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            dist_left,dist_right=post_order(r.left),post_order(r.right)</span><br><span class="line">            <span class="keyword">if</span> dist_left&gt;=<span class="number">0</span> <span class="keyword">or</span> dist_right&gt;=<span class="number">0</span>:</span><br><span class="line">                d[r]=max(dist_left,dist_right)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[r]==K: res.append(r.val)</span><br><span class="line">                <span class="keyword">return</span> d[r]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                <span class="keyword">if</span> r.left <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[r.left]=d[r]+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[r.left]==K: res.append(r.left.val)</span><br><span class="line">                pre_order(r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                <span class="keyword">if</span> r.right <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[r.right]=d[r]+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[r.right]==K: res.append(r.right.val)</span><br><span class="line">                pre_order(r.right)</span><br><span class="line"></span><br><span class="line">        post_order(root)</span><br><span class="line">        pre_order(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Score After Flipping Matrix</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/score-after-flipping-matrix/</p>
<blockquote>
<p>We have a two dimensional matrix <code>A</code> where each value is <code>0</code> or <code>1</code>.</p>
</blockquote>
<blockquote>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all <code>0</code>s to <code>1</code>s, and all <code>1</code>s to <code>0</code>s.</p>
</blockquote>
<blockquote>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
</blockquote>
<blockquote>
<p>Return the highest possible score.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br><span class="line">Explanation:</span><br><span class="line">Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20</code></li>
<li><code>1 &lt;= A[0].length &lt;= 20</code></li>
<li><code>A[i][j]</code> is <code>0</code> or <code>1</code>.</li>
</ol>
<p>直接的做法：先通过行变换把每行的最高位翻转成1，再通过列变换使得每列的1最多（如果该列的1不足半数则翻转）</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixScore</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n,m=len(A),len(A[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> sum([A[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])&lt;n/<span class="number">2.0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum([int(<span class="string">''</span>.join([str(c) <span class="keyword">for</span> c <span class="keyword">in</span> r]),<span class="number">2</span>) <span class="keyword">for</span> r <span class="keyword">in</span> A])</span><br></pre></td></tr></table></figure></p>
<h2>Shortest Subarray with Sum at Least K</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/shortest-subarray-with-sum-at-least-k/</p>
<blockquote>
<p>Return the <strong>length</strong> of the shortest, non-empty, contiguous subarray of <code>A</code> with sum at least <code>K</code>.</p>
</blockquote>
<blockquote>
<p>If there is no non-empty subarray with sum at least <code>K</code>, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1], K = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], K = 4</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,-1,2], K = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5</code></li>
<li><code>1 &lt;= K &lt;= 10 ^ 9</code></li>
</ol>
<p>因为有连续限定，直接莽上去也是可以解决的（但几乎一定TLE），受到<a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C++JavaPython-O(N)-Using-Deque" target="_blank" rel="noopener">这个解法</a>的启发，可以先计算<code>A</code>的前<code>n</code>个元素的和记为<code>S[n+1]</code>，这样<code>sum(A[j:i])</code>可以用<code>S[i]-S[j]</code>表示。对于每个<code>j&lt;i</code>，检查是否有<code>S[i]-S[j]&lt;=K</code>，如果满足，对于<code>j</code>来说满足要求且从<code>j</code>开始的最小子数组就是<code>A[j:i]</code>，之后不用继续检查大于<code>i</code>的终点。如果<code>j&lt;i</code>且有<code>S[i]&lt;=S[j]</code>，那么如果有一个<code>k</code>使得<code>S[k]-S[j]&gt;=K</code>必然有<code>S[k]-S[i]&gt;=K</code>，所以从<code>i</code>开始能找到更短的满足要求的子数组，同样的，接下来不用考虑以<code>j</code>为起点的子数组。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSubarray</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(A)</span><br><span class="line">        S=[<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        res=N+<span class="number">1</span></span><br><span class="line">        d=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            S[i+<span class="number">1</span>]=S[i]+A[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">and</span> S[i]-S[d[<span class="number">0</span>]]&gt;=K:</span><br><span class="line">                res=min(res,i-d.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">and</span> S[i]&lt;=S[d[<span class="number">-1</span>]]:</span><br><span class="line">                d.pop()</span><br><span class="line">            d.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res&lt;N+<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度也为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-91/" data-id="cjm54ylmo002mfkw3r7lpdr29" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-90" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-90/">LeetCode Weekly Contest 90</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-90/" class="article-date"><time datetime="2018-06-24T03:04:18.514Z" itemprop="datePublished">2018-06-24</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-90</p>
<p>&lt;!-- more --&gt;</p>
<h2>Buddy Strings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/buddy-strings/</p>
<blockquote>
<p>Given two strings <code>A</code> and <code>B</code> of lowercase letters, return <code>true</code> if and only if we can swap two letters in A so that the result equals B.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aa&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aaaaaaabc&quot;, B = &quot;aaaaaaacb&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= B.length &lt;= 20000</code></li>
<li>A and B consist only of lowercase letters.</li>
</ol>
<p>时间来不及所以就写的比较丑陋，检查是否只有两个位置不同，是否可以交换。如果全相同，是否存在重复字符。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A)!=len(B):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        diff=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i]!=B[i]:</span><br><span class="line">                diff.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> diff:</span><br><span class="line">            <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> A[:i]+A[i+<span class="number">1</span>:]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(diff)!=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A[diff[<span class="number">0</span>]]==B[diff[<span class="number">1</span>]] <span class="keyword">and</span> B[diff[<span class="number">0</span>]]==A[diff[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p>
<h2>Score of Parentheses</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/score-of-parentheses/</p>
<blockquote>
<p>Given a balanced parentheses string <code>S</code>, compute the score of the string based on the following rule:</p>
</blockquote>
<ul>
<li><code>()</code> has score 1</li>
<li><code>AB</code> has score <code>A + B</code>, where A and B are balanced parentheses strings.</li>
<li><code>(A)</code> has score <code>2 * A</code>, where A is a balanced parentheses string.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(())&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()(()))&quot;</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> is a balanced parentheses string, containing only <code>(</code> and <code>)</code>.</li>
<li><code>2 &lt;= S.length &lt;= 50</code></li>
</ol>
<p>只有括号一种运算符，那么可以只用一个栈存操作数，每对一对括号完成求值就把值放入前一个操作数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        operand=[<span class="number">0</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">eval_par</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i]==<span class="string">'('</span>:</span><br><span class="line">                operand.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x=operand.pop()</span><br><span class="line">                <span class="keyword">if</span> len(operand)&gt;<span class="number">1</span>:</span><br><span class="line">                    operand[<span class="number">-1</span>]+=<span class="number">2</span>*eval_par(x)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    operand[<span class="number">-1</span>]+=eval_par(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> eval_par(operand[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<h2>Mirror Reflection</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/mirror-reflection/</p>
<blockquote>
<p>There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered <code>0</code>, <code>1</code>, and <code>2</code>.</p>
</blockquote>
<blockquote>
<p>The square room has walls of length <code>p</code>, and a laser ray from the southwest corner first meets the east wall at a distance <code>q</code> from the <code>0</code>th receptor.</p>
</blockquote>
<blockquote>
<p>Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: p = 2, q = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png" alt=""></p>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= p &lt;= 1000</code></li>
<li><code>0 &lt;= q &lt;= p</code></li>
</ol>
<p>直接算每个入射点和反射点的坐标也可以AC</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :type q: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">next_point</span><span class="params">(<span class="params">(x1,y1)</span>,<span class="params">(x2,y2)</span>,d)</span>:</span></span><br><span class="line">            dx,dy=(x2-x1)*d[<span class="number">0</span>],(y2-y1)*d[<span class="number">1</span>]</span><br><span class="line">            ks=[-x2/dx,(p-x2)/dx,-y2/dy,(p-y2)/dy]</span><br><span class="line">            i=min(range(<span class="number">4</span>),key=<span class="keyword">lambda</span> x: ks[x] <span class="keyword">if</span> ks[x]&gt;<span class="number">0</span> <span class="keyword">else</span> float(<span class="string">'inf'</span>))</span><br><span class="line">            k=ks[i]</span><br><span class="line">            temp=[(<span class="number">0</span>,y2+k*dy),(p,y2+k*dy),(x2+k*dx,<span class="number">0</span>),(x2+k*dx,p)]</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> temp[i],(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> temp[i],(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_receptors</span><span class="params">(<span class="params">(x,y)</span>)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> (i,(x0,y0)) <span class="keyword">in</span> enumerate([(p,<span class="number">0</span>),(p,p),(<span class="number">0</span>,p)]):</span><br><span class="line">                <span class="keyword">if</span> abs(x-x0)&lt;<span class="number">0.001</span> <span class="keyword">and</span> abs(y-y0)&lt;<span class="number">0.001</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        p1,p2,d=(<span class="number">0</span>,<span class="number">0</span>),(p,q),(<span class="number">-1.0</span>,<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> in_receptors(p2)&lt;<span class="number">0</span>:</span><br><span class="line">            next_p2,next_d=next_point(p1,p2,d)</span><br><span class="line">            p1,p2,d=p2,next_p2,next_d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> in_receptors(p2)</span><br></pre></td></tr></table></figure></p>
<p>该轨迹每在水平方向运动<code>p</code>距离，会在竖直方向移动<code>q</code>距离，当两个方向经过的距离同时为<code>p</code>的整数倍时，遇到接收器。y方向第一次到达的<code>p</code>的整数倍是<code>lcm(p,q)</code>，在<code>y</code>方向上经过了<code>lcm(p,q)/p</code>个<code>p</code>，在x方向上经过了<code>lcm(p,q)/q</code>个<code>p</code>，每经历2个<code>p</code>则在坐标上往复一次，很容易找出这些数模2对应的接收器编号。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :type q: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        g=fractions.gcd(p,q)</span><br><span class="line">        <span class="comment"># the ray travels the distance p*q/g on y-axis direction and p*p/g on x-axis direction</span></span><br><span class="line">        <span class="keyword">if</span> q/g%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> p/g%<span class="number">2</span>==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> q/g%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> p/g%<span class="number">2</span>==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> q/g%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> p/g%<span class="number">2</span>==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2>Minimum Cost to Hire K Workers</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/minimum-cost-to-hire-k-workers/</p>
<blockquote>
<p>There are <code>N</code> workers.  The <code>i</code>-th worker has a <code>quality[i]</code> and a minimum wage expectation <code>wage[i]</code>.</p>
</blockquote>
<blockquote>
<p>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:</p>
</blockquote>
<ol>
<li>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.</li>
<li>Every worker in the paid group must be paid at least their minimum wage expectation.
Return the least amount of money needed to form a paid group satisfying the above conditions.</li>
</ol>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: quality = [10,20,5], wage = [70,50,30], K = 2</span><br><span class="line">Output: 105.00000</span><br><span class="line">Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3</span><br><span class="line">Output: 30.66667</span><br><span class="line">Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= N &lt;= 10000</code>, where <code>N = quality.length = wage.length</code></li>
<li><code>1 &lt;= quality[i] &lt;= 10000</code></li>
<li><code>1 &lt;= wage[i] &lt;= 10000</code></li>
<li>Answers within <code>10^-5</code> of the correct answer will be considered correct.</li>
</ol>
<p>先按照<code>ratio[i]=wage[i]/quality[i]</code>进行排序，当<code>ratio[j]&lt;=ratio[i]</code>时，按照<code>ratio[i]</code>给第<code>j</code>个工人支付的报酬<code>ratio[i]*quality[j]&gt;=wage[i]</code>满足要求，因此对于每个<code>ratio[i]</code>只要找到<code>K</code>个满足<code>ratio[j]&lt;=ratio[i]</code>的最小的<code>quality[j]</code>的和再乘以<code>ratio[i]</code>就是支付的总额。</p>
<p>具体做法是在按照<code>ratio</code>给<code>quality</code>升序排序后，对于每个<code>i&gt;=K-1</code>，计算<code>ratio[i]*sum(nsmallest(K,quality[:i+1]))</code>取最小值。为了提高效率，可以维护一个大小为<code>K</code>的最大堆，遍历到<code>quality[i]</code>时如果比堆顶大则弹出堆顶压入<code>quality[i]</code>，再计算这<code>K</code>个<code>quality</code>的和与<code>ratio[i]</code>的乘积并与当前最小的支付组比较。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostToHireWorkers</span><span class="params">(self, quality, wage, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type quality: List[int]</span></span><br><span class="line"><span class="string">        :type wage: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rq=sorted([(<span class="number">1.0</span>*wage[i]/quality[i],quality[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(quality))])</span><br><span class="line">        q=[-qual <span class="keyword">for</span> ratio,qual <span class="keyword">in</span> rq[:K]]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        q_sum=-sum(q)</span><br><span class="line">        res=rq[K<span class="number">-1</span>][<span class="number">0</span>]*q_sum</span><br><span class="line">        <span class="keyword">for</span> r,qual <span class="keyword">in</span> rq[K:]:</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">and</span> qual&lt;-q[<span class="number">0</span>]:</span><br><span class="line">                q_sum+=(qual+q[<span class="number">0</span>])</span><br><span class="line">                heapq.heapreplace(q,-qual)</span><br><span class="line">                res=min(res,r*q_sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-90/" data-id="cjm54yllo002cfkw3z3xtva8t" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-mathcs" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/MIT6-042/mathcs/">Math for CS 一周目阅读完成纪念！</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/MIT6-042/mathcs/" class="article-date"><time datetime="2018-06-18T16:00:00.000Z" itemprop="datePublished">2018-06-19</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MIT6-042/">MIT6.042</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>google books https://books.google.com/books?id=EdOQswEACAAJ</li>
<li>豆瓣读书主页 https://book.douban.com/subject/20472991/</li>
<li>2004版（339页）http://www.boazbarak.org/cs121/LehmanLeighton.pdf</li>
<li>2012版（800页） https://www.seas.harvard.edu/courses/cs20/MIT6_042Notes.pdf</li>
<li>2017版（1006页） https://courses.csail.mit.edu/6.042/spring17/mcs.pdf</li>
<li>2018版（1048页） https://courses.csail.mit.edu/6.042/spring18/mcs.pdf</li>
<li>MIT 6.042相关习题/材料 https://learning-modules.mit.edu/materials/index.html?uuid=/course/6/sp18/6.042#materials</li>
<li>MIT 6.042 2017 final https://courses.csail.mit.edu/6.042/spring17/finalS17.pdf</li>
</ul>
<hr>
<p>这本久负盛名的6.042同名教材Mathematics for Computer Science几乎每年随着MIT重新开设6.042更新一遍，从2004年单薄的339页到今年已经1000多页。第一次被介绍这本书是在Stanford的公开课<a href="https://www.coursera.org/learn/algorithm-design-analysis" target="_blank" rel="noopener">Algorithms: Design and Analysis</a>的延伸阅读材料里推荐了这本书2004版作为课程的数学基础参考，我也只通读了这一版的全部内容。</p>
<p>&lt;!-- more --&gt;</p>
<p>目前市面上没有正式出版过它的纸质书，它实质上只是MIT 6.042这门课的讲义集。相比附赠丰富习题集的2012以及后来版本，2004版339页的讲解内容显得清爽紧凑，但或许也因为只是电子版的讲义集，编写时间距今已久，其中存在不少可能会使人困扰的勘误。所以如果此时决定入手阅读这本书，可以从这一年最近的电子版开始，习题大部分也是值得一做的。比较遗憾的是，网上比较难找到这些习题的题解，我也在读完2004版开始<a href="http://notebook.xyli.me/MIT6-042/2017final/">尝试</a>着做了一下2017 final（欢迎和感谢有兴趣的朋友交流和指正），试图快速检验阅读成效和两版之间的区别，发现近年以来这本书也增加了很多有趣实用的概念和方法。</p>
<p>Mathematics for Computer Science这个标题试图涵盖的范围很大，让人无端联想到知乎式的提问</p>
<blockquote>
<p>我数学零基础，想当程序员，应该先从什么内容学起？</p>
</blockquote>
<p>在了解到这本书之前，被问到想学计算机应该学哪些数学，大概会很潦草模糊的回答就像大部分大学的CS本科生一样，学微积分，线性代数，离散数学，概率论……大概想学密码学还需要补一下数论等等建议。突然有了这么一本标题宏大的书似乎能一次性解决这个老生常谈的问题？不存在的，稍有常识的人都知道不可能有一本书能够一次打包计算机科学领域所需的全部数学工具，每当你想了解新理论和技术的基础，都几乎必须再去了解新的你所未曾了解过的数学知识。数学的应用和发展支持着计算机科学的常用常新，但反之计算机领域的新成果也一样深刻地影响着数学，用静态的眼光试图一劳永逸掌握计算机领域的所有数学不过是不切实际的幻想。那么为什么MIT还要开这门课呢？我们还有继续读这本书的必要吗？</p>
<p>当然有。MIT 6.042对于计算机基础薄弱的低年级本科生来说，是非常快速和实用的前导课程。这本书无法成为万用的灵丹妙药帮助任何人一步登天，但可以拉着初学者的手温柔平稳地把迷茫的他们送到美妙的计算机科学世界的门口。对于已经从事计算机工作或学习很久的读者来说，也同样可以通过它了解到自己可能忽视和遗忘的世界。应数风格的编书使得每个新概念都由一个具体的计算机问题引入，一步步手把手教你建模，用直观的方法解决和证明，然后引出更多在计算机领域相关的该概念应用。即使抛开这些工具的实用性，它们也本来就是很美好的东西，阅读这本书也可以仅凭直觉感受到这种让人拍案的精妙。</p>
<ul>
<li>Proofs 部分讲了逻辑规范表达，以及一般会用到的证明方法。不仅有归纳和反证等贯穿全书的证明工具，也有针对于可计算基础的递归定义的递归结构证明。这些都构成了good proof template的一部分。</li>
<li>Number Theory 部分以具体的Turing Code场景，展现了简洁的密码学发展史。</li>
<li>Communication Networks 部分介绍了图论的知识在现实的分组转发网络是如何运作的，以bufferfly模型为例引入分析整个网络的性能指标在不同的图结构下的差异。</li>
<li>Counting 部分介绍了复杂度理论常用的渐近工具的定义和用法，Generating Functions转换序列，以集合映射关系作为规范的计数基础，配合丰富的应用场景讲解计数方法，为后面的Probability部分打下坚实的铺垫。</li>
<li>Recurrences 部分为递归问题提供了强力的计算工具，解Linear Recurrences递推式同样给了很多动态规划问题另一种可能性。</li>
</ul>
<p>以上作为本科时学习过相关数学课程的我仍感到值得一读的地方，很多培养计划里面不会涉及这些内容或者只是草草带过。当然虽然名字叫Mathematics for Computer Science却完全没有涉及微积分或者线性代数任何相关基础知识，大概是默认这些内容需要另开课程详细讲解，其实对于其他出现在书中数学工具也是如此，它只能拉着你的手带你了解到有这些东西的存在，敲开它们的门还是需要你自己动手，主动去寻求更深入的用法。正如前文所说，不存在这样一劳永逸的包裹（正如<a href="https://book.douban.com/subject/4470166/" target="_blank" rel="noopener">Mathematics for Physics: A Guided Tour for Graduate Students</a>本质上也只是更深刻严谨的“标题党”，笑），想保持自己站在计算机科学技术的前沿，永远要不断去学习和开发新的数学工具，但这不影响这本书对于新手的巨大价值，以及系统和连贯讲解这些本质美丽自由之物的美感。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/MIT6-042/mathcs/" data-id="cjm54yloa0038fkw3zoc0tx2t" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/书评/">书评</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-89" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-89/">LeetCode Weekly Contest 89</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-89/" class="article-date"><time datetime="2018-06-17T06:52:46.549Z" itemprop="datePublished">2018-06-17</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-89</p>
<p>&lt;!-- more --&gt;</p>
<h2>Peak Index in a Mountain Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/peak-index-in-a-mountain-array/</p>
<blockquote>
<p>Let's call an array <code>A</code> a mountain if the following properties hold:</p>
<ul>
<li><code>A.length &gt;= 3</code></li>
<li>There exists some <code>0 &lt; i &lt; A.length - 1</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
</blockquote>
<blockquote>
<p>Given an array that is definitely a mountain, return any <code>i</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
<li><code>A</code> is a mountain, as defined above.</li>
</ol>
<p>真没什么好说的，特别是还告诉你<code>A</code>肯定是个mountain</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i<span class="number">-1</span>]&lt;A[i] <span class="keyword">and</span> A[i]&gt;A[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<h2>Car Fleet</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/car-fleet/</p>
<blockquote>
<p><code>N</code> cars are going to the same destination along a one lane road.  The destination is <code>target</code> miles away.</p>
</blockquote>
<blockquote>
<p>Each car <code>i</code> has a constant speed <code>speed[i]</code> (in miles per hour), and initial position <code>position[i]</code> miles towards the target along the road.</p>
</blockquote>
<blockquote>
<p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p>
</blockquote>
<blockquote>
<p>The distance between these two cars is ignored - they are assumed to have the same position.</p>
</blockquote>
<blockquote>
<p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p>
</blockquote>
<blockquote>
<p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.</p>
</blockquote>
<blockquote>
<p>How many car fleets will arrive at the destination?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class="line">The car starting at 0 doesn&apos;t catch up to any other car, so it is a fleet by itself.</span><br><span class="line">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class="line">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= N &lt;= 10 ^ 4</code></li>
<li><code>0 &lt; target &lt;= 10 ^ 6</code></li>
<li><code>0 &lt; speed[i] &lt;= 10 ^ 6</code></li>
<li><code>0 &lt;= position[i] &lt; target</code></li>
<li>All initial positions are different.</li>
</ol>
<p>因为语言问题，一开始可能会疑惑成为车队后的速度到底是哪辆车原来的速度，其实是车队所有车速度的最小值。</p>
<p>先将车辆按照初始位置的降序排序，分别计算到达<code>target</code>所需的时间<code>time[i]</code>，如果该车辆到达终点的所需时间是当前最长，说明不会和前面任何车汇合，因此可以形成一个车队。反之如果时间小于前面任何一辆车，则会<s>追尾前面的一辆高级黑色车</s>有一个车队被赶上并汇合，不可能单独形成一个车队。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">carFleet</span><span class="params">(self, target, position, speed)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type position: List[int]</span></span><br><span class="line"><span class="string">        :type speed: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur,res=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        time=[float(target-p)/s <span class="keyword">for</span> p,s <span class="keyword">in</span> sorted(zip(position,speed),reverse=<span class="keyword">True</span>)]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">            <span class="keyword">if</span> t&gt;cur:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                cur=t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$n\log(n)$，空间复杂度为$o(n)$</p>
<h2>Exam Room</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/exam-room/</p>
<blockquote>
<p>n an exam room, there are <code>N</code> seats in a single row, numbered <code>0, 1, 2, ..., N-1</code>.</p>
</blockquote>
<blockquote>
<p>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)</p>
</blockquote>
<blockquote>
<p>Return a class <code>ExamRoom(int N)</code> that exposes two functions: <code>ExamRoom.seat()</code> returning an <code>int</code> representing what seat the student sat in, and <code>ExamRoom.leave(int p)</code> representing that the student in seat number <code>p</code> now leaves the room.  It is guaranteed that any calls to <code>ExamRoom.leave(p)</code> have a student sitting in seat <code>p</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</span><br><span class="line">Output: [null,0,9,4,2,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">ExamRoom(10) -&gt; null</span><br><span class="line">seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.</span><br><span class="line">seat() -&gt; 9, the student sits at the last seat number 9.</span><br><span class="line">seat() -&gt; 4, the student sits at the last seat number 4.</span><br><span class="line">seat() -&gt; 2, the student sits at the last seat number 2.</span><br><span class="line">leave(4) -&gt; null</span><br><span class="line">seat() -&gt; 5, the student​​​​​​​ sits at the last seat number 5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
<li><code>ExamRoom.seat()</code> and <code>ExamRoom.leave()</code> will be called at most 10^4 times across all test cases.</li>
<li>Calls to <code>ExamRoom.leave(p)</code> are guaranteed to have a student currently sitting in seat number p.</li>
</ol>
<p>和上周的<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-88/#Maximize-Distance-to-Closest-Person">Maximize-Distance-to-Closest-Person</a>有点像，这里要求最近距离最大，那么就取两个被占座位中间的座位，为了以较小的成本维护有序<code>token</code>，需要在查找新座位时额外找到它在<code>token</code>的索引。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.N=N</span><br><span class="line">        self.token=[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_dist</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur,s,pos=self.token[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.token)<span class="number">-1</span>):</span><br><span class="line">            temp=int((self.token[i+<span class="number">1</span>]-self.token[i])/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> temp&gt;cur:</span><br><span class="line">                cur,s,pos=temp,self.token[i]+temp,i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.N<span class="number">-1</span>-self.token[<span class="number">-1</span>]&gt;cur:</span><br><span class="line">            s,pos=self.N<span class="number">-1</span>,len(self.token)</span><br><span class="line">        <span class="keyword">return</span> pos,s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.token:</span><br><span class="line">            self.token.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pos,s=self.max_dist()</span><br><span class="line">        self.token.insert(pos,s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leave</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.token.remove(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your ExamRoom object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = ExamRoom(N)</span></span><br><span class="line"><span class="comment"># param_1 = obj.seat()</span></span><br><span class="line"><span class="comment"># obj.leave(p)</span></span><br></pre></td></tr></table></figure></p>
<h2>K-Similar Strings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/k-similar-strings/</p>
<blockquote>
<p>Strings <code>A</code> and <code>B</code> are <code>K</code>-similar (for some non-negative integer <code>K</code>) if we can swap the positions of two letters in <code>A</code> exactly <code>K</code> times so that the resulting string equals <code>B</code>.</p>
</blockquote>
<blockquote>
<p>Given two anagrams <code>A</code> and <code>B</code>, return the smallest <code>K</code> for which <code>A</code> and <code>B</code> are K-similar.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;abc&quot;, B = &quot;bca&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;abac&quot;, B = &quot;baca&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aabc&quot;, B = &quot;abca&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length == B.length &lt;= 20</code></li>
<li><code>A</code> and <code>B</code> contain only lowercase letters from the set <code>{'a', 'b', 'c', 'd', 'e', 'f'}</code></li>
</ol>
<p>第一反应就是BFS，有点像<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-64/#Open-the-Lock">Open the Lock</a>而且远远没有那么麻烦，生成新的结点时注意当<code>s[j]==b[j]</code>或者<code>s[j]!=b[i]</code>时，交换<code>i,j</code>所在位置的字符并不能使<code>s</code>和<code>B</code>“更加相似”。这个做法是符合直觉的，当你要面对这些交换工作时，也是想着如何从左到右，用后面的字符交换当前第一个不匹配的字符，直到把每个字符匹配正确。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSimilarity</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> A==B:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        seen=&#123;A&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,A)]</span><br><span class="line">        n=len(A)</span><br><span class="line">        <span class="keyword">for</span> step,s <span class="keyword">in</span> q:</span><br><span class="line">            i=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> s[i]==B[i]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> s[j]!=B[j] <span class="keyword">and</span> s[i]==B[j]:</span><br><span class="line">                    temp=s[:i]+s[j]+s[i+<span class="number">1</span>:j]+s[i]+s[j+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> temp==B:</span><br><span class="line">                        <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                            q.append((step+<span class="number">1</span>,temp))</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-89/" data-id="cjm54yllw002gfkw3z0whr6cr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-2017final" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/MIT6-042/2017final/">试着做一下MIT 6.042的期末题</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/MIT6-042/2017final/" class="article-date"><time datetime="2018-06-15T06:29:01.762Z" itemprop="datePublished">2018-06-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MIT6-042/">MIT6.042</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>2017年的math for cs期末题，180分钟，原题挂在了 https://courses.csail.mit.edu/6.042/spring17/finalS17.pdf 但题解需要MIT注册学生的权限，我暂时也找不到。只能自己尝试着做一份题解，可能（几乎一定）存在错误，先预先感谢一下愿意指出和纠正交流者。</p>
<p>&lt;!-- more --&gt;</p>
<hr>
<h2>Problem 1 Simple Graphs &amp; Trees</h2>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$${41 \choose 2}$$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>完全图中每个顶点都必然与其他所有顶点邻接，$K_{41}$只有1种结构</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>$C_{41}$已经是规定了边集顺序的特定的环，而不是一般意义上的顶点数为41的环</p>
<blockquote>
<p>isomorphisms from $C_{41}$ to $C_{41}$</p>
</blockquote>
<p>这个说法有点奇怪，我暂且理解为问题中的$C_{41}$有多少isomorphisms</p>
<p>选择从环的一个顶点开始依次放置41个顶点，这里有$41!$种排列的方法，而起始顶点之间又是等效的，因此共有$41!/41=40!$种同构。</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>众所周知，有$\chi \left( {K_n} \right) = n$，所以$\chi \left( K_{41} \right) = 41$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; e</h4>
<p>同样，我们知道$\chi \left( C_{odd} \right) = 3$，所以$\chi \left( C_{41} \right) = 3$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; f</h4>
<p>41个结点的树的边数$\left| E \right| = \left| V \right| - 1 = 40$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; g</h4>
<p>移除$C_{41}$的任意一条边都可以得到$C_{41}$的一个独特的生成树（实际上是路径），因此生成树的数量就是边数41</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; h</h4>
<p>$K_{41}$的任意两个顶点之间直接由边连通，找长度为10的路径数可以通过找11个顶点组成的不同序列数即${}^{41}{P_{11}}$，路径的起点与终点不作区分，因此为${}^{41}{P_{11}}/2=41!/(2 \cdot 30!)$</p>
</div></p>
<h2>Problem 2 Quantifiers</h2>
<p><s>就是problem 3.43 原题</s></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>i.o.的限制只要求使得$R(n)$为真的$n$有无限多个，可以是
${\bf{Q}}_1$: $\forall {n_0}$
${\bf{Q}}_2$: $\exists n \ge {n_0}$
如果这样的集合是有限的，那么该集合存在一个最大的$n_0$，对于$n_0+1$也存在一个$n \ge n_0+1&gt;n_0$使$R(n)$为真，这与$n_0$是该集合最大值矛盾，故该集合有限的假设不成立。使得$R(n)$成立的$n$构成无限集。</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>a.e.严格规定了使$R(n)$为假的$n$只能为有限个，可以是
${\bf{Q}}_3$: $\exists {n_0}$
${\bf{Q}}_4$: $\forall n \ge {n_0}$
仅当$n&lt;n_0$时$S(n)$可能为假，则这样$n$数量不可能超过$n_0$的最小值，使$S(n)$为假的$n$是有限的。</p>
</div></p>
<h2>Problem 3 Logical Injections</h2>
<p><s>problem 4.43 原题简化</s></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>找到使得$R$为单射关系的充分条件</p>
<ul>
<li>&lt;i class=&quot;fa fa-square-o&quot;&gt;&lt;/i&gt; (i) $R(x)$和$R(y)$都是集合，只要里面的元素不完全相同就可以取到$\ne$，二者仍然可能交集不为空，在交集中的点存在$\ge 2$条入边，不符合单射关系。</li>
<li>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; (ii) 不同的$x$和$y$无法通过$R$与同一个点连接，即陪域上不存在超过1的点，符合单射的定义。</li>
<li>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; (iii) 任意$x$指向的点只被$\le 1$个点指向，如果$x$出度不为0，则这个点就是$x$，如果$x$出度为0，则为空集。</li>
<li>&lt;i class=&quot;fa fa-square-o&quot;&gt;&lt;/i&gt; (iv) 任意$x$指向的点至少被$\ge 1$个点指向，这是不符合单射定义的。</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>$not(S ; inj ; [0,1]) \iff not([0,1] ; surj ; S) \iff A ; strict ;  B$
找一个严格小于$[0,1]$的无穷集就可以了，最简单的构造$pow([0,1])$</p>
</div></p>
<h2>Problem 4 Number Theory</h2>
<p><s>类似原题在problem 9.10</s></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>True</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>(ii)</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>False</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>$\gcd \left(a^2,b^2 \right) = \left( \gcd \left( a,b \right)\right)^2$
(iii)</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; e</h4>
<p>(iv)</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; f</h4>
<p>True</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; g</h4>
<p>Fermat小定理要求(i)+(vii)就够了，但只能选一项就选(viii)</p>
</div></p>
<h2>Problem 5 Counting</h2>
<p><s>原题 Problem 15.43</s>
<div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p><s>原结论见Problem 15.7</s>
(2)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>(1)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>(8)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>(7)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; e</h4>
<p>(8)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; f</h4>
<p>(1)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; g</h4>
<p>(5)</p>
</div></p>
<h2>Problem 6 Structural Induction</h2>
<p>不太想写证明，特别是这种自娱自乐的recursive definitions的structural induction真没什么意思，随便写写吧，不用当真。</p>
<p>命题：对于任意Atrig $f(x)$，其导函数也是Atrig
<div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Base Case</h4>
<ul>
<li>当$f(x)=id(x)$时，导函数$f'(x)=1$是常函数，所以是Atrig</li>
<li>当$f(x)=c$为常函数时，导函数$f'(x)=0$是常函数，所以是Atrig</li>
<li>当$f(x)=\sin(x)$时，导函数$f'(x)=\cos(x)=\sin(x-\pi/2)$，$y=x$是Atrig，$y=\pi/2$也是Atrig，这两个函数的和$y=x-\pi/2$根据递归定义Atrig函数的和也是Atrig，那它与另一个Atrig函数$y=\sin(x)$的复合结构根据递归定义也是Atrig，即$f'$是Atrig</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Constructor case</h4>
<p>假设对于$f$和$g$，都有$f'$和$g'$也为Atrig成立</p>
<ul>
<li>$(f+g)'=f'+g'$，因为$f'$和$g'$都是Atrig，$(f+g)'$也是Atrig</li>
<li>$(f \cdot g)'=f \cdot g'+f' \cdot g$，$f$和$g'$都是Atrig，所以二者的乘积$f \cdot g'$也是Atrig，同理$f' \cdot g$也是，它们的和也是，所以$(f \cdot g)'$是Atrig</li>
<li>$\left( f \circ g \right)'= g' \cdot \left( {f' \circ g} \right)$，$f'$和$g$都是Atrig，所以$f' \circ g$也是Atrig，又因为$g'$是Atrig，所以它们的乘积即$\left( f \circ g \right)'$也是Atrig</li>
</ul>
</div></p>
<p>综上所述，该命题成立。</p>
<h2>Problem 7 Probable Satisfiability</h2>
<p><s>原题Promblem 19.22</s></p>
<p>不严格按照概率和期望的格式来写了</p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$1-1/2^3=7/8$</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>每个3-clause为真的期望为$7/8$，真3-clause数量的期望为$7/8 \times 7=49/8$</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>假设$G$是不可能为真的，即真3-clause数量$X$有$Pr(X=7)=0$
&lt;span&gt;$$\begin{align}
Ex\left( X \right) &amp; = \sum\limits_{i = 0}^6 {i \cdot \Pr \left( {X = i} \right)} \\
&amp; \le \sum\limits_{i = 0}^6 {6 \cdot \Pr \left( {X = i} \right)} \\
&amp; = 6
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
与b的答案$Ex(X)&gt;6$矛盾，所以假设不成立，$G$是可以满足的。</p>
</div></p>
<h2>Problem 8 Connectivity, Induction</h2>
<p><s>Problem 12.64</s></p>
<p>我不太会写证明，也懒得再开TeX画图了，就简单说下思路，等有空了再补上严谨的证明和示意图。<s>（这句话的意思就是以后也不会写的啦）</s></p>
<p>题给的结论是完全符合直觉的：想象一个长度为$m$的路径上面所有结点都是hub，除了两个结点各可以连接4个computer，其他中间的hub都可以连接3个computer，这是图上所有hub能容纳的最大computer数量($n=8+3(m-2)$)，此时如果增加$[1,3]$个computer，只需要在路径中间添加一个hub</p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Base Case</h4>
<p>当$n \le 8$时：</p>
<ul>
<li>当$2 \le n \le 5$时： 以一个hub为中心连接所有computer的星状网络可以使结论成立</li>
<li>当$6 \le n \le 8$时: 两个直接相连的hub各自剩下的4个可以连接的位置最多容纳数为8，可以满足只用2个hub的要求</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Inductive Step</h4>
<p>假设对于$x&gt;1$和$0 \le y &lt;3$，$n=3x+2-y$，可以找到只用$x$个hub的组装方法，即长度为$x$的hub路径</p>
<ul>
<li>当$y=0$时，当增加一个computer时可以在路径中间增加一个hub并与其连接，此时共有$x+1$个hub，$\left\lceil {\left( {n+1 - 2} \right)/3} \right\rceil=\left\lceil {\left( {3x + 3} \right)/3} \right\rceil =x+1$</li>
<li>当$y&gt;0$时，路径上必然有一个hub的度&lt;5，再增加一个computer时，连接在这个$hub$上即可，还是只需要$x$个hub，$\left\lceil {\left( {n+1 - 2} \right)/3} \right\rceil=\left\lceil {\left( {3x + 3-y} \right)/3} \right\rceil =x$</li>
</ul>
</div>
综上所述，对于$n$个computer，只需要$\left\lceil {\left( {n - 2} \right)/3} \right\rceil$个hub即可组装cluster</p>
<h2>Problem 9 Conditional Probability</h2>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$\Pr(E|R)&gt;\Pr(E|B)$</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>$\Pr(R|E)&gt;\Pr(B|E)$</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>已知$Pr(A)=Pr(B)$
&lt;span&gt;$$\begin{align}
\Pr(E|R) &amp; &gt;\Pr(E|B) \\
\Pr(E|R) \cdot \Pr(R) / \Pr(E) &amp; &gt; \Pr(E|B) \cdot \Pr(B) / \Pr(E) \\
\Pr(R|E) &amp;&gt; \Pr(B|E)
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>不能，当$\Pr(R)/\Pr(B) \le \Pr(E|B)/\Pr(E|R)$时不成立</p>
</div></p>
<h2>Problem 10 Expectation, Sums</h2>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$Ex(X_i) = 5/4$
$Ex\left( {X_1} \ldots {X_k} \right) \cdot $ 1,000,000 = {\left( 5/4 \right)}^k \cdot $ 1,000,000$</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>&lt;span&gt;$$\begin{align}
&amp; \left( {1/10} \right) \cdot \left( Ex({X_1}) + Ex({X_1}{X_2}) +  \ldots  + Ex({X_1}{X_2} \ldots X_{10}) \right) \cdot {10^6}\\
= &amp; (1/10) \cdot \left( 5/4 \right) \cdot \left(\frac{1 - {\left( 5/4 \right)}^{10}}{1 - 5/4} \right) \cdot 10^6\\
\approx &amp; 4,156,613
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>$Ex\left( 2^Y \right) \ne 2^{Ex\left( Y \right)}$</p>
</div></p>
<h2>Problem 11 Chebyshev Bound</h2>
<p><s>原题Problem 20.5</s></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>collection-variance与Chebyshev边界的方差定义是一致的，用概率和统计转换一下可以推导。
$\Pr \left(\left|T - Ex(T) \right| \ge 10 \right) \le \frac{CVar(A)}{10^2} = 0.2$</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>outcomes: all the body temperatures
每个outcome的概率相等，假设牛的数量为$n$，那么概率为$1/n$</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<blockquote>
<p>Explain why for this probability space, the fraction of cows with any given cow property $P$ is the same as $\Pr[P]$.</p>
</blockquote>
<p>我没看懂这个问题的意思，是问为什么每头牛的体温的概率分布都一样吗？</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>令$A$为这群牛所有体温数的集合
&lt;span&gt;$$\begin{align}
CVar(A) &amp; =  \frac{\sum\nolimits_{t \in A} {\left( t - Ex\left( T \right)\right)}^2 }{n}  \\
&amp; = \sum\nolimits_{t \in A} {\Pr[T=t] \cdot ( t - Ex( T))^2} \\
&amp; = \sum\nolimits_{t \in A} {\Pr[(T-Ex(T))^2 = (t - Ex(T)))^2] \cdot ( t - Ex( T))^2} \\
&amp; = Ex[(T - Ex(T))^2] \\
&amp; = Var[T]
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;</p>
</div></p>
<h2>Problem 12 Random Walk, Expectation</h2>
<p>似乎并不要求解出方程</p>
<p>$$a=p_{AC} + p_{AB} (1+b) + p_{AA} (1+a)$$ $$b=p_{BC} + p_{BB} (1+b) + p_{BA} (1+a)$$</p>
<h2>Problem 13 Sampling &amp; Confidence</h2>
<p>这一问也是不要求具体计算的，虽然二项分布算方差也没什么麻烦的。</p>
<p>$\epsilon$取0.006，找到令$f(0.006,n_0) \le 0.03$的最小$n_0$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/MIT6-042/2017final/" data-id="cjm54ylc50001fkw3wxf7rxus" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-88" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-88/">LeetCode Weekly Contest 88</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-88/" class="article-date"><time datetime="2018-06-10T12:17:08.175Z" itemprop="datePublished">2018-06-10</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-88/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Shifting Letters</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/shifting-letters/</p>
<blockquote>
<p>We have a string S of lowercase letters, and an integer array shifts.</p>
</blockquote>
<blockquote>
<p>Call the shift of a letter, the next letter in the alphabet, (wrapping around so that <code>'z'</code> becomes <code>'a'</code>).</p>
</blockquote>
<blockquote>
<p>For example, <code>shift('a') = 'b'</code>, s<code>hift('t') = 'u'</code>, <code>and shift('z') = 'a'</code>.</p>
</blockquote>
<blockquote>
<p>Now for each <code>shifts[i] = x</code>, we want to shift the first <code>i+1</code> letters of <code>S</code>, <code>x</code> times.</p>
</blockquote>
<blockquote>
<p>Return the final string after all such shifts to <code>S</code> are applied.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abc&quot;, shifts = [3,5,9]</span><br><span class="line">Output: &quot;rpl&quot;</span><br><span class="line">Explanation:</span><br><span class="line">We start with &quot;abc&quot;.</span><br><span class="line">After shifting the first 1 letters of S by 3, we have &quot;dbc&quot;.</span><br><span class="line">After shifting the first 2 letters of S by 5, we have &quot;igc&quot;.</span><br><span class="line">After shifting the first 3 letters of S by 9, we have &quot;rpl&quot;, the answer.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length = shifts.length &lt;= 20000</code></li>
<li><code>0 &lt;= shifts[i] &lt;= 10 ^ 9</code></li>
</ol>
<p>难度被标记为<code>Medium</code>有些夸张，大概主要是要对<code>shifts</code>处理一下，每个元素还要加上后面所有元素的和。不过这题也是够直接和无聊的</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shiftingLetters</span><span class="params">(self, S, shifts)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type shifts: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        S=list(S)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(shifts)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            shifts[i]+=shifts[i+<span class="number">1</span>]%<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            S[i]=chr((ord(S[i])+shifts[i]-ord(<span class="string">'a'</span>))%<span class="number">26</span>+ord(<span class="string">'a'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(S)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$</p>
<h2>Maximize Distance to Closest Person</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/maximize-distance-to-closest-person/</p>
<blockquote>
<p>In a row of <code>seats</code>, <code>1</code> represents a person sitting in that seat, and <code>0</code> represents that the seat is empty.</p>
</blockquote>
<blockquote>
<p>There is at least one empty seat, and at least one person sitting.</p>
</blockquote>
<blockquote>
<p>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.</p>
</blockquote>
<blockquote>
<p>Return that maximum distance to closest person.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0,1,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.</span><br><span class="line">If Alex sits in any other open seat, the closest person has distance 1.</span><br><span class="line">Thus, the maximum distance to the closest person is 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">If Alex sits in the last seat, the closest person is 3 seats away.</span><br><span class="line">This is the maximum distance possible, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= seats.length &lt;= 20000</code></li>
<li><code>seats</code> contains only 0s or 1s, at least one <code>0</code>, and at least one <code>1</code>.</li>
</ol>
<p>比上一题还要简单一些，两个<code>1</code>中间的位置，<code>seats[0]</code>，<code>seats[-1]</code>都可能成为使最近人最远的选座，找到最大值即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(self, seats)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type seats: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seats)) <span class="keyword">if</span> seats[i]]</span><br><span class="line">        gap=[int((token[i]-token[i<span class="number">-1</span>])/<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(token))]</span><br><span class="line">        <span class="keyword">return</span> max(gap+[token[<span class="number">0</span>],len(seats)<span class="number">-1</span>-token[<span class="number">-1</span>]])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度为$o(n)$</p>
<h2>Loud and Rich</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/loud-and-rich/</p>
<blockquote>
<p>n a group of N people (labelled <code>0, 1, 2, ..., N-1</code>), each person has different amounts of money, and different levels of quietness.</p>
</blockquote>
<blockquote>
<p>For convenience, we'll call the person with label <code>x</code>, simply &quot;person <code>x</code>&quot;.</p>
</blockquote>
<blockquote>
<p>We'll say that <code>richer[i] = [x, y]</code> if person <code>x</code> definitely has more money than person <code>y</code>.  Note that <code>richer</code> may only be a subset of valid observations.</p>
</blockquote>
<blockquote>
<p>Also, we'll say <code>quiet[x] = q</code> if person x has quietness <code>q</code>.</p>
</blockquote>
<blockquote>
<p>Now, return <code>answer</code>, where <code>answer[x] = y</code> if <code>y</code> is the least quiet person (that is, the person y with the smallest value of <code>quiet[y]</code>), among all people who definitely have equal to or more money than person <code>x</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]</span><br><span class="line">Output: [5,5,2,5,4,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line">answer[0] = 5.</span><br><span class="line">Person 5 has more money than 3, which has more money than 1, which has more money than 0.</span><br><span class="line">The only person who is quieter (has lower quiet[x]) is person 7, but</span><br><span class="line">it isn&apos;t clear if they have more money than person 0.</span><br><span class="line"></span><br><span class="line">answer[7] = 7.</span><br><span class="line">Among all people that definitely have equal to or more money than person 7</span><br><span class="line">(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])</span><br><span class="line">is person 7.</span><br><span class="line"></span><br><span class="line">The other answers can be filled out with similar reasoning.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= quiet.length = N &lt;= 500</code></li>
<li><code>0 &lt;= quiet[i] &lt; N</code>, all <code>quiet[i]</code> are different.</li>
<li><code>0 &lt;= richer.length &lt;= N * (N-1) / 2</code></li>
<li><code>0 &lt;= richer[i][j] &lt; N</code></li>
<li><code>richer[i][0] != richer[i][1]</code></li>
<li><code>richer[i]</code>'s are all different.</li>
<li>The observations in <code>richer</code> are all logically consistent.</li>
</ol>
<p>这问题背景的描述实在过于意义不明，我没有仔细看题，也没详细的去测试test case，我所理解的<code>richer</code>在逻辑上的一致，是指以<code>richer</code>关系为有向边构造出来的图中不存在环，那么可能是全序的路径，可能是树，也可能是不联通的森林，无所谓了，总之对每个结点只要找到子树中<code>quiet</code>最小的元素再和该结点的<code>quiet</code>比较就可以得到<code>answer[i]</code>了，很朴素的分治递归问题。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(self, richer, quiet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type richer: List[List[int]]</span></span><br><span class="line"><span class="string">        :type quiet: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(quiet)</span><br><span class="line">        g=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        res=[<span class="number">-1</span>]*N</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loudest</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> res[i]&gt;<span class="number">0</span>: <span class="keyword">return</span> res[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g[i]:</span><br><span class="line">                res[i]=i</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[i]=min([loudest(j) <span class="keyword">for</span> j <span class="keyword">in</span> g[i]]+[i],key=<span class="keyword">lambda</span> x:quiet[x])</span><br><span class="line">                <span class="keyword">return</span> res[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> richer:</span><br><span class="line">            g[y].append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> res[i]&lt;<span class="number">0</span>:</span><br><span class="line">                loudest(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$，空间复杂度为$o(N^2)$</p>
<h2>Rectangle Area II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/rectangle-area-ii/</p>
<blockquote>
<p>We are given a list of (axis-aligned) rectangles.  Each <code>rectangle[i] = [x1, y1, x2, y2]</code> , where <code>(x1, y1)</code> are the coordinates of the bottom-left corner, and <code>(x2, y2)</code> are the coordinates of the top-right corner of the <code>i</code>th rectangle.</p>
</blockquote>
<blockquote>
<p>Find the total area covered by all <code>rectangles</code> in the plane.  Since the answer may be too large, <strong>return it modulo 10^9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: As illustrated in the picture.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1000000000,1000000000]]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>
<li><code>rectanges[i].length = 4</code></li>
<li><code>0 &lt;= rectangles[i][j] &lt;= 10^9</code></li>
<li>The total area covered by all rectangles will never exceed <code>2^63 - 1</code> and thus will fit in a 64-bit signed integer.</li>
</ol>
<p>根据所有矩形的水平边（即<code>y</code>值）对整个图像进行分片，计算每个分片中的<code>x</code>范围长度与分片高度的乘积，再累加所有分片的计算结果。可以先按照底边<code>y</code>值进行排序，把每个底边在<code>upper</code>以下的矩形放入分片，顶边在达到<code>upper</code>在计算完分片中覆盖面积后删除。注意结果需要模<code>10^9 + 7</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectangleArea</span><span class="params">(self, rectangles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rectangles: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge_x_range</span><span class="params">(rlist)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rlist: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            rlist.sort()</span><br><span class="line">            start,end=rlist[<span class="number">0</span>][<span class="number">0</span>],rlist[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rlist:</span><br><span class="line">                <span class="keyword">if</span> r[<span class="number">0</span>]&lt;=end:</span><br><span class="line">                    end=max(r[<span class="number">2</span>],end)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append((start,end))</span><br><span class="line">                    start,end=r[<span class="number">0</span>],r[<span class="number">2</span>]</span><br><span class="line">            res.append((start,end))</span><br><span class="line">            <span class="keyword">return</span> sum(j-i <span class="keyword">for</span> i,j <span class="keyword">in</span> res)</span><br><span class="line"></span><br><span class="line">        area=<span class="number">0</span></span><br><span class="line">        rectangles.sort(key=<span class="keyword">lambda</span> r:(r[<span class="number">1</span>],r[<span class="number">3</span>]))</span><br><span class="line">        y=sorted(set([r[<span class="number">1</span>] <span class="keyword">for</span> r <span class="keyword">in</span> rectangles]+[r[<span class="number">3</span>] <span class="keyword">for</span> r <span class="keyword">in</span> rectangles]))</span><br><span class="line">        temp=[]</span><br><span class="line">        upper=y.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> y:</span><br><span class="line">            lower,upper=upper,y.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> rectangles <span class="keyword">and</span> rectangles[<span class="number">0</span>][<span class="number">1</span>]&lt;upper:</span><br><span class="line">                temp.append(rectangles.pop(<span class="number">0</span>))</span><br><span class="line">            area+=(upper-lower)*merge_x_range(temp)</span><br><span class="line">            area%=(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">while</span> temp:</span><br><span class="line">                h=min(range(len(temp)),key=<span class="keyword">lambda</span> x:temp[x][<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">if</span> temp[h][<span class="number">3</span>]!=upper: <span class="keyword">break</span></span><br><span class="line">                temp.pop(h)</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度可以达到$o(N\log N)$，当然我这里在计算<code>x</code>范围的过程写的很不好，拖慢了速度。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-88/" data-id="cjm54ylmd002ifkw350hgtush" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-87" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-87/">LeetCode Weekly Contest 87</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-87/" class="article-date"><time datetime="2018-06-03T07:55:34.617Z" itemprop="datePublished">2018-06-03</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-87</p>
<p>&lt;!-- more --&gt;</p>
<h2>Backspace String Compare</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/backspace-string-compare/</p>
<blockquote>
<p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>1 &lt;= T.length &lt;= 200</code></li>
<li><code>S</code> and <code>T</code> only contain lowercase letters and <code>'#'</code> characters.</li>
</ol>
<p>直接比较退格处理后的字符串，可能需要注意一下，当前面没有字符的时候退格符不进行任何操作。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">output_text</span><span class="params">(s)</span>:</span></span><br><span class="line">            res=<span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> c==<span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">if</span> res:</span><br><span class="line">                        res=res[:<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>: res+=c</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output_text(S)==output_text(T)</span><br></pre></td></tr></table></figure></p>
<h2>Longest Mountain in Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/longest-mountain-in-array/</p>
<blockquote>
<p>Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:</p>
</blockquote>
<ul>
<li><code>B.length &gt;= 3</code></li>
<li>There exists some<code>0 &lt; i &lt; B.length - 1</code> such that<code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code>
(Note that B could be any subarray of A, including the entire array A.)</li>
</ul>
<blockquote>
<p>Given an array <code>A</code> of integers, return the length of the longest mountain.</p>
</blockquote>
<blockquote>
<p>Return <code>0</code> if there is no mountain.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,4,7,3,2,5]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no mountain.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<p>直接按照题意，先找到上升开始的地方，再找到顶点，然后找到下坡的终点。很容易实现的线性扫描。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur,pos=<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_start</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> pos+<span class="number">2</span>&lt;len(A) <span class="keyword">and</span> A[pos]&gt;=A[pos+<span class="number">1</span>]:</span><br><span class="line">                pos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_end</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> pos+<span class="number">1</span>&lt;len(A) <span class="keyword">and</span> A[pos]&gt;A[pos+<span class="number">1</span>]:</span><br><span class="line">                pos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_peak</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> pos+<span class="number">2</span>&lt;len(A) <span class="keyword">and</span> A[pos]&lt;A[pos+<span class="number">1</span>]:</span><br><span class="line">                pos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">        i=find_start(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> i&lt;len(A)<span class="number">-2</span>:</span><br><span class="line">            p=find_peak(i)</span><br><span class="line">            <span class="keyword">if</span> p&lt;len(A)<span class="number">-1</span>:</span><br><span class="line">                e=find_end(p)</span><br><span class="line">                <span class="keyword">if</span> e&gt;p+<span class="number">1</span>: res=max(res,e-i)</span><br><span class="line">                p=e<span class="number">-1</span></span><br><span class="line">            i=find_start(p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Hand of Straights</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/hand-of-straights/</p>
<blockquote>
<p>Alice has a <code>hand</code> of cards, given as an array of integers.</p>
</blockquote>
<blockquote>
<p>Now she wants to rearrange the cards into groups so that each group is size<code>W</code>, and consists of <code>W</code> consecutive cards.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if she can.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hand = [1,2,3,6,2,3,4,7,8], W = 3</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice&apos;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hand = [1,2,3,4,5], W = 4</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice&apos;s hand can&apos;t be rearranged into groups of 4.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= hand.length &lt;= 10000</code></li>
<li><code>0 &lt;= hand[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= W &lt;= hand.length</code></li>
</ol>
<p>既然每个数都必须在且仅在一个长度为<code>W</code>的序列，那么对升序排序后的数组，抽出最小的数开始寻找剩下的<code>W-1</code>个数在不在数组内，在则取出，不在则直接返回<code>False</code>。时间开销主要在寻址，因此可以考虑用基于hash表的效率实现来表达数组中的所有元素，比如<code>SortedDict</code>之类的，这里用的是<code>Counter</code>，在计数值减到0时直接删去该项，而用<code>+=Counter()</code>这样传统的计数器维护操作为极大增加时间成本。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNStraightHand</span><span class="params">(self, hand, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type hand: List[int]</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span>            </span><br><span class="line">        <span class="keyword">if</span> len(hand)%W != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        k=len(hand)/W</span><br><span class="line">        counter=collections.Counter(hand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            cur=min(counter)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(W):</span><br><span class="line">                <span class="keyword">if</span> cur+j <span class="keyword">in</span> counter:</span><br><span class="line">                    counter[cur+j]-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> counter[cur+j]==<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> counter[cur+j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(\max (n,n\log(n)/W))$，空间复杂度为$o(n)$</p>
<h2>Shortest Path Visiting All Nodes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/shortest-path-visiting-all-nodes/</p>
<blockquote>
<p>An undirected, connected graph of N nodes (labeled <code>0, 1, 2, ..., N-1</code>) is given as graph.</p>
</blockquote>
<blockquote>
<p><code>graph.length = N</code>, and <code>j != i</code> is in the list <code>graph[i]</code> exactly once, if and only if nodes <code>i</code> and <code>j</code> are connected.</p>
</blockquote>
<blockquote>
<p>Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[0],[0],[0]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible path is [1,0,2,0,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible path is [0,1,4,2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= graph.length &lt;= 12</code></li>
<li><code>0 &lt;= graph[i].length &lt; graph.length</code></li>
</ol>
<p>乍一看有点像TSP问题，但因为有单向，连通，无权的条件限制，实际上也没那么麻烦，动态规划处理即可。<code>dp[path][node]</code>表示到经过结点集<code>path</code>到当前结点<code>node</code>的最短路径长度，<code>path</code>可以由<code>2^N</code>个数表示是否经过各个结点。因为边无权重，BFS第一次访问到该结点的时候，必然是到该结点的最短路径。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathLength</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(graph)</span><br><span class="line">        M=<span class="number">1</span>&lt;&lt;N</span><br><span class="line">        dp=[[<span class="number">-1</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(M)]</span><br><span class="line">        q=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            dp[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">0</span></span><br><span class="line">            q.append((i,<span class="number">1</span>&lt;&lt;i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node,path=q.pop(<span class="number">0</span>)</span><br><span class="line">            step=dp[path][node]</span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[node]:</span><br><span class="line">                next_path=path|(<span class="number">1</span>&lt;&lt;nei)</span><br><span class="line">                <span class="keyword">if</span> dp[next_path][nei]&lt;<span class="number">0</span>:</span><br><span class="line">                    dp[next_path][nei]=step+<span class="number">1</span></span><br><span class="line">                    q.append((nei,next_path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(E)$，空间复杂度为$o(N\times 2^N)$，$E$为边数。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-87/" data-id="cjm54ylls002efkw3p5jlvf7s" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p> <p>随着一次次的失败，一无所有的作者我已经别无所求了，只想安静的生活下去，不想再被打扰。谢谢大家的关心和照顾，可惜我已经无力回报，非常对不起。有事请联系<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">43</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
        </li>
      
        <li>
          <a href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
