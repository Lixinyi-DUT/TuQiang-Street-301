<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/5/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-66" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-66/">LeetCode Weekly Contest 66</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-66/" class="article-date"><time datetime="2018-01-07T11:24:46.970Z" itemprop="datePublished">2018-01-07</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新年快乐！我现在借口也懒得找了，直接说我又划水了。好好的博客被我当成日记在用。尽管如此，我知道这个博客也会在三月被停掉，我也知道我并不是一个擅长输出、创造、记录和分享的人，但我仍然会一周至少一篇的写下去。</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-66/</p>
<h2>Find Anagram Mappings</h2>
<p>原题 https://leetcode.com/contest/weekly-contest-66/problems/find-anagram-mappings/</p>
<blockquote>
<p>Given two lists <code>A</code> and <code>B</code>, and <code>B</code> is an anagram of <code>A</code>. <code>B</code> is an anagram of <code>A</code> means <code>B</code> is made by randomizing the order of the elements in <code>A</code>.</p>
</blockquote>
<blockquote>
<p>We want to find an index mapping <code>P</code>, from <code>A</code> to <code>B</code>. <code>A</code> mapping <code>P[i] = j</code> means the ith element in <code>A</code> appears in <code>B</code> at index <code>j</code>.</p>
</blockquote>
<blockquote>
<p>These lists <code>A</code> and <code>B</code> may contain duplicates. If there are multiple answers, output any of them.</p>
</blockquote>
<blockquote>
<p>For example, given
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = [12, 28, 46, 32, 50]</span><br><span class="line">B = [50, 12, 32, 46, 28]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>We should return
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 3, 2, 0]</span><br><span class="line">as P[0] = 1 because the 0th element of A appears at B[1], and P[1] = 4 because the 1st element of A appears at B[4], and so on.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code>, <code>B</code> have equal lengths in range <code>[1, 100]</code>.</li>
<li><code>A[i]</code>, <code>B[i]</code> are integers in range <code>[0, 10^5]</code>.</li>
</ol>
<p>直接按题意写就行，似乎没有特别需要注意的地方</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">anagramMappings</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            res.append(B.index(i))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>记<code>len(A)=len(B)=n</code>，时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>
<h2>Bold Words in String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-66/problems/bold-words-in-string/</p>
<blockquote>
<p>Given a set of keywords <code>words</code> and a string <code>S</code>, make all appearances of all keywords in S bold. Any letters between <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code> tags become bold.</p>
</blockquote>
<blockquote>
<p>The returned string should use the least number of tags possible, and of course the tags should form a valid combination.</p>
</blockquote>
<blockquote>
<p>For example, given that <code>words = [&quot;ab&quot;, &quot;bc&quot;]</code> and <code>S = &quot;aabcd&quot;</code>, we should return <code>&quot;a&lt;b&gt;abc&lt;/b&gt;d&quot;</code>. Note that returning <code>&quot;a&lt;b&gt;a&lt;b&gt;b&lt;/b&gt;c&lt;/b&gt;d&quot;</code> would use more tags, so it is incorrect.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>words has length in range <code>[0, 50]</code>.</li>
<li><code>words[i]</code> has length in range <code>[1, 10]</code>.</li>
<li>S has length in range <code>[0, 500]</code>.</li>
<li>All characters in <code>words[i]</code> and <code>S</code> are lowercase letters.</li>
</ol>
<p>从Note可以看出数据规模不算大，所以少花注意力在复杂度上，直接按照自己的直觉先想出可行的解法。我是通过找子串把所有需要加粗的字符的坐标标记下来，当然这一点上也有不少人考虑到的，比如讨论区有人提出使用<code>bitset</code>。最后遍历一遍<code>S</code>找到需要打标签的位置进行标记。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">boldWords</span><span class="params">(self, words, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(S)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> S</span><br><span class="line">        bold=set()</span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        start=<span class="number">0</span></span><br><span class="line">        index=[[m.start() <span class="keyword">for</span> m <span class="keyword">in</span> re.finditer(<span class="string">'(?=%s)'</span>%word, S)] <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(index)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> index[i]:</span><br><span class="line">                bold.update(range(j,j+len(words[i])))</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> bold:</span><br><span class="line">            res+=<span class="string">'&lt;b&gt;'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(S)):</span><br><span class="line">            <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> bold <span class="keyword">and</span> i <span class="keyword">in</span> bold:</span><br><span class="line">                res += S[start:i]+<span class="string">'&lt;b&gt;'</span></span><br><span class="line">                start=i</span><br><span class="line">            <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">in</span> bold <span class="keyword">and</span> i <span class="keyword">not</span> <span class="keyword">in</span> bold:</span><br><span class="line">                res += S[start:i]+<span class="string">'&lt;/b&gt;'</span></span><br><span class="line">                start=i</span><br><span class="line">        res+=S[start:len(S)]</span><br><span class="line">        <span class="keyword">if</span> len(S)<span class="number">-1</span> <span class="keyword">in</span> bold:</span><br><span class="line">            res+=<span class="string">'&lt;/b&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>需要当心的是找子串的时候可能会存在同一子串重叠的情况，比如<code>aaa</code>包含两个<code>aa</code>，所以整个<code>aaa</code>都是需要加粗的。另外根据个人的写法不同，输出结果的首尾尤其需要注意边界的处理。时间复杂度主要体现在找子串的过程中，记<code>words[i]</code>平均长度为<code>k</code>,<code>words</code>长度为<code>n</code>，<code>S</code>长度为<code>l</code>，则时间复杂度为$o(k\times n\times l)$，空间复杂度(最差)为$o(n\times l)$</p>
<h2>Employee Free Time</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-66/problems/employee-free-time/</p>
<blockquote>
<p>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.</p>
</blockquote>
<blockquote>
<p>Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.</p>
</blockquote>
<blockquote>
<p>Return the list of finite intervals representing <strong>common, positive-length free time</strong> for all employees, also in sorted order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]</span><br><span class="line">Output: [[3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There are a total of three employees, and all common</span><br><span class="line">free time intervals would be [-inf, 1], [3, 4], [10, inf].</span><br><span class="line">We discard any intervals that contain inf as they aren&apos;t finite.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]</span><br><span class="line">Output: [[5,6],[7,9]]</span><br><span class="line">(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are Intervals, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined.)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Also, we wouldn't include intervals like <code>[5, 5]</code> in our answer, as they have zero length.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>schedule</code> and <code>schedule[i]</code> are lists with lengths in range <code>[1, 50]</code>.</li>
<li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code>.</li>
</ol>
<p>这题虽然被标记为<code>hard</code>但我个人感觉没有特别难以理解的地方。我的思路是把这题当成<a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">区间合并</a>的衍生问题：<code>schedule</code>中的工作时间区间是一个员工的还是多个员工的对我来说根本不重要，直接<s>碾平</s>flatten处理即可，接下来对这些区间按照起点的升序排序，逐个向后合并。对于合并完成的区间再找出其补集。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">employeeFreeTime</span><span class="params">(self, schedule)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type schedule: List[List[Interval]]</span></span><br><span class="line"><span class="string">        :rtype: List[Interval]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        all_intervals=[i <span class="keyword">for</span> em <span class="keyword">in</span> schedule <span class="keyword">for</span> i <span class="keyword">in</span> em]</span><br><span class="line">        all_intervals.sort(key=<span class="keyword">lambda</span> (i):i.start)</span><br><span class="line">        merged_intervals=[]</span><br><span class="line">        res=[]</span><br><span class="line">        temp=all_intervals[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> all_intervals:</span><br><span class="line">            <span class="keyword">if</span> i.start &lt;= temp.end &lt; i.end:</span><br><span class="line">                temp.end=i.end</span><br><span class="line">            <span class="keyword">elif</span> i.start &gt; temp.end:</span><br><span class="line">                merged_intervals.append(temp)</span><br><span class="line">                temp=i</span><br><span class="line">        merged_intervals.append(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(merged_intervals)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(merged_intervals)):</span><br><span class="line">            res.append(Interval(s=merged_intervals[i<span class="number">-1</span>].end,e=merged_intervals[i].start))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>记区间的总个数为<code>n</code>，时间复杂度为排序的时间复杂度即$o(n \log n)$，空间复杂为$o(n)$</p>
<h2>Special Binary String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-66/problems/special-binary-string/</p>
<blockquote>
<p>Special binary strings are binary strings with the following two properties:</p>
</blockquote>
<ol>
<li>The number of 0's is equal to the number of 1's.</li>
<li>Every prefix of the binary string has at least as many 1's as 0's.</li>
</ol>
<blockquote>
<p>Given a special string <code>S</code>, a move consists of choosing two consecutive, non-empty, special substrings of <code>S</code>, and swapping them. (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)</p>
</blockquote>
<blockquote>
<p>At the end of any number of moves, what is the lexicographically largest resulting string possible?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;11011000&quot;</span><br><span class="line">Output: &quot;11100100&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The strings &quot;10&quot; [occuring at S[1]] and &quot;1100&quot; [at S[3]] are swapped.</span><br><span class="line">This is the lexicographically largest string possible after some number of swaps.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> has length at most <code>50</code>.</li>
<li><code>S</code> is guaranteed to be a special binary string as defined above.</li>
</ol>
<p>一开始我有点不太理解题目的意思(因为没有注意Note 2的限定)，所以参考了一下<a href="https://discuss.leetcode.com/topic/116280/easy-and-concise-solution-with-explanation-c-java-python" target="_blank" rel="noopener">其他人的讨论</a>。关键的部分在于理解Special Binary String到底是什么东西，列出来的两个约束有点啰嗦，因为满足1的情况下只要长度足够总能满足2。<code>S</code>本身也是一个长长的Special Binary String，可以从中划分出很多个短的Special Binary String，容易想到可以递归去解决这个问题。因为<code>S</code>打碎成了多个符合要求的（单位？）字符串，这些字符串之间也可以互相置换，所以&quot;连续&quot;这个限定反而不用刻意去关注。</p>
<p>递归的出口在于<code>01</code>被调转成<code>10</code>，对于一般情况即中间为任意特殊二进制字符串<code>M</code>的特殊二进制字符串<code>0M1</code>都可以转换为lexicographically意义上更大的<code>1M0</code>，<code>S</code>被打散成多个这样的字符串进行以上操作，再按照子串们lexicographical大小排序重组即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeLargestSpecial</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start=count=<span class="number">0</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i]==<span class="string">'1'</span>:</span><br><span class="line">                count +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="string">'1'</span>+self.makeLargestSpecial(S[start+<span class="number">1</span>:i])+<span class="string">'0'</span>)</span><br><span class="line">                start=i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(sorted(res,reverse=<span class="keyword">True</span>))</span><br></pre></td></tr></table></figure></p>
<p>假设<code>S</code>长度为<code>n</code>，时间复杂度在最坏的情况下（即）$o(nlogn)$，辅助空间依然线性。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-66/" data-id="cjm54ylef000bfkw31szo87ga" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-65" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-65/">LeetCode Weekly Contest 65</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-65/" class="article-date"><time datetime="2017-12-31T12:33:12.577Z" itemprop="datePublished">2017-12-31</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>提前祝新年快乐！本失败人士即将迎来另一个失败年，如我在<a href="http://notebook.xyli.me/Introduction/broken-project-yangzhou/">扬州计划破产声明</a>中所说，本站也即将在新的一年关闭，可以说是写一天少一天了，我也是怀着向死而生的心情在为自己的编程生涯写遗书呢。祝看到这篇文章的朋友们在新的一年里走向成功，除了我，大家都有光明的未来。今天因为回老家探亲，所以周赛例行划水，题做了下讲下我自己的想法。</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-65/</p>
<h2>Reach a Number</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-65/problems/reach-a-number/</p>
<blockquote>
<p>You are standing at position <code>0</code> on an infinite number line. There is a goal at position <code>target</code>.</p>
</blockquote>
<blockquote>
<p>On each move, you can either go left or right. During the n-th move (starting from 1), you take n steps.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of steps required to reach the destination.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">On the first move we step from 0 to 1.</span><br><span class="line">On the second step we step from 1 to 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">On the first move we step from 0 to 1.</span><br><span class="line">On the second move we step  from 1 to -1.</span><br><span class="line">On the third move we step from -1 to 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>target will be a non-zero integer in the range <code>[-10^9, 10^9]</code>.</li>
</ol>
<p>容易看出，这题对正负数的处理是对称的，所以暂时不需要考虑符号问题，直接取绝对值就行。简单的思路是先找到一个<code>n</code>使得<code>sum(n-1)&lt;target&lt;=sum(n)</code>，至于<code>sum(n)-target</code>可以靠<code>{0,1,....n}</code>中取若干个和为<code>sum(n)-target/2</code>的数取反抵消。当然如果<code>sum(n)-target</code>是个奇数，那就需要再加上<code>n+1</code>甚至<code>n+2</code>去凑齐这个偶数了。代码如下：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachNumber</span><span class="params">(self, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        step=<span class="number">0</span></span><br><span class="line">        acc=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> acc &lt; abs(target):</span><br><span class="line">            step +=<span class="number">1</span></span><br><span class="line">            acc += step</span><br><span class="line">        <span class="keyword">if</span> (abs(target)-acc)%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> step+<span class="number">1</span>+step%<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>复杂度主要来自于<code>step</code>（也就是<code>n</code>）自增循环，找到最小的<code>sum(n)=n(n-1)/2</code>恰好大于等于<code>target</code>显然需要$o(\sqrt {target} )$的时间复杂度。</p>
<h2>Pour Water</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-65/problems/pour-water/</p>
<blockquote>
<p>We are given an elevation map, <code>heights[i]</code> representing the height of the terrain at that index. The width at each index is 1. After <code>V</code> units of water fall at index <code>K</code>, how much water is at each index?</p>
</blockquote>
<blockquote>
<p>Water first drops at index <code>K</code> and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules:</p>
</blockquote>
<blockquote>
<ol>
<li>If the droplet would eventually fall by moving left, then move left.</li>
</ol>
</blockquote>
<ol start="2">
<li>Otherwise, if the droplet would eventually fall by moving right, then move right.</li>
<li>Otherwise, rise at it's current position.</li>
</ol>
<blockquote>
<p>Here, &quot;eventually fall&quot; means that the droplet will eventually be at a lower level if it moves in that direction. Also, &quot;level&quot; means the height of the terrain plus any water in that column.
We can assume there's infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3</span><br><span class="line">Output: [2,2,2,3,2,2,2]</span><br><span class="line">Explanation:</span><br><span class="line">#       #</span><br><span class="line">#       #</span><br><span class="line">##  # ###</span><br><span class="line">#########</span><br><span class="line"> 0123456    &lt;- index</span><br><span class="line"></span><br><span class="line">The first drop of water lands at index K = 3:</span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#   w   #</span><br><span class="line">##  # ###</span><br><span class="line">#########</span><br><span class="line"> 0123456    </span><br><span class="line"></span><br><span class="line">When moving left or right, the water can only move to the same level or a lower level.</span><br><span class="line">(By level, we mean the total height of the terrain plus any water in that column.)</span><br><span class="line">Since moving left will eventually make it fall, it moves left.</span><br><span class="line">(A droplet &quot;made to fall&quot; means go to a lower height than it was at previously.)</span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#       #</span><br><span class="line">## w# ###</span><br><span class="line">#########</span><br><span class="line"> 0123456    </span><br><span class="line"></span><br><span class="line">Since moving left will not make it fall, it stays in place.  The next droplet falls:</span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#   w   #</span><br><span class="line">## w# ###</span><br><span class="line">#########</span><br><span class="line"> 0123456  </span><br><span class="line"></span><br><span class="line">Since the new droplet moving left will eventually make it fall, it moves left.</span><br><span class="line">Notice that the droplet still preferred to move left,</span><br><span class="line">even though it could move right (and moving right makes it fall quicker.)</span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#  w    #</span><br><span class="line">## w# ###</span><br><span class="line">#########</span><br><span class="line"> 0123456  </span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#       #</span><br><span class="line">##ww# ###</span><br><span class="line">#########</span><br><span class="line"> 0123456  </span><br><span class="line"></span><br><span class="line">After those steps, the third droplet falls.</span><br><span class="line">Since moving left would not eventually make it fall, it tries to move right.</span><br><span class="line">Since moving right would eventually make it fall, it moves right.</span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#   w   #</span><br><span class="line">##ww# ###</span><br><span class="line">#########</span><br><span class="line"> 0123456  </span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#       #</span><br><span class="line">##ww#w###</span><br><span class="line">#########</span><br><span class="line"> 0123456  </span><br><span class="line"></span><br><span class="line">Finally, the fourth droplet falls.</span><br><span class="line">Since moving left would not eventually make it fall, it tries to move right.</span><br><span class="line">Since moving right would not eventually make it fall, it stays in place:</span><br><span class="line"></span><br><span class="line">#       #</span><br><span class="line">#   w   #</span><br><span class="line">##ww#w###</span><br><span class="line">#########</span><br><span class="line"> 0123456  </span><br><span class="line"></span><br><span class="line">The final answer is [2,2,2,3,2,2,2]:</span><br><span class="line"></span><br><span class="line">    #    </span><br><span class="line"> #######</span><br><span class="line"> #######</span><br><span class="line"> 0123456</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: heights = [1,2,3,4], V = 2, K = 2</span><br><span class="line">Output: [2,3,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: heights = [3,1,3], V = 5, K = 1</span><br><span class="line">Output: [4,4,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>heights will have length in <code>[1, 100]</code> and contain integers in <code>[0, 99]</code>.</li>
<li>V will be in range <code>[0, 2000]</code>.</li>
<li>K will be in range <code>[0, heights.length - 1]</code>.</li>
</ol>
<p>题有点啰嗦，规则的陈述有些奇怪，但只要直接看给出的例子就差不多能明白它想要你做什么了。把水逐滴滴到某个坐标，如果左边存在一个比当前坐标还低的“极低点”（注意是局部最低而非全局）就滑到这个地方去，如果左边没有再这样考虑右边存在不存在这样的点，如果都没有也就是说当前坐标就是地势最低（尽管可能只是和周围持平）的点，就保留在原地。没有什么特别的算法，直接按照游戏规则暴力码就可以通过，我的提交如下
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pourWater</span><span class="params">(self, heights, V, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type heights: List[int]</span></span><br><span class="line"><span class="string">        :type V: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(i,d)</span>:</span></span><br><span class="line">            temp=i</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span>&lt;=i+d&lt;len(heights):</span><br><span class="line">                <span class="keyword">if</span> heights[i+d]&lt;heights[i]:</span><br><span class="line">                    temp=i+d</span><br><span class="line">                <span class="keyword">elif</span> heights[i+d]&gt;heights[i]:</span><br><span class="line">                    <span class="keyword">if</span> heights[i]&lt;heights[temp]:</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> temp</span><br><span class="line">                i += d</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> V&gt;<span class="number">0</span>:</span><br><span class="line">            lowest=move(K,<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> lowest==K:</span><br><span class="line">                lowest=move(K,<span class="number">1</span>)</span><br><span class="line">            heights[lowest]+=<span class="number">1</span></span><br><span class="line">            V-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heights</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(V \times heights.length)$</p>
<h2>Pyramid Transition Matrix</h2>
<blockquote>
<p>We are stacking blocks to form a pyramid. Each block has a color which is a one letter string, like <code>'Z'</code>.</p>
</blockquote>
<blockquote>
<p>For every block of color <code>C</code> we place not in the bottom row, we are placing it on top of a left block of color <code>A</code> and right block of color <code>B</code>. We are allowed to place the block there only if <code>(A, B, C)</code> is an allowed triple.</p>
</blockquote>
<blockquote>
<p>We start with a bottom row of <code>bottom</code>, represented as a single string. We also start with a list of <code>allowed</code> triples allowed. Each allowed triple is represented as a string of length 3.</p>
</blockquote>
<blockquote>
<p>Return true if we can build the pyramid all the way to the top, otherwise false.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: bottom = &quot;XYZ&quot;, allowed = [&quot;XYD&quot;, &quot;YZE&quot;, &quot;DEA&quot;, &quot;FFF&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We can stack the pyramid like this:</span><br><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  D   E</span><br><span class="line"> / \ / \</span><br><span class="line">X   Y   Z</span><br><span class="line"></span><br><span class="line">This works because (&apos;X&apos;, &apos;Y&apos;, &apos;D&apos;), (&apos;Y&apos;, &apos;Z&apos;, &apos;E&apos;), and (&apos;D&apos;, &apos;E&apos;, &apos;A&apos;) are allowed triples.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: bottom = &quot;XXYX&quot;, allowed = [&quot;XXX&quot;, &quot;XXY&quot;, &quot;XYX&quot;, &quot;XYY&quot;, &quot;YXZ&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We can&apos;t stack the pyramid to the top.</span><br><span class="line">Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>bottom will be a string with length in range <code>[2, 100]</code>.</li>
<li>allowed will have length in range <code>[0, 350]</code>.</li>
<li>Letters in all strings will be chosen from the set <code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>.</li>
</ol>
<p>我自己的第一反应是DFS，但是马上能明白在时间和空间上是不可行的。建议直接看<a href="https://leetcode.com/problems/pyramid-transition-matrix/solution/" target="_blank" rel="noopener">官方题解</a>的思路比较清晰，按照位操作的方法去标记每一个的可能性，7位二进制数每位分别代表一位数字在此能否取到，使用位或运算（<code>|</code>）把所有可能性放在同一个结点的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pyramidTransition</span><span class="params">(self, bottom, allowed)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bottom: str</span></span><br><span class="line"><span class="string">        :type allowed: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        T=[[<span class="number">0</span>]*<span class="number">7</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>)]</span><br><span class="line">        <span class="keyword">for</span> a,b,c <span class="keyword">in</span> allowed:</span><br><span class="line">            T[ord(a)-ord(<span class="string">'A'</span>)][ord(b)-ord(<span class="string">'A'</span>)] |= <span class="number">1</span>&lt;&lt;(ord(c)-ord(<span class="string">'A'</span>))</span><br><span class="line"></span><br><span class="line">        candidate=[<span class="number">1</span>&lt;&lt;(ord(c)-ord(<span class="string">'A'</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> bottom] <span class="comment"># possible next node list in each loop (level)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(bottom)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(bottom)<span class="number">-1</span>-i):</span><br><span class="line">                temp=<span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">                    <span class="keyword">if</span> (candidate[j] &gt;&gt; x) &amp; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">                            <span class="keyword">if</span> (candidate[j+<span class="number">1</span>] &gt;&gt; y) &amp; <span class="number">1</span>:</span><br><span class="line">                                temp |= T[x][y]</span><br><span class="line">                candidate[j]=temp</span><br><span class="line">        <span class="keyword">return</span> bool(candidate[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>字母表即颜色数量为$A$，底部行即塔高度为$N$，那么所需的时间复杂度为$o(2^{2A}N^2)$，辅助空间则为$o(A^2)$</p>
<h2>Set Intersection Size At Least Two</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-65/problems/set-intersection-size-at-least-two/</p>
<blockquote>
<p>An integer interval <code>[a, b]</code> (for integers <code>a &lt; b</code>) is a set of all consecutive integers from <code>a</code> to <code>b</code>, including <code>a</code>and <code>b</code>.</p>
</blockquote>
<blockquote>
<p>Find the minimum size of a set S such that for every integer interval A in <code>intervals</code>, the intersection of S with A has size at least 2.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Consider the set S = &#123;2, 3, 4&#125;.  For each interval, there are at least 2 elements from S in the interval.</span><br><span class="line">Also, there isn&apos;t a smaller size set that fulfills the above condition.</span><br><span class="line">Thus, we output the size of this set, which is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">An example of a minimum sized set is &#123;1, 2, 3, 4, 5&#125;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>intervals</code> will have length in range <code>[1, 3000]</code>.</li>
<li><code>intervals[i]</code> will have length <code>2</code>, representing some integer interval.</li>
<li><code>intervals[i][j]</code> will be an integer in <code>[0, 10^8]</code>.
Discuss</li>
</ol>
<p>虽然标记为<code>hard</code>难度但实际上做起来也并没有特别难。如果题目改为交集大小至少为1，那么我们很容易就能想到取每个区间的终点（起点也是同理）并去除那些终点本来就在<code>S</code>的区间。对于交集大小至少为2的情况，也可以使用相似的贪心算法，先把区间按终点大小<strong>升序</strong>排序，对于每个区间<code>[s,e]</code>观察区间内有几个数在<code>S</code>中：</p>
<ol>
<li>0：取最大的两个数放进<code>S</code></li>
<li>&gt;=2：那么这个区间没有影响，忽略</li>
<li>1：如果这个数不是区间的终点，则把终点放进<code>S</code>；如果这个数就是区间的终点，则取终点前一位数</li>
</ol>
<p>这样尽量取区间内最大的两个数补足的做法，能保证处理下一个区间时（因为我们是按照<code>e</code>的升序排列），下个区间有最大的与<code>S</code>交集期望大小。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersectionSizeTwo</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type intervals: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> (s,e): e)</span><br><span class="line">        low,high,count=<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (s,e) <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> s&gt;high:</span><br><span class="line">                count+=<span class="number">2</span></span><br><span class="line">                low,high=e<span class="number">-1</span>,e</span><br><span class="line">            <span class="keyword">elif</span> s&gt;low:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> high==e:</span><br><span class="line">                    low=high<span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    low=high</span><br><span class="line">                high=e</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度主要来自于区间的排序和后面检查取值时的线性遍历，就直接按照排序取$o(n\log{n})$，空间复杂度为$o(1)$，$n$为区间数量</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-65/" data-id="cjm54ylgc000vfkw3rcpfa912" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-64" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-64/">LeetCode Weekly Contest 64</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-64/" class="article-date"><time datetime="2017-12-24T07:28:52.846Z" itemprop="datePublished">2017-12-24</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>首先大家平安夜快乐哈。</p>
<p>这一个星期来，因为我个人犯下的不可弥补的错误和失败，夜夜在浅色床单上熬夜痛哭，开玩笑的，主要还是肝fgo肝晚了点，导致这周周赛又完美错过开赛点了，所以我又例行划水的随便做了下题就行，然后随便写写题解，不要深究，看其他用户的时间应该这次不算难。</p>
<p>好了，直接看题。</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-64/</p>
<h2>Largest Number Greater Than Twice of Others</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-64/problems/largest-number-greater-than-twice-of-others/</p>
<blockquote>
<p>In a given integer array <code>nums</code>, there is always exactly one largest element.</p>
</blockquote>
<blockquote>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
</blockquote>
<blockquote>
<p>If it is, return the <strong>index</strong> of the largest element, otherwise return -1.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3, 6, 1, 0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 6 is the largest integer, and for every other number in the array x,</span><br><span class="line">6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 2, 3, 4]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: 4 isn&apos;t at least as big as twice the value of 3, so we return -1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>nums</code> will have a length in the range <code>[1, 50]</code>.</li>
<li>Every <code>nums[i]</code> will be an integer in the range <code>[0, 99]</code>.</li>
</ol>
<p>这题真没啥好说了，按着题目的思路直接写就行了，我估计也翻不出什么花来。大概想考堆的用法？但是模板基本都封装好了应该不会有人还舍近求远吧。线性时间，常数空间，直接上代码</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dominantIndex</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        maxNum=max(nums)</span><br><span class="line">        maxIndex=nums.index(maxNum)</span><br><span class="line">        nums.pop(maxIndex)</span><br><span class="line">        second=max(nums)</span><br><span class="line">        <span class="keyword">if</span> maxNum&gt;=<span class="number">2</span>*second:</span><br><span class="line">            <span class="keyword">return</span> maxIndex</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2>IP to CIDR</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-64/problems/ip-to-cidr/</p>
<blockquote>
<p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>
</blockquote>
<blockquote>
<p>A CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length. For example: &quot;123.45.67.89/20&quot;. That prefix length &quot;20&quot; represents the number of common prefix bits in the specified range.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Input: ip = &quot;255.0.0.7&quot;, n = 10</span><br><span class="line">Output: [&quot;255.0.0.7/32&quot;,&quot;255.0.0.8/29&quot;,&quot;255.0.0.16/32&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">The initial ip address, when converted to binary, looks like this (spaces added for clarity):</span><br><span class="line">255.0.0.7 -&gt; 11111111 00000000 00000000 00000111</span><br><span class="line">The address &quot;255.0.0.7/32&quot; specifies all addresses with a common prefix of 32 bits to the given address,</span><br><span class="line">ie. just this one address.</span><br><span class="line"></span><br><span class="line">The address &quot;255.0.0.8/29&quot; specifies all addresses with a common prefix of 29 bits to the given address:</span><br><span class="line">255.0.0.8 -&gt; 11111111 00000000 00000000 00001000</span><br><span class="line">Addresses with common prefix of 29 bits are:</span><br><span class="line">11111111 00000000 00000000 00001000</span><br><span class="line">11111111 00000000 00000000 00001001</span><br><span class="line">11111111 00000000 00000000 00001010</span><br><span class="line">11111111 00000000 00000000 00001011</span><br><span class="line">11111111 00000000 00000000 00001100</span><br><span class="line">11111111 00000000 00000000 00001101</span><br><span class="line">11111111 00000000 00000000 00001110</span><br><span class="line">11111111 00000000 00000000 00001111</span><br><span class="line"></span><br><span class="line">The address &quot;255.0.0.16/32&quot; specifies all addresses with a common prefix of 32 bits to the given address,</span><br><span class="line">ie. just 11111111 00000000 00000000 00010000.</span><br><span class="line"></span><br><span class="line">In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .</span><br><span class="line"></span><br><span class="line">There were other representations, such as:</span><br><span class="line">[&quot;255.0.0.7/32&quot;,&quot;255.0.0.8/30&quot;, &quot;255.0.0.12/30&quot;, &quot;255.0.0.16/32&quot;],</span><br><span class="line">but our answer was the shortest possible.</span><br><span class="line"></span><br><span class="line">Also note that a representation beginning with say, &quot;255.0.0.7/30&quot; would be incorrect,</span><br><span class="line">because it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100</span><br><span class="line">that are outside the specified range.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>ip</code> will be a valid IPv4 address.</li>
<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>
<li>n will be an integer in the range <code>[1, 1000]</code>.</li>
</ol>
<p>题长的可怕，但看完就会发现其实和算法的设计或者应用没太大关系，无视IPv4地址这种特殊的数据形式，可以把题意化简成：</p>
<p><div class="bs-callout bs-callout-default"><p>琪露诺小姐姐从雾之湖冻了很多青蛙上来分放在很多筐里，筐有大有小，里面青蛙的数量也各不相同。现在她觉得本天才心情很好计划解冻放生<code>n</code>只青蛙，一筐青蛙没放完不可以开下一筐，且筐的取用顺序有严格的编号规定，请问小姐姐最少要拿哪几筐？</p>
</div></p>
<p>这样一看，无非是线性遍历数出这<code>n</code>只青蛙，就像从储蓄罐里数出<code>n</code>枚硬币，<s>孔乙己排出<code>n</code>枚铜板</s>顺序都是固定的，没有什么技巧发挥的空间。但是IPv4地址自带一些麻烦的规则，这些规则包括从哪个筐开始取蛙（初始IP），取用顺序和每个筐的大小（子网/掩码长度），每个筐里有多少青蛙（每段子网可用的IP数量）。我试了下不允许用<code>ipaddress</code>模块，所以我们还得自己去领会这些规则然后自己把数据形式转换过来写。</p>
<p>我们直接把一个IPv4地址转换成二进制形式，找到最低位的1开始，如果后面有<code>i</code>位0则代表有<code>2^i</code>个IP可以使用，“遍历”数出这些地址再到下一个起点，也就是把最低位的1向前进位，再重复以上操作，直至遍历完<code>n</code>个IP地址。当然，最后一轮可能会不需要该段子网全部的IP就可以遍历完，这时取大于剩余需求数的最小的2的幂次方数的子网就可以了。</p>
<p>一开始找最低位1我是全数转换为二进制，效率不高，在编辑给的题解里看见是取<code>start &amp; - start</code>找到的，因为我位运算学的水写的也少，说出来不怕丢人，我以为<code>&amp;-</code>是什么神奇的运算符呢查了半天查不到。只是<code>start</code>和它的相反数进行位与计算，因为对于正整数<code>x</code>来说，其相反数<code>-x = ~x + 1</code>，容易看出这样操作可以快速找到最低位1，具体原理可以见《深入理解计算机系统》P40左右的内容。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ipToCIDR</span><span class="params">(self, ip, range)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ip: str</span></span><br><span class="line"><span class="string">        :type range: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">int2ip</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'.'</span>.join([str((n&gt;&gt;i) %<span class="number">256</span>) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">24</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        start=int(<span class="string">''</span>.join([bin(int(i))[<span class="number">2</span>:].zfill(<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ip.split(<span class="string">'.'</span>)]),<span class="number">2</span>)</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">while</span> range&gt;<span class="number">0</span>:</span><br><span class="line">            fill=min((start &amp; -start),range)</span><br><span class="line">            mask=<span class="number">33</span>-fill.bit_length()</span><br><span class="line">            res.append(int2ip(start)+<span class="string">'/'</span>+str(mask))</span><br><span class="line">            range -= <span class="number">1</span> &lt;&lt; (fill.bit_length()<span class="number">-1</span>)</span><br><span class="line">            start += <span class="number">1</span> &lt;&lt; (fill.bit_length()<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Open the Lock</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-64/problems/open-the-lock/</p>
<blockquote>
<p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>. The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>. Each move consists of turning one wheel one slot.</p>
</blockquote>
<blockquote>
<p>The lock initially starts at <code>'0000'</code>, a string representing the state of the 4 wheels.</p>
</blockquote>
<blockquote>
<p>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p>
</blockquote>
<blockquote>
<p>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.</span><br><span class="line">Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,</span><br><span class="line">because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">We can&apos;t reach the target without getting stuck.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: deadends = [&quot;0000&quot;], target = &quot;8888&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>因为<code>deadends</code>的存在，虽然数据形式是特性很好的四位自然数，但不适合直接从数字间减法的方法出发找转数。主流的做法就是把它当成和琪露诺数蛙一样的题，用BFS这种“笨办法”一个个枚举出转到密码为止需要经历多少组合，走一步摸一步，如果遇上deadend就表示这个节点不与其他相连。当然这种做法的开销很大，我一开始也一直TLE，参考编辑的题解改用了<code>set</code>和<code>deque</code>等高效容器才通过，另外注意标记节点是否已经访问过以防发生回溯
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span><span class="params">(self, deadends, target)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">next_node</span><span class="params">(lock)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">yield</span> lock[:i]+str((int(lock[i])+d)%<span class="number">10</span>)+lock[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> deadends:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        deadends = set(deadends)</span><br><span class="line">        queue = collections.deque([(<span class="string">'0000'</span>, <span class="number">0</span>)])</span><br><span class="line">        visited=set([<span class="string">'0000'</span>])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            num, depth = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> num==target:</span><br><span class="line">                <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> deadends:</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> next_node(num):</span><br><span class="line">                    <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(node)</span><br><span class="line">                        queue.append((node,depth+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>容易看出复杂度主要与节点数，即密码组合总个数（这里是<code>10^4</code>）相关。比较直觉的去寻找单源最短路径想到了Dijkstra算法，我看也确实有人用Java实现了。虽然是不错的想法但这题用处不大，毕竟不存在复杂的权边，空间开销又会迅速增加，试着写了个被TLE的反面示例
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span><span class="params">(self, deadends, target)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">next_node</span><span class="params">(lock)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">yield</span> lock[:i]+str((int(lock[i])+d)%<span class="number">10</span>)+lock[i+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> deadends:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        deadends = set(deadends)</span><br><span class="line">        queue = []</span><br><span class="line">        heapq.heappush(queue,(<span class="number">0</span>,<span class="string">'0000'</span>))</span><br><span class="line">        dist=dict()</span><br><span class="line">        dist[<span class="string">'0000'</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(queue)&gt;<span class="number">0</span>:</span><br><span class="line">            d,num= heapq.heappop(queue)</span><br><span class="line">            <span class="keyword">if</span> num==target:</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> deadends:</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> next_node(num):</span><br><span class="line">                    <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> dist <span class="keyword">or</span> d+<span class="number">1</span>&lt;=dist[node]:</span><br><span class="line">                        dist[node]=d+<span class="number">1</span></span><br><span class="line">                        heapq.heappush(queue,(dist[node],node))</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> dist&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dist[target]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>如果对此题有兴趣可以直接去讨论区看看，虽然基本都是BFS，但在实现技巧上讨论了很多，比如这里的<a href="https://discuss.leetcode.com/topic/114830/ac-java-solution-using-2-end-bfs" target="_blank" rel="noopener">AC JAVA Solution using 2-end BFS</a>提到可以从起点（<code>0000</code>）和终点（<code>target</code>）一起同时开始向中间找。</p>
<h2>Cracking the Safe</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-64/problems/cracking-the-safe/</p>
<blockquote>
<p>There is a box protected by a password. The password is n digits, where each letter can be one of the first <code>k</code> digits <code>0, 1, ..., k-1</code>.</p>
</blockquote>
<blockquote>
<p>You can keep inputting the password, the password will automatically be matched against the last <code>n</code> digits entered.</p>
</blockquote>
<blockquote>
<p>For example, assuming the password is <code>&quot;345&quot;</code>, I can open it when I type <code>&quot;012345&quot;</code>, but I enter a total of 6 digits.</p>
</blockquote>
<blockquote>
<p>Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1, k = 2</span><br><span class="line">Output: &quot;01&quot;</span><br><span class="line">Note: &quot;10&quot; will be accepted too.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2, k = 2</span><br><span class="line">Output: &quot;00110&quot;</span><br><span class="line">Note: &quot;01100&quot;, &quot;10011&quot;, &quot;11001&quot; will be accepted too.</span><br><span class="line">Note:</span><br><span class="line">n will be in the range [1, 4].</span><br><span class="line">k will be in the range [1, 10].</span><br><span class="line">k^n will be at most 4096.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>n</code> will be in the range <code>[1, 4]</code>.</li>
<li><code>k</code> will be in the range <code>[1, 10]</code>.</li>
<li><code>k^n</code> will be at most <code>4096</code></li>
</ol>
<p>本来想了很多也写了很多，最后还是觉得直接看<a href="https://leetcode.com/problems/cracking-the-safe/solution/" target="_blank" rel="noopener">编辑的题解</a>比听我说废话管用的多。我就大致说一下其中的思路：</p>
<p>这个问题可以等同于有$k^{(n-1)}$个节点，每个结点有$k$条边，需要恰好遍历所有边一次，也就是求图中的Euler回路。例如<code>k = 4, n = 3</code>时，结点为<code>'00', '01', '02', ..., '32', '33'</code>，每个结点有<code>k=4</code>条边分别为<code>'0', '1', '2', '3'</code>，节点和边共同构成一个“完全边”，也就是密码组合，原文中没说清楚的是这些边分别指向哪个节点，当然理解思路以后就可以知道一个结点的所有入边都和节点的第一位数字相同，出边都与最后一位数字相同。那么<code>'00'</code>的四条出边分布指向<code>'00','01','02', '03'</code>。把图构造完了，注意力应该放在求Euler回路的算法上，这里使用基于贪心策略的Hierholzer算法，即找出所有回路上的子回路。使用BFS去遍历这些（子）回路时，为防止过早结束遍历，采用后序遍历的方法先表示出最高层的子回路：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crackSafe</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visited=set()</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(k):</span><br><span class="line">                nei=node+str(d)</span><br><span class="line">                <span class="keyword">if</span> nei <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(nei)</span><br><span class="line">                    bfs(nei[<span class="number">1</span>:])</span><br><span class="line">                    res.append(str(d))</span><br><span class="line">        bfs(<span class="string">"0"</span>*(n<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)+<span class="string">"0"</span>*(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<p>原文说这样的算法复杂度为$o(n \times k^n)$，但我认为应该是遍历所有边的复杂度即$o(k^n)$，这一点我看有人也提出了质疑，随时等候说法。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-64/" data-id="cjm54yley000gfkw3gma3bv83" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-63" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-63/">LeetCode Weekly Contest 63</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-63/" class="article-date"><time datetime="2017-12-17T13:47:35.194Z" itemprop="datePublished">2017-12-17</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>因为很久没刷题了没法判断这周的难度，根据其他用户的完成情况我觉得应该是中规中矩的难度吧。本来昨天准备参加一次周赛的，因为睡的太晚梦到自己未来既没有学上又找不到工作的真实惨状，由于过于真实以至于我一直没意识到是梦境所以就睡过了开赛时间~~（真是拙劣的偷懒理由，活该失业失学）~~所以我只把题做了一遍，只写下自己的想法，好了废话不多说了，赶紧看题吧</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-63/</p>
<h2>Min Cost Climbing Stairs</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-63/problems/min-cost-climbing-stairs/</p>
<blockquote>
<p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p>
</blockquote>
<blockquote>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [10, 15, 20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>cost will have a length in the range <code>[2, 1000]</code>.</li>
<li>Every cost[i] will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<p>这题没有什么特别的地方，就是非常典型的动态规划题。既然一次能走1-2级，那么走到第<code>i</code>级阶梯(<code>i&gt;2</code>)，要么经过第<code>i-1</code>级要么通过第<code>i-2</code>级，假设已经知道了到第<code>i-1</code>级和第<code>i-2</code>的最小总代价<code>minCost</code>，再分别加上它们本身的代价就可以得到到第<code>i</code>级的两种方法分别需要的总代价，取<code>minCost[i-1]+cost[i-1]</code>和<code>minCost[i-2]+cost[i-2]</code>中较小的一个即可得到<code>minCost[i]</code>，代码如下</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span><span class="params">(self, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type cost: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        minCost=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cost)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(cost)+<span class="number">1</span>):</span><br><span class="line">            minCost[i]=min(minCost[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>],minCost[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> minCost[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>如上所示，时间和空间复杂度都是线性的。</p>
<p>需要注意的是，<code>cost</code>列表的最后一个元素并不是终点，只是通向终点最后一级阶梯，所以最后需要计算到<code>minCost[i]</code>。另外，对于这样的一维动态规划，其实很显然是没有太大必要另开一个列表的，常数级的辅助空间（3个临时变量）足够，但我为了写起来方便还是偷懒这么写了，我是坏榜样，请大家尽量不要这么做。</p>
<h2>Shortest Completing Word</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-63/problems/shortest-completing-word/</p>
<blockquote>
<p>Find the minimum length word from a given dictionary <code>words</code>, which has all the letters from the string <code>licensePlate</code>. Such a word is said to complete the given string <code>licensePlate</code></p>
</blockquote>
<blockquote>
<p>Here, for letters we ignore case. For example, <code>&quot;P&quot;</code> on the licensePlate still matches <code>&quot;p&quot;</code> on the word.</p>
</blockquote>
<blockquote>
<p>It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</p>
</blockquote>
<blockquote>
<p>The license plate might have the same letter occurring multiple times. For example, given a licensePlate of <code>&quot;PP&quot;</code>, the word <code>&quot;pair&quot;</code> does not complete the licensePlate, but the word <code>&quot;supper&quot;</code> does.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]</span><br><span class="line">Output: &quot;steps&quot;</span><br><span class="line">Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.</span><br><span class="line">Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.</span><br><span class="line">Also note that we ignored case for the purposes of comparing whether a letter exists in the word.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: licensePlate = &quot;1s3 456&quot;, words = [&quot;looks&quot;, &quot;pest&quot;, &quot;stew&quot;, &quot;show&quot;]</span><br><span class="line">Output: &quot;pest&quot;</span><br><span class="line">Explanation: There are 3 smallest length words that contains the letters &quot;s&quot;.</span><br><span class="line">We return the one that occurred first.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>licensePlate</code> will be a string with length in range <code>[1, 7]</code>.</li>
<li><code>licensePlate</code> will contain digits, spaces, or letters (uppercase or lowercase).</li>
<li><code>words</code> will have a length in the range <code>[10, 1000]</code>.</li>
<li>Every <code>words[i]</code> will consist of lowercase letters, and have length in range <code>[1, 15]</code></li>
</ol>
<p>我个人感觉这就是在考察字符串操作，虽然这题的标签是hash表。我个人的做法是统计<code>licensePlate</code>中各字母出现的频数，再找<code>words</code>列表中符合这个最低频数的最小字符串。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestCompletingWord</span><span class="params">(self, licensePlate, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type licensePlate: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        obj=string.lower(<span class="string">''</span>.join(filter(<span class="keyword">lambda</span> c:c.isalpha(),licensePlate)))</span><br><span class="line">        d=dict()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> obj:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[c]=string.count(obj,c)</span><br><span class="line">        shortest=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            flag=<span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">if</span> d[c] &gt; string.count(w,c):</span><br><span class="line">                    flag=<span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">if</span>  len(shortest)==<span class="number">0</span> <span class="keyword">or</span> len(shortest)&gt;len(w):</span><br><span class="line">                    shortest=w</span><br><span class="line">        <span class="keyword">return</span> shortest</span><br></pre></td></tr></table></figure></p>
<p>假设<code>licensePlate</code>长度为$m$，<code>words</code>长度为$N$，其中最长的字符串长度为$n$：使用字典统计频数的时间复杂度为$o(m)$，空间复杂度为$o(26)$也就是$o(1)$，在对比<code>words</code>中元素词频时，所用到的辅助空间也是常数级的，而时间则是$o(26 \times n \times N )$，考虑到$n \le 15$和$m \le 7$也可以直接当成常数忽略不计了，所以最终整个过程的时间复杂度为$o(N)$，是线性的，空间复杂度则为$o(1)$。</p>
<p>字典存字频某种意义上也算确实用了hash表。确实急着写所以写出来有点难看，而且我对字符串相关函数确实不熟悉就只能xjb写了，不过我看其他人写的虽然比我干净也是用的差不多的思路，也有考虑用正则表达式的，我因为很久没刷题都不知道现在允许用<code>re</code>了，有兴趣的可以直接去这题的讨论区看看，我不方便贴别人的代码。</p>
<h2>Number Of Corner Rectangles</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-63/problems/number-of-corner-rectangles/</p>
<blockquote>
<p>Given a grid where each entry is only 0 or 1, find the number of corner rectangles.</p>
</blockquote>
<blockquote>
<p>A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[1, 0, 0, 1, 0],</span><br><span class="line"> [0, 0, 1, 0, 1],</span><br><span class="line"> [0, 0, 0, 1, 0],</span><br><span class="line"> [1, 0, 1, 0, 1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[1, 1, 1],</span><br><span class="line"> [1, 1, 1],</span><br><span class="line"> [1, 1, 1]]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[1, 1, 1, 1]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Rectangles must have four distinct corners.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of rows and columns of grid will each be in the range <code>[1, 200]</code>.</li>
<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>
<li>The number of 1s in the grid will be at most <code>6000</code>.</li>
</ol>
<p>这题我个人感觉不是很难解出结果，但是要非常当心所写的算法的复杂度，一不留神就会TLE，而且即使想出了相对高效的算法，也要留心实现的方法，要不也容易TLE，当然算法上可以说是八仙过海了，题目的限定不明确，没有明显很优秀的算法。</p>
<p>我的第一直觉就是<s>朴实无华的</s>暴力搜索，先把答案解出来再慢慢想~~（我们没文化的人就是这个样子的.jpg 这也是我和大佬的区别）~~
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/1.png" alt="">
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCornerRectangles</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row=len(grid)</span><br><span class="line">        col=len(grid[<span class="number">0</span>])</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> y0 <span class="keyword">in</span> range(row<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> x0 <span class="keyword">in</span> range(col<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> grid[y0][x0]==<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">for</span> y1 <span class="keyword">in</span> range(y0+<span class="number">1</span>,row):</span><br><span class="line">                        <span class="keyword">if</span> grid[y1][x0]==<span class="number">1</span>:</span><br><span class="line">                            <span class="keyword">for</span> x1 <span class="keyword">in</span> range(x0+<span class="number">1</span>,col):</span><br><span class="line">                                <span class="keyword">if</span> grid[y0][x1]==<span class="number">1</span> <span class="keyword">and</span> grid[y1][x1]==<span class="number">1</span>:</span><br><span class="line">                                    count +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Warning</h4>
<p>注意上面那个提交毫不意外地是TLE，$o(r^2 c^2)$时间复杂度就问你怕不怕？是反面教材，请不要模仿。</p>
<p>注：$r$为矩阵行数，$c$为矩阵列数</p>
</div></p>
<p>接下来我思考的是这么大个矩阵里面<code>1</code>不超过6000个，是不是也算稀疏矩阵了&lt;a name=&quot;sparse&quot;&gt;&lt;/a&gt;？那么考虑去用矩阵存储数据有点浪费，不如借助一个类似邻接列表的数据结构存放每行或者每列中<code>1</code>的位置。</p>
<p>接着遍历这些<code>1</code>，再考虑这些<code>1</code>与某个在它右下方的<code>1</code>能否组成一个矩形的对角线？
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/2.png" alt=""></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCornerRectangles</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        row=len(grid)</span><br><span class="line">        col=len(grid[<span class="number">0</span>])</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        corner_row=[[] <span class="keyword">for</span> i <span class="keyword">in</span> range(row)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                    corner_row[i].append(j)</span><br><span class="line">        <span class="keyword">for</span> y0 <span class="keyword">in</span> range(row):</span><br><span class="line">            <span class="keyword">for</span> x0 <span class="keyword">in</span>  corner_row[y0]:</span><br><span class="line">                <span class="keyword">for</span> y1 <span class="keyword">in</span> range(y0+<span class="number">1</span>,row):</span><br><span class="line">                    <span class="keyword">for</span> x1 <span class="keyword">in</span> corner_row[y1]:</span><br><span class="line">                        <span class="keyword">if</span> x1&gt;x0 <span class="keyword">and</span> grid[y0][x1]==<span class="number">1</span> <span class="keyword">and</span> grid[y1][x0]==<span class="number">1</span>:</span><br><span class="line">                            count=count+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Warning</h4>
<p>注意上面那个提交也毫不意外地是个TLE，是反面示例，请不要模仿。</p>
<ol>
<li>辅助空间（即“邻接列表”）为$o(\max{(rc,re)})$，其中$e$为整个矩阵中<code>1</code>的个数</li>
<li>在“寻找矩阵的对角线”过程中，时间复杂度为$o(e^2)$</li>
<li>所以说我一个最大$200 \times 200$的矩阵有6000个1，怎么把我算到稀疏矩阵去了？我的数学老师听了想打死我吧，<a href="#sparse">上面</a>犯了非常严重的错误，请不要被我想当然的分析误导。因此可以说$e$和$rc$是近似数量级的规模了，我这一拍大腿的解法相比原来的暴力搜索并没有在复杂度上有什么优化，反而拖慢了。</li>
<li>我一时也想不到用什么好的数据结构去表示“右下”的元素，所以上面的遍历范围只规定了&quot;下&quot;，“右”还得靠<code>if</code>语句去判别。</li>
</ol>
</div></p>
<p>接下来我想对于确定的两行<code>y0</code>和<code>y1</code>，找到它们在有几个列<code>x</code>上的元素都为<code>1</code>，这些<code>(y0,x)</code>和<code>(y1,x)</code>即可两两组成一个矩形
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/3.png" alt="">
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCornerRectangles</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        row=len(grid)</span><br><span class="line">        col=len(grid[<span class="number">0</span>])</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> y0 <span class="keyword">in</span> range(row<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> y1 <span class="keyword">in</span> range(y0+<span class="number">1</span>,row):</span><br><span class="line">                ones=<span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(col):</span><br><span class="line">                    <span class="keyword">if</span> grid[y0][x]==<span class="number">1</span> <span class="keyword">and</span> grid[y1][x]==<span class="number">1</span>:</span><br><span class="line">                        ones+=<span class="number">1</span></span><br><span class="line">                  count+=ones*(ones<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Warning</h4>
<p>不例外地，上面的提交又是一个TLE，容易看出时间复杂度为$o(r^2 c)$，其实到这里算法的复杂度上也真的没太大的优化余地了。还是那句话，看看就行，不要模仿，这不是什么好代码，只希望后来人别再犯我犯下的错误。</p>
</div>
然后我按照完全一致的思路用C++又写了一遍
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCornerRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=grid.size();</span><br><span class="line">        <span class="keyword">int</span> col=grid[<span class="number">1</span>].size();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ones=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y0=<span class="number">0</span>;y0&lt;row<span class="number">-1</span>;y0++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y1=y0+<span class="number">1</span>;y1&lt;row;y1++)&#123;</span><br><span class="line">                ones=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;col;x++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(grid[y0][x]&amp;&amp;grid[y1][x]) ones++;</span><br><span class="line">                &#125;</span><br><span class="line">                count+=ones*(ones<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结果就被接受了。和其他人交流，发现也有人想到一样的算法，我看了他的Java代码也确实和我的想法基本一致，也成功地提交了。~~我好气啊，我看你就是在针对我Python吧。~~所以说就算有了思路，实现也很重要啊。</p>
<p>LeetCode的编辑推的<a href="https://leetcode.com/articles/number-of-corner-rectangles/" target="_blank" rel="noopener">题解</a>中第一种方法和提示也是用了大同小异的算法。每增加一行<code>y</code>时，如果有<code>x0</code>和<code>x1</code>列同时为<code>1</code>，那么增加多少个矩形？
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/4.png" alt="">
显然取决于<code>y</code>之前有多少行的<code>x0</code>和<code>x1</code>列同时为<code>1</code>，有多少就增加多少。这种想法与之前我给出的解法不谋而合，我们知道$$\sum\limits_{i = 0}^{n - 1} i  = C_n^2 = n\left( {n - 1} \right)/2$$不管是求和还是组合数，最后都是这个表达式。不过这个方法是固定了行，对列进行两层循环，所以时间复杂度是$o(rc^2)$，让我按他的思路写估计我又得TLE，但是这位作者很巧妙地借助了高效的计数器<code>collections.counter()</code>，作为妥协空间复杂度增加到了$o(c^2)$，但这完全是可以接受的。</p>
<p>虽然说对于刷题一般Python运行时性能不怎么占优势，但也可以利用一些高性能模块来弥补，比如这题可以用处理矩阵常用的<code>NumPy</code>的点乘方法计算两行有几个同列为<code>1</code>的元素，比如我的一个成功AC的提交
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countCornerRectangles</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m=np.array(grid)</span><br><span class="line">        counter=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (y0,y1) <span class="keyword">in</span> itertools.combinations(m,<span class="number">2</span>):</span><br><span class="line">            ones=np.dot(y0,y1)</span><br><span class="line">            counter+=ones*(ones<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> int(counter)</span><br></pre></td></tr></table></figure></p>
<p>当然我写得不好，比较啰嗦。写的比较干净利落的方法可以见这位大佬的<a href="https://discuss.leetcode.com/topic/114267/1-liner-numpy" target="_blank" rel="noopener">一行题解</a>，用的是位与运算和等差数列求和，虽然稍慢于我的解法，但更清晰更优雅。</p>
<h2>Contain Virus</h2>
<p>原题地址：https://leetcode.com/contest/weekly-contest-63/problems/contain-virus/</p>
<blockquote>
<p>A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.</p>
</blockquote>
<blockquote>
<p>The world is modeled as a 2-D array of cells, where <code>0</code> represents uninfected cells, and <code>1</code> represents cells contaminated with the virus. A wall (and only one wall) can be installed <strong>between any two 4-directionally</strong> adjacent cells, on the shared boundary.</p>
</blockquote>
<blockquote>
<p>Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.</p>
</blockquote>
<blockquote>
<p>Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[0,1,0,0,0,0,0,1],</span><br><span class="line"> [0,1,0,0,0,0,0,1],</span><br><span class="line"> [0,0,0,0,0,0,0,1],</span><br><span class="line"> [0,0,0,0,0,0,0,0]]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:</span><br><span class="line">There are 2 contaminated regions.</span><br><span class="line">On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:</span><br><span class="line">[[0,1,0,0,0,0,1,1],</span><br><span class="line"> [0,1,0,0,0,0,1,1],</span><br><span class="line"> [0,0,0,0,0,0,1,1],</span><br><span class="line"> [0,0,0,0,0,0,0,1]]</span><br><span class="line">On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[1,1,1],</span><br><span class="line"> [1,0,1],</span><br><span class="line"> [1,1,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Even though there is only one cell saved, there are 4 walls built.</span><br><span class="line">Notice that walls are only built on the shared boundary of two different cells.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[1,1,1,0,0,0,0,0,0],</span><br><span class="line"> [1,0,1,0,1,1,1,1,1],</span><br><span class="line"> [1,1,1,0,0,0,0,0,0]]</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: The region on the left only builds two new walls.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of rows and columns of grid will each be in the range <code>[1, 50]</code>.</li>
<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>
<li>Throughout the described process, there is always a contiguous viral region that will infect strictly more uncontaminated squares in the next round.</li>
</ol>
<p>我不是很喜欢这题，一来这题我读了大半天每个字都认识连起来就不知道想表达什么了，而且这题刚出来的时候还有不少错，比如Example 3的结果当时给的是11而不是13；二来不知道这题意义何在，当你明白了题意会觉得这题确实不同于普通的算法题，考验的主要还是编程的耐心，比如<a href="https://discuss.leetcode.com/topic/114469/does-this-problem-require-the-most-lines-of-codes-on-leetcode" target="_blank" rel="noopener">有人</a>直接去评论区吐槽这题明明没难度还写到心态崩了；三来，我在写解法的时候正一边写一边处理一些因为我个人的错误导致的不愉快的事，所以我不太愿意仔细讨论这题，我也觉得没太大的讨论价值。直接给出我参考<a href="https://discuss.leetcode.com/topic/114353/self-explaining-python-solution" target="_blank" rel="noopener">Self-Explaining Python Solution</a>的想法写出的提交：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containVirus</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(visited,i,j,label)</span>:</span></span><br><span class="line">            queue=[(i,j)]</span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> grid[x][y]&gt;<span class="number">0</span>:</span><br><span class="line">                    grid[x][y]=label</span><br><span class="line">                    <span class="keyword">for</span> dx,dy <span class="keyword">in</span> adj:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= x+dx &lt;row <span class="keyword">and</span> <span class="number">0</span> &lt;= y+dy &lt;col:</span><br><span class="line">                            <span class="keyword">if</span> visited[x+dx][y+dy]==<span class="number">0</span>:</span><br><span class="line">                                visited[x+dx][y+dy]=<span class="number">1</span></span><br><span class="line">                                queue.append((x+dx,y+dy))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">regions</span><span class="params">()</span>:</span></span><br><span class="line">            visited=[[<span class="number">0</span>] * col <span class="keyword">for</span> _ <span class="keyword">in</span> range(row)]</span><br><span class="line">            label=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(col):</span><br><span class="line">                    <span class="keyword">if</span> visited[i][j]==<span class="number">0</span>:</span><br><span class="line">                        visited[i][j]=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> grid[i][j]&gt;<span class="number">0</span>:</span><br><span class="line">                            label+=<span class="number">1</span></span><br><span class="line">                            bfs(visited,i,j,label)</span><br><span class="line">            <span class="keyword">return</span> label</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">infect_range</span><span class="params">()</span>:</span></span><br><span class="line">            counter=collections.Counter()</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(row):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(col):</span><br><span class="line">                    <span class="keyword">if</span> grid[x][y]==<span class="number">0</span>:</span><br><span class="line">                        virus=set([grid[x+dx][y+dy] <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> adj <span class="keyword">if</span> <span class="number">0</span> &lt;= x+dx &lt;row <span class="keyword">and</span> <span class="number">0</span> &lt;= y+dy &lt;col <span class="keyword">and</span> grid[x+dx][y+dy]&gt;<span class="number">0</span>])</span><br><span class="line">                        counter+=collections.Counter(virus)</span><br><span class="line">            <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_walls</span><span class="params">(label)</span>:</span></span><br><span class="line">            walls=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(row):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(col):</span><br><span class="line">                    <span class="keyword">if</span> grid[x][y]==label:</span><br><span class="line">                        grid[x][y]=<span class="number">-1</span></span><br><span class="line">                        walls+=sum([<span class="number">1</span> <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> adj <span class="keyword">if</span> <span class="number">0</span> &lt;= x+dx &lt;row <span class="keyword">and</span> <span class="number">0</span> &lt;= y+dy &lt;col <span class="keyword">and</span> grid[x+dx][y+dy]==<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> walls</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">infect</span><span class="params">()</span>:</span></span><br><span class="line">            grid_new=[[x <span class="keyword">for</span> x <span class="keyword">in</span> line] <span class="keyword">for</span> line <span class="keyword">in</span> grid]</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(row):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(col):</span><br><span class="line">                    <span class="keyword">if</span> grid[x][y]&gt;<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">for</span> dx,dy <span class="keyword">in</span> adj:</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= x+dx &lt;row <span class="keyword">and</span> <span class="number">0</span> &lt;= y+dy &lt;col <span class="keyword">and</span> grid[x+dx][y+dy]==<span class="number">0</span>:</span><br><span class="line">                                grid_new[x+dx][y+dy]=grid[x][y]</span><br><span class="line">            <span class="keyword">return</span> grid_new</span><br><span class="line"></span><br><span class="line">        adj=[(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        row=len(grid)</span><br><span class="line">        col=len(grid[<span class="number">0</span>])</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">if</span> regions()&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            c=infect_range()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            emergency_area=c.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            res+=set_walls(emergency_area)</span><br><span class="line">            grid=infect()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>解题的想法非常直觉：</p>
<ol>
<li>用BFS或DFS找到图中的所有“连通分支”（即病毒区域）并进行原地标记数字</li>
<li>如果有没有活跃的病毒区域直接退出。找到未来污染范围最大的病毒区域，并在边界建墙，把里面的病毒标记为<code>-1</code>表示失活，如果已经没有未污染区域了则直接结束算法</li>
<li>让其他病毒区域继续传播</li>
<li>从步骤1开始重复</li>
</ol>
<p>确实知识性和技巧性的成分不大，有一种大学时期上机课要求做的订票系统排队系统之类的东西的感觉。所以最重要的还是耐心和细心，尤其是注意下时间和空间复杂度，特别是对于列表的操作需要各位小心。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-63/" data-id="cjm54yldv0009fkw3mf0lbxey" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-function-of-function" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/function-of-function/">函数的函数</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/function-of-function/" class="article-date"><time datetime="2017-10-25T07:57:19.464Z" itemprop="datePublished">2017-10-25</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>&lt;!-- toc --&gt;</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true" alt="知らないわ そんな魔法"></p>
<p>&lt;!--more---&gt;</p>
<h2>头等函数 (First-class Function)</h2>
<p>一般来说，程序设计语言（编程语言）会在计算元素的使用上推行一些限制，限制最少的函数拥有最高的特权，被称为一等公民，它们有包括但不限于以下特权&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;：</p>
<ul>
<li>可以以变量命名</li>
<li>可以作为过程（函数）的参数传入</li>
<li>可以作为过程（函数）的结果返回</li>
<li>可以被包含在数据结构中</li>
</ul>
<p>无疑是该语言下的成功元素了。函数式编程语言(<em>functional languages</em>)的重要特征之一是将函数视为头等成功人士，赋予这些特权。函数的名字在此仅仅是一个函数类型的变量，这些函数能和其他变量一样被计算、存储、传递，被称为头等函数。匿名函数也可以作为这样的一等公民，正如匿名用户也可以享受其他用户一样的权利，但当你怀疑这些用户在分享刚编的故事时，又想再次引用他们的经历作为参数时往往很难再找到他们。在函数式编程语言中，我们日常接触到的函数都是头等函数比如</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x)</span><br><span class="line">        (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure></p>
<p>借助这个函数进行定义的
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-sum</span> x y)</span><br><span class="line">        (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y))</span><br></pre></td></tr></table></figure></p>
<p>也是头等函数。</p>
<h2>高阶函数 (Higher-order Function)</h2>
<p>与头等函数相对的一个概念为高阶函数，但这并不能说是对立的（与之对立的函数称为一阶函数）。或许应该说引入头等函数这个名词，是为了引出理解高阶函数的存在。</p>
<p>上面说到函数和其他数值变量在应用时可以做到某种意义上的一视同仁，函数名即函数变量的名字，那么也可以被当成实参变量传入另一个过程。高阶函数至少满足以下一个条件：</p>
<ol>
<li>至少参数中有一个是函数</li>
<li>返回的是一个函数</li>
</ol>
<p>在几乎所有语言中都会定义一些idiom来方便应用，比较有代表性的有<code>map</code>，<code>fold</code>和<code>filter</code>这三个高阶函数，暂时先无视命名冲突问题，为了直观理解这些函数的意义，可以自己这样定义一遍</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">map</span> f xs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">      null</span><br><span class="line">      (<span class="name">cons</span> (<span class="name">f</span> (<span class="name">car</span> xs)) (<span class="name">map</span> f (<span class="name">cdr</span> xs)))))</span><br></pre></td></tr></table></figure></p>
<p><code>map</code>将一个函数<code>f</code>和一个list<code>xs</code>作为参数，<code>xs</code>中的每个元素作为<code>f</code>的参数返回的结果组成一个新的<code>list</code>作为<code>map</code>的返回结果。</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">fold</span> f acc xs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">      acc</span><br><span class="line">      (<span class="name">fold</span> f (<span class="name">f</span> acc (<span class="name">car</span> xs)) (<span class="name">cdr</span> xs))))</span><br></pre></td></tr></table></figure></p>
<p><code>fold</code>将一个函数<code>f</code>，初始值<code>acc</code>，和一个list<code>xs</code>作为参数，取<code>xs</code>中每个值<code>x</code>与当前的<code>acc</code>计算<code>f(acc,x)</code>作为下一个<code>acc</code>依次传递，如多米诺骨牌，与函数名的意义“折叠”不谋而合。</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">filter</span> f xs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">      null</span><br><span class="line">      (<span class="name">if</span> (<span class="name">f</span> (<span class="name">car</span> xs))</span><br><span class="line">          (<span class="name">cons</span> (<span class="name">car</span> xs) (<span class="name">filter</span> f (<span class="name">cdr</span> xs)))</span><br><span class="line">          (<span class="name">filter</span> f (<span class="name">cdr</span> xs)))))</span><br></pre></td></tr></table></figure></p>
<p><code>filter</code>使用函数<code>f</code>对list<code>xs</code>中的每个元素进行筛选，当且仅当返回值为真（<code>#t</code>）时把这个元素放入作为返回结果的新list</p>
<p>这三个高阶函数都是把一个函数作为了自己的参数，但返回的并不一定是一个函数（<code>map</code>和<code>filter</code>返回的必然不是，<code>fold</code>看具体情况）,它们也可以作为头等函数成为其他函数的参数。这些函数的参数<code>f</code>可以用函数的变量名传入，也可以用匿名函数，实际应用时匿名函数的使用情况也非常常见，甚至可以说匿名函数的一个重要作用就是临时地定义一个高阶函数中的过程参数，如计算一个常数<code>c</code>和行向量<code>xs</code>的乘积可表示为</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> c x)) xs)</span><br></pre></td></tr></table></figure></p>
<p>再如在Python中经常问的一个基础问题：如何将<code>dict</code>中的元素按<code>value</code>的大小排序？</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(mydict.iteritems(), key=<span class="keyword">lambda</span> (k,v): v)</span><br></pre></td></tr></table></figure></p>
<h2>Currying</h2>
<p>当我们说一个函数有几个参数的时候我们在说什么？很多语言（如ML）中形如<code>f(arg1,arg2,...,argn)</code>的函数定义，看似使用了好几个参数，实际上这些参数只是作为一个长度为<code>n</code>的<code>list</code>或<code>tuple</code>传入，本质上还是一个单参数的函数。</p>
<p>有时我们并不需要或者来不及等所有参数都准备齐全才能使用函数，这种所有参数塞进一个数据结构的用法让人很恼火。curry正是这样一种方法：把这样的函数转化成只有真正意义上一个参数的函数的链。</p>
<p>如果每个参数<code>arg</code>都有一个类型<code>t</code>，那么在currying操作之前，<code>f(arg1,arg2,...,argn)</code>整个函数的类型为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(t1 * t2 * ... * tn) -&gt; rtype</span><br></pre></td></tr></table></figure></p>
<p>即取<code>(t1 * t2 * ... * tn)</code>类型的值<code>(arg1 * arg2 * ... *argn)</code>作为参数，返回<code>rtype</code>的值作为结果的函数。Currying操作之后的函数我们记为<code>f arg1 arg2 ... argn</code>，这个函数的类型为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 -&gt; (t2 -&gt; (... -&gt;(tn -&gt; rtype)...))</span><br></pre></td></tr></table></figure></p>
<p>此时<code>f</code>仅使用一个<code>t1</code>类型的参数，返回一个<code>t2 -&gt; (... -&gt;(tn -&gt; rtype)...)</code>类型的函数作为结果。当我们仅以一个参数去调用<code>f arg1</code>时，返回一个取<code>t2</code>类型数据为参数返回<code>t3-&gt; (... -&gt;(tn -&gt; rtype)...)</code>类型函数的函数，就像洋葱一样一层层地调用函数才能剥出最后的返回结果，当然<code>f(arg1,arg2,...,argn)</code>和<code>f arg1 arg2 ... argn</code>运算最后得到的结果是一致的。</p>
<p>按照这种思路可以重写<code>map</code>函数为<code>curried-map</code>：
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">curried-map</span> f)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">xs</span>)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">        null</span><br><span class="line">        (<span class="name">cons</span> (<span class="name">f</span> (<span class="name">car</span> xs)) ((<span class="name">curried-map</span> f) (<span class="name">cdr</span> xs)) ))))</span><br></pre></td></tr></table></figure></p>
<p>当我们要写一个对<code>list</code>中每个元素的值进行乘2操作的函数时，可以直接写作
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> double-list (<span class="name">curried-map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x <span class="number">2</span>))))</span><br></pre></td></tr></table></figure></p>
<p>这个<code>(curried-map (lambda (x) (* x 2)))</code>就是这样一个函数，是<code>curried-map</code>的一个部分应用（<em>partial application</em>）实例，currying使得这样的用法更为便捷。当然，我不是说部分应用必须依靠curry函数，完全没有那样的意思，实际上一定要用原来的<code>map</code>函数也可以达到目的
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">double-list2</span> xs)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x <span class="number">2</span>)) xs))</span><br></pre></td></tr></table></figure></p>
<p>差不多就是绑定了参数<code>y</code>的值然后定义<code>g(x)=f(x,y)</code>的意思，<code>map</code>只有两个参数，所以固定其中一个，然后把其他形参照着“抄写”一遍在定义里走个过场也不费事，但参数一多的时候不用curry函数就显得麻烦了。</p>
<h2>*部分应用 (Partial Application)</h2>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt; Optional</h4>
<p>这部分并非必须内容，我只是以自己的理解给出一个概念的实例实现，直接跳过不影响全文的内容脉络，仅供感兴趣的读者加深印象和交流改进。</p>
</div></p>
<p>部分应用的作用在于，将抽象的模型的<strong>一部分</strong>具体转化成为一个常见，实用的<strong>不那么</strong>抽象的模型。众所周知，Maclaurin公式（省略余项）
$$f\left( x \right) \approx f\left( 0 \right) + \frac{f'\left( 0 \right)}{1!}x + \frac{f^{\left(2 \right)}\left( 0 \right)}{2!}{x^2} +  \ldots  + \frac{f^{\left( n \right)}\left( 0 \right)}{n!}{x^n}$$
是Taylor公式（省略余项）$$f\left( x \right) \approx f\left( {x_0} \right) + \frac{f'\left( {x_0} \right)}{1!}\left( x - {x_0} \right) + \frac{f^{\left( 2 \right)}\left( x_0 \right)}{2!}{\left(x - x_0\right)^2} +  \ldots  + \frac{f^{\left( n \right)}\left( x_0 \right)}{n!}{\left( x - x_0\right)^n}$$在$x_0=0$处的特例，换言之也是绑定了参数<code>x0</code>的一个部分应用，两个公式给出的也都是包含参数<code>x</code>的函数作为返回结果，即一个<code>f</code>的近似函数。对于毫无编程基础或者像我这样编程基础薄弱的人来说，理解这个“部分应用”不需要借助任何代码，借助这个例子可以很好地感受“部分应用”概念本身的含义。</p>
<p>但是为了完整性，我还是试图从最基础的部分开始一步步给出它们的实现。</p>
<p>首先利用导数的定义$$f'\left( x \right) = \mathop {\lim }\limits_{dx \to 0} \frac{f\left( x + dx \right) - f\left( x \right)}{dx}$$写出导函数的定义</p>
<p>&lt;a name=&quot;deriv&quot;&gt;&lt;/a&gt;
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> dx <span class="number">0.000001</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">deriv</span> f)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">/</span> (<span class="name">-</span> (<span class="name">f</span> (<span class="name">+</span> x dx)) (<span class="name">f</span> x)) dx)))</span><br></pre></td></tr></table></figure></p>
<p><code>deriv</code>函数是部分curry化的，调用<code>(deriv f)</code>返回的是<code>f</code>的导函数，如果你想求<code>f</code>在某点<code>(x0,f(x0))</code>的导数<code>f'(x0)</code>，还需要再调用一次这个结果，即<code>((deriv f) x0)</code>，当然因为我只是取了一个数值上接近无穷小的<code>dx</code>常量，所以最后的结果也只会是一个近似值，但这也够用了。</p>
<p>接下来实现Taylor公式中各项的表达。一般来说，Taylor公式中的求和项数越多结，这个近似的结果越接近函数的真实值，当$n \to \infty$时可认为等号成立。但这个真正的“无穷”是编写程序的人无法实现的，如果要写出无限长的Taylor数列$\frac{f^{\left( n \right)}\left( x_0 \right)}{n!}{\left(x - x_0\right)^n}$，那么可以利用惰性计算（<em>lazy evaluation</em>）的特性去模拟一个无限的“流（<em>stream</em>）”</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">taylor-stream</span> f)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x0</span>)</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">x</span>)</span><br><span class="line">      (<span class="name">letrec</span> ([taylor-series (<span class="name">lambda</span> (<span class="name">n</span> cof func base)</span><br><span class="line">                                (<span class="name">cons</span> ( <span class="name">/</span> (<span class="name">*</span> (<span class="name">func</span> x0) base) cof)</span><br><span class="line">                                      (<span class="name">lambda</span> () (<span class="name">taylor-series</span> (<span class="name">+</span> n <span class="number">1</span>)</span><br><span class="line">                                                                (<span class="name">*</span> cof (<span class="name">+</span> n <span class="number">1</span>))</span><br><span class="line">                                                                (<span class="name">deriv</span> func)</span><br><span class="line">                                                                (<span class="name">*</span> base (<span class="name">-</span> x x0))))))])</span><br><span class="line">        (<span class="name">lambda</span> () (<span class="name">taylor-series</span> <span class="number">0</span> <span class="number">1</span> f <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure></p>
<p><code>(taylor-stream f)</code>不仅是一个无限的流，也是关于<code>x</code>和<code>x0</code>的curry函数，仅当<code>x</code>和<code>x0</code>参数都传入时才进行真正的函数值计算，仅调用<code>(taylor-stream f)</code>时得到的只是如上罗列的公式。</p>
<p>然后然后针对这个数列（流）写一个前<code>n</code>项求和函数，没什么特别讲究的只需要随便写写就行
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">stream-sum</span> n s)</span><br><span class="line">   (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (<span class="name">let</span> ([p (<span class="name">s</span>)])</span><br><span class="line">            (<span class="name">+</span> (<span class="name">car</span> p)</span><br><span class="line">               (<span class="name">stream-sum</span> (<span class="name">-</span> n <span class="number">1</span>) (<span class="name">cdr</span> p))))))</span><br></pre></td></tr></table></figure></p>
<p>那么根据Taylor展开公式（取2阶导数），函数<code>f(x)</code>在<code>x0</code>点的近似多项式函数为
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> order <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">taylor-approx</span> x)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x0</span>)</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">f</span>)</span><br><span class="line">      (<span class="name">stream-sum</span> (<span class="name">+</span> order <span class="number">1</span>)</span><br><span class="line">                  (((<span class="name">taylor-stream</span> f) x0) x)))))</span><br></pre></td></tr></table></figure></p>
<p>接下来作为固定了取值点<code>x0</code>为0的特例Maclaurin公式可以按照上文的部分应用写法写为
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">maclaurin-approx</span> x) ((<span class="name">taylor-approx</span> x) <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p>
<p>然后就可以同时地，方便地去用这两个近似公式求多项式近似函数的值了。比如$2^x$在$x=0$时的Taylor近似函数在$x=2$处的值
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">maclaurin-approx</span> <span class="number">2</span>) (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">expt</span> <span class="number">2</span> x))) <span class="comment">;;3.347303891703234</span></span><br></pre></td></tr></table></figure></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Warning</h4>
<p>注意这里的求导方法也是数值近似的，因此对于低阶函数，高阶近似，所求近似的自变量与取值点相距较远时，会产生巨大的误差。如果想提高微分的精确度，可以考虑用类似<code>eval</code>函数或解释器的方法递归地对表达式结果编写求导函数（参阅<a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/node39.html" target="_blank" rel="noopener">SICP: 2.3.2 Example: Symbolic Differentiation P197-199</a>）</p>
</div></p>
<h2>词法作用域 (Lexical Scope)</h2>
<p>众所周知，为变量命名是件非常苦手的事，一般我们不提倡在一个程序内多次使用一个变量名，但这是个正确的废话，现实中总是无法避免的。而重复使用同一个变量名带来的问题就是不知道这个变量名到底和什么绑定了，我调用这个变量（包括函数）的时候，这个变量绑定的是哪个表达式，这个表达式中出现的变量绑定的又是哪个？好在程序设计语言的语法中对作用域（<em>scope</em>）都作出了相应的规定。</p>
<p>词法作用域是现在大多数语言采用的作用域类型，或者被称为静态作用域（<em>static scope</em>） 也是相对容易实现的类型。在这种规定下，函数体中的变量根据函数被定义的环境进行计算，而不是放在被调用的环境中计算。</p>
<p>有的教材在解释这个概念的时候会用到形如这样的例子&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</p>
<p>&lt;a name=&quot;ex1&quot;&gt;&lt;/a&gt;
<figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">fun</span> f y = x + y</span><br><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> z = f (x+y)</span><br></pre></td></tr></table></figure></p>
<p>这里<code>z</code>的值为6。<code>f</code>的函数体在被计算时，在<code>f</code>被定义的环境中查找变量<code>x</code>的绑定，所以不管后面<code>x</code>怎样被shadow了，<code>f</code>执行的都是<code>+1</code>操作，不会出现<code>z==7</code>的结果。函数的参数<code>x+y</code>在被调用的新环境计算后传入函数体，但函数体却在被定义的旧环境中进行计算。</p>
<p>如果想要这个使<code>f</code>中的<code>x</code>更新为2，那么语言的作用域法则需要更改为动态作用域（<em>dynamic scope</em>）。在这种语法下，函数被调用时，函数体的求值过程中可以访问到现在的环境中的变量，而在词法作用域中，函数体的求值除了传入的参数之外，调用时的环境是被完全隔离开的，也就是不透明的。</p>
<p>上面是一个关于ML的例子，用同样的思路去写一个Python的例子
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">x=<span class="number">2</span></span><br><span class="line">y=<span class="number">3</span></span><br><span class="line">z=f(x+y)</span><br></pre></td></tr></table></figure></p>
<p><code>z</code>的值为7，但这并不意味着Python是使用动态作用域的语言。Python是静态作用域的，但缺少类似于<code>val</code>关键字引导的类型声明。ML的<code>val x=2</code>所做的是重新声明了一个绑定为2的变量<code>x</code>shadow掉了原来的<code>val x=1</code>，实质上这是两个变量，虽然名字都是<code>x</code>，但作用域不同。而Python中<code>x=2</code>则是对已有的变量<code>x</code>的值的修改，即引用（<em>reference</em>）的更新。由于函数体<code>f</code>中并没有本地变量<code>x</code>的声明，遵循LEGB原则（<em>Local, Enclosing, Global, Built-in</em>），函数的定义环境中<code>x</code>即为全局变量<code>x</code>，函数体计算时使用的是<code>x</code>的引用。Python也支持前向引用（<em>forward reference</em>），换言之即使这个<code>x</code>在函数被定义时还没有被声明或者更新，函数值计算时<code>x</code>也是使用该全局变量最新的值。虽然整个过程看上去别扭，但始终遵循函数被放到了定义的环境中去计算的原则，只是在这个定义的环境中函数里面出现的变量被定义为一个可变的引用。<s>Python不是函数式编程语言，但有部分函数式编程语言的特性，然而函数式编程认为使用可修改的变量（引用）是很不优雅的坏文明。</s></p>
<p>这样写就不会出现上面的困扰了
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(y)</span>:</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f(x+y)</span><br><span class="line"></span><br><span class="line">z=f(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里<code>x=2</code>是在函数<code>g</code>中声明了一个值为2的局部变量<code>x</code>去shadow掉了值为1的全局变量，然而根据词法作用域的原则，在<code>g</code>中调用的<code>f</code>并不会用这个新环境被求值，还是使用被定义时<code>x</code>为全局变量的旧环境，所以<code>z</code>的值为6。</p>
<p>Racket不允许top-level的变量重复定义，所以在top-level上重复使用一个变量名造成的混乱可以避免。但是，在函数（过程）中被调用的函数的定义里如果出现了和外界同名的变量，还是遵循词法作用域的原则，外面的过程中的局部变量对调用的函数不可见。这可以体现在用<code>let</code>引导的局部变量定义，比如这个与<a href="#ex1">ML表示的例子</a>完全相同的逻辑，毫不意外地，<code>z</code>的值为6
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">f</span> y)</span><br><span class="line">  (<span class="name">+</span> x y))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> z</span><br><span class="line">  (<span class="name">let</span> ([x <span class="number">2</span>]</span><br><span class="line">        [y <span class="number">3</span>])</span><br><span class="line">    (<span class="name">f</span> (<span class="name">+</span> x y)))) <span class="comment">;;z=6</span></span><br></pre></td></tr></table></figure></p>
<p>也可以体现在一个函数定义时使用的形参名字，与该函数代码内调用的另一个函数中的变量名冲突时的情况：
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">disp-deriv</span> f x1 x2 dx)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> x1 x2)</span><br><span class="line">      null</span><br><span class="line">      (<span class="name">cons</span> ((<span class="name">deriv</span> f) x1) (<span class="name">disp-deriv</span> f (<span class="name">+</span> x1 dx) x2 dx))))</span><br></pre></td></tr></table></figure></p>
<p><code>disp-deriv</code>是一个求<code>[x1,x2]</code>区间内按<code>dx</code>为步长取点的<code>f(x)</code>的导数列表的函数，我们知道之前在<a href="#deriv">deriv</a>函数的定义里已经有了其中常数<code>dx</code>的指定，这里再用<code>dx</code>来当代表步长的形参，这种做法确实挺不好的，但人难免会有一拍大腿想不出什么好名字理性蒸发瞎写的时候。词法作用域保证了在调用<code>deriv</code>给取值点挨个求导的时候，<code>deriv</code>内部的极小增量<code>dx</code>的取值不会受到外部步长<code>dx</code>的干扰，所以当你调用
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">disp-deriv</span> square <span class="number">0</span> <span class="number">4</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>时，可以正确得到这5个整数点上的导数值。</p>
<h3>环境（<em>Environmnet</em>）与闭包 （<em>Closure</em>）</h3>
<p>所谓环境，通俗来说就是记录变量名绑定的字典。作用域法则已经在大方向上规定了应该怎么去分类这些字典，在哪个情形下我们应该去翻哪本字典，新“注册”了一个绑定又应该往哪本字典里去添加“词条”。至于具体在去一个指定的字典查找一个变量的定义，可以用这样的写法&lt;a name=&quot;envlookup&quot;&gt;&lt;/a&gt;
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">envlookup</span> env str)</span><br><span class="line">  (<span class="name">cond</span> [(<span class="name">null</span>? env) (<span class="name">error</span> <span class="string">"unbound variable during evaluation"</span> str)]</span><br><span class="line">        [(<span class="name">equal</span>? (<span class="name">car</span> (<span class="name">car</span> env)) str) (<span class="name">cdr</span> (<span class="name">car</span> env))]</span><br><span class="line">        [#t (<span class="name">envlookup</span> (<span class="name">cdr</span> env) str)]))</span><br></pre></td></tr></table></figure></p>
<p>环境<code>env</code>是一个由<code>(str,exp)</code>对表示（变量名，表达式）组成的列表，<code>str</code>是一个字符串类型的变量名字，<code>exp</code>则是该变量名所绑定的，在该语言中的一个表达式。</p>
<p>当表达式需要在指定环境<code>env</code>下进行“解释”（求值）的时候，把<code>env</code>作为求值过程的一个参数传进去就可以了，再在过程内部调用<code>envlookup</code>函数。</p>
<p>既然词法作用域严格地强调了定义与调用两种环境的隔离，那就需要用一种方法去把函数定义的环境和函数本身进行“打包封装”作为一个整体传入其他过程或函数，再等到调用时就地“拆包”进行求值。闭包就是为此而诞生的技术。如果函数体中有一些变量本身并没有在函数体中被定义，需要依赖函数被定义的环境确定这些变量的具体指代，那么这些变量的定义环境就需要连同函数代码本身一起被放进这样一个被称为闭包的数据结构
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> closure (<span class="name">env</span> fun) #<span class="symbol">:transparent</span>)</span><br></pre></td></tr></table></figure></p>
<p>闭包就是函数被“解释”的结果，它就是一个可以被用来传递的值。在这里闭包的实现方法实际是一个偷懒的trick，直接把函数定义时的环境和函数一起放进了<code>closure</code></p>
<h3>*自由变量 （<em>Free variable</em>）</h3>
<p>上面简单的“打包”将函数定义存在的所有绑定，无论函数体求值时是否用到，一并封装到了<code>closure</code>，当然仅根据词法作用域的定义也不能说这种做法存在什么错误，也完全可以通过<a href="#call">下文中实现的方法</a>正常地运行这个机制。但是把不必要的绑定放到<code>closure</code>里确实也会造成冗余，实践中的闭包实现也基本不会容忍这种低效的方法，一个可行的改进的思路就是仅在<code>closure</code>中引用与函数“相关”的变量名的绑定，这些变量就是所谓的自由变量。</p>
<p>和数学中所使用的“自由变量”和“约束变量”含义相似，自由变量是指仅在函数体代码中直接占位使用，却没有在函数体中给出定义（约束）的变量，它的定义在函数体外，不同的作用域法则争议的是对这些自由变量的“解释权”。在<a href="#ex1">上面的例子</a>中<code>x</code>就是函数<code>f</code>的自由变量，在词法作用域下需要做的就是在闭包的环境中把<code>x</code>与整数值<code>1</code>对应，另外还有一些判断函数中那些变量是自由变量的例子&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lambda</span> () (<span class="name">+</span> x y z)) <span class="comment">; &#123;x, y, z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> x y z)) <span class="comment">; &#123;y, z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">if</span> x y z)) <span class="comment">; &#123;y, z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">let</span> ([y <span class="number">0</span>]) (<span class="name">+</span> x y z))) <span class="comment">; &#123;z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span> y z) (<span class="name">+</span> x y z)) <span class="comment">; &#123;&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> y (<span class="name">let</span> ([y z]) (<span class="name">+</span> y y)))) <span class="comment">; &#123;y, z&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>实际上会一点编程的人都能敏锐地凭借直感找出自由变量，仅凭自然语言描述怎么去找一堆代码里面有几个自由变量也有些困难，如果有兴趣可以看后文中的<a href="#%E6%9B%B4%E8%BD%BB%E7%9A%84%E7%8E%AF%E5%A2%83">代码实现</a>。</p>
<h2>*简易解释器</h2>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt; Optional</h4>
<p>本部分内容和实践中的解释器（<em>Interpreter</em>）存在巨大的差异，给出实现仅为帮助理解以上概念所写。内容基本直接参考<a href="https://www.coursera.org/learn/programming-languages/home/welcome" target="_blank" rel="noopener">Programming Languages</a>中给出的指导进行实现。</p>
</div>
现在我们要定义一种由如下表达式表示出来的语言，可以命名该语言为MUPL (Make Up Programming Language)
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> var  (<span class="name">string</span>) #<span class="symbol">:transparent</span>)  <span class="comment">;; 变量，例如(var "foo")</span></span><br><span class="line">(<span class="name">struct</span> int  (<span class="name">num</span>)    #<span class="symbol">:transparent</span>)  <span class="comment">;; 常数,  例如(int 17)</span></span><br><span class="line">(<span class="name">struct</span> add  (<span class="name">e1</span> e2)  #<span class="symbol">:transparent</span>)  <span class="comment">;; 加法表达式</span></span><br><span class="line">(<span class="name">struct</span> ifgreater (<span class="name">e1</span> e2 e3 e4)    #<span class="symbol">:transparent</span>) <span class="comment">;; 如果 e1 &gt; e2 则结果为 e3 否则为 e4</span></span><br><span class="line">(<span class="name">struct</span> fun  (<span class="name">nameopt</span> formal body) #<span class="symbol">:transparent</span>) <span class="comment">;; 单参数函数，如果nameopt域即函数名为#f则为匿名函数</span></span><br><span class="line">(<span class="name">struct</span> call (<span class="name">funexp</span> actual)       #<span class="symbol">:transparent</span>) <span class="comment">;; 函数调用</span></span><br><span class="line">(<span class="name">struct</span> mlet (<span class="name">var</span> e body) #<span class="symbol">:transparent</span>) <span class="comment">;;本地绑定 (let var = e in body)</span></span><br><span class="line">(<span class="name">struct</span> apair (<span class="name">e1</span> e2)     #<span class="symbol">:transparent</span>) <span class="comment">;; 定义一个(e1,e2)对</span></span><br><span class="line">(<span class="name">struct</span> fst  (<span class="name">e</span>)    #<span class="symbol">:transparent</span>) <span class="comment">;; 取对的第一个数</span></span><br><span class="line">(<span class="name">struct</span> snd  (<span class="name">e</span>)    #<span class="symbol">:transparent</span>) <span class="comment">;; 取对的第二个数</span></span><br><span class="line">(<span class="name">struct</span> aunit ()    #<span class="symbol">:transparent</span>) <span class="comment">;; unit，list的“休止符”</span></span><br><span class="line">(<span class="name">struct</span> isaunit (<span class="name">e</span>) #<span class="symbol">:transparent</span>) <span class="comment">;; 判断e是不是unit，是则为1否则为0</span></span><br></pre></td></tr></table></figure></p>
<p>我们的最终目的是写一个Racket程序（函数）来解释和MUPL语言给出的表达式，那么要做的就是用Racket模拟MUPL中各表达式的求值过程，对于复合的语义结构，无疑应该使用递归一层层去进行求值。首先列出一个框架：
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">eval-under-env</span> e env)</span><br><span class="line">  (<span class="name">cond</span> [...]</span><br><span class="line">        [...]</span><br><span class="line">        ....</span><br><span class="line">        [#t (<span class="name">error</span> (<span class="name">format</span> <span class="string">"bad (MUPL expression: ~v"</span> e))]))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">eval-exp</span> e)</span><br><span class="line">  (<span class="name">eval-under-env</span> e null))</span><br></pre></td></tr></table></figure></p>
<p>最终实现的结果就是<code>eval-exp</code>函数，用于解释MUPL程序。<code>eval-under-env</code>则是用于不同环境进行递归的辅助函数，可以说是这个解释器的“单元”，<code>cond</code>语句对不同类型的表达式做出了<code>eval</code>方面不同操作的规定，接下来我们要做的只有一步步按照MUPL的语义填充这些<code>[...]</code>从句。</p>
<p>首先，所有的变量都被当成变量本身（包括<code>closure</code>）
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(int? e) e]</span><br><span class="line">[(closure? e) e]</span><br><span class="line">[(aunit? e) e]</span><br></pre></td></tr></table></figure></p>
<p>接下来，遇到某个<code>var &quot;name&quot;</code>形式的变量的时候，利用<a href="#envlookup">envlookup</a>函数找到在当前环境下这个变量名绑定的值
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(var? e)</span><br><span class="line"> (envlookup env (var-string e))]</span><br></pre></td></tr></table></figure></p>
<p>对于加法运算，先对两个操作数（子表达式）进行求值，然后相加得到一个整数
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(add? e)</span><br><span class="line"> (<span class="name">let</span> ([v1 (<span class="name">eval-under-env</span> (<span class="name">add-e1</span> e) env)]</span><br><span class="line">       [v2 (<span class="name">eval-under-env</span> (<span class="name">add-e2</span> e) env)])</span><br><span class="line">   (<span class="name">if</span> (<span class="name">and</span> (<span class="name">int</span>? v1)</span><br><span class="line">            (<span class="name">int</span>? v2))</span><br><span class="line">       (<span class="name">int</span> (<span class="name">+</span> (<span class="name">int-num</span> v1)</span><br><span class="line">               (<span class="name">int-num</span> v2)))</span><br><span class="line">       (error "MUPL addition applied to non-number")))]</span><br></pre></td></tr></table></figure></p>
<p>采用词法作用域规则，把函数与其被定义的环境打包成一个<code>closure</code>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(fun? e) (closure env e)]</span><br></pre></td></tr></table></figure></p>
<p><code>ifgreater</code>的情况和<code>add</code>差不多，但注意<code>e3</code>和<code>e4</code>只能根据条件选一个计算一次
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(ifgreater? e)</span><br><span class="line"> (<span class="name">let</span> ([v1 (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e1</span> e) env)]</span><br><span class="line">       [v2 (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e2</span> e) env)])</span><br><span class="line">   (<span class="name">if</span> (<span class="name">and</span> (<span class="name">int</span>? v1) (<span class="name">int</span>? v2))</span><br><span class="line">       (<span class="name">if</span> (<span class="name">&gt;</span> (<span class="name">int-num</span> v1) (<span class="name">int-num</span> v2))</span><br><span class="line">           (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e3</span> e) env)</span><br><span class="line">           (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e4</span> e) env))</span><br><span class="line">       (error "MUPL ifgreater applied to non-number")))]</span><br></pre></td></tr></table></figure></p>
<p><code>mlet</code>先将表达式<code>e</code>进行求值并与变量名<code>var</code>绑定，再把这个绑定添加到现在的环境，在这个环境中去<code>body</code>进行求值
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(mlet? e) (let ([v (eval-under-env (mlet-e e) env)])</span><br><span class="line">           (<span class="name">eval-under-env</span> (<span class="name">mlet-body</span> e)</span><br><span class="line">                           (cons (cons (mlet-var e) v) env)))]</span><br></pre></td></tr></table></figure></p>
<p>当遇到函数调用语句<code>call</code>时，按如下步骤进行求值</p>
<ol>
<li>对第一个域<code>funexp</code>在当前环境下进行求值，是否为一个<code>closure</code>，即这个域本来是不是一个<code>func</code>或<code>closure</code>或函数名，如果不是则直接报错跳出</li>
<li>如果对<code>funexp</code>求值产生的<code>closure</code>中，函数部分<code>fun</code>的函数名<code>optname</code>不是<code>#f</code>，则把函数名和在<code>closure</code>的<code>env</code>环境下对函数体的求值结果绑定，并把这个绑定添加到这个<code>closure</code>的<code>env</code>环境</li>
<li>对第二个域<code>actual</code>在当前环境下求值，把这个值与函数的参数名<code>formal</code>绑定，添加到上面的<code>closure</code>的<code>env</code>环境。</li>
<li>在这个被添加了函数名绑定和参数绑定的旧<code>env</code>下对函数体进行求值作为返回结果</li>
</ol>
<p>&lt;a name=&quot;call&quot;&gt;&lt;/a&gt;</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[(call? e) (let ([c (eval-under-env (call-funexp e) env)])</span><br><span class="line">             (<span class="name">if</span> (<span class="name">closure</span>? c)</span><br><span class="line">               (<span class="name">letrec</span> ([parameter (<span class="name">eval-under-env</span> (<span class="name">call-actual</span> e) env)]</span><br><span class="line">                 [f (<span class="name">closure-fun</span> c)]</span><br><span class="line">                 [fbody (<span class="name">fun-body</span> f)]</span><br><span class="line">                 [fname (<span class="name">fun-nameopt</span> f)]</span><br><span class="line">                 [old-env (<span class="name">cons</span> (<span class="name">cons</span> (<span class="name">fun-formal</span> f) parameter) (<span class="name">closure-env</span> c))]</span><br><span class="line">                 [new-env (<span class="name">if</span> fname (<span class="name">cons</span> (<span class="name">cons</span> fname c) old-env) old-env)])</span><br><span class="line">                 (<span class="name">eval-under-env</span> fbody new-env))</span><br><span class="line">               (error "MUPL call applied to non-closure")))]</span><br></pre></td></tr></table></figure></p>
<p>对<code>apair</code>中的两个表达式分别进行求值，再把结果重组成一个<code>apair</code>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(apair? e) (apair (eval-under-env (apair-e1 e) env)</span><br><span class="line">                   (eval-under-env (apair-e2 e) env))]</span><br></pre></td></tr></table></figure></p>
<p>至于<code>fst</code>和<code>snd</code>就更与上面的做法大同小异了，先对子表达式求值再取其中的一个域，按照语义随便写就行
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(fst? e) (let ([subexp (eval-under-env (fst-e e) env)])</span><br><span class="line">            (<span class="name">if</span> (<span class="name">apair</span>? subexp)</span><br><span class="line">                (<span class="name">apair-e1</span> subexp)</span><br><span class="line">                (error "not a pair")))]</span><br><span class="line">[(snd? e) (let ([subexp (eval-under-env (snd-e e) env)])</span><br><span class="line">            (<span class="name">if</span> (<span class="name">apair</span>? subexp)</span><br><span class="line">                (<span class="name">apair-e2</span> subexp)</span><br><span class="line">                (error "not a pair")))]</span><br></pre></td></tr></table></figure></p>
<p><code>isaunit</code>也是如此，先对表达式求值再判断是不是<code>aunit</code>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(isaunit? e) (let ([subexp (eval-under-env (isaunit-e e) env)])</span><br><span class="line">                (if (aunit? subexp) (int 1) (int 0)))]</span><br></pre></td></tr></table></figure></p>
<p>当然我们还可以为了使用方便再去“创造”一个<code>(ifaunit e1 e2 e3)</code>语句，也可以说是这个语言的idiom，也可以把它当成一个使用前预处理的“宏（<em>macro</em>）”，当我们用我们写的“解释器”即<code>eval-exp</code>函数去求这个语句的值时，如果e1是<code>aunit</code>则对<code>e2</code>求值作为结果，否则对<code>e3</code>求值
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">ifaunit</span> e1 e2 e3)</span><br><span class="line">  (<span class="name">ifgreater</span> (<span class="name">isaunit</span> e1) (<span class="name">int</span> <span class="number">0</span>) e2 e3))</span><br></pre></td></tr></table></figure></p>
<p>接下来用MUPL语言写一个<code>map</code>函数
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> mupl-map</span><br><span class="line">  (<span class="name">fun</span> #f <span class="string">"func"</span></span><br><span class="line">       (<span class="name">fun</span> <span class="string">"loop"</span> <span class="string">"mlst"</span></span><br><span class="line">            (<span class="name">ifaunit</span> (<span class="name">var</span> <span class="string">"mlst"</span>)</span><br><span class="line">                     (<span class="name">aunit</span>)</span><br><span class="line">                     (<span class="name">apair</span> (<span class="name">call</span> (<span class="name">var</span> <span class="string">"func"</span>) (<span class="name">fst</span> (<span class="name">var</span> <span class="string">"mlst"</span>)))</span><br><span class="line">                            (<span class="name">call</span> (<span class="name">var</span> <span class="string">"loop"</span>) (<span class="name">snd</span> (<span class="name">var</span> <span class="string">"mlst"</span>))))))))</span><br></pre></td></tr></table></figure></p>
<p>以及它的部分应用，对MUPL列表中所有整数元素进行自增操作的函数<code>mupl-mapAddOne</code>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> mupl-mapAddOne</span><br><span class="line">  (<span class="name">mlet</span> <span class="string">"map"</span> mupl-map</span><br><span class="line">      (<span class="name">call</span> (<span class="name">var</span> <span class="string">"map"</span>) (<span class="name">fun</span> #f <span class="string">"j"</span> (<span class="name">add</span> (<span class="name">int</span> <span class="number">1</span>) (<span class="name">var</span> <span class="string">"j"</span>))))))</span><br></pre></td></tr></table></figure></p>
<p>当我们用<code>eval-exp</code>对<code>mupl-mapAddOne</code>的如下调用实例求值时可以得到预期的结果
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">eval-exp</span> (<span class="name">call</span> mupl-mapAddOne</span><br><span class="line">          (<span class="name">apair</span> (<span class="name">int</span> <span class="number">3</span>) (<span class="name">apair</span> (<span class="name">int</span> <span class="number">4</span>) (<span class="name">apair</span> (<span class="name">int</span> <span class="number">9</span>) (<span class="name">aunit</span>))))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; (apair (int 4) (apair (int 5) (apair (int 10) (aunit))))</span></span><br></pre></td></tr></table></figure></p>
<h3>更轻的环境</h3>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt; Optional</h4>
<p>本部分直接使用<a href="https://www.coursera.org/learn/programming-languages/home/welcome" target="_blank" rel="noopener">Programming Languages</a>中给出的样例代码。</p>
</div></p>
<p>基于<a href="#%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F-%EF%BC%88Free-variable%EF%BC%89">自由变量</a>部分所提的优化思路，把函数的结构<code>(struct fun (nameopt formal body))</code>重写为
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> fun-challenge (<span class="name">nameopt</span> formal body freevars) #<span class="symbol">:transparent</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>freevars</code>域用于存储函数用到的自由变量名，是一个字符串类型的list</p>
<p>接下来需要定义一个函数<code>compute-free-vars</code>去找到原函数<code>fun</code>的所有自由变量，直接得到新函数<code>fun-challenge</code>的<code>freevars</code>域，在此之前可以先定义<code>compute-free-vars</code>用到的返回类型为
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> res (<span class="name">e</span> fvs))</span><br></pre></td></tr></table></figure></p>
<p><code>e</code>域为MUPL表达式，<code>fvs</code>域即freevars列表的一种形式，这里用的是<code>set</code>，避免同一个自由变量多次被算到里面。接下来和<code>eval</code>的思路相似，也是使用递归一层层去找函数中每个结构含有哪些自由变量&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">compute-free-vars</span> e)</span><br><span class="line">  (<span class="name">struct</span> res (<span class="name">e</span> fvs)) <span class="comment">; result type of f (could also use a pair)</span></span><br><span class="line">    (<span class="name">define</span> (<span class="name">f</span> e)</span><br><span class="line">      (<span class="name">cond</span> [(<span class="name">var</span>? e) (<span class="name">res</span> e (<span class="name">set</span> (<span class="name">var-string</span> e)))]</span><br><span class="line">            [...]))</span><br><span class="line">    (<span class="name">res-e</span> (<span class="name">f</span> e)))</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>f</code>就是用于递归的辅助函数，<code>res</code>的<code>e</code>存储着表达式本身，当然在后文我们可以看到，除了<code>fun</code>的情况这个<code>e</code>域会成为一个新的携带着<code>freevars</code>结果的<code>fun-challenge</code>变量，其余情况输出<code>res-e</code>都与输入<code>e</code>一致。实际上真正涉及到自由变量集合的增删的操作只会在<code>var</code>，<code>fun</code>，<code>mlet</code>语句中出现，其他语句只是把子表达式中的自由变量集合进行合并。<code>var</code>的情况已经给出了，只需要构造一个仅包含其变量名的自由向量集合即可，接下来我们又要按着这样的想法去填充这些<code>[...]</code>了：</p>
<p>先看数值类型的数据结构<code>int</code>和<code>aunit</code>，它们不可能包含任何自由变量，直接返回空集
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(int? e) (res e (set))]</span><br><span class="line">[(aunit? e) (res e (set))]</span><br></pre></td></tr></table></figure></p>
<p><code>add</code>和<code>ifgreater</code>语句本身不创造自由变量，对其所有的操作数（子表达式）逐个寻找出现过的自由变量，然后返回它们的并集
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[(add? e) (let ([r1 (f (add-e1 e))]</span><br><span class="line">                [r2 (f (add-e2 e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">add</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                 (set-union (res-fvs r1) (res-fvs r2))))]</span><br><span class="line">[(ifgreater? e) (let ([r1 (f (ifgreater-e1 e))]</span><br><span class="line">                      [r2 (f (ifgreater-e2 e))]</span><br><span class="line">                      [r3 (f (ifgreater-e3 e))]</span><br><span class="line">                      [r4 (f (ifgreater-e4 e))])</span><br><span class="line">                  (<span class="name">res</span> (<span class="name">ifgreater</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2) (<span class="name">res-e</span> r3)  (<span class="name">res-e</span> r4))</span><br><span class="line">                       (set-union (res-fvs r1) (res-fvs r2) (res-fvs r3) (res-fvs r4))))]</span><br></pre></td></tr></table></figure></p>
<p>举一反三，接下来要处理的情况中，<code>fun</code>和<code>mlet</code>以外的语句都是与上面相似的情况，直接写就行
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[(call? e) (let ([r1 (f (call-funexp e))]</span><br><span class="line">                 [r2 (f (call-actual e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">call</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                 (set-union (res-fvs r1) (res-fvs r2))))]</span><br><span class="line">[(apair? e) (let ([r1 (f (apair-e1 e))]</span><br><span class="line">                  [r2 (f (apair-e2 e))])</span><br><span class="line">              (<span class="name">res</span> (<span class="name">apair</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                 (set-union (res-fvs r1) (res-fvs r2))))]</span><br><span class="line">[(fst? e) (let ([r (f (fst-e e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">fst</span> (<span class="name">res-e</span> r))</span><br><span class="line">                 (res-fvs r)))]</span><br><span class="line">[(snd? e) (let ([r (f (snd-e e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">snd</span> (<span class="name">res-e</span> r))</span><br><span class="line">                 (res-fvs r)))]</span><br><span class="line">[(isaunit? e) (let ([r (f (isaunit-e e))])</span><br><span class="line">                (<span class="name">res</span> (<span class="name">isaunit</span> (<span class="name">res-e</span> r))</span><br><span class="line">                     (res-fvs r)))]</span><br></pre></td></tr></table></figure></p>
<p>在考虑<code>fun</code>的情况时，需要注意的是函数的形参虽然在函数体中出现过，但它并不是一个自由变量，所以要从函数体的自由变量集合中去除这个变量；另外，当函数还具有函数名时，如果这个函数名又在函数体中出现了，也就是发生了递归，显然这个函数本身并不是自由变量，那么函数名也需要从自由变量列表<code>fvs</code>中去除。</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[(fun? e) (let* ([r (f (fun-body e))]</span><br><span class="line">                 [fvs (set-remove (res-fvs r) (fun-formal e))]</span><br><span class="line">                 [fvs (if (fun-nameopt e)</span><br><span class="line">                          (<span class="name">set-remove</span> fvs (<span class="name">fun-nameopt</span> e))</span><br><span class="line">                          fvs)])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">fun-challenge</span> (<span class="name">fun-nameopt</span> e) (<span class="name">fun-formal</span> e)</span><br><span class="line">                (<span class="name">res-e</span> r) fvs)</span><br></pre></td></tr></table></figure></p>
<p><code>mlet</code>的处理稍简单一些，只需把<code>var</code>这个局部变量名从<code>body</code>的自由变量列表中去除，再合并<code>e</code>的自由变量列表</p>
<p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(mlet? e) (let* ([r1 (f (mlet-e e))]</span><br><span class="line">                  [r2 (f (mlet-body e))])</span><br><span class="line">             (<span class="name">res</span> (<span class="name">mlet</span> (<span class="name">mlet-var</span> e) (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                  (set-union (res-fvs r1) (set-remove (res-fvs r2) (mlet-var e)))))]</span><br></pre></td></tr></table></figure></p>
<p>完成<code>compute-free-vars</code>函数后，可以重写<code>eval-under-env</code>为<code>eval-under-env-c</code>，只需要添加<code>fun-challenge</code>的情况，其余部分与原函数一致</p>
<p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">eval-under-env-c</span> e env)</span><br><span class="line">  (<span class="name">cond</span></span><br><span class="line">        [(<span class="name">fun-challenge</span>? e)</span><br><span class="line">         (<span class="name">closure</span> (<span class="name">set-map</span> (<span class="name">fun-challenge-freevars</span> e)</span><br><span class="line">                           (<span class="name">lambda</span> (<span class="name">s</span>) (<span class="name">cons</span> s (<span class="name">envlookup</span> env s))))</span><br><span class="line">                  e)]</span><br><span class="line">        <span class="comment">; call case uses fun-challenge as appropriate</span></span><br><span class="line">        <span class="comment">; all other cases the same</span></span><br><span class="line">        [...] ))</span><br></pre></td></tr></table></figure></p>
<p>对于fun-challenge的闭包封装指令为找到<code>freevars</code>中所有变量名在<code>env</code>的对应（绑定），这里的<code>set-map</code>是作用于<code>set</code>类型的高阶函数<code>map</code>。再把这些绑定关系构成的列表作为<code>closure</code>中的环境。最后改写这个解释函数的函数：
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">eval-exp-c</span> e)</span><br><span class="line">  (<span class="name">eval-under-env-c</span> (<span class="name">compute-free-vars</span> e) null))</span><br></pre></td></tr></table></figure></p>
<p>在更轻的环境负担下发挥和原来的解释器一样的作用。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. &lt;a href=&quot;https://mitpress.mit.edu/sicp/&quot;&gt;&lt;em&gt;Structure and interpretation of computer programs.&lt;/em&gt;&lt;/a&gt; Justin Kelly, 1996.&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;样例代码来源于University of Washington在Coursera的公开课&lt;a href=&quot;https://www.coursera.org/learn/programming-languages/home/welcome&quot;&gt;Programming Languages&lt;/a&gt;讲义&lt;a href=&quot;https://d3c33hcgiwev3.cloudfront.net/<em>34a95c9c790777fb7c103349682d7691_section3sum.pdf?Expires=1511049600&amp;Signature=FrFVyG0glBPM-Mh8uuAgdgOmHnaV7Aq7Hk5SEj3pejrdeFVZck71OtEzx3YzOSz~CUTOoze5Ffpp0Z6djKbLXQ-00Vi4Lxu5U3hrVxZ8Z4oBNxwpKQSn37FostE8px9bIrWS8QAFKOYSWIHYPosQBTm3TXJFurZTwZSriU08sNQ</em>&amp;Key-Pair-Id=APKAJLTNE6QMUY6HBC5A&quot;&gt;section3sum.pdf&lt;/a&gt;和&lt;a href=&quot;https://d3c33hcgiwev3.cloudfront.net/<em>36330b45ef211f77a0547a38665a954f_114_closures_efficient.pdf?Expires=1511481600&amp;Signature=bY5~armSTpcFkwLAk3CfjMctTIEo0y7jvc1HCeZAw53FdCYk8xHbnG6IxDyt3~JOjYnEU~cExRDtN7cBO05SAmUWLI1puj2XcS5pJqh4aJE00f0fUAs2~fi8cP5~Gt3q9Pbjoe~70OtLD4WScNJBHe3h8LKImvUCbW9FHZwr6gs</em>&amp;Key-Pair-Id=APKAJLTNE6QMUY6HBC5A&quot;&gt;slides&lt;/a&gt;等&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;这里对应的源代码第六行是&lt;code&gt;(res-fvs (f e)))&lt;/code&gt;，我认为这是一个typo，根据逻辑应该是&lt;code&gt;(res-e (f e)))&lt;/code&gt;，我已经向该材料的制作者反映过这个问题，且也有其他人认为这里有问题，正在等候回复。&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/function-of-function/" data-id="cjm54ylo20032fkw3n30l3quo" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-Deutsche-101-1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/Deutsche101/Deutsche-101-1/">失败人士的专属语言——德语</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/Deutsche101/Deutsche-101-1/" class="article-date"><time datetime="2017-08-13T16:00:00.000Z" itemprop="datePublished">2017-08-14</time></a>
</div>

    <div class="article-author">Alraemon</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Deutsche101/">Deutsche101</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2>前言</h2>
<blockquote>
<p>作为一个在同济就读失败人士，我小在不断和周围人对比中发觉了自己失败的终极命运，在这种焦虑促使下最终花了一年时间专门学习德语，成为本科延毕升级人。虽然还是无法避免失败，但是为了让这一年的时间不白白浪费，特给欣宜的扬州计划投稿，开更德语学习笔记。限于我小的语言水平，可能当中存在不少谬误，望大手子们不吝赐教。</p>
</blockquote>
<p>&lt;!-- more --&gt;</p>
<h2>介绍</h2>
<p>德语，作为一门和英语同属日耳曼语族西日耳曼语支的语言，在和大程度上和英语十分相似，但是屈折程度相比英语要高不少。因此会存在一些让我们这种以汉语这种分析语为母语的学习者感到匪夷所思的地方。比如名词的性、数、格这三点，都会在初识这门语言时让人困惑不已。但是我为什么又说德语是失败人士的专属语言呢？在众多小语种学习者中有一段笑话</p>
<blockquote>
<p>韩语学习是笑着进去，笑着出来；
日语学习是笑着进去，哭着出来；
德语学习是哭着进去，笑着出来；
阿语学习是哭着进去，哭着出来。</p>
</blockquote>
<p>原因就是德语这门语言的规范性很高，并不像英语一样存在大量的例外，前期需要花大量的时间学习这些规则，并且这些规则给口语也带来了很大的障碍，但后期的学习任务就主要是口语和词汇了，简单方便。而且德语的单词发音除了像<code>das Computer</code>这样的英语外来词和像<code>der Ingenieur</code>这样的法语外来词会保留其原来的读音之外，其他的单词根本不需要音标就可以知道它的读音，学习难度就更低啦~</p>
<h2>笔记计划</h2>
<p>目前的粗略打算如下:</p>
<ol>
<li>语音</li>
<li>名词的数、性、格</li>
<li>直陈式的各个时态</li>
<li>第二虚拟式</li>
<li>第一虚拟式</li>
<li>功能动词总结</li>
</ol>
<blockquote>
<p><strong>Das deutsche Notiz-Projekt fängt damit an!</strong></p>
</blockquote>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/Deutsche101/Deutsche-101-1/" data-id="cjm54ylcp0002fkw3h3o3eczt" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/德语/">德语</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/语种介绍/">语种介绍</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-39" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-39/">LeetCode Weekly Contest 39</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-39/" class="article-date"><time datetime="2017-07-06T07:28:00.000Z" itemprop="datePublished">2017-07-06</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>整体不难，注意避坑。</p>
<p>https://leetcode.com/contest/leetcode-weekly-contest-39/</p>
<p>&lt;!--more--&gt;</p>
<h2>Sum of Square Numbers</h2>
<p>https://leetcode.com/contest/leetcode-weekly-contest-39/problems/sum-of-square-numbers/</p>
<p><div class="bs-callout bs-callout-info"><p>Given a non-negative integer <code>c</code>, your task is to decide whether there're two integers a and b such that $a^2 + b^2 = c$.</p>
<p><strong>Example 1</strong>:
Input: 5
Output: True
Explanation: <code>1 * 1 + 2 * 2 = 5</code></p>
<p><strong>Example 2</strong>:
Input: 3
Output: False</p>
</div></p>
<p>我一开始感觉这问题是想问怎么判断完全平方数，就按照Babylonianf方法&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;写了个函数判断（想这么干的注意另外讨论0和1的情况）,结果TLE了噜。破oj又不让用<code>gmpy</code>库，我能怎么样我也很绝望啊。后来试了下最糙的判断方法<code>math.sqrt(x)==round(math.sqrt(x))</code>就过去了，，，最后警告，，，请你出题文明点
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type c: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> c==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(c))+<span class="number">1</span>):</span><br><span class="line">            j=c-i*i</span><br><span class="line">            <span class="keyword">if</span> math.sqrt(j)==round(math.sqrt(j)):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>之所以觉得这题野蛮是因为<code>math.sqrt(x)==round(math.sqrt(x))</code>并不是一个很好的判断方法，有时<code>math.sqrt</code>返回的结果的小数部分因为太小被当作<code>0</code>处理了，但参数并非一个完全平方数，可能测试使用的数据都太小所以没出现这个问题就直接AC了。</p>
<h2>Design Log Storage System</h2>
<p>https://leetcode.com/problems/design-log-storage-system/</p>
<p><div class="bs-callout bs-callout-info"><p>You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: <code>Year:Month:Day:Hour:Minute:Second</code>, for example, <code>2017:01:01:23:59:59</code>. All domains are zero-padded decimal numbers.</p>
<p>Design a log storage system to implement the following functions:</p>
<p><code>void Put(int id, string timestamp)</code>: Given a log's unique id and timestamp, store the log in your storage system.</p>
<p><code>int[] Retrieve(String start, String end, String granularity)</code>: Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = &quot;2017:01:01:23:59:59&quot;, end = &quot;2017:01:02:23:59:59&quot;, granularity = &quot;Day&quot;, it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.</p>
<p><strong>Example 1</strong>:</p>
<p>put(1, &quot;2017:01:01:23:59:59&quot;);
put(2, &quot;2017:01:01:22:59:59&quot;);
put(3, &quot;2016:01:01:00:00:00&quot;);
retrieve(&quot;2016:01:01:01:01:01&quot;,&quot;2017:01:01:23:00:00&quot;,&quot;Year&quot;); // return [1,2,3], because you need to return all logs within 2016 and 2017.
retrieve(&quot;2016:01:01:01:01:01&quot;,&quot;2017:01:01:23:00:00&quot;,&quot;Hour&quot;); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.</p>
<p><strong>Note</strong>:</p>
<ol>
<li>There will be at most 300 operations of Put or Retrieve.</li>
<li>Year ranges from [2000,2017]. Hour ranges from [00,23].</li>
<li>Output for Retrieve has no order required.</li>
</ol>
</div></p>
<p>没什么好说的无脑码就行，把日期时间转换为一个可以<strong>直接比较</strong>的数值就行，比如C系语言有<code>ctime</code>库给你折腾，直接返回从1970年零点到那个时间的秒数。这里我的做法比较偷懒，按顺序构成各个位，生成一个数值。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogSystem</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.record=dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, id, timestamp)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type id: int</span></span><br><span class="line"><span class="string">        :type timestamp: str</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.record[id]=timestamp</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(self, s, e, gra)</span>:</span></span><br><span class="line">        re=[]</span><br><span class="line">        order=[<span class="string">'Year'</span>,<span class="string">'Month'</span>,<span class="string">'Day'</span>,<span class="string">'Hour'</span>,<span class="string">'Minute'</span>,<span class="string">'Second'</span>]</span><br><span class="line">        length=order.index(gra)</span><br><span class="line">        val_s=self.trans_val(s,length)</span><br><span class="line">        val_e=self.trans_val(e,length)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.record:</span><br><span class="line">            <span class="keyword">if</span> val_s &lt;= self.trans_val(self.record[i],length)&lt;=val_e:</span><br><span class="line">                re.append(i)</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trans_val</span><span class="params">(self,s,length)</span>:</span></span><br><span class="line">        date=s.split(<span class="string">':'</span>)</span><br><span class="line">        val=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length+<span class="number">1</span>):</span><br><span class="line">            val=val*<span class="number">100</span>+int(date[i])</span><br><span class="line">            <span class="keyword">if</span> i !=<span class="number">0</span>:</span><br><span class="line">                val += <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure></p>
<p>其实比起<code>dict</code>，用<code>list</code>也没问题，其他语言中还能用有序向量之类的数据类型提高检索速度。</p>
<h2>Find the Derangement of An Array</h2>
<p>https://leetcode.com/contest/leetcode-weekly-contest-39/problems/find-the-derangement-of-an-array/</p>
<p><div class="bs-callout bs-callout-info"><p>In combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position.</p>
<p>There's originally an array consisting of <code>n</code> integers from 1 to <code>n</code> in ascending order, you need to find the number of derangement it can generate.</p>
<p>Also, since the answer may be very large, you should return the output mod <code>10^9 + 7</code>.</p>
<p><strong>Example 1</strong>:
Input: 3
Output: 2
Explanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].</p>
<p><strong>Note</strong>:
<code>n</code> is in the range of [1, 106].</p>
</div></p>
<p>我的想法是递归，去找参数为<code>n</code>时，和函数为<code>n-1</code>时有什么关系，但是发现只关注这个函数是没法直接找出和前一个值的关系的。所有需要规定两个函数，或者说是向量（数列？）。首先规定$a_n$为所有值都和下标不一致的数组的总个数（即题目里面问的那个函数），作为辅助规定$b_n$为有且仅有一个值与下标一致（这个位置下面记为不动点）的数组的总个数。这样容易得到
$$a_n=(n-1)a_{n-1}+b_{n-1}$$
在第$n$位的值$n$和任意属于$a_{n-1}$的数组的任意位置交换即可得到一个rerangement，和属于$b_{n-1}$的数组中唯一的不动点交换也可以得到一个rerangement，而且只能通过这两种方法得到。同样有$$b_n=na_{n-1}$$把不动点规定在$n-1$个数之间的任意空隙位置（包括首尾），假设这个不动点的位置在新数组的下标为$i$，其他比$i$大的值代换为$i+1$即可得到这样有且只有一个数与下标一致的数组，反过来对这样的数组进行反向操作，删除这个不动点，把$i$换成$i-1$也可以得到长度为$n-1$的rerangement，根据这种方法写个迭代的解法：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDerangement</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        a,b=<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        mod=<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            a,b=(a*(i<span class="number">-1</span>)+b)%mod,i*a%mod</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></p>
<p>这是我一个没文化的野蛮人的方法，我看了下其他人交的解法，更多的是直接看出了这个函数在<code>n</code>为参数时与<code>n-1</code>,<code>n-2</code>为参数时的关系，即$$a_n=(n-1)(a_{n-1}+a_{n-2})$$这种关系也很好理解，在长度为$n-1$的rerangement里面用$n$交换任意位置，以及长度为$n-2$的rerangement的任意空隙插入这对数。无疑这是优雅的，，，文明的解法。</p>
<h2>Smallest Range</h2>
<p><div class="bs-callout bs-callout-info"><p>You have <code>k</code> lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.</p>
<p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code>or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p>
<p><strong>Example 1</strong>:
Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation:
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].</p>
<p><strong>Note</strong>:</p>
<ol>
<li>The given list may contain duplicates, so ascending order means &gt;= here.</li>
<li>1 &lt;= <code>k</code> &lt;= 3500</li>
<li>-10^5 &lt;= <code>value of elements</code> &lt;= 10^5.</li>
<li>For Java users, please note that the input type has been changed to List&lt;List&lt;Integer&gt;&gt;. And after you reset the code template, you'll see this point.</li>
</ol>
</div></p>
<p>思路撸顺了感觉题目问的还是挺清晰的，既然要找到最小范围，那就需要维护一个长度为<code>k</code>的数组，数组中的每个数都来自于不同的<code>list</code>，其中的最大值和最小值即为数组的两个端点。为了让这个数组的范围尽可能的小，我们可以规定从每个<code>list</code>的左端（或右端）开始全部放进数组，取出最小的值后再换如这个<code>list</code>后面一位的值，以此尝试缩小范围。当然也可以从右端开始不断取出最大值再用前一位替补，但是规定了区间长度相等时左端点较小的数是更小的区间，那么从左端开始更好。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestRange</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pq=[(row[<span class="number">0</span>],i,<span class="number">0</span>)<span class="keyword">for</span> i,row <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">        heapq.heapify(pq)</span><br><span class="line">        start=min([row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> nums])<span class="number">-1</span></span><br><span class="line">        end=max([row[<span class="number">0</span>] <span class="keyword">for</span> row <span class="keyword">in</span> nums])</span><br><span class="line">        r=start,end</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            start,i,j=heapq.heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> end-start&lt;r[<span class="number">1</span>]-r[<span class="number">0</span>]:</span><br><span class="line">                r=start,end</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>==len(nums[i]):</span><br><span class="line">                <span class="keyword">return</span> [r[<span class="number">0</span>],r[<span class="number">1</span>]]</span><br><span class="line">            val=nums[i][j+<span class="number">1</span>]</span><br><span class="line">            end=max(val,end)</span><br><span class="line">            heapq.heappush(pq,(val,i,j+<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://en.wikipedia.org/wiki/Methods_of_computing_square_roots&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-39/" data-id="cjm54ylf8000kfkw3zq2ow6i8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-38" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-38/">LeetCode Weekly Contest 38</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-38/" class="article-date"><time datetime="2017-06-28T07:28:00.000Z" itemprop="datePublished">2017-06-28</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/leetcode-weekly-contest-38/</p>
<p>本周刷题，周日睡晚了所以没参加。这周的题我看了下，根据前几名的时间来推算，比上周麻烦多了。但实际上主要问题出在第二题的贪心策略和第三题的动态规划上，虽然很明显能想到是通过贪心和动规解决的，但具体策略上容易想不到。标注为<code>hard</code>难度的第四题反而是硬码就能过去的。</p>
<p>&lt;!--more--&gt;</p>
<h2>Maximum Product of Three Numbers</h2>
<p>原题地址：https://leetcode.com/contest/leetcode-weekly-contest-38/problems/maximum-product-of-three-numbers/</p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt; Maximum Product of Three Numbers</h4>
<p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example 1</strong>:</p>
<p>Input: [1,2,3]</p>
<p>Output: 6</p>
<p><strong>Example 2</strong>:</p>
<p>Input: [1,2,3,4]</p>
<p>Output: 24</p>
<p><strong>Note</strong>:</p>
<ol>
<li>The length of the given array will be in range $[3,10^4]$ and all elements are in the range $[-1000, 1000]$.</li>
<li>Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.</li>
</ol>
</div></p>
<p>我思路比较简单，取整个数组里面最大的正数，最大的由三个数产生的乘积中一定有一个是来自这个数的，剩下的要比较的就是最小的两个负数的乘积，以及两个次大的正数的乘积，哪个更大？</p>
<p>当然如果根本不存在最大的正数，也就是说整个数组的数都小于等于0，那么就把最大的三个数（也就是绝对值最小的三个负数）相乘。说到底，本质上就是把数组按升序排序后记为<code>a</code>，比较<code>a[-1]*a[-2]*a[-3]</code>和<code>a[-1]*a[0]*a[1]</code>哪个大。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m1=max(nums)</span><br><span class="line">        nums.pop(nums.index(m1))</span><br><span class="line">        m2=max(nums)</span><br><span class="line">        nums.pop(nums.index(m2))</span><br><span class="line">        m3=max(nums)</span><br><span class="line">        nums.pop(nums.index(m3))</span><br><span class="line">        nums.append(m2)</span><br><span class="line">        nums.append(m3)</span><br><span class="line">        <span class="keyword">if</span> m1&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> m1*m2*m3</span><br><span class="line">        l1=min(nums)</span><br><span class="line">        nums.pop(nums.index(l1))</span><br><span class="line">        l2=min(nums)</span><br><span class="line">        <span class="keyword">if</span> l1*l2&gt;m2*m3:</span><br><span class="line">            <span class="keyword">return</span> l1*l2*m1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m1*m2*m3</span><br></pre></td></tr></table></figure></p>
<p>我为了运行的快一点，没做排序但做了不少分支，结果提交的时候也是所有py代码里面最快的。如果不追求运行速度的话完全可以写的简单一些，直接排序后比较上面两个乘积的大小就行了。</p>
<h2>Course Schedule III</h2>
<p>原题地址：https://leetcode.com/contest/leetcode-weekly-contest-38/problems/course-schedule-iii/</p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt; Course Schedule III</h4>
<p>There are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length) <code>t</code> and closed on dth day. A course should be taken continuously for <code>t</code> days and must be finished before or on the dth day. You will start at the 1st day.</p>
<p>Given <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.</p>
<p><strong>Example</strong>:
Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]</p>
<p>Output: 3</p>
<p>Explanation:</p>
<p>There're totally 4 courses, but you can take 3 courses at most:</p>
<p>First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.</p>
<p>Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.</p>
<p>Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.</p>
<p>The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.</p>
<p><strong>Note</strong>:</p>
<ol>
<li>The integer 1 &lt;= d, t, n &lt;= 10,000.</li>
<li>You can't take two courses simultaneously.</li>
</ol>
</div></p>
<p>这类任务调度问题在CS161的习题中已经讨论了不少，不过一般讨论的优化目标是$\mathop {\max }\limits_i \left[ \max (f_i - d_i,0) \right]$或者$\sum\nolimits_i {\max (f_i - d_i,0)}$，其中$f_i$表示任务$i$的实际完成时间，这类问题通常遵循死线最近优先完成原则&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，这题的优化目标是$\sum\nolimits_i {[d_i - f_i \ge 0]}$，策略上也没有太大不同，先按照<code>d</code>的升序给课程们排序，依次开始完成课程，当当前完成时间晚于课程的<code>d</code>时，从之前完成的课程中去除用时最多(<code>t</code>最大)的课再放入当前的课，这样以一课换一课如果失败则确实不存在更优的课程安排。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduleCourse</span><span class="params">(self, courses)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type courses: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c= sorted(courses, key = <span class="keyword">lambda</span> x :  x[<span class="number">1</span>] )</span><br><span class="line">        roll=[]</span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">            time += i[<span class="number">0</span>]</span><br><span class="line">            heapq.heappush(roll,-i[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">while</span> time &gt; i[<span class="number">1</span>]:</span><br><span class="line">                time += heapq.heappop(roll)</span><br><span class="line">        <span class="keyword">return</span> len(roll)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是我一开始从<code>roll</code>中选择<code>t</code>最大的课时直接用了<code>max</code>和<code>pop</code>函数出现了TLE，所以这里维护了一个最小堆来快速寻找最大的<code>t</code></p>
<h2>K Inverse Pairs Array</h2>
<p>原题地址 https://leetcode.com/contest/leetcode-weekly-contest-38/problems/k-inverse-pairs-array/</p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-info-circle&quot;&gt;&lt;/i&gt; K Inverse Pairs Array</h4>
<p>Given two integers <code>n</code> and <code>k</code>, find how many different arrays consist of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> inverse pairs.</p>
<p>We define an inverse pair as following: For ith and jth element in the array, if <code>i &lt; j</code>and <code>a[i] &gt; a[j]</code> then it's an inverse pair; Otherwise, it's not.</p>
<p>Since the answer may very large, the answer should be modulo <code>10^9 + 7</code>.</p>
<p><strong>Example 1</strong>:
Input: n = 3, k = 0
Output: 1
Explanation:
Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.</p>
<p><strong>Example 2</strong>:
Input: n = 3, k = 1
Output: 2
Explanation:
The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.</p>
<p><strong>Note:</strong>
The integer <code>n</code> is in the range [1, 1000] and <code>k</code> is in the range [0, 1000].</p>
</div></p>
<p>这个一开始我想的是递归，假设这个函数为$f(n,k)$，比较容易看出$f(n+1,k)$和$f(n,k),f(n,k-1),\ldots f(n,k-n)$之间的关系:</p>
<p>现在把$n+1$在数组的位置固定在第$n+1$位，那么$k$对逆就要在$[1,\ldots,n]$中产生，即这种条件下可以有$f(n,k)$中数组。</p>
<p>把$n+1$在数组的位置固定在第$n$位，那至少和第$n+1$已经形成一对逆，剩下的$k-1$对也要在$[1,\ldots,n]$中产生，即有$f(n,k-1)$</p>
<p>……</p>
<p>如果把$n+1$放在第一位，那就已经和后面$n$位形成了$n$对逆了，后面这些数再排出$k-n$对即可，即有$f(n,n-k)$</p>
<p>综上所述$$f(n+1,k)=\sum\limits_{j = n -k}^{k} {f(n,j)}$$显然可能出现$f$的第二个参数为负数的情况，也就是$n&lt;k-1$，对应的意义就是把$n$放的太前不用再排其他数就已经凑够了$k$对逆，那么很显然这些位置代表的情况就不用算了直接置为0就行。不过这个递归关系写出来调用的函数次数真是有点多了，再加上$k$这个维度，其实考虑动态规划更加现实。接下来我们用$k+1$替换掉上式的$k$得到$$f(n+1,k+1)=\sum\limits_{j = n - (k+1) }^{k+1} {f(n,j)}$$
再用这个等式减去上面的等式有：
$$f(n+1,k+1)=f(n,k+1)+f(n+1,k)-f(n,n-k)$$
我想我的意思已经很明确了，不过这里比较需要费心的地方是边界条件，更功利的说是一开始作为基石的那几个需要自己规定的函数值。比如对于</p>
<ul>
<li>$n=0$ 时函数值都要置为0</li>
<li>$k=0$ 时函数值规定为1</li>
<li>$k&gt;n(n-1)/2$时函数值为0 取等号时为1</li>
<li>刚刚说到的函数参数为负的问题</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kInversePairs</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n*(n<span class="number">-1</span>)/<span class="number">2</span> <span class="keyword">or</span> k&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k==n*(n<span class="number">-1</span>)/<span class="number">2</span> <span class="keyword">or</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        d=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        mod=<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(min(n*(n<span class="number">-1</span>)/<span class="number">2</span>,k)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">or</span> j==i*(i<span class="number">-1</span>)/<span class="number">2</span>:</span><br><span class="line">                    d[i][j]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> j&gt;i*(i<span class="number">-1</span>)/<span class="number">2</span>:</span><br><span class="line">                    d[i][j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">elif</span> j&gt;=i:</span><br><span class="line">                    d[i][j]=d[i][j<span class="number">-1</span>]+d[i<span class="number">-1</span>][j]-d[i<span class="number">-1</span>][j-i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[i][j]=d[i][j<span class="number">-1</span>]+d[i<span class="number">-1</span>][j]</span><br><span class="line">                d[i][j]=d[i][j]%mod</span><br><span class="line">        <span class="keyword">return</span> d[n][k]</span><br></pre></td></tr></table></figure></p>
<p>我写这个的时候遇到了比较少见的MLE错误，起初我也在想这种规模的二维数组也能MLE吗，后来加了那句<code>d[i][j]=d[i][j]%mod</code>就过了，原因是数据值本身太大了，仔细看题目说过要返回取模以后的数，其实学过密码学就会觉得对于只涉及加减乘的运算来说取模是每步运算都取还是只有最后返回取对于结果没什么影响，所以没必要担心，大胆地在每次计算后都取一下模吧。</p>
<h2>Design Excel Sum Formula</h2>
<p>原题地址 https://leetcode.com/contest/leetcode-weekly-contest-38/problems/design-excel-sum-formula/
因为题实在太长了我就不重新贴了，我之前说过其实这题不怎么需要动脑，暴力码就行。比较容易出错的是<code>int Sum(int row, char column, List of Strings : numbers)</code>要求被设置成存放求和结果的那个单元<code>(r,c)</code>是动态的，调用过一次<code>Sum</code>后，如果求和函数的范围内的单元的值发生了变化，<code>(r,c)</code>也要随之变化。而<code>(r,c)</code>再被调用<code>Sum</code>或者<code>Set</code>函数改变值时，原来的公式定义才会被覆盖。</p>
<p>我们没文化的人就是这个样子，不会用什么精巧的方法，在<code>Excel</code>类内定义了一个成员字典<code>formula</code>维护被赋予的函数定义，每次有任何单元的值发生变化时先检查字典里面这个函数有没有被作为其他那个求和函数的成员，如果有，就顺便重新在哪个被定义的单元上更改求和结果。至于怎样区别是直接命令更改的单元值，还是因为定义范围内的单元变化导致的这个单元的变化，我是通过修改了<code>Set</code>函数原型，增加了一个默认参数区分是直接调用还是其他函数的调用引起的调用，当然我不建议好孩子学这种做法，如果不修改函数原型，可以添加一个成员来标识这次的调用是不是由于其他函数的调用引发的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Excel</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, H,W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :type W: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.H=H</span><br><span class="line">        self.W=ord(W)-ord(<span class="string">'A'</span>)+<span class="number">1</span></span><br><span class="line">        self.c=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(self.W)] <span class="keyword">for</span> i <span class="keyword">in</span> range(self.H)]</span><br><span class="line">        self.formula=dict()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, r, c, v,user=True)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type r: int</span></span><br><span class="line"><span class="string">        :type c: str</span></span><br><span class="line"><span class="string">        :type v: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">and</span> (r,c) <span class="keyword">in</span> self.formula:</span><br><span class="line">            self.formula[r,c]=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;r&lt;=self.H <span class="keyword">and</span> ord(<span class="string">'A'</span>)&lt;=ord(c)&lt;ord(<span class="string">'A'</span>)+self.W:</span><br><span class="line">            temp=self.c[r<span class="number">-1</span>][ord(c)-ord(<span class="string">'A'</span>)]</span><br><span class="line">            self.c[r<span class="number">-1</span>][ord(c)-ord(<span class="string">'A'</span>)]=v</span><br><span class="line">        <span class="keyword">for</span> (r0,c0) <span class="keyword">in</span> self.formula:</span><br><span class="line">            <span class="keyword">if</span> (r,c) <span class="keyword">in</span> self.formula[(r0,c0)]:</span><br><span class="line">                val=self.get(r0,c0)</span><br><span class="line">                self.set(r0,c0,val+(v-temp)*self.formula[(r0,c0)].count((r,c)),<span class="keyword">False</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, r, c)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type r: int</span></span><br><span class="line"><span class="string">        :type c: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;r&lt;=self.H <span class="keyword">and</span> ord(<span class="string">'A'</span>)&lt;=ord(c)&lt;ord(<span class="string">'A'</span>)+self.W:</span><br><span class="line">            <span class="keyword">return</span> self.c[r<span class="number">-1</span>][ord(c)-ord(<span class="string">'A'</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, r, c, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type r: int</span></span><br><span class="line"><span class="string">        :type c: str</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.formula[r,c]=[]</span><br><span class="line">        s=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cal <span class="keyword">in</span> strs:</span><br><span class="line">            points=cal.split(<span class="string">':'</span>)</span><br><span class="line">            <span class="keyword">if</span> len(points)&lt;<span class="number">2</span>:</span><br><span class="line">                s+=self.get(int(points[<span class="number">0</span>][<span class="number">1</span>:]),points[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                self.formula[(r,c)].append((int(points[<span class="number">0</span>][<span class="number">1</span>:]),points[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start=points[<span class="number">0</span>]</span><br><span class="line">                end=points[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(int(start[<span class="number">1</span>:]),int(end[<span class="number">1</span>:])+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(ord(start[<span class="number">0</span>]),ord(end[<span class="number">0</span>])+<span class="number">1</span>):</span><br><span class="line">                        s+=self.get(i,chr(j))</span><br><span class="line">                        self.formula[(r,c)].append((i,chr(j)))</span><br><span class="line">        self.set(r,c,s,<span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">return</span> self.get(r,c)</span><br></pre></td></tr></table></figure></p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;http://courses.cs.vt.edu/cs5114/spring2009/lectures/lecture04-greedy-scheduling.pdf 从第26页开始可以看到这个策略及其证明&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-38/" data-id="cjm54ylg3000rfkw3imvukhol" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/贪心算法/">贪心算法</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-illustrations" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/Introduction/illustrations/">灵魂画手的插画集</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/Introduction/illustrations/" class="article-date"><time datetime="2017-06-11T09:21:00.000Z" itemprop="datePublished">2017-06-11</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Introduction/">Introduction</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>我一直梦想着成为一名穷画师，现在梦想已经实现了三分之一了。</p>
<p>&lt;!-- more --&gt;</p>
<p>我在<a href="https://www.yangzhou301.com/" target="_blank" rel="noopener">扬州计划</a>和自己的一些笔记中的插图大多是我自己画的，也有一部分是直接从资料里面截取下来的（这部分一般会标注引用），我想分享一些插图绘制的工具和技巧，让大家感受engineering drawing的乐趣。</p>
<p>这些文章所使用到的插图及其代码都可以见作为图床的仓库<a href="https://github.com/Lixinyi-DUT/Project-Yangzhou" target="_blank" rel="noopener">Project-Yangzhou</a></p>
<h2>LaTeX/Tikz</h2>
<h3>Picture</h3>
<p>首先可以直接用LaTeX的<code>picture</code>环境&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;画一些简单的图，比如一个二元对称离散信道的转换图
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/illustrations/BSC.png" alt="">
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;center&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;picture&#125;</span></span>(100,60)(-5,0)</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(0,0)&#123;<span class="tag">\<span class="name">vector</span></span>(2,0)&#123;78&#125;&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(0,0)&#123;<span class="tag">\<span class="name">vector</span></span>(4,3)&#123;78&#125;&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(0,60)&#123;<span class="tag">\<span class="name">vector</span></span>(2,0)&#123;78&#125;&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(0,60)&#123;<span class="tag">\<span class="name">vector</span></span>(4,-3)&#123;78&#125;&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(-5,2)&#123;<span class="formula">$1$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(-5,58)&#123;<span class="formula">$0$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(83,2)&#123;<span class="formula">$1$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(83,58)&#123;<span class="formula">$0$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(30,3)&#123;<span class="formula">$1-p$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(30,65)&#123;<span class="formula">$1-p$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(60,40)&#123;<span class="formula">$p$</span>&#125;</span><br><span class="line">        	<span class="tag">\<span class="name">put</span></span>(60,20)&#123;<span class="formula">$p$</span>&#125;</span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;picture&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;center&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p><div class="bs-callout bs-callout-default"><p><code>picture</code>环境可以完成基础的作图，但是因为没有坐标计算的插件支持以及原生图形太少的缘故，有些复杂的图形就难以胜任了</p>
</div></p>
<h3>Tikz/Pgf</h3>
<p>这时候可以借助一下<code>tikz</code>包&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;作图，但是一般默认<code>TeX</code>输出的文档为<code>pdf</code>格式的，必须转换为图片格式才能在网络博客中使用，而一般一篇博客会用到很多张插图，为了管理这些大小不一致的图片，会把它们写入同一个文档中，这时可以使用<code>standalone</code>类型的文档，每页会显示一张图片：</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%!TEX program = xelatex</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[tikz]</span><span class="string">&#123;standalone&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ctex&#125;</span></span> <span class="comment">%支持中文标注</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;tikz&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line">    <span class="comment">%图1 代码</span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line">    <span class="comment">%图2 代码</span></span><br><span class="line">  <span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以在把一篇博客中用到的多张大小各异的插图写入同一个<code>pdf</code>文件了。我建议每个<code>tikzpicture</code>的内容部分的代码都另写在一个文件如<code>pic1.tikz</code>，然后在代码部分用<code>\input{pic1.tikz}</code>，方便作图的模块化和重用。接下来要解决的是如何将这个<code>pdf</code>文件的每一张图（即每一页）转换成多张博客可以直接使用的（比如<code>png</code>文件）图片：</p>
<p>首先图片转换永远绕不开的就是<a href="https://www.imagemagick.org/script/index.php" target="_blank" rel="noopener">ImageMagick</a>库，在安装了ImageMagick之后，可以用Python写个小小的脚本<code>convert.py</code>来解放双手：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wand.image <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">diag=<span class="string">'xxxx.pdf'</span> <span class="comment">#pdf的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(Image(filename=diag,resolution=<span class="number">200</span>)) <span class="keyword">as</span> source:</span><br><span class="line">    images=source.sequence</span><br><span class="line">    pages=len(images)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(pages):</span><br><span class="line">        Image(images[i]).save(filename=str(i+<span class="number">1</span>)+<span class="string">'.png'</span>)</span><br></pre></td></tr></table></figure></p>
<p>图片处理的问题解决了，那就可以放心大胆的画图了。</p>
<h3>插画示例Part 1</h3>
<hr>
<p>扬州计划的一篇博文（<a href="https://www.yangzhou301.com/2016/03/14/826442654/" target="_blank" rel="noopener">这么早就说Hessian矩阵是半正定的，会不会给人一种凸函数的感觉？</a>）中用到的插图
<img src="https://raw.githubusercontent.com/Lixinyi-DUT/Project-Yangzhou/master/pictures/826442654/5.png" alt=""></p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span><span class="string">[decoration=&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">markings,</span></span></span><br><span class="line"><span class="tag"><span class="string">mark=at position 1 with &#123;\arrow[scale=1.5]</span><span class="string">&#123;angle 60&#125;</span></span>&#125;;</span><br><span class="line">&#125;]</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> [-&gt;,postaction=&#123;decorate&#125;](0,0) node[left]&#123;&#125; -- node[pos=0.75,above,sloped]&#123;<span class="formula">$&#123;<span class="tag">\<span class="name">bf</span><span class="string">&#123;x&#125;</span></span>&#125;_1$</span>&#125;(3,3) node[right]&#123;&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> [-&gt;,postaction=&#123;decorate&#125;](0,0) node[left]&#123;&#125; -- node[pos=0.75,below,sloped]&#123;<span class="formula">$&#123;<span class="tag">\<span class="name">bf</span><span class="string">&#123;x&#125;</span></span>&#125;_2$</span>&#125;(6,0) node[right]&#123;&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> [-,dashed](3,3) node[left]&#123;&#125; -- node[]&#123;&#125;(6,0) node[right]&#123;&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt&#125;]</span><br><span class="line">(3,3) -- (6,0) node [black,midway,above,sloped,yshift=5pt] &#123;<span class="formula">$<span class="tag">\<span class="name">theta</span></span> &#123;<span class="tag">\<span class="name">bf</span><span class="string">&#123;x&#125;</span></span>&#125;_1 + <span class="tag">\<span class="name">left</span></span>( 1 - <span class="tag">\<span class="name">theta</span></span>  <span class="tag">\<span class="name">right</span></span>)&#123;<span class="tag">\<span class="name">bf</span><span class="string">&#123;x&#125;</span></span>&#125;_2$</span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (4,2) circle (1pt);</span><br><span class="line">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (5,1) circle (1pt);</span><br><span class="line">    &#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;red&#125;</span><span class="string">&#123;\draw [-&gt;,postaction=&#123;decorate&#125;</span></span>](0,0) node[left]&#123;&#125; -- node[pos=0.75,above,sloped]&#123;<span class="formula">$<span class="tag">\<span class="name">theta</span> = <span class="number">2</span></span>/3 $</span>&#125;(4,2) node[right]&#123;&#125;;&#125;&#125;</span><br><span class="line">    &#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;blue&#125;</span><span class="string">&#123;\draw [-&gt;,postaction=&#123;decorate&#125;</span></span>](0,0) node[left]&#123;&#125; -- node[pos=0.75,above,sloped]&#123;<span class="formula">$<span class="tag">\<span class="name">theta</span> = <span class="number">1</span></span>/3 $</span>&#125;(5,1) node[right]&#123;&#125;;&#125;&#125;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>一阶条件直观演示图</p>
<p><img src="https://raw.githubusercontent.com/Lixinyi-DUT/Project-Yangzhou/master/pictures/826442654/6.png" alt=""></p>
<p>可以明显看到我还真用了个二次函数计算了一番</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span><span class="string">[domain=0:5]</span></span></span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span>   plot (<span class="tag">\<span class="name">x</span></span>,&#123;<span class="tag">\<span class="name">x</span></span>^2/8&#125;)             node[right,xshift=0.2cm] &#123;<span class="formula">$y = f<span class="tag">\<span class="name">left</span></span>( x <span class="tag">\<span class="name">right</span></span>)$</span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span>   plot (<span class="tag">\<span class="name">x</span></span>,&#123;1/2*<span class="tag">\<span class="name">x</span></span>-1/2&#125;)         node[right] &#123;<span class="formula">$l$</span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[red]</span></span> (1/2,-1/4) -- (4,3/2);</span><br><span class="line">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (2,1/2) circle (1pt) node[below,xshift=0.3cm] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$p_0\left( &#123;x,f\left( x \right)&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)<span class="formula">$&#125;&#125;;</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (1/2,1/32) circle (1pt) node[above,xshift=-0.2cm] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$p_1\left( &#123;&#123;x_1&#125;</span></span>,f<span class="tag">\<span class="name">left</span></span>( &#123;&#123;x_1&#125;&#125; <span class="tag">\<span class="name">right</span></span>)&#125; <span class="tag">\<span class="name">right</span></span>)$</span>&#125;&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (1/2,-1/4) circle (1pt) node[below,yshift=-0.3cm]&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$p_3\left( &#123;&#123;x_1&#125;</span></span>,f<span class="tag">\<span class="name">left</span></span>( x <span class="tag">\<span class="name">right</span></span>) + f'<span class="tag">\<span class="name">left</span></span>( x <span class="tag">\<span class="name">right</span></span>) <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">left</span></span>( &#123;&#123;x_1&#125; - x&#125; <span class="tag">\<span class="name">right</span></span>)&#125; <span class="tag">\<span class="name">right</span></span>)<span class="formula">$&#125;&#125;;</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">draw</span><span class="string">[dashed,dash pattern=on 1pt off 1pt]</span></span> (1/2,1/32) -- (1/2,-1/4);</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (4,2) circle (1pt) node[above] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$p_2\left( &#123;&#123;x_2&#125;</span></span>,f<span class="tag">\<span class="name">left</span></span>( &#123;&#123;x_2&#125;&#125; <span class="tag">\<span class="name">right</span></span>)&#125; <span class="tag">\<span class="name">right</span></span>)$</span>&#125;&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (4,3/2) circle (1pt) node[below,xshift=1.8cm]&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$p_4\left( &#123;&#123;x_2&#125;</span></span>,f<span class="tag">\<span class="name">left</span></span>( x <span class="tag">\<span class="name">right</span></span>) + f'<span class="tag">\<span class="name">left</span></span>( x <span class="tag">\<span class="name">right</span></span>) <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">left</span></span>( &#123;&#123;x_2&#125; - x&#125; <span class="tag">\<span class="name">right</span></span>)&#125; <span class="tag">\<span class="name">right</span></span>)<span class="formula">$&#125;&#125;;</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">draw</span><span class="string">[dashed,dash pattern=on 1pt off 1pt]</span></span> (4,2) -- (4,3/2);</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">draw</span><span class="string">[dashed,blue]</span></span> (1/2,1/32) -- (4,2);</span></span><br><span class="line"><span class="formula">    <span class="tag">\<span class="name">filldraw</span><span class="string">[blue]</span></span> (2,7/8) circle (1pt) node[above,xshift=-1.4cm]&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$p'\left( x,\theta f\left( &#123;&#123;x_1&#125;</span></span>&#125; <span class="tag">\<span class="name">right</span></span>) + <span class="tag">\<span class="name">left</span></span>( &#123;1 - <span class="tag">\<span class="name">theta</span></span> &#125; <span class="tag">\<span class="name">right</span></span>)f<span class="tag">\<span class="name">left</span></span>( &#123;&#123;x_2&#125;&#125; <span class="tag">\<span class="name">right</span></span>) <span class="tag">\<span class="name">right</span></span>)$</span>&#125;&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[dashed,,blue]</span></span> (2,1/2) -- (2,7/8);</span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>还有用来演示二维的支持平面和法向量的图
<img src="https://raw.githubusercontent.com/Lixinyi-DUT/Project-Yangzhou/master/pictures/826442654/7.png" alt=""></p>
<p>为了方便找法向量和切线我直接画了个圆来演示凸集
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span><span class="string">[domain=0:5/2]</span></span></span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[fill=gray,fill opacity=.1]</span></span> (0,0) circle (&#123;sqrt(2)&#125;) node[opacity=1]&#123;<span class="formula">$S$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span></span>   plot (<span class="tag">\<span class="name">x</span></span>,2-<span class="tag">\<span class="name">x</span></span>) node[right]&#123;<span class="formula">$h$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">filldraw</span></span>  (1,1) circle (1pt) node[right]&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$&#123;\bf&#123;x&#125;</span></span>&#125;_0<span class="formula">$&#125;&#125;;</span></span><br><span class="line"><span class="formula"> <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;]</span></span> (1,1) -- (2,2) node[above]&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$&#123;\bf&#123;\alpha &#125;</span></span>&#125;$</span>&#125;&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-]</span></span> (1.1,1.1)--(1.1-0.1,1.1+0.1)--(0.9,1.1);</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>还有一阶条件和Lagrange中值定理的关系示意图
<img src="https://raw.githubusercontent.com/Lixinyi-DUT/Project-Yangzhou/master/pictures/826442654/9.png" alt="">
还是用的刚刚那个二次函数，这种图最头疼的还是计算和标注</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span><span class="string">[domain=0:11/2]</span></span></span><br><span class="line">        <span class="tag">\<span class="name">draw</span></span>   plot (<span class="tag">\<span class="name">x</span></span>,&#123;<span class="tag">\<span class="name">x</span></span>^2/8&#125;)             node[right,xshift=0.2cm] &#123;<span class="formula">$y = f<span class="tag">\<span class="name">left</span></span>( x <span class="tag">\<span class="name">right</span></span>)$</span>&#125;;</span><br><span class="line">        <span class="tag">\<span class="name">draw</span></span>   plot (<span class="tag">\<span class="name">x</span></span>,&#123;5/8*<span class="tag">\<span class="name">x</span></span>-25/32&#125;)             node[right,xshift=0.2cm] &#123;<span class="formula">$l$</span>&#125;;</span><br><span class="line">        <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (0,0) circle (1pt) node[left] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$\left( &#123;x_0,f\left( x_0 \right)&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)<span class="formula">$&#125;&#125;;</span></span><br><span class="line"><span class="formula">        <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (5,25/8) circle (1pt) node[right,xshift=0.1cm] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$\left( &#123;x,f\left( x \right)&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)$</span>&#125;&#125;;</span><br><span class="line">        <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (5/2,25/32) circle (1pt) node[below,xshift=0.3cm] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$\left( &#123;\xi,f\left( \xi \right)&#125;</span></span> <span class="tag">\<span class="name">right</span></span>)<span class="formula">$&#125;&#125;;</span></span><br><span class="line"><span class="formula">        <span class="tag">\<span class="name">filldraw</span><span class="string">[black]</span></span> (5,0) circle (1pt);</span></span><br><span class="line"><span class="formula">        <span class="tag">\<span class="name">draw</span><span class="string">[dashed,blue]</span></span> (0,0) -- (5,25/8) node[above,midway,sloped] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$k=f'\left( \xi \right)$&#125;</span></span>&#125;;</span></span><br><span class="line"><span class="formula">        <span class="tag">\<span class="name">draw</span><span class="string">[dashed]</span></span> (0,0) -- (5,0) --(5,25/8);</span></span><br><span class="line"><span class="formula">        <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,mirror&#125;]</span></span><br><span class="line"><span class="formula">(0,0) -- (5,0) node [black,midway,above,sloped,yshift=-20pt] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$x-x_0$&#125;</span></span>&#125;;</span></span><br><span class="line"><span class="formula">        <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,mirror&#125;]</span></span><br><span class="line"><span class="formula">(5,0) -- (5,25/8) node [black,below,midway,sloped,yshift=-0.4cm] &#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$f'\left( \xi \right)\left(x-x_0 \right)$&#125;</span></span>&#125;;</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>扬州计划的博文（<a href="https://www.yangzhou301.com/2016/04/07/471457613/" target="_blank" rel="noopener">计网课堂测试题解</a>）中可以看到画通信示意图也是很合适的
<img src="https://raw.githubusercontent.com/Lixinyi-DUT/Project-Yangzhou/master/pictures/471457613/4.png" alt=""></p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span><span class="string">[decoration=&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    markings,</span></span></span><br><span class="line"><span class="tag"><span class="string">    mark=at position 1 with &#123;\arrow[scale=1]</span><span class="string">&#123;angle 90&#125;</span></span>&#125;;</span><br><span class="line">  &#125;]</span><br><span class="line">  <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,dashed,line width=2,color=gray]</span></span> (0,-0.5) node[above,color=black]&#123;<span class="tag">\<span class="name">large</span><span class="string">&#123;$A$&#125;</span></span>&#125; -- (0,-10);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,dashed,line width=2,color=gray]</span></span> (8,-0.5) node[above,color=black]&#123;<span class="tag">\<span class="name">large</span><span class="string">&#123;$B$&#125;</span></span>&#125; -- (8,-10);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span>&lt;1-&gt;[-&gt;,line width=1,postaction=&#123;decorate&#125;] (0,-1) --node[above,sloped]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;FIN=1, seq=5001&#125;</span></span>&#125; (8,-3);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span>&lt;2-&gt;[-&gt;,line width=1,postaction=&#123;decorate&#125;] (8,-3.1) --node[above,sloped]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;ACK=1, seq=10001, ack=5002&#125;</span></span>&#125; (0,-5.1);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span>&lt;3-&gt;[-&gt;,line width=1,postaction=&#123;decorate&#125;] (8,-5.2) --node[above,sloped]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;FIN=1, seq=10001&#125;</span></span>&#125; (0,-7.2);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span>&lt;4-&gt;[-&gt;,line width=1,postaction=&#123;decorate&#125;] (0,-7.3) --node[above,sloped]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;ACK=1, seq=5002, ack=10002&#125;</span></span>&#125; (8,-9.3);</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>来自我毕设（<a href="https://github.com/Lixinyi-DUT/graduation-project" target="_blank" rel="noopener">graduation-project</a>）的一张示意图，演示某种机制的隐写方案中消息的结构
<img src="https://github.com/Lixinyi-DUT/graduation-project/raw/master/codes/plots/ill/structure-1.png" alt="">
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span> (0,0) rectangle node&#123;消息长度<span class="formula">$l$</span>&#125; (5,1);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span>(5,0) rectangle node&#123;起始坐标<span class="formula">$<span class="tag">\<span class="name">left</span></span>(x_0,y_0<span class="tag">\<span class="name">right</span></span>)$</span>&#125;  (10,1);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span><span class="string">[fill=gray,fill opacity=0.3]</span></span>(10,0) rectangle node&#123;<span class="formula">$<span class="tag">\<span class="name">cdots</span></span>$</span>&#125;(13,1);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span><span class="string">[dashed]</span></span> (13,0) rectangle node&#123;秘密消息&#125; (23,1);</span><br><span class="line">  <span class="tag">\<span class="name">draw</span><span class="string">[fill=gray,fill opacity=0.3]</span></span>(23,0) rectangle node&#123;<span class="formula">$<span class="tag">\<span class="name">cdots</span></span>$</span>&#125;(26,1) ;</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,mirror&#125;]</span><br><span class="line">  (0,0) -- (5,0) node [black,midway,above,sloped,yshift=-40pt]&#123;前<span class="formula">$l_1$</span>位&#125;;</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,mirror&#125;] (5,0) -- (10,0) node [black,midway,above,sloped,yshift=-40pt]&#123;接下来<span class="formula">$l_2$</span>位&#125;;</span><br><span class="line">  <span class="tag">\<span class="name">filldraw</span></span>(13,0) circle (1pt) node[below]&#123;<span class="formula">$<span class="tag">\<span class="name">left</span></span>(x_0,y_0<span class="tag">\<span class="name">right</span></span>)$</span>&#125;;</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,mirror&#125;] (13,0) -- (23,0) node [black,midway,above,sloped,yshift=-40pt]&#123;<span class="formula">$l <span class="tag">\<span class="name">times</span></span> 8$</span>位&#125;;</span><br><span class="line">  <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt&#125;,yshift=5pt] (0,1) -- (26,1) node [black,midway,above,sloped,yshift=10pt]&#123;<span class="formula">$m <span class="tag">\<span class="name">times</span></span> n$</span>位二进制数据&#125;;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>知乎用户<a href="https://www.zhihu.com/people/lfgu_dut" target="_blank" rel="noopener">顾凌峰</a>大哥的回答<a href="https://www.zhihu.com/question/34624915/answer/85854651" target="_blank" rel="noopener">请解释一下什么是选择明文攻击及选择密文攻击？</a>的插图，也是我画的。
<img src="https://pic3.zhimg.com/3c0f9b579b7ea46002da756afe9e206a_b.png" alt=""></p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;picture&#125;</span></span>(140,200)(5,5)</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(-10,100)&#123;<span class="tag">\<span class="name">framebox</span><span class="string">&#123;Christopher&#125;</span></span>&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(130,100)&#123;<span class="tag">\<span class="name">framebox</span><span class="string">&#123;Sharon&#125;</span></span>&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(20,95)&#123;<span class="tag">\<span class="name">line</span></span>(0,-1)&#123;180&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(150,97)&#123;<span class="tag">\<span class="name">line</span></span>(0,-1)&#123;180&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(20,80)&#123;<span class="tag">\<span class="name">vector</span></span>(4,-1)&#123;130&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(150,40)&#123;<span class="tag">\<span class="name">vector</span></span>(-4,-1)&#123;130&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(150,0)&#123;<span class="tag">\<span class="name">vector</span></span>(-4,-1)&#123;130&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(20,-40)&#123;<span class="tag">\<span class="name">vector</span></span>(4,-1)&#123;130&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(-70,85)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;\bf&#123;Encrypt&#125;</span></span>&#125; <span class="formula">$p_1=$</span>&#123;<span class="tag">\<span class="name">emph</span><span class="string">&#123;A Report from EU&#125;</span></span>&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(30,70)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$c_1=E_k(\mbox&#123;\emph&#123;A Report from EU&#125;</span></span>&#125;)<span class="formula">$&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(160,60)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;&#123;\bf&#123;Decrypt&#125;</span></span>&#125; $</span>p_1=D_k(c_1)<span class="formula">$&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(160,50)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;and get &#123;\emph&#123;A Report from EU&#125;</span></span>&#125;&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(160,40)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;\bf&#123;Encrypt&#125;</span></span>&#125; $</span>p_2=<span class="formula">$&#123;<span class="tag">\<span class="name">emph</span><span class="string">&#123;Roger!&#125;</span></span>&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(-70,10)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;&#123;\bf&#123;Decrypt&#125;</span></span>&#125; $</span>p_2=D_k(c_2)<span class="formula">$&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(40,35)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$c_2=E_k(\mbox&#123;\emph&#123;Roger!&#125;</span></span>&#125;)$</span>&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(160,20)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;Make a big news!&#125;</span></span>&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(160,0)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;\bf&#123;Encrypt&#125;</span></span>&#125; <span class="formula">$p_3=$</span>&#123;<span class="tag">\<span class="name">emph</span><span class="string">&#123;A big news&#125;</span></span>&#125;&#125;</span><br><span class="line">  <span class="tag">\<span class="name">put</span></span>(30,-10)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$c_3=E_k(\mbox&#123;\emph&#123;A big news&#125;</span></span>&#125;)<span class="formula">$&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(-70,-25)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;&#123;\bf&#123;Decrypt&#125;</span></span>&#125; $</span>p_3=D_k(c_3)<span class="formula">$&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(-70,-35)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;Excited!&#125;</span></span>&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(-70,-45)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;\bf&#123;Encrypt&#125;</span></span>&#125; $</span>p_2=<span class="formula">$&#123;<span class="tag">\<span class="name">emph</span><span class="string">&#123;Roger!&#125;</span></span>&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(160,-75)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;&#123;\bf&#123;Decrypt&#125;</span></span>&#125; $</span>p_2=D_k(c_2)<span class="formula">$&#125;&#125;</span></span><br><span class="line"><span class="formula">  <span class="tag">\<span class="name">put</span></span>(40,-65)&#123;<span class="tag">\<span class="name">footnotesize</span><span class="string">&#123;$c_2=E_k(\mbox&#123;\emph&#123;Roger!&#125;</span></span>&#125;)$</span>&#125;&#125;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;picture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<h3>插画示例Part 2</h3>
<p>Part 1的插图色调不够丰富，其实我本人是一个色弱患者~~（导致不能报考化学生物等专业以及从事一些工作）~~，也无法凭自己的能力去调色，所以借助一些工具比如<a href="http://latexcolor.com/" target="_blank" rel="noopener">LaTeX Color Definitions</a>画一些色彩比较丰富的插图。</p>
<p>扬州计划的一篇博文（<a href="https://www.yangzhou301.com/2017/04/01/489526910/" target="_blank" rel="noopener">和你相见不到40分钟，我就认定你是我的妻子了</a>）中就是用了三种颜色象征了男性结点，女性结点，原谅绿边。</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">definecolor</span><span class="string">&#123;babypink&#125;</span><span class="string">&#123;rgb&#125;</span><span class="string">&#123;0.96, 0.76, 0.76&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">definecolor</span><span class="string">&#123;babyblue&#125;</span><span class="string">&#123;rgb&#125;</span><span class="string">&#123;0.54, 0.81, 0.94&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">definecolor</span><span class="string">&#123;cadmiumgreen&#125;</span><span class="string">&#123;rgb&#125;</span><span class="string">&#123;0.0, 0.42, 0.24&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这里挑一些主要的插图给出示例代码
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/pictures/489526910/2.png" alt="">
老实男人m'的狡猾配偶w'与老实女人w的狡猾配偶m互相发生了绿色的倾慕，这张插图是我全文最喜欢的插图，反映了爱情的脆弱和无常，也是我微博 <a href="http://weibo.com/LxySeptember" target="_blank" rel="noopener"><i class="fa fa-weibo"></i> @我是欣宜我正常吗</a>的头像图。</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babypink,minimum size=1cm]</span></span> (w1) at (0,0) &#123;<span class="formula">$w$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babyblue,minimum size=1cm]</span></span> (m1) at (2,2) &#123;<span class="formula">$m$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babypink,minimum size=1cm]</span></span> (w2) at (4,0) &#123;<span class="formula">$w'$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babyblue,minimum size=1cm]</span></span> (m2) at (6,2) &#123;<span class="formula">$m'$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span></span> (w1) -- node[sloped,above]&#123;<span class="tag">\<span class="name">small</span></span> matched&#125; (m1) ;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span></span> (w2) -- node[sloped,below]&#123;<span class="tag">\<span class="name">small</span></span> matched&#125; (m2) ;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[dashed,color=cadmiumgreen,-&gt;]</span></span> (m1.10) --node[sloped,above]&#123;<span class="tag">\<span class="name">small</span></span> prefer&#125; (w2.170);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[dashed,color=cadmiumgreen,-&gt;]</span></span> (w2.190) --node[sloped,below]&#123;<span class="tag">\<span class="name">small</span></span> prefer&#125; (m1.350);</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>当然还有一些其他的NTR假设，比如
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/pictures/489526910/6.png" alt="">
借着<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">font awesome</a>搞一波事，既然他/她比我高出那么多，忘了我吧。</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;fontawesome&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[dashed,opacity=0.7,color=babyblue]</span></span> (-2,2) -- (6,2);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[dashed,opacity=0.7,color=babyblue]</span></span> (-2,4) -- (6,4);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[dashed,opacity=0.7,color=babypink]</span></span> (-2,0) -- (6,0);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[dashed,opacity=0.7,color=babypink]</span></span> (-2,-2) -- (6,-2);</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babyblue,minimum size=1cm]</span></span> (m1) at (0,4) &#123;<span class="formula">$m$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babypink,minimum size=1cm]</span></span> (w1) at (5,0) &#123;<span class="formula">$w$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babyblue,minimum size=1cm]</span></span> (m2) at (5,2) &#123;<span class="formula">$m'$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">node</span><span class="string">[circle,draw,fill=babypink,minimum size=1cm]</span></span> (w2) at (0,-2) &#123;<span class="formula">$w'$</span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[thick]</span></span> (w2)-- node[above,sloped]&#123;<span class="tag">\<span class="name">footnotesize</span></span> matched in <span class="formula">$S$</span>&#125;(m1);</span><br><span class="line"><span class="tag">\<span class="name">draw</span><span class="string">[thick]</span></span> (w1)-- node[below,sloped,yshift=-0.5cm]&#123;<span class="tag">\<span class="name">footnotesize</span></span> matched in <span class="formula">$S$</span>&#125;(m2);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,mirror,raise=2pt&#125;]</span><br><span class="line">(5.5,2) -- node[midway,right,xshift=0.4cm]&#123;<span class="tag">\<span class="name">small</span></span> &#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;babypink&#125;</span><span class="string">&#123;$w$&#125;</span></span>&#125; prefers <span class="formula">$&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;babyblue&#125;</span><span class="string">&#123;m&#125;</span></span>&#125;&gt;&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;babyblue&#125;</span><span class="string">&#123;m'&#125;</span></span>&#125;$</span>&#125; (5.5,4);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span></span> [decorate,decoration=&#123;brace,amplitude=10pt,raise=2pt&#125;]</span><br><span class="line">(-0.5,-2) -- node[midway,left,xshift=-0.4cm]&#123;<span class="tag">\<span class="name">small</span></span> <span class="formula">$&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;babyblue&#125;</span><span class="string">&#123;m&#125;</span></span>&#125;$</span> prefers <span class="formula">$&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;babypink&#125;</span><span class="string">&#123;w&#125;</span></span>&#125;&gt;&#123;<span class="tag">\<span class="name">color</span><span class="string">&#123;babypink&#125;</span><span class="string">&#123;w'&#125;</span></span>&#125;$</span>&#125; (-0.5,0);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[thick,dashed,red]</span></span> (w1) --node[sloped]&#123;<span class="tag">\<span class="name">Large</span></span><span class="tag">\<span class="name">faExclamationTriangle</span></span>&#125; (m1);</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3>插画示例Part 3</h3>
<p><code>Tikz</code>本身提供的基本图形也很有限，我们可以用第三方的矢量图集拓展它。</p>
<p>在<a href="https://www.yangzhou301.com/2016/04/07/471457613/" target="_blank" rel="noopener">计网课堂测试题解</a>中，为了画一些计算机网络相关的图形，利用了<a href="http://www.cisco.com/c/en/us/about/brand-center/network-topology-icons.html" target="_blank" rel="noopener"> Cisco Network Topology Icons</a>库中的<code>.eps</code>图像集
<img src="https://raw.githubusercontent.com/Lixinyi-DUT/Project-Yangzhou/master/pictures/471457613/8.png" alt="">
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;epstopdf&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (-4,0) -- node[below,label=below:LAN1]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/webcluster&#125;</span></span>&#125; (8,0) ;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (-3,0) -- node[label=left:<span class="tag">\<span class="name">textbf</span></span> &#123;路由器&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/router&#125;</span></span>&#125; (-3,4) node[above,yshift=-5pt,label=above:LAN2: <span class="tag">\<span class="name">textbf</span></span> &#123;91台主机&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/webcluster&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (2,0) -- node[label=left:<span class="tag">\<span class="name">textbf</span></span> &#123;路由器&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/router&#125;</span></span>&#125; (2,4) node[above,yshift=-5pt,label=above:LAN3: <span class="tag">\<span class="name">textbf</span></span> &#123;150台主机&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/webcluster&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (7,0) -- node[label=left:<span class="tag">\<span class="name">textbf</span></span> &#123;路由器&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/router&#125;</span></span>&#125; (7,4) node[above,yshift=-5pt,label=above:LAN4: <span class="tag">\<span class="name">textbf</span></span> &#123;3台主机&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/webcluster&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (7,2) -- (10,2) node[right,xshift=-5pt,label=above:LAN5: <span class="tag">\<span class="name">textbf</span></span> &#123;15台主机&#125;]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.7]</span><span class="string">&#123;icon/webcluster&#125;</span></span>&#125;;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>2016年计算机网络期末考试的最后一题，其实图也是我画的（奉旨出题而已）
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/codes/471457613/diag3-1.png" alt="">
其实题中的IP地址全是我从扬州计划的访客IP中按照某个指标聚集拉下来的，至于具体是哪个指标我就不说了，大家自己猜吧。</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br><span class="line"> <span class="tag">\<span class="name">path</span></span> (0,4) node(A) [label=&#123;[align=center]below:&#123;Host <span class="formula">$A$</span>&#125;<span class="tag">\<span class="name">\</span></span>IP:222.195.65.197<span class="tag">\<span class="name">\</span></span>MAC:74-29-9C-E8-FF-55&#125;] &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.6]</span><span class="string">&#123;icon/pc&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">path</span></span> (12,4) node(B) [label=&#123;[align=center]below:&#123;Host <span class="formula">$B$</span>&#125;<span class="tag">\<span class="name">\</span></span>IP:210.32.157.79<span class="tag">\<span class="name">\</span></span>MAC:49-BD-D2-C7-56-2A&#125;]  &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.6]</span><span class="string">&#123;icon/pc&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">path</span></span> (2,4) node(R1) [label=below:<span class="formula">$R_1$</span>] &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.6]</span><span class="string">&#123;icon/router&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">path</span></span> (6,7) node(R2) [label=above:<span class="formula">$R_2$</span>]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.6]</span><span class="string">&#123;icon/router&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">path</span></span> (10,4) node(R3)[label=below:<span class="formula">$R_3$</span>] &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.6]</span><span class="string">&#123;icon/router&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">path</span></span> (6,1) node(R4) [label=below:<span class="formula">$R_4$</span>]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.6]</span><span class="string">&#123;icon/router&#125;</span></span>&#125;;</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (A) --node[pos=.86,sloped,above]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN1&#125;</span></span>&#125; (R1) --node[pos=.25,sloped,above,align=left]&#123;IP:49.74.228.20<span class="tag">\<span class="name">\</span></span>MAC:64-27-37-60-74-C7&#125; node[pos=.07,sloped,below]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN2&#125;</span></span>&#125; node[pos=.73,sloped,below,align=right]&#123;IP:49.74.228.52<span class="tag">\<span class="name">\</span></span>MAC:E0-06-E6-87-8E-C2&#125; node[pos=.93,sloped,above]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN1&#125;</span></span>&#125;(R2)  --node[pos=.28,sloped,above,align=left]&#123;IP:114.212.81.12<span class="tag">\<span class="name">\</span></span>MAC:58-91-CF-37-49-75&#125; node[pos=.07,sloped,below]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN2&#125;</span></span>&#125; node[pos=.7,sloped,below,align=right]&#123;IP:114.212.81.31<span class="tag">\<span class="name">\</span></span>MAC:88-9F-FA-FA-3C-E3&#125; node[pos=.93,sloped,above]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN2&#125;</span></span>&#125; (R3) --node[pos=.29,sloped,below,align=right]&#123;IP:139.226.16.203<span class="tag">\<span class="name">\</span></span>MAC:00-05-A1-48-06-7B&#125; node[pos=.09,sloped,above]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN3&#125;</span></span>&#125; node[pos=.7,sloped,above,align=left]&#123;IP:139.226.109.46<span class="tag">\<span class="name">\</span></span>MAC:00-0C-29-C4-CD-16&#125;(R4) node[pos=.93,sloped,below]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN2&#125;</span></span>&#125; -- node[pos=.29,sloped,below,align=right]&#123;IP:117.68.196.65<span class="tag">\<span class="name">\</span></span>MAC:00-14-22-43-62-76&#125; node[pos=.07,sloped,above]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN1&#125;</span></span>&#125; node[pos=.7,sloped,above,align=left]&#123;IP:117.68.202.11<span class="tag">\<span class="name">\</span></span>MAC:00-60-16-0A-B5-A3&#125; node[pos=.93,sloped,below]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN3&#125;</span></span>&#125; (R1);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[-,thick]</span></span> (B) -- node[pos=.87,sloped,above]&#123;<span class="tag">\<span class="name">texttt</span><span class="string">&#123;LAN1&#125;</span></span>&#125; (R3);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[&lt;-,font=\tiny]</span></span> (1,6) node[align=center,above]&#123;IP:222.195.65.101<span class="tag">\<span class="name">\</span></span>MAC:00-01-6C-06-A6-29&#125; --  (1.6,4.2);</span><br><span class="line"> <span class="tag">\<span class="name">draw</span><span class="string">[&lt;-,font=\tiny]</span></span> (11,6) node[align=center,above]&#123;IP:210.32.157.6<span class="tag">\<span class="name">\</span></span>MAC:1A-23-F9-CD-D6-9B&#125; -- (10.4,4.2);</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>在毕设中用到的一张示意图</p>
<p><img src="https://github.com/Lixinyi-DUT/graduation-project/raw/master/codes/plots/ill/structure-2.png" alt=""></p>
<p>其实这上面的小图像都是临时去网上搜的免费的图标，画图的时候基本上想到什么去google搜关键词+icon就行了</p>
<p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;tikzpicture&#125;</span><span class="string">[decoration=&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    	markings,</span></span></span><br><span class="line"><span class="tag"><span class="string">    	mark=at position 1 with &#123;\arrow[scale=2]</span><span class="string">&#123;angle 90&#125;</span></span>&#125;;</span><br><span class="line">    &#125;]</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (0,6) node(M1) [label=below:秘密消息]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.15]</span><span class="string">&#123;icons/email&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (0,0) node(C) [label=below:载体] &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.08]</span><span class="string">&#123;icons/landscape-image&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (5,10) node(K1) [label=above:秘钥]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.15]</span><span class="string">&#123;icons/house-door-key&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (25,10) node(K2) [label=above:秘钥]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.15]</span><span class="string">&#123;icons/house-door-key&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (30,3) node(M2) [label=below:秘密消息]&#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.15]</span><span class="string">&#123;icons/email&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (10,3) node(S1) [label=below:伪装图像] &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.08]</span><span class="string">&#123;icons/landscape-image&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>  (20,3) node(S2) [label=below:伪装图像] &#123;<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=.08]</span><span class="string">&#123;icons/landscape-image&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[line width=1.1]</span></span> (3.5,2.1) rectangle node(P1)[align=center] &#123;嵌入消息<span class="tag">\<span class="name">\</span></span>（隐写）&#125; (6.5,3.9);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> (23.5,2.1) rectangle node(P2)[align=center] &#123;提取消息<span class="tag">\<span class="name">\</span></span>（恢复）&#125; (26.5,3.9);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> (13.4,2.5) rectangle node(CH1) &#123;公共信道&#125;</span><br><span class="line">(16.6,3.5);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span></span> (13.4,9.5) rectangle node(CH2) &#123;安全信道&#125;</span><br><span class="line">    (16.6,10.5);  </span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>(5,13) node(A) &#123;<span class="tag">\<span class="name">bf</span><span class="string">&#123;发送方&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">path</span></span>(25,13) node(B) &#123;<span class="tag">\<span class="name">bf</span><span class="string">&#123;接收方&#125;</span></span>&#125;;</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (C) -- (3.4,2.5);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (M1) -- (3.4,3.5);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (K1) -- (5,4);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (6.6,3) -- (S1);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (S1)--(13.3,3);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (16.7,3)--(S2);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (S2) -- (23.4,3);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (26.6,3) -- (M2);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[&lt;-&gt;,thick]</span></span> (K1)--(13.3,10);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[&lt;-&gt;,thick]</span></span> (16.7,10)--(K2);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[-&gt;,thick]</span></span> (K2)--(25,4);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[line width=2.5,dashed,dash pattern=on 6pt off 4pt,color=gray]</span></span> (-2,-2) rectangle  (12,12);</span><br><span class="line">    <span class="tag">\<span class="name">draw</span><span class="string">[line width=2.5,dashed,dash pattern=on 6pt off 4pt,color=gray]</span></span> (18,-2) rectangle  (32,12);</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;tikzpicture&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>当然用LaTeX的好处就是插图几乎可以无缝对接到论文或者幻灯片（<code>beamer</code>）中。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://en.wikibooks.org/wiki/LaTeX/Picture&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://en.wikibooks.org/wiki/LaTeX/PGF/TikZ&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/Introduction/illustrations/" data-id="cjm54ylnn0030fkw3wnfpqvvc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LaTeX/">LaTeX</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-Intro-to-greedy-algo1" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/CS161/Intro-to-greedy-algo1/">贪心算法小试牛刀 （一）</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/CS161/Intro-to-greedy-algo1/" class="article-date"><time datetime="2016-10-29T12:03:00.000Z" itemprop="datePublished">2016-10-29</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CS161/">CS161</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇主要介绍贪心算法和其在一些简单规划问题上的应用，对应Stanford算法课（<a href="https://www.coursera.org/learn/algorithm-design-analysis-2" target="_blank" rel="noopener">Algorithms: Design and Analysis, Part 2</a>）第一周内容，在此仅给出一些浅显的综述性的结论和证明，主要针对典型的规划（调度）问题，含有部分相关习题。&lt;!--more--&gt;而涉及图论部分的贪心算法应用预计在几天后在另一篇笔记中具体给出。</p>
<hr>
<p><div class="bs-callout bs-callout-success"><p>贪心算法（&lt;em&gt;Greedy Algorithm&lt;/em&gt;）是指通过每一步决策的<strong>局部最优</strong>达到整体的<strong>全局最优</strong>的一类算法。我们对这个算法并不陌生，无论知道不知道这个名字，对于此类算法的应用都十分熟悉。比如我们寻找单源最短路径的Dijkstra最短路径算法就是贪心策略的典型应用，接下来也会讲到找到最小生成树两种贪心算法，即Prim算法和Kruskal算法。</p>
</div></p>
<p>总的来说，对于很多优化问题，我们很容易想到用贪心算法来解决，这是非常直觉性的选择，对于已经证明正确的贪心算法，分析运行时间也很容易。然而，证明这些已有的贪心算法本来就不是件容易的事，针对于具体的优化问题，依赖于直觉创造出来的贪心算法更是很难保证得到最优解。实际上，大多数贪心算法确实不会给出最优解。</p>
<p>本篇将介绍一些贪心算法在规划（调度）问题上的应用，并使用一种较为普遍适应的证明方法，也就是交换参数（&lt;em&gt;Exchange Argument&lt;/em&gt;）法证明这些贪心算法的正确性。</p>
<hr>
<h2>最优Caching</h2>
<h3>问题定义</h3>
<p>系统调用内容（比如变量）的序列被称为页请求（<em>Page Request</em>）,为了提高计算效率，“常用”的内容会被从大而慢的存储空间（内存）中取出，放入小而快的存储空间（比如Cache），而系统在发出请求时优先到Cache中寻找请求内容是否在其中，如果不在（<em>Cache Miss</em> / <em>Page Fault</em>）则放弃速度去内存中取出该内容，并用它替换Cache中现存的某个内容。</p>
<p>受限于Cache的容量，有时缺页再所难免，但如果能够在<strong>替换</strong>这一操作时合理选择被替换的页（内容），可以避免接下来多次不必要的缺页发生。</p>
<h3>Furthest(Farthest) in future算法</h3>
<p>对于Caching问题来说，我们定义衡量缺页算法的优劣是依据发生缺页的次数，miss发生得越少，代表算法越好。</p>
<p>解决Caching问题的最优算法是Belady在1960s提出的furthest-in-future算法&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，正如字面所示，每当缺页发生时，替换掉在调度序列中从当前项开始最晚出现的项。</p>
<p>当Cache中的初始项和系统请求序列如下所示&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Cache</td>
<td style="text-align:left">a b c d e f</td>
</tr>
<tr>
<td style="text-align:left">请求序列</td>
<td style="text-align:left"><code>g</code> a b c e d a b b a c d e a <code>f</code> a d e f g h ...</td>
</tr>
</tbody>
</table>
<p>处理第一个请求<code>g</code>时发生了缺页，此时选择替换原Cache中的一项，根据furthest-in-future原则，选择<code>g</code>之后在请求序列中最晚出现且在原Cache中的项即<code>f</code>作为被替换的项。</p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt;定理</h4>
<p>furthest-in-future算法是最优的Caching算法，也就是使缺页（更替）次数最小的算法。</p>
</div></p>
<p>这是非常典型的贪心策略，接下来我们将证明该算法的正确性。</p>
<h3>证明</h3>
<p>证明这个算法所使用的是对于贪心算法非常常用的交换参数法。</p>
<p>首先介绍一种较为一般性的Caching算法分类，即简化淘汰调度（<em>Reduced Eviction Schedules</em>）：仅当一项被请求时才把该项插入Cache的调度。
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/intro-to-greedy-algorithm/reduced_schedule.png" alt="非简化调度与简化调度，左第一列代表左边表示请求序列，接下来三列为Cache内容，标红的项为该步发送替换（淘汰）的项&amp;lt;sup id=&amp;quot;fnref:2&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#fn:2&amp;quot; rel=&amp;quot;footnote&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/sup&amp;gt;">
而所有的非简化调度都可以转化为缺页次数不超过原调度的简化调度。</p>
<p>对于给定任意一个调度$S$，都可以被转换为调度$S'$，而$S'$发生缺页的次数不多于$S$，证明如下</p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark&quot;&gt;&lt;/i&gt; 证明</h4>
<p>假设$S$在$t$时刻在Cache中放入$d$，而此时并没有发生$d$的请求（这也是被称为<em>非简化调度</em>的原因），令$c$表示放入$d$前Cache中存在的项（即被替换的项）</p>
<p>那么存在以下两种情况：</p>
<p>第一种情况是$d$并没有被保存到$d$的下一次请求，在$t'$时刻收到了$e$的请求，于是放弃了$d$存入了$e$
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/intro-to-greedy-algorithm/trans-case-1.png" alt="Case 1:在$t'$时刻（$d$被再次请求前）$d$被$e$替代">
显然在结果上可以等效于$t'$时刻用$e$替换$c$的调度，$S \to S'$减少了一次替换</p>
<p>第二种情况则是在$d$被替换之前，又收到了$d$的请求，此时因为$d$在Cache中，没有发生缺页
<img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/intro-to-greedy-algorithm/trans-case-2.png" alt="Case 2:在$t'$时刻$d$被请求前没有发生替换">
很显然可以等效于在$t'$时刻用$d$替换$c$，$S \to S'$替换发生的次数不变 ■</p>
<p>值得一提的是，对于简化淘汰调度来说，发生缺页的次数等于发生更替的次数，但对于非简化调度调度，因为不发生缺页也会换页（替代），此时考察缺页次数就没什么意义了，从<a href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89">问题定义</a>中我们就假设了所有调度都是用的简化淘汰的方法避免讨论缺页&amp;换页哪个作为优化目标的问题，最终目标都是要优化替换次数的。</p>
</div></p>
<p>通过以上证明，很容易得出结论，最优Caching调度一定是简化淘汰调度。</p>
<p>现在要证明一个定理</p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt;定理</h4>
<p>对于任意$n \ge 0$且不超过请求队列长度的整数$n$，存在一个前$n$项所有换页都与farthest-in-future调度$S_{FF}$相同的最优简化淘汰调度$S$。</p>
</div></p>
<p>这个定理基本上就是直接说了farthest-in-future调度就是最优算法了。</p>
<p><s>仍然是“这也要证？”的废话</s>证明的方法是归纳法：</p>
<p>首先当$n=0$时显然这个定理成立<s>这不废话么</s></p>
<p>接下来我们假设当$n=j$时定理的结论成立，存在一个这样的$S$，需要证明当$n=j+1$时这个定理依然成立，因为是存在性证明，只需要借助于$S$构造一个前$j+1$项换页与$S_{FF}$完全一致的最优简化淘汰调度$S'$，这里假设第$j+1$个请求的内容为$d$，分为以下几种情况讨论：</p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 1</h4>
<p>如果$d$已经在Cache中了，那么没有缺页发生，不存在换页，$S'=S$即可符合要求。</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 2</h4>
<p>如果$d$不在Cache中但$S$和$S_{FF}$换掉了同一项内容，依然可以令$S'=S$使命题成立。</p>
</div></p>
<p>这两种情况都没有在$S$的基础上增加$S'$的换页次数，$S'$依然是简化最优调度，且与$S_{FF}$在前$j+1$歩完全一致。</p>
<p>如果$d$不在Cache中，为了把$d$放入Cache，$S_{FF}$换掉了$e$，而$S$换掉了$f$且$f \ne e$，就是我们讨论的第三种情况。</p>
<p>在Case 3我们要证明的是换掉$e$不比换掉$f$差，这也就是$S_{FF}$的体现，现在构造基于$S$构造一个$S'$，把$S$的Cache中的$e$换成$f$</p>
<p>容易看出$S'$和$S$目前为止换页次数相同，既然$S$是最优的，$S'$目前（至少前$j+1$步)也可以认为是最优的。</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/intro-to-greedy-algorithm/case-3.png" alt="$S$与$S'$在第$j+1$步换掉了不同的项，除此以外其他部分完全相同&amp;lt;sup id=&amp;quot;fnref:2&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;#fn:2&amp;quot; rel=&amp;quot;footnote&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/sup&amp;gt;"></p>
<p>用$j'$表示在$j+1$步后$S$和$S'$第一次发生不同操作的歩数，这个操作也必然与$e$或$f$中至少一个相关，令$g$代表$j'$时刻的请求项</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/intro-to-greedy-algorithm/j-prime-time.png" alt=""></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-times-circle&quot;&gt;&lt;/i&gt; Case 3a: $g=e$</h4>
<p>这是不可能发生的情况,$S_{FF}$要求替换最晚出现的项，既然在$S_{FF}$ 中已经换掉了$e$，说明$e$是当时Cache中最晚出现的，所以$e$的请求不可能先于$f$</p>
</div></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 3b: $g=f$</h4>
<p>$f$不在$S$的Cache中，假设接下来$S$换掉的Cache内容为$e'$</p>
<ul>
<li>如果$e'=e$，$S'$直接可以从Cache中获得$f$而不发生缺页，现在$S$和$S'$的Cache内容相同，</li>
<li>如果$e' \ne e$，$S'$把$e'$换成$e$后Cache内容和$S$相同，此事$S'$不是简化最优调度，但可以转化为换页次数不多于其本身的简化最优调度，而且根据Case 3a的讨论，转化后新的$S'$前$j+1$步也与$S_{FF}$一致</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 3b: $g \ne e$且$g \ne f$</h4>
<p>此时$S$必然换掉$e$，只需要$S'$换掉$f$，两者的Cache内容就再次相同</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/intro-to-greedy-algorithm/j-prime-time2.png" alt=""></p>
</div></p>
<p>至此，我们找到了一个前$j+1$步换页与$S_{FF}$完全一致的简化最优调度$S'$，因此命题成立 ■</p>
<p>综上所述，当取$n$为调度队列长度时，命题依然成立，因此可以认为farthest-in-future算法是最优的Caching算法</p>
<h2>后记</h2>
<p>本文只是简单地介绍和证明了贪心算法的一个微小的应用,更多内容将在以后的笔记中给出。</p>
<p>笔记中的证明脉络主要参考了&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，因为我认为这是我看见的材料中最清晰完整的证明，当然也有很多相关的资料可以阅读一下，比如&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;给出的是类似的思路而且更具体（实例化）一些，但符号标记问题可能看着有些麻烦；再如&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;紧扣Argument Exchange大法用词颇为规范当读上去略晦涩。</p>
<p>当然这个问题本身不是很实际，在实践中，几乎不可能一开始就知道完整的请求队列，更不可能知道将来最晚出现的是Cache中的哪一项，我们讨论的是离线Caching问题，可以在调度前就知道请求队列，而事实上比较受关注的问题是如何在不知道后面会请求什么内容的情况下的在线Caching问题，常用的是LRU算法&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;。</p>
<p>至于为什么要费这么大力气去写farthest-in-future的证明，看似是毫无意义的茴香豆，实际上对于此类贪心算法证明的规范训练是件很有意义的事，至少有了这样的思路帮助我们看待其他问题的时候，依靠直接迅速找到一个正确的贪心算法，并知道怎样去证明这个贪心算法为什么是正确的，这是应用贪心算法过程中两个非常困难的问题，但很多时候解决的方法和farthest-in-future并无本质差异。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Belady, Laszlo A. &quot;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.641.9013&amp;rep=rep1&amp;type=pdf&quot;&gt;A study of replacement algorithms for a virtual-storage computer.&lt;/a&gt;&quot; &lt;em&gt;IBM Systems journal&lt;/em&gt; 5.2 (1966): 78-101.&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;例子来源于 http://www.cs.princeton.edu/courses/archive/spr05/cos423/lectures/04greed.pdf&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;HENRY POON'S BLOG：&lt;a href=&quot;https://blog.henrypoon.com/blog/2014/02/02/proof-of-the-farthest-in-future-optimal-caching-algorithm/&quot;&gt;Proof of the Farthest-in-Future Optimal Caching Algorithm&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:4&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;4.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://www.cs.umd.edu/class/fall2009/cmsc451/lectures/Lec05b-optcache.pdf&lt;/span&gt;&lt;a href=&quot;#fnref:4&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:5&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;5.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU&lt;/span&gt;&lt;a href=&quot;#fnref:5&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/CS161/Intro-to-greedy-algo1/" data-id="cjm54yld90004fkw3jh61jsrx" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/规划问题/">规划问题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/贪心算法/">贪心算法</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="active"><span class="page-number">5</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-next" rel="next" href="/page/6/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p> <p>随着一次次的失败，一无所有的作者我已经别无所求了，只想安静的生活下去，不想再被打扰。谢谢大家的关心和照顾，可惜我已经无力回报，非常对不起。有事请联系<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">43</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
        </li>
      
        <li>
          <a href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
