<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/5/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-SICP-with-DrRacket" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/SICP-with-DrRacket/">SICP从DrRacket钻了出来</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/SICP-with-DrRacket/" class="article-date"><time datetime="2018-09-22T14:22:36.245Z" itemprop="datePublished">2018-09-22</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>标题致敬<a href="https://music.163.com/#/song?id=460880169" target="_blank" rel="noopener">沙丁鱼从地里钻了出来（イワシがつちからはえてくるんだ）</a></p>
</blockquote>
<p>在条件允许的情况下，一般建议阅读<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a> 和实验时用GNU/MIT Scheme比较合适，不过我之前习惯写了Racket语言懒得转过去，所以还是用DrRacket环境了。我在这里碎碎念一些遇到的问题和解决的方法，其中也不少借助了前人的资料和其他友人的指导，希望能帮助后来人避开一些坑。</p>
<p>&lt;!-- more --&gt;</p>
<h4>参考资料</h4>
<ul>
<li>我的知乎相关回答 https://www.zhihu.com/question/21207722/answer/441645471</li>
<li>我在GitLab上SICP学习项目 https://gitlab.com/xyli/SICP-learning-notes</li>
<li>Racket中文FAQ https://racket-zh.org/faq</li>
<li>DrRacket的安装与SICP的配置 https://zhuanlan.zhihu.com/p/37056659</li>
</ul>
<p>所以具体怎么安装DrRacket和<a href="http://docs.racket-lang.org/sicp-manual/index.html" target="_blank" rel="noopener">SICP collection</a>就不必多说了，早一些的资料可能会提到PLaneT包的<a href="https://planet.racket-lang.org/package-source/neil/sicp.plt/1/18/planet-docs/sicp/index.html" target="_blank" rel="noopener">neil/SICP</a>即</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#lang planet neil/sicp</span><br></pre></td></tr></table></figure></p>
<p>但这个包已经<strong>停止维护</strong>了，而且作者也加入了新的SICP支持包的开发团队。所以我也还是推荐按照上述方法按照后使用</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br></pre></td></tr></table></figure></p>
<p>接下来会给出一些我在直接使用书中代码实验时遇到的困难，并且将根据我自己的学习进度<strong>保持更新</strong>。</p>
<hr>
<h2>Picture Language</h2>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%25_sec_2.2.4" target="_blank" rel="noopener">2.2.4  Example: A Picture Language</a> 整个小节的环境差不多都是自定义的，所以其实也无所谓什么语言标准差异了。使用前先声明
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br><span class="line">(#%require sicp-pict)</span><br></pre></td></tr></table></figure></p>
<p>几个primitive painter过程对象如<code>rogers</code>和<code>wave</code>都没有在这个包里实现，不过也无所谓，反正那几个图案你在图样图sample也见过了，主要是测试接下来你写的那些图片处理（旋转，放缩，组合）函数是否正确，那么用这个包的其他<code>painter</code>也可以。</p>
<p>可以通过指定一个<code>0-255</code>的灰度值用<code>(number-&gt;painter color)</code>构造一个色块作为<code>painter</code>，或者指定一个图片文件路径用<code>(load-painter filename)</code>构造一个<code>painter</code>。当然我自己为了方便起见直接用built-in的两个<code>painter</code>了
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">paint</span> einstein)</span><br><span class="line">(<span class="name">paint</span> diagonal-shading)</span><br></pre></td></tr></table></figure></p>
<p>调用这两个<code>paint</code>过程会在REPL中打印这两个<code>painter</code>，前者是爱因斯坦的画像，后者是一个沿着对角线方向渐变的灰色色块。<code>einstein</code>和<code>diagonal-shading</code>都是已经被定义完成的<code>painter</code>，都可以用来作为这小节各个函数定义的测试输入。</p>
<p>这个环境中的<code>(transform-painter origin corner1 corner2)</code>的返回结果为<code>(painter? -&gt; painter?)</code>的函数，而原书的<code>transform-painter</code>原型则是<code>(transform-painter painter origin corner1 corner2)</code>，需要包括被变形的<code>painter</code>在内的四个参数，直接返回变形结果，而非我们的package中定义的返回一个变形函数。需要稍微注意一下，以免编写时出现传参错误。</p>
<h2>Case Sensitive</h2>
<p>Racekt语言区分符号和其他identifier的大小写&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，而MIT Scheme并不区分。但SICP包并没有在这一点沿用模仿Scheme的特性
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br><span class="line">(<span class="name"><span class="builtin-name">eq?</span></span> <span class="symbol">'A</span> <span class="symbol">'a</span>) <span class="comment">;#f</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-16.html#%25_thm_2.70" target="_blank" rel="noopener">Exercise 2.70</a>所使用的Huffman树alphabet全为大写，需要编码的message部分却是含有部分小写。会导致无法找到目标字符在树中的位置。可以使用<code>#ci</code>前缀令所有字符都case-fold到小写
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tree (<span class="name">generate-huffman-tree</span> #ci'((WAH <span class="number">1</span>)</span><br><span class="line">                                         (BOOM <span class="number">1</span>)</span><br><span class="line">                                         (A <span class="number">2</span>)</span><br><span class="line">                                         (GET <span class="number">2</span>)</span><br><span class="line">                                         (JOB <span class="number">2</span>)</span><br><span class="line">                                         (SHA <span class="number">3</span>)</span><br><span class="line">                                         (YIP <span class="number">9</span>)</span><br><span class="line">                                         (NA <span class="number">16</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> message #ci'(Get a job</span><br><span class="line">                     Sha na na na na na na na na</span><br><span class="line">                     Get a job</span><br><span class="line">                     Sha na na na na na na na na</span><br><span class="line">                     Wah yip yip yip yip yip yip yip yip yip</span><br><span class="line">                     Sha boom))</span><br></pre></td></tr></table></figure></p>
<h2>Get/Put</h2>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-17.html#%25_sec_2.4.3" target="_blank" rel="noopener">2.4.3 Data-Directed Programming and Additivity</a>已经开始使用<code>put</code>和<code>get</code>两个过程了，实际上MIT Scheme也没有内置它们的实现，但书中假设我们已经实现了，Chapter 2都在直接使用它们。实质上，<code>put</code>是对一个二维表进行增操作，<code>get</code>是对同一个二维表进行查操作，这些在Chapter 3，具体来说是<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_sec_3.3.3" target="_blank" rel="noopener">3.3.3  Representing Tables</a>部分给出了两个函数的定义。为了提前使用可以照抄Chapter 3二维表部分的所有定义内容，也可以通过Racket的内置hash table实现：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br><span class="line">(#%require (<span class="name">only</span> racket/base make-hash hash-ref hash-set!))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> *op-table* (<span class="name">make-hash</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">put</span> op type proc)</span><br><span class="line">  (<span class="name">hash-set!</span> *op-table* (<span class="name"><span class="builtin-name">list</span></span> op type) proc))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get</span> op type)</span><br><span class="line">  (<span class="name">hash-ref</span> *op-table* (<span class="name"><span class="builtin-name">list</span></span> op type) <span class="literal">#f</span>)</span><br></pre></td></tr></table></figure></p>
<h2>Cyclic List</h2>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.16" target="_blank" rel="noopener">Exercise 3.16</a> 开始出现带有回路的list结构，比如这里一个“长度为无穷大”的list
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#lang sicp</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> n3 (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'c</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> n2 (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'b</span> n3))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> w (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'a</span> n2))</span><br><span class="line">(<span class="name"><span class="builtin-name">set-cdr!</span></span> n3 w)</span><br></pre></td></tr></table></figure></p>
<p>在DrRacket的REPL下调用<code>display</code>可以看到这个pair结构是这样表示的
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">display</span></span> w)</span><br><span class="line"><span class="comment">;#0=(a b c . #0#)</span></span><br></pre></td></tr></table></figure></p>
<p>借助于<a href="https://scheme-legacy.apps.cs61a.org/editor.html" target="_blank" rel="noopener">Scheme Editor</a>绘制当前环境的box-pointer以及frame图
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/sicp-with-drraket/cyclic-list.png?inline=false" alt="">
当然我<strong>不推荐</strong>你在Scheme环境下试图直接返回<code>w</code>或者调用<code>(display w)</code>打印这个循环的pair结构，Scheme是个老实人，遇到这些list/pair时不会检查它是否含有回路结构，从而陷入一个找不到出口的递归（死循环），这点在原书上也有相关警告：</p>
<blockquote>
<p>Be careful not to make the interpreter try to print a structure that contains cycles.</p>
</blockquote>
<p>然而这种情况在DrRacket<strong>没什么可担心</strong>的。Racket在表示循环结构时会引入<code>#n=</code>这样的符号，用来递归定义被表示的对象&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。<code>#n</code>可以看作某个反身代词，<code>n</code>的取值为从0开始的整数，用于代表需要被表示的某个单元结构。在上面的表达式<code>#0=(a b c . #0#)</code>中，<code>#0</code>用于指代<code>w</code>,<code>#0=</code>后面的表达式表示<code>#0</code>实际上是什么，是<code>(a b c . #0#)</code>这样一个pair，用我们熟悉的写法可以写为<code>(cons 'a (cons 'b (cons 'c #0)))</code>，从<code>w</code>开始用3个<code>cdr</code>可以把这个pair剥茧抽丝到<code>#0#</code>（<code>#0</code>的引用），也就是<code>w</code>本身。</p>
<p>当然，<code>#n</code>的写法也可以用来表达非循环对象&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，比如<code>(list 100 100 100)</code>可以表示为<code>(#1=100 #1# #1#)</code>。</p>
<p>所以在DrRacket调试带有回路的list时，就算debug工具的中间量也可以直接显示这种表示，就没必要像原书指导的那样如履薄冰了，放心大胆的去尝试探索吧。</p>
<h2>Internal Definitions</h2>
<p>在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-24.html#%25_sec_3.5.4" target="_blank" rel="noopener"><em>3.5.4  Streams and Delayed Evaluation</em></a> 解微分方程的过程中，出现了一个block definition结构的互递归变量定义，当然毫无疑问第一次出现的是哪个Scheme解释器都不可能接受的写法，但是第二次在<code>integral</code>中使用延迟求值参数，如下
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">solve</span> f y0 dt)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> y (<span class="name">integral</span> (<span class="name"><span class="builtin-name">delay</span></span> dy) y0 dt))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> dy (<span class="name">stream-map</span> f y))</span><br><span class="line">  y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">integral</span> delayed-integrand initial-value dt)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> int</span><br><span class="line">    (<span class="name">cons-stream</span></span><br><span class="line">      initial-value</span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">integrand</span> (<span class="name"><span class="builtin-name">force</span></span> delayed-integrand)))</span><br><span class="line">        (<span class="name">add-streams</span> (<span class="name">scale-stream</span> integrand dt) int))))</span><br><span class="line">  int)</span><br></pre></td></tr></table></figure></p>
<p>在GNU/MIT Scheme是支持的，但DrRacket的解释器并不支持这样的写法，会提示这样的错误
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y: undefined;</span><br><span class="line"> cannot use before initialization</span><br></pre></td></tr></table></figure></p>
<p>毕竟它对internal definitions的实现就是这个样子的，我也很无奈，一时也想不到什么合适的解决方案，试过<code>letrec</code>和双<code>delay</code>都无效。这个坑先放着吧。</p>
<p>另外，这个小节围绕的微分方程$$dy/dt=f(y)$$在编程实现中，无论是电路图上还是代码中的中间变量<code>dy</code>，按照我的个人理解，实际上对应的都是公式中的$dy/dt$，这一点十分让人困惑。我想等我有空了还是发邮件问问作者吧（<s>这也要等有空，不是一顺手的事吗，懒癌发作没救了</s>）</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://docs.racket-lang.org/guide/symbols.html&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;见 https://docs.racket-lang.org/reference/pairs.html 4.9.8 Immutable Cyclic Data 部分，顺便小声说一句这种表示法的争议比较大，以前还可以用于直接定义循环对象&lt;code&gt;(define x ’#0=(1 . #0#))&lt;/code&gt;，现在直接废止这种定义法了，只能用于打印显示，详见http://blog.racket-lang.org/2007/11/getting-rid-of-set-car-and-set-cdr.html&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://docs.racket-lang.org/reference/reader.html&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/SICP-with-DrRacket/" data-id="cjuh9jx7w004kfww3j39n9cqm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DrRacket/">DrRacket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-propagation-of-constraints" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/propagation-of-constraints/">约束传播</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/propagation-of-constraints/" class="article-date"><time datetime="2018-09-18T10:53:25.445Z" itemprop="datePublished">2018-09-18</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在之前的文章中我们试着利用可变数据建模完成了<a href="http://notebook.xyli.me/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>系统，<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a>在紧随其后的小节<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_sec_3.3.5" target="_blank" rel="noopener">Propagation of Constraints</a>中用类似的方法实现了一个与之类似的约束系统（constraints system）用于加深对可变数据结构的理解。</p>
<p>&lt;!-- more --&gt;</p>
<p>数字电路模拟系统本身和其他大多数计算机程序体现一部分单向约束的性质，即给定足够的输入值即可约束输出值。而在实际的建模中，约束关系往往是双向的，给定一个等式关系，已知其中足够的变量值，就可以推导出其中未知变量的值。比如书中给的一个机械结构相关的方程&lt;a name=&quot;eq1&quot;&gt;&lt;/a&gt;：$$dAE=Fl$$其中$d$是金属杆的偏转（deflection），$A$为金属杆的横截面积（cross-sectional area），$E$为弹性模量（elastic modulus），$F$是作用于金属杆的力（force），$l$为杆的长度（length）。这个等式关系保证了获得了其中任意四个变量的值即可求得到剩下的那个变量的值，无论这些量在等式的左边还是右边。但传统的程序设计语言迫使我们把这些量的计算表达为单向的赋值（assignment），同一个程序无法用于计算在等式两边的量，当然也无法用于计算在等式一边的两个量。</p>
<p>在本文中，我们的目标是给约束系统的实现提供一些简单的支持，就像前文所设计的电路模拟系统，我们在此也用scheme设计一个能添加变量约束并使用它们来完成一些变量求值的系统。很容易想象，需要解决的问题是某个值确定后，它参与的约束关系中的其他值是否也会被确定？而它们被确定后它们参与的其他约束中的其他值是否也会被确定？这样如同多米诺骨牌的坍塌来自于约束关系本身之间的连接，环境中的约束关系们形成了一个约束网络（constraint network），而痛点在于如何实现新设置的值在这个网络中无向的传播。</p>
<p>正如前文所说，这里的实现非常类似于数字电路模拟器，但约束系统却不要求约束传播（constraint propagation）的行为存在延迟，比起电路更纯粹的地方便是不用<code>agenda</code>来规划值的变化，只需即时反馈。而相比电路复杂的地方，在于值的传播是在整个网络中无向的。接下来，我们就要一步步用scheme去完成这样的系统。</p>
<h2>Connector</h2>
<p>连接器<code>connector</code>可以类比为数字电路的<a href="http://notebook.xyli.me/SICP/represent-digital-circuits-simulator/#Wire"><code>wire</code></a>对象，可以看成一个“装载”变量值的容器，是参与约束的基本元素，比如<a href="#eq1">上式</a>的五个变量分别可以看成一个<code>connector</code>。除了要求能容纳变量值的信息，它能被放置到约束网络，也同时要求它记录着自己参与了哪些约束。</p>
<p>更具体的去考虑它应该满足的性质，还需要能够实现以下针对它的操作：</p>
<ul>
<li><code>(has-value? &lt;connector&gt;)</code> 这个变量的值是否已知</li>
<li><code>(get-value &lt;connector&gt;)</code> 返回这个变量当前的值</li>
<li><code>(set-value! &lt;connector&gt; &lt;new-value&gt; &lt;informant&gt;)</code> 把当前变量<code>connector</code>的值根据<code>informat</code>的指令设置为新值<code>new-value</code>，这里的<code>informat</code>泛指一切有权改变<code>connector</code>值的对象，比如直接来自用户<code>'user</code>的命令，或者它参与的约束，可以在收集了关于其他变量的足够信息后来确定它的值。</li>
<li><code>(forget-value! &lt;connector&gt; &lt;retractor&gt;)</code> 让<code>connector</code>根据<code>retractor</code>的要求丢弃掉现在的值。这是与前一个函数相对的操作，<code>retractor</code>同样可以是用户或者约束</li>
<li><code>(connect &lt;connector&gt; &lt;new-constraint&gt;)</code> 令<code>connector</code>参与新的约束<code>new-constraint</code></li>
</ul>
<p>如果选择模仿<code>wire</code>的实现，把<code>connector</code>表达为message-passing风格的，带有局部状态变量的过程对象，那么封装在每个<code>connector</code>的局部变量应该有这样的三个：</p>
<ul>
<li><code>value</code>： <code>connector</code>当前装载的变量值，初始化为<code>#f</code>表示当前没有值，在被设置后为具体的变量值</li>
<li><code>constraints</code>: <code>connector</code>参与的所有约束，是一个由<code>constraint</code>构成的<code>list</code>，初始化为空列表</li>
<li><code>informant</code>：最后一次改变<code>connector</code>值时的对象</li>
</ul>
<p>前两个变量可以分别类比为<code>wire</code>的局部变量<code>signal-value</code>和<code>action-procedures</code>，而增加的<code>informant</code>是由于约束的传播是无向的，被要求丢弃当前值时必须确认这个请求是否来自之前设置它的值的对象，保证数据的一致性。
&lt;a name=&quot;make-connector&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-connector</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">value</span> false) (<span class="name">informant</span> false) (<span class="name">constraints</span> '()))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-my-value</span> newval setter)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">not</span></span> (<span class="name">has-value?</span> me))</span><br><span class="line">             (<span class="name"><span class="builtin-name">set!</span></span> value newval)</span><br><span class="line">             (<span class="name"><span class="builtin-name">set!</span></span> informant setter)</span><br><span class="line">             (<span class="name">for-each-except</span> setter</span><br><span class="line">                              inform-about-value <span class="comment">;defined differently for different constraint</span></span><br><span class="line">                              constraints))</span><br><span class="line">            ((<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">=</span></span> value newval)) <span class="comment">;has a value different from the designated value</span></span><br><span class="line">             (<span class="name">error</span> <span class="string">"Contradiction"</span> (<span class="name"><span class="builtin-name">list</span></span> value newval)))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> <span class="symbol">'ignored</span>)))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">forget-my-value</span> retractor)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> retractor informant)</span><br><span class="line">          (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name"><span class="builtin-name">set!</span></span> informant false)</span><br><span class="line">                 (<span class="name">for-each-except</span> retractor</span><br><span class="line">                                  inform-about-no-value <span class="comment">;defined differently for different constraint</span></span><br><span class="line">                                  constraints))</span><br><span class="line">          <span class="symbol">'ignored</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">connect</span> new-constraint)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">memq</span></span> new-constraint constraints)) <span class="comment">;ensure the constraint NEW</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">set!</span></span> constraints</span><br><span class="line">                (<span class="name"><span class="builtin-name">cons</span></span> new-constraint constraints)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">has-value?</span> me) <span class="comment">;already has a value</span></span><br><span class="line">          (<span class="name">inform-about-value</span> new-constraint)) <span class="comment">;propagate immediately</span></span><br><span class="line">      <span class="symbol">'done</span>)</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">me</span> request)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'has-value?</span>)</span><br><span class="line">             (<span class="name"><span class="builtin-name">if</span></span> informant true false))</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'value</span>) value)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'set-value!</span>) set-my-value)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'forget</span>) forget-my-value)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'connect</span>) connect)</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Unknown operation -- CONNECTOR"</span></span><br><span class="line">                         request))))</span><br><span class="line">    me))</span><br></pre></td></tr></table></figure></p>
<p>在<code>set-my-value</code>和<code>forget-my-value</code>这两个对偶的局部过程中用到的<code>for-each-except</code>定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">for-each-except</span> exception procedure list)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">loop</span> items)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">null?</span></span> items) <span class="symbol">'done</span>)</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> items) exception) (<span class="name">loop</span> (<span class="name"><span class="builtin-name">cdr</span></span> items)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">procedure</span> (<span class="name"><span class="builtin-name">car</span></span> items))</span><br><span class="line">                (<span class="name">loop</span> (<span class="name"><span class="builtin-name">cdr</span></span> items)))))</span><br><span class="line">  (<span class="name">loop</span> list))</span><br></pre></td></tr></table></figure></p>
<p>对<code>list</code>中除了<code>exception</code>以外的对象都依次当成参数执行<code>procedure</code>过程。这两个局部过程都是由于值的改变需要传播给参与约束的其他变量，所以调用它参与的约束的<code>inform-about-value</code>或<code>inform-about-no-value</code>过程，这两个过程的定义根据被调用的约束对象<code>constraint</code>的不同会调用不同的过程，这种行为有些类似于面向对象编程的多态（polymorphism）概念，它们的具体实现会在后文定义不同的<code>constraint</code>时详细给出。至于为什么必须把传值的约束排除出列表，很好理解，除了本身没必要以外，还会造成该约束不断地再次传值回来，使得传播无法终止。</p>
<p><code>forget-my-value</code>会检查<code>retractor</code>是否为<code>informant</code>，因为如果丢弃值的请求并非来自确定值的约束，那么其他约束中缺失了某个值，对确定这个<code>connector</code>实际上是没有影响的。比如<code>a=b+c,c=d*e</code>，如果<code>c</code>的值已经由<code>a=b+c</code>约束确定了，那么<code>e</code>值丢失通过<code>c=d*e</code>传递到<code>c</code>，<code>c</code>的值还是由<code>a</code>和<code>b</code>决定的，不需要理会<code>e</code>值丢失的通知。</p>
<p><code>me</code>过程的作用相当于我们之前见过的<code>dispatch</code>过程，每个<code>connector</code>实质上也由<code>me</code>过程对象来表示的。接下来还是依循惯例用语法接口把它包装得更像一个数据对象而非过程对象：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">has-value?</span> connector)</span><br><span class="line">  (<span class="name">connector</span> <span class="symbol">'has-value?</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-value</span> connector)</span><br><span class="line">  (<span class="name">connector</span> <span class="symbol">'value</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-value!</span> connector new-value informant)</span><br><span class="line">  ((<span class="name">connector</span> <span class="symbol">'set-value!</span>) new-value informant))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">forget-value!</span> connector retractor)</span><br><span class="line">  ((<span class="name">connector</span> <span class="symbol">'forget</span>) retractor))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">connect</span> connector new-constraint)</span><br><span class="line">  ((<span class="name">connector</span> <span class="symbol">'connect</span>) new-constraint))</span><br></pre></td></tr></table></figure></p>
<h2>Constraint</h2>
<p>约束<code>constraint</code>类似于数字电路的<a href="http://notebook.xyli.me/SICP/represent-digital-circuits-simulator/#Function-box">功能元件（function box）</a>，用于规定<code>connector</code>之间的关系。<code>connector</code>之间通过<code>constraint</code>通信，更具体来说，<code>connector</code>的变值操作通过对<code>constraint</code>的<code>inform-about-value</code>/<code>inform-about-no-value</code>传递给同一个约束的其他<code>connector</code>，正如前文所给的<code>for-each-except</code>规定的传播关系。那么<code>constraint</code>自然需要有以下过程可供操作</p>
<ul>
<li><code>(inform-about-value &lt;constraint&gt;)</code> 通知<code>constraint</code>约束关系中有一个<code>connector</code>的值被设置了，需要刷新确定其他参与该约束的<code>connector</code>的值</li>
<li><code>(inform-about-no-value &lt;constraint&gt;)</code>通知<code>constraint</code>约束关系中有一个<code>connector</code>的值被丢弃了，需要刷新丢弃其他参与该约束的<code>connector</code>的值</li>
</ul>
<p>具体如何设置和丢弃约束中其他量，需要根据约束的类型而确定。</p>
<p>复杂的约束也可以通过简单的约束组合而成，这里我们使用三种基础的约束关系<code>adder</code>，<code>multiplier</code>和<code>constant</code>作为primitive constraint，这个选择并非基于任何理论基础，只是为了演示方便，你完全可以定义其他的primitive constraint作为基本元件来组装你自己的约束网络。</p>
<h3>Primitive constraints</h3>
<p><code>(adder a1 a2 sum)</code>构造了一个表示<code>a1+a2=sum</code>的加法关系约束，已知其中任意两个量可以得到第三个量。也用message-passing风格的写法定义：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">adder</span> a1 a2 sum)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> a1) (<span class="name">has-value?</span> a2))</span><br><span class="line">           (<span class="name">set-value!</span> sum</span><br><span class="line">                       (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">get-value</span> a1) (<span class="name">get-value</span> a2)) <span class="comment">;sum=a1+a2</span></span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> a1) (<span class="name">has-value?</span> sum))</span><br><span class="line">           (<span class="name">set-value!</span> a2</span><br><span class="line">                       (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">get-value</span> sum) (<span class="name">get-value</span> a1)) <span class="comment">;a2=sum-a1</span></span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> a2) (<span class="name">has-value?</span> sum))</span><br><span class="line">           (<span class="name">set-value!</span> a1</span><br><span class="line">                       (<span class="name"><span class="builtin-name">-</span></span> (<span class="name">get-value</span> sum) (<span class="name">get-value</span> a2)) <span class="comment">;a1=sum-a2</span></span><br><span class="line">                       me))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">forget-value!</span> sum me)</span><br><span class="line">    (<span class="name">forget-value!</span> a1 me)</span><br><span class="line">    (<span class="name">forget-value!</span> a2 me)</span><br><span class="line">    (<span class="name">process-new-value</span>))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-have-a-value</span>)  </span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-lost-my-value</span>)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">           (<span class="name">error</span> <span class="string">"Unknown request -- ADDER"</span> request))))</span><br><span class="line"></span><br><span class="line">  (<span class="name">connect</span> a1 me)</span><br><span class="line">  (<span class="name">connect</span> a2 me)</span><br><span class="line">  (<span class="name">connect</span> sum me)</span><br><span class="line"></span><br><span class="line">  me)</span><br></pre></td></tr></table></figure></p>
<p><code>adder</code>过程的返回对象是加法约束关系构造完成后的局部过程<code>me</code>，<code>me</code>就代表这个约束关系本身。同时<code>me</code>也充当了其他函数的<code>dispatch</code>角色根据需求调用不同的过程。另外，函数中调用了许多如<code>set-value!</code>等需要一个<code>constraint</code>对象作为一个参数的过程，都使用<code>me</code>代表这个<code>adder</code>实例作为实参传入了，它就像C++的<code>this</code>指针或者Python的<code>self</code>对象，<code>connector</code>的某些操作需要填入来自于哪个<code>constraint</code>，它就在这里签名“是我干的”，至于“我”是谁，从外部当然能看得到。</p>
<p>局部过程<code>process-new-value</code>根据加法等式关系，确定并设置未知量。局部过程<code>process-forget-value</code>丢弃掉所有根据这个<code>adder</code>关系决定的值，并再次调用<code>(process-new-value)</code>恢复一些根据这个关系和关系中依然已知的值（比如常量）确定的变量值。</p>
<p>当然，还是需要用一直和<code>dispatch</code>连用的语法接口继续封装一下：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inform-about-value</span> constraint)</span><br><span class="line">  (<span class="name">constraint</span> <span class="symbol">'I-have-a-value</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inform-about-no-value</span> constraint)</span><br><span class="line">  (<span class="name">constraint</span> <span class="symbol">'I-lost-my-value</span>))</span><br></pre></td></tr></table></figure></p>
<p>Scheme是动态类型语言，调用<code>inform-about-value</code>/<code>inform-about-no-value</code>时也不会检查<code>constraint</code>是否是<code>adder</code>，甚至不会检查是否是<code>constraint</code>，当然<code>constraint</code>本来就是我们自己定义的一个过程对象而已，也没法检查。它只会检查<code>constraint</code>是不是能被以一个参数调用的过程，这就给我们针对不同的约束定义行为不同的<code>(constraint 'I-have-a-value)</code>/<code>(constraint 'I-lost-my-value)</code>过程留下很大的自由。接下来完成的其他约束定义还可以调用<code>inform-about-value</code>和<code>inform-about-no-value</code>过程，但可能在约束中完成的就是完全不同的操作了。</p>
<p>乘法约束与加法约束类似，<code>(multiplier m1 m2 product)</code>构造了<code>m1*m2=product</code>的关系，可以仿照上面的写法完成<code>multiplier</code>的定义，稍有不同的是，<code>m1</code>和<code>m2</code>只要有一个是0，无论另一个取值为多少，<code>product</code>也必须为0
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">multiplier</span> m1 m2 product)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> m1) (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">get-value</span> m1) <span class="number">0</span>))</span><br><span class="line">               (<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> m2) (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">get-value</span> m2) <span class="number">0</span>)))</span><br><span class="line">           (<span class="name">set-value!</span> product <span class="number">0</span> me))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> m1) (<span class="name">has-value?</span> m2))</span><br><span class="line">           (<span class="name">set-value!</span> product</span><br><span class="line">                       (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">get-value</span> m1) (<span class="name">get-value</span> m2))</span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> product) (<span class="name">has-value?</span> m1))</span><br><span class="line">           (<span class="name">set-value!</span> m2</span><br><span class="line">                       (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">get-value</span> product) (<span class="name">get-value</span> m1))</span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name">has-value?</span> product) (<span class="name">has-value?</span> m2))</span><br><span class="line">           (<span class="name">set-value!</span> m1</span><br><span class="line">                       (<span class="name"><span class="builtin-name">/</span></span> (<span class="name">get-value</span> product) (<span class="name">get-value</span> m2))</span><br><span class="line">                       me))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">forget-value!</span> product me)</span><br><span class="line">    (<span class="name">forget-value!</span> m1 me)</span><br><span class="line">    (<span class="name">forget-value!</span> m2 me)</span><br><span class="line">    (<span class="name">process-new-value</span>))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-have-a-value</span>)</span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-lost-my-value</span>)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">           (<span class="name">error</span> <span class="string">"Unknown request -- MULTIPLIER"</span> request))))</span><br><span class="line"></span><br><span class="line">  (<span class="name">connect</span> m1 me)</span><br><span class="line">  (<span class="name">connect</span> m2 me)</span><br><span class="line">  (<span class="name">connect</span> product me)</span><br><span class="line"></span><br><span class="line">  me)</span><br></pre></td></tr></table></figure></p>
<p>所以在<code>(process-new-value)</code>中会先讨论<code>m1</code>或<code>m2</code>为0的情况，这样也避免了之后方向计算<code>product</code>除以<code>m1</code>或<code>m2</code>时出现除零错误的可能性。同样，我们在上面定义的语法接口对<code>multiplier</code>也可以用，即使它的<code>inform-about-value</code>非常不同于加法。</p>
<p>最后我们来定义常量约束<code>(constant value connector)</code>，把<code>connector</code>的值固定为常量<code>value</code>，不可更改也不可丢失，也就是说<code>'I-have-a-value</code>和<code>'I-lost-my-value</code>消息的传入对于这样的常量是没有意义的，会产生错误&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">constant</span> value connector)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name">error</span> <span class="string">"Unknown request -- CONSTANT"</span> request))</span><br><span class="line"></span><br><span class="line">  (<span class="name">connect</span> connector me)</span><br><span class="line">  (<span class="name">set-value!</span> connector value me)</span><br><span class="line"></span><br><span class="line">  me)</span><br></pre></td></tr></table></figure></p>
<h3>Probe</h3>
<p>同样为了观察变量值的变化，需要在<code>connector</code>上安置探针<code>probe</code>。<a href="http://notebook.xyli.me/SICP/represent-digital-circuits-simulator/#Probe">回顾</a>数字电路中安置于<code>wire</code>的探针<code>probe</code>所做的是在<code>wire</code>的<code>action-procedures</code>列表中添加一个打印过程，而这里<code>connector</code>上的<code>probe</code>需要的也是在<code>connector</code>的<code>constraints</code>列表中添加一个过程对象，保证<code>connector</code>的值发生变化（由于局部过程<a href="#make-connector"><code>set-my-value</code></a>/<a href="#make-connector"><code>forget-my-value</code></a>的调用）时遍历调用<code>constraints</code>时顺便调用一个这样一个打印过程，<code>probe</code>的行为在形式上与一般的<code>constraint</code>十分相似。因此为了方便起见，也可以把<code>probe</code>定义为一个类似于<code>constraint</code>的过程对象，传入<code>'I-have-a-value</code>和<code>'I-lost-my-value</code>时只需要打印新的值而不负责传播改变其他<code>connector</code>的值。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">probe</span> name connector)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">print-probe</span> value)</span><br><span class="line">    (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"Probe: "</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">display</span></span> name) <span class="comment">;identifier of the probe</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">display</span></span> <span class="string">" = "</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">display</span></span> value)</span><br><span class="line">    (<span class="name"><span class="builtin-name">newline</span></span>))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name">print-probe</span> (<span class="name">get-value</span> connector)))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">print-probe</span> <span class="string">"?"</span>)) <span class="comment">;indicates the connector has no value</span></span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-have-a-value</span>)</span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-lost-my-value</span>)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">           (<span class="name">error</span> <span class="string">"Unknown request -- PROBE"</span> request))))</span><br><span class="line"></span><br><span class="line">  (<span class="name">connect</span> connector me)</span><br><span class="line"></span><br><span class="line">  me)</span><br></pre></td></tr></table></figure></p>
<p>初始化后的<code>probe</code>同样可以作为<code>constraint</code>以语法接口<code>inform-about-value</code>和<code>inform-about-no-value</code>调用。</p>
<h2>Sample usages</h2>
<p>至此，约束系统的基础环境已经定义结束。我在这里同样把上面用到的所有代码打包，在<a href="https://scheme-legacy.apps.cs61a.org/" target="_blank" rel="noopener">Scheme Interpreter and Visualizer</a>或<a href="https://scheme-legacy.apps.cs61a.org/editor.html" target="_blank" rel="noopener">Editor</a>可以通过命令
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">download</span> <span class="symbol">'9e52aa9cadce69f251a11fed2b0f0e8a</span>)</span><br></pre></td></tr></table></figure></p>
<p>直接使用这个简单的约束系统进行体验。</p>
<p>下面给出一些简单的示例演示如何直接使用我们之前定义的约束。</p>
<h3>Temperature converter</h3>
<p>众所周知，摄氏（Celsius）温度$C$华氏（Fahrenheit）温度$F$之间的关系为$$9C=5(F-32)$$由这个关系构造的约束网络如下图所示
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/constraint-system/temperature-convert.png?inline=false" alt="9C=5(F-32)定义的约束网络">
从左到右三个灰色的盒子分别代表<code>multiplier</code>，<code>multiplier</code>和<code>adder</code>三个约束关系。形参连接的终端为某个量（<code>connector</code>）：如<code>C</code>为摄氏温度的值，<code>F</code>为华氏温度的值，<code>w</code>，<code>x</code>,<code>y</code>分别被设置为常量<code>9</code>,<code>5</code>,<code>32</code>，这里还命名和使用了很多没有在公式中出现的中间量，如<code>u</code>同时参与约束<code>C*w=u</code>和<code>u=v*x</code>，同样<code>v</code>也是这样一个中间量表示<code>v+y=F</code>。整个约束中的变量只有<code>C</code>和<code>F</code>，其他都是常量或是由它们决定的中间量。</p>
<p>那么利用primitives构造的<code>celsius-fahrenheit-converter</code>约束可以表示为&lt;a name=&quot;celsius-fahrenheit-converter&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">celsius-fahrenheit-converter</span> c f)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">u</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">v</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">w</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">x</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">y</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">multiplier</span> c w u)</span><br><span class="line">    (<span class="name">multiplier</span> v x u)</span><br><span class="line">    (<span class="name">adder</span> v y f)</span><br><span class="line">    (<span class="name">constant</span> <span class="number">9</span> w)</span><br><span class="line">    (<span class="name">constant</span> <span class="number">5</span> x)</span><br><span class="line">    (<span class="name">constant</span> <span class="number">32</span> y)</span><br><span class="line">    <span class="symbol">'ok</span>))</span><br></pre></td></tr></table></figure></p>
<p>新建一个<code>celsius-fahrenheit-converter</code>的实例
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> C (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> F (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name">celsius-fahrenheit-converter</span> C F)</span><br></pre></td></tr></table></figure></p>
<p>在终端连接器<code>C</code>和<code>F</code>上安置<code>probe</code>以便观察取值变化
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">probe</span> <span class="string">"Celsius temp"</span> C)</span><br><span class="line">(<span class="name">probe</span> <span class="string">"Fahrenheit temp"</span> F)</span><br></pre></td></tr></table></figure></p>
<p>用户设置<code>C</code>为25可以马上发现<code>C</code>和<code>F</code>的值被确定了
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-value!</span> C <span class="number">25</span> <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: Celsius temp = 25</span></span><br><span class="line"><span class="comment">;Probe: Fahrenheit temp = 77</span></span><br><span class="line"><span class="comment">;'done</span></span><br></pre></td></tr></table></figure></p>
<p>但再次试图直接设置<code>F</code>时发现取值冲突
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-value!</span> F <span class="number">212</span> <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Error! Contradiction (77 212)</span></span><br></pre></td></tr></table></figure></p>
<p>因为<code>F</code>已经被约束关系确定为77了，不能再通过命令直接更改，除非重置清除<code>C</code>的取值
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">forget-value!</span> C <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: Celsius temp = ?</span></span><br><span class="line"><span class="comment">;Probe: Fahrenheit temp = ?</span></span><br><span class="line"><span class="comment">;done</span></span><br></pre></td></tr></table></figure></p>
<p>使得<code>F</code>也同时无法被确定，那么此时再直接设置<code>F</code>为212可以重新获得一组<code>C</code>和<code>F</code>的值
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-value!</span> F <span class="number">212</span> <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: Fahrenheit temp = 212</span></span><br><span class="line"><span class="comment">;Probe: Celsius temp = 100</span></span><br><span class="line"><span class="comment">;done</span></span><br></pre></td></tr></table></figure></p>
<p>至此，我们分别完成了<code>celsius-fahrenheit-converter</code>两个方向的约束传播。</p>
<h3>Averager</h3>
<blockquote>
<p>定义一个约束<code>(averager a b c)</code>，其中<code>a</code>,<code>b</code>和<code>c</code>都是<code>connector</code>，要求满足关系<code>c=(a+b)/2</code></p>
</blockquote>
<p>可以像组装电路一样用我们刚才定义好的三种primitives直接组合，把关系写为<code>a+b=2*c</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">averager</span> a b c)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">a-plus-b</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">const</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">constant</span> <span class="number">2</span> const)</span><br><span class="line">    (<span class="name">adder</span> a b a-plus-b)</span><br><span class="line">    (<span class="name">multiplier</span> const c a-plus-b)) <span class="comment">;a+b=const*c</span></span><br><span class="line">    <span class="symbol">'ok</span>)</span><br></pre></td></tr></table></figure></p>
<p>开始一个实例
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> A (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> B (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> C (<span class="name">make-connector</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">averager</span> A B C)</span><br><span class="line"></span><br><span class="line">(<span class="name">probe</span> <span class="string">"a"</span> A)</span><br><span class="line">(<span class="name">probe</span> <span class="string">"b"</span> B)</span><br><span class="line">(<span class="name">probe</span> <span class="string">"c"</span> C)</span><br></pre></td></tr></table></figure></p>
<p>简单进行操作：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-value!</span> A <span class="number">5</span> <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: a = 5</span></span><br><span class="line"><span class="comment">;done</span></span><br><span class="line"></span><br><span class="line">(<span class="name">set-value!</span> B <span class="number">7</span> <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: b = 7</span></span><br><span class="line"><span class="comment">;Probe: c = 6</span></span><br><span class="line"><span class="comment">;done</span></span><br><span class="line"></span><br><span class="line">(<span class="name">forget-value!</span> A <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: a = ?</span></span><br><span class="line"><span class="comment">;Probe: c = ?</span></span><br><span class="line"><span class="comment">;done</span></span><br><span class="line"></span><br><span class="line">(<span class="name">set-value!</span> C <span class="number">20</span> <span class="symbol">'user</span>)</span><br><span class="line"><span class="comment">;Probe: c = 20</span></span><br><span class="line"><span class="comment">;Probe: a = 33</span></span><br><span class="line"><span class="comment">;done</span></span><br></pre></td></tr></table></figure></p>
<h3>Squarer</h3>
<blockquote>
<p>某人想建立一个<code>(squarer a b)</code>约束，变量值满足关系<code>b=a^2</code>，于是他一拍大腿想到利用<code>multiplier</code>写了一个&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">squarer</span> a b)</span><br><span class="line">  (<span class="name">multiplier</span> a a b))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这个投机取巧的写法存在着严重的缺陷。不同于普通的乘法约束，平方约束关系隐含着<code>b</code>的值必须非负的限制。而且当<code>b</code>的值为0时，<code>a</code>的值也必然为0。另外，如果有<code>a</code>为非负数的约定，那么还可以通过<code>b</code>反向传播得到<code>a</code>的取值。</p>
<p>另一个实现的方法就是从底层开始自己定义<code>squarer</code>约束，把它作为primitive来写，为了简单起见，这里规定<code>a&gt;=0</code></p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="builtin-name">*</span></span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">squarer</span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">has-value?</span> b)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name">get-value</span> b) <span class="number">0</span>)</span><br><span class="line">            (<span class="name">error</span> <span class="string">"square less than 0 -- SQUARER"</span> (<span class="name">get-value</span> b))</span><br><span class="line">            (<span class="name">set-value!</span> a (<span class="name"><span class="builtin-name">sqrt</span></span> (<span class="name">get-value</span> b)) me))</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">has-value?</span> a)</span><br><span class="line">            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name">get-value</span> a) <span class="number">0</span>)</span><br><span class="line">                (<span class="name">error</span> <span class="string">"a less than 0 -- SQUARER"</span> (<span class="name">get-value</span> a))</span><br><span class="line">                (<span class="name">set-value!</span> b (<span class="name">square</span> (<span class="name">get-value</span> a)) me))</span><br><span class="line">              <span class="symbol">'ignore</span>)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">forget-value!</span> a me)</span><br><span class="line">    (<span class="name">forget-value!</span> b me)</span><br><span class="line">    (<span class="name">process-new-value</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-have-a-value</span>)</span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> request <span class="symbol">'I-lost-my-value</span>)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">           (<span class="name">error</span> <span class="string">"Unknown request -- SQUARER"</span> request))))</span><br><span class="line">  (<span class="name">connect</span> a me)</span><br><span class="line">  (<span class="name">connect</span> b me)</span><br><span class="line">  me)</span><br></pre></td></tr></table></figure></p>
<h3>Expression-oriented format</h3>
<p>前文的<a href="#celsius-fahrenheit-converter"><code>celsius-fahrenheit-converter</code></a>定义内部使用了很多中间变量，然后一句句写了连接命令，略显笨拙，我们可以用更简洁的方式重新定义它
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">celsius-fahrenheit-converter</span> x)<span class="comment">;</span></span><br><span class="line">  (<span class="name">c+</span> (<span class="name">c*</span> (<span class="name">c/</span> (<span class="name">cv</span> <span class="number">9</span>) (<span class="name">cv</span> <span class="number">5</span>))</span><br><span class="line">          x)</span><br><span class="line">      (<span class="name">cv</span> <span class="number">32</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> C (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> F (<span class="name">celsius-fahrenheit-converter</span> C))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">c+</span> x y) <span class="comment">;return a connector whose value=x+y</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">z</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">adder</span> x y z)</span><br><span class="line">    z))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">c*</span> x y) <span class="comment">;return a connector whose value=x*y</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">z</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">multiplier</span> x y z)</span><br><span class="line">    z))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">c/</span> x y) <span class="comment">;return a connector whose value=x/y</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">z</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">multiplier</span> z y x)</span><br><span class="line">    z))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cv</span> x) <span class="comment">;return a connector whose value=constant x</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">z</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">constant</span> x z)</span><br><span class="line">    z))</span><br></pre></td></tr></table></figure></p>
<p>这样的定义中，复合成<code>celsius-fahrenheit-converter</code>所用到的单句表达式更符合纯函数式编程的习惯，在这里更是和Scheme原生的前缀算术表达式高度相似；而<a href="#celsius-fahrenheit-converter">原定义</a>则更具指令式编程（imperative programming）的风格。</p>
<p>Lisp允许复合对象作为过程的值返回，所以我们可以轻松转换成上面面向表达式（expression-oriented）的程序写法，而在如Algol, Basic和Pascal（除非熟练指针变量的操作）等不擅长处理复合对象的语言中，处理复合对象就只能用指令式的写法了。当然非面向表达式的写法也同样有不可替代的优势，除了编写时更符合人类自然语言的思维习惯，还有一点是在约束对象和连接器对象上提供了句柄（handle），使得我们在系统中直接用约束扩展的连接扩展更加方便快捷，而不用通过间接变换连接器的操作实现。</p>
<h2>Epilogue</h2>
<p>至此，关于约束系统的讲解已基本结束。虽然上面的工作看上去像是小孩子拿着玩具在过家家，但真实世界中的约束系统还是有不少实用之处的，如果对此感兴趣可以尝试着做一些扩展阅读。</p>
<p>约束传播的概念最早出现在Sutherland&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;在1963年的博士论文中，当然这篇论文网上也很难找了，但容易找到基于相同内容的技术报告材料，不过似乎constraint只是他用以辅助规范graphical language的小工具，并没有非常侧重的去讨论。最早实现的一个优雅的基于 Smalltalk语言的约束传播系统ThinkPad&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;用于仿真。还有一些早期应用于电路分析&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; rel=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;的约束系统。如今在更多领域，<a href="https://en.wikipedia.org/wiki/Constraint_satisfaction" target="_blank" rel="noopener">约束问题</a>都被广泛地讨论着，甚至发展出了<a href="https://en.wikipedia.org/wiki/Constraint_programming" target="_blank" rel="noopener">约束编程（constraint programming）</a>。</p>
<p>当然广义的constraint思想也可以给我们很多问题的启发，比如国内的教科书往往会在提到约束传播时用八皇后问题的求解作为例子。除此以外，也有些很有趣的妙用，如求解数独<a href="http://norvig.com/sudoku.html" target="_blank" rel="noopener">Solving Every Sudoku Puzzle</a>。</p>
<p>在本文的结尾，我想转引SICP第三章用到的两句名言：</p>
<blockquote>
<p>Mεταβάλλον ὰναπαύεται
(Even while it changes, it stands still.)
—Heraclitus</p>
</blockquote>
<p>以及</p>
<blockquote>
<p>Plus ça change, plus c’est la même chose.
—Alphonse Karr</p>
</blockquote>
<p>大意为事物变化得越多，他们保留不变得也越多。它们被用在讲述使用mutable data structure进行编程的第三章，是想告诉你即使使用了不那么纯粹的函数式编程的方式去操纵改变数据，我们还是有办法紧紧抓住数据中不变的部分服务于我们的程序。而我在这里引用这两句话，是想说即使我们不断地去尝试和开拓不同的语言在不同的环境中光怪陆离的用法，实现曾经想都没想过的东西，都是从最基础的用法开始一点点编写，每次写不同的东西最终都是加深对同一个体系的理解，一步步找寻住在计算机内的神灵，在追求本质美丽和自由的道路上曲折前行。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;传入这两个消息直接调用&lt;code&gt;error&lt;/code&gt;过程的写法是SICP给出的，但在实际应用中，尝试对常量进行修改操作一般并非出于用户直接的不当操作，而是它参与的其他约束关系传播过来的变值请求，忽略这些请求返回&lt;code&gt;'ignored&lt;/code&gt;即可，没有必要处理成&lt;code&gt;error&lt;/code&gt;消息。&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;案例来源于&lt;a href=&quot;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.34&quot;&gt;习题3.34&lt;/a&gt;，schemewiki社区对此给出的解释是这个设计的瑕疵在于&lt;code&gt;b&lt;/code&gt;获取值后无法传播给&lt;code&gt;a&lt;/code&gt;，但事实上如果没有限定&lt;code&gt;a&lt;/code&gt;的符号，已知&lt;code&gt;b&lt;/code&gt;的值依然无法确定&lt;code&gt;a&lt;/code&gt;的值。&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Sutherland, Ivan E. &quot;&lt;a href=&quot;https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-574.pdf&quot;&gt;Sketch pad a man-machine graphical communication system.&lt;/a&gt;&quot; In &lt;em&gt;Proceedings of the SHARE design automation workshop&lt;/em&gt;, pp. 6-329. ACM, 1964.&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:4&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;4.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Borning, Alan. &quot;&lt;a href=&quot;https://www.ijcai.org/Proceedings/77-1/Papers/085.pdf&quot;&gt;ThingLab: an object-oriented system for building simulations using constraints.&lt;/a&gt;&quot; In &lt;em&gt;Proceedings of the 5th international joint conference on Artificial intelligence-Volume 1&lt;/em&gt;, pp. 497-498. Morgan Kaufmann Publishers Inc., 1977.&lt;/span&gt;&lt;a href=&quot;#fnref:4&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:5&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;5.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Sussman, Gerald Jay, and Guy Lewis Steele Jr. &quot;&lt;a href=&quot;https://dspace.mit.edu/bitstream/handle/1721.1/6312/AIM-502a.pdf?sequence=2&quot;&gt;CONSTRAINTS—A language for expressing almost-hierarchical descriptions.&lt;/a&gt;&quot; &lt;em&gt;Artificial intelligence&lt;/em&gt; 14, no. 1 (1980): 1-39.&lt;/span&gt;&lt;a href=&quot;#fnref:5&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/propagation-of-constraints/" data-id="cjuh9jxav005pfww348hlft31" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/约束编程/">约束编程</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-102" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-102/" class="article-date"><time datetime="2018-09-16T14:30:58.475Z" itemprop="datePublished">2018-09-16</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-102</p>
<p>&lt;!-- more --&gt;</p>
<h2>Sort Array By Parity</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-102/problems/sort-array-by-parity/</p>
<blockquote>
<p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>You may return any answer array that satisfies this condition.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 5000</code></li>
<li><code>0 &lt;= A[i] &lt;= 5000</code></li>
</ol>
<p>提供一个没动脑子的写法，肯定有比我的方法高效的多的方法，然而懒得写了，因为这题真没什么思考的价值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> A <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>] + [i <span class="keyword">for</span> i <span class="keyword">in</span> A <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<h2>Fruit Into Baskets</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-102/problems/fruit-into-baskets/</p>
<blockquote>
<p>In a row of trees, the <code>i</code>-th tree produces fruit with type <code>tree[i]</code>.</p>
</blockquote>
<blockquote>
<p>You <strong>start at any tree of your choice</strong>, then repeatedly perform the following steps:</p>
</blockquote>
<blockquote>
<p>Add one piece of fruit from this tree to your baskets.  If you cannot, stop.
Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.
Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.</p>
</blockquote>
<blockquote>
<p>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.</p>
</blockquote>
<blockquote>
<p>What is the total amount of fruit you can collect with this procedure?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can collect [1,2,1].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can collect [1,2,2].</span><br><span class="line">If we started at the first tree, we would only collect [0, 1].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,2,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: We can collect [2,3,2,2].</span><br><span class="line">If we started at the first tree, we would only collect [1, 2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Example 4:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We can collect [1,2,1,1,2].</span><br><span class="line">If we started at the first tree or the eighth tree, we would only collect fruits.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= tree.length &lt;= 40000</code></li>
<li><code>0 &lt;= tree[i] &lt; tree.length</code></li>
</ol>
<p>题目说的有点绕，简单来说就是给你一个数组<code>tree</code>，让你找至多包含两个不同元素的连续子数组的最大长度。</p>
<p>当<code>tree</code>的元素不超过两种时，显然返回<code>tree</code>的长度即可。</p>
<p>当<code>tree</code>的元素数量大于2时，使用一个<code>next</code>向量把向右第一个与<code>tree[i]</code>不同的元素坐标<code>j</code>记录到<code>next[i]=j</code>，遍历时迭代找<code>next[j]</code>下标的元素是否还在两种元素内，如果不在则从<code>j</code>开始继续遍历，之前的长度<code>next[j]-i</code>作为候选的结果。如果在则从<code>j=next[j]</code>开始找到第三种元素出现的地方。当然，当<code>next[j]</code>已经到达数组末尾<code>len(tree)</code>时，也没必要再从<code>j</code>开始遍历了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type tree: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        next = [<span class="number">0</span>] * len(tree)</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(set(tree)) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> len(tree)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(tree)):</span><br><span class="line">            <span class="keyword">if</span> tree[i] != tree[cur]:</span><br><span class="line">                next[cur] = i</span><br><span class="line">                cur = i</span><br><span class="line"></span><br><span class="line">        next[cur] = len(tree)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        a, b = tree[i], tree[next[i]]</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(tree):</span><br><span class="line">            a, b = tree[i], tree[next[i]]</span><br><span class="line">            j = next[i]</span><br><span class="line">            <span class="keyword">while</span> next[j] &lt; len(tree) <span class="keyword">and</span> tree[next[j]] <span class="keyword">in</span> (a, b):</span><br><span class="line">                j = next[j]</span><br><span class="line">            res = max(res, next[j] - i)</span><br><span class="line">            <span class="keyword">if</span> next[j] == len(tree):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Sum of Subarray Minimums</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-102/problems/sum-of-subarray-minimums/</p>
<blockquote>
<p>Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.</p>
</blockquote>
<blockquote>
<p>Since the answer may be large, return the answer modulo 10^9 + 7.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].</span><br><span class="line">Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>1 &lt;= A[i] &lt;= 30000</code></li>
</ol>
<p>这个问题实际上已经在<a href="http://notebook.xyli.me/LeetCode/LC891-alter/#%E5%8D%95%E8%B0%83%E6%A0%88">LC891的变体</a>中讨论过了，而且这里只要求最小值之和，正反两个反向用两次单调栈遍历一下即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        s_x, e_x = [<span class="number">-1</span>] * n, [n] * n</span><br><span class="line"></span><br><span class="line">        mono_stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &gt;= A[i]:</span><br><span class="line">                e_x[mono_stack.pop()] = i</span><br><span class="line">            mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">        mono_stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &gt; A[i]:</span><br><span class="line">                s_x[mono_stack.pop()] = i</span><br><span class="line">            mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(A[i] * (e_x[i] - i) * (i - s_x[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<h2>Super Palindromes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-102/problems/super-palindromes/</p>
<blockquote>
<p>Let's say a positive integer is a superpalindrome if it is a palindrome, and it is also the square of a palindrome.</p>
</blockquote>
<blockquote>
<p>Now, given two positive integers <code>L</code> and <code>R</code> (represented as strings), return the number of superpalindromes in the inclusive range <code>[L, R]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: L = &quot;4&quot;, R = &quot;1000&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4, 9, 121, and 484 are superpalindromes.</span><br><span class="line">Note that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= len(L) &lt;= 18</code></li>
<li><code>1 &lt;= len(R) &lt;= 18</code></li>
<li><code>L</code> and <code>R</code> are strings representing integers in the range <code>[1, 10^18)</code>.</li>
<li><code>int(L) &lt;= int(R)</code></li>
</ol>
<p>这题有点<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-92/#Prime-Palindrome">Prime Palindrome</a>的味道，在如何找比一个大于等于<code>n</code>的最小palindrome上可以直接用<code>palind(n)</code>，然后验证其平方是否也为palindrome，当然这么做肯定会超时。我当时是观察了所有平方数也为palindrome的palindrome，发现除了中间位，它的每一位都不能超过2，我当时也不知道该如何证明这个结论，就直接用了，在<code>palind(n)</code>加上了各位不能超过2的限制。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superpalindromesInRange</span><span class="params">(self, L, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type L: str</span></span><br><span class="line"><span class="string">        :type R: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">palind</span><span class="params">(n)</span>:</span></span><br><span class="line">            x = str(n)</span><br><span class="line">            l = len(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l / <span class="number">2</span>) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> int(x[i]) &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> palind(n + <span class="number">10</span>**(l - i) - int(x[i:]))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l / <span class="number">2</span>)):</span><br><span class="line">                <span class="keyword">if</span> int(x[<span class="number">-1</span> - i]) &gt; int(x[i]):</span><br><span class="line">                    <span class="keyword">return</span> palind(n + (<span class="number">10</span> - int(x[<span class="number">-1</span> - i])) * (<span class="number">10</span>**i))</span><br><span class="line">            x = list(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l / <span class="number">2</span>)):</span><br><span class="line">                x[<span class="number">-1</span> - i] = x[i]</span><br><span class="line">            <span class="keyword">return</span> int(<span class="string">''</span>.join(x))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_palind</span><span class="params">(x)</span>:</span></span><br><span class="line">            x = str(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(x) / <span class="number">2</span>)):</span><br><span class="line">                <span class="keyword">if</span> int(x[<span class="number">-1</span> - i]) != int(x[i]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = int(palind(int(math.sqrt(int(L)))))</span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line">        <span class="keyword">while</span> i &lt;= int(math.sqrt(int(R))):</span><br><span class="line">            <span class="keyword">if</span> is_palind(i**<span class="number">2</span>):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            i = palind(i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>接下来试图简单证明这个结论。假设palindrome数$x$的各位分别为$d_{i-1}$，即
$$x=10^{n-1} d_{n-1}+10^{n-2} d_{n-2}+\cdots+10 d_1 +d_0$$且有$$d_i=d_{n-1-i}$$那么$x^2$天然可以被表达为某种palindrome结构
<span>$$\begin{align}
x^2 &amp; = 10^{2n - 2}d_{n - 1}^2 + 10^{2n - 3}({d_{n - 1}}d_{n - 2} + d_{n - 2}d_{n - 1}) + 10^{2n - 4}(d_{n - 1}d_{n - 3} + d_{n - 2}^2 + d_{n - 3}d_{n - 1}) +  \cdots \\
 &amp; + 10^{n - 1}(d_{n - 1}d_0 +  \cdots  + d_0d_{n - 1}) +  \cdots \\
 &amp; + 10^2(d_2d_0 + d_1^2 + d_0d_2) + 10(d_1d_0 + d_0d_1) + d_0^2
\end{align}$$</span><!-- Has MathJax --></p>
<p>当且仅当$10^i$的系数都为个位数（<code>&lt;10</code>）时，不存在进位的干扰，各项系数关于中间对称。系数中一定存在每个$d_i$的平方项，而且除了一位数以外，中间项系数$10^{n-1}$还能写成平方和$\sum\nolimits_{i = 0}^{n - 1} {d_i^2}$，显然除了一位数3，其他任何数的各位都不能超过2，且各位平方和不能超过10，那么至多可以存在2个2和1个1，或者9个1。</p>
<p>具体来说可以分奇数偶讨论，取palindrome的前半部分长度为<code>n</code>（不包含中间元素），如果palindrome为偶数：</p>
<ul>
<li><code>1xxxxxxxx1</code>，前<code>n</code>位可以放1-4个<code>1</code>，其中第一位必然为<code>1</code>，那么共有${n-1 \choose 1}+{n-1 \choose 2}+{n-1 \choose 3}+1$种情况</li>
<li><code>2xxxxxxxx2</code>，其他位必须全为<code>0</code>，共有1种情况</li>
</ul>
<p>如果palindrome为奇数</p>
<ul>
<li><code>1xxxx1xxxx1</code>，前<code>n</code>位可以放1-4个<code>1</code>，其中第一位必然为1，那么共有${n-1 \choose 1}+{n-1 \choose 2}+{n-1 \choose 3}+1$种情况</li>
<li><code>1xxxx0xxxx1</code>,前<code>n</code>位可以放1-4个<code>1</code>，其中第一位必然为1，那么共有${n-1 \choose 1}+{n-1 \choose 2}+{n-1 \choose 3}+1$种情况</li>
<li><code>2xxxx0xxxx2</code>，其他位必须全为<code>0</code>，共有1种情况</li>
<li><code>2xxxx1xxxx2</code>，其他位必须全为<code>0</code>，共有1种情况</li>
<li><code>1xxxx2xxxx1</code>，前<code>n</code>位可以放1-2个<code>1</code>，其中第一位必然为<code>1</code>，共有$n-1+1$种情况</li>
</ul>
<p>当<code>sqrt(L)</code>有<code>d1</code>位数，<code>sqrt(R)</code>有<code>d2</code>位数时，<code>d1+1</code>至<code>d2-1</code>位的superpalindrome平方根有多少个可以直接按照上面给的计数方法计算。接下来需要从大到小遍历找到大于等于<code>sqrt(L)</code>的palindrome，从小到大找到小于等于<code>sqrt(R)</code>的palindrome，并进行验证这些边界情况。另外，<code>d1==d2</code>可能需要另外讨论。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superpalindromesInRange</span><span class="params">(self, L, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type L: str</span></span><br><span class="line"><span class="string">        :type R: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        l, r = int(math.sqrt(int(L))), int(math.sqrt(int(R)))</span><br><span class="line">        res = <span class="number">1</span> <span class="keyword">if</span> l &lt;= <span class="number">3</span> &lt;= r <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        d1, d2 = len(str(l)), len(str(r))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">des_palind_part</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> int(x[i]) &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> des_palind_part(x[:i] + <span class="string">'2'</span> * (len(x) - i))</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">asc_palind_part</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">                <span class="keyword">if</span> int(x[<span class="number">-1</span> - i]) &gt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> asc_palind_part(str(int(x) + <span class="number">10</span>**(i + <span class="number">1</span>) - int(x[<span class="number">-1</span> - i:])))</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">construct_palind</span><span class="params">(x, d)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> d % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x + x[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> x[:<span class="number">-1</span>] + x[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(d1 + <span class="number">1</span>, d2):</span><br><span class="line">            n = i / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">2</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">                    <span class="keyword">if</span> k &gt; n - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    res += int(scipy.misc.comb(n - <span class="number">1</span>, k))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="number">5</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">                    <span class="keyword">if</span> k &gt; n:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    res += <span class="number">2</span> * int(scipy.misc.comb(n - <span class="number">1</span>, k))</span><br><span class="line">                res += n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> d1 == d2:</span><br><span class="line">            x = <span class="string">'1'</span> + <span class="string">'0'</span> * \</span><br><span class="line">                max((d1 / <span class="number">2</span> - <span class="number">1</span>), <span class="number">0</span>) <span class="keyword">if</span> d1 % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'1'</span> + <span class="string">'0'</span> * max(d1 / <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">            guess = construct_palind(x, d1)</span><br><span class="line">            <span class="keyword">while</span> int(guess) &lt; l:</span><br><span class="line">                x = asc_palind_part(str(int(x) + <span class="number">1</span>))</span><br><span class="line">                guess = construct_palind(x, d1)</span><br><span class="line">            <span class="keyword">while</span> int(guess) &lt;= r:</span><br><span class="line">                <span class="keyword">if</span> sum(int(i)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> guess) &lt; <span class="number">10</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                x = asc_palind_part(str(int(x) + <span class="number">1</span>))</span><br><span class="line">                guess = construct_palind(x, d2)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        x = <span class="string">'2'</span> * (d1 / <span class="number">2</span>) <span class="keyword">if</span> d1 % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'2'</span> * (d1 / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        guess = construct_palind(x, d1)</span><br><span class="line">        <span class="keyword">while</span> int(guess) &gt;= l:</span><br><span class="line">            <span class="keyword">if</span> sum(int(i)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> guess) &lt; <span class="number">10</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            x = des_palind_part(str(int(x) - <span class="number">1</span>))</span><br><span class="line">            guess = construct_palind(x, d1)</span><br><span class="line"></span><br><span class="line">        x = <span class="string">'1'</span> + <span class="string">'0'</span> * max((d2 / <span class="number">2</span> - <span class="number">1</span>), <span class="number">0</span>) <span class="keyword">if</span> d2 % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'1'</span> + <span class="string">'0'</span> * max(d2 / <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">        guess = construct_palind(x, d2)</span><br><span class="line">        <span class="keyword">while</span> int(guess) &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> sum(int(i)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> guess) &lt; <span class="number">10</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            x = asc_palind_part(str(int(x) + <span class="number">1</span>))</span><br><span class="line">            guess = construct_palind(x, d2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-102/" data-id="cjuh9jwrj000bfww3ag8v5zio" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-101" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-101/" class="article-date"><time datetime="2018-09-09T14:19:15.418Z" itemprop="datePublished">2018-09-09</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-101</p>
<p>&lt;!-- more --&gt;</p>
<h2>RLE Iterator</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/rle-iterator/</p>
<blockquote>
<p>Write an iterator that iterates through a run-length encoded sequence.</p>
</blockquote>
<blockquote>
<p>The iterator is initialized by <code>RLEIterator(int[] A)</code>, where <code>A</code> is a run-length encoding of some sequence.  More specifically, for all even <code>i</code>, <code>A[i]</code> tells us the number of times that the non-negative integer value <code>A[i+1]</code> is repeated in the sequence.</p>
</blockquote>
<blockquote>
<p>The iterator supports one function: <code>next(int n)</code>, which exhausts the next <code>n</code> elements (<code>n &gt;= 1</code>) and returns the last element exhausted in this way.  If there is no element left to exhaust, <code>next</code> returns <code>-1</code> instead.</p>
</blockquote>
<blockquote>
<p>For example, we start with <code>A = [3,8,0,9,2,5]</code>, which is a run-length encoding of the sequence <code>[8,8,8,5,5]</code>.  This is because the sequence can be read as &quot;three eights, zero nines, two fives&quot;.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span><br><span class="line">Output: [null,8,8,5,-1]</span><br><span class="line">Explanation:</span><br><span class="line">RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).</span><br><span class="line">This maps to the sequence [8,8,8,5,5].</span><br><span class="line">RLEIterator.next is then called 4 times:</span><br><span class="line"></span><br><span class="line">.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].</span><br><span class="line"></span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].</span><br><span class="line"></span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].</span><br><span class="line"></span><br><span class="line">.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,</span><br><span class="line">but the second term did not exist.  Since the last term exhausted does not exist, we return -1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 1000</code></li>
<li><code>A.length</code> is an even integer.</li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
<li>There are at most <code>1000</code> calls to <code>RLEIterator.next(int n)</code> per test case.</li>
<li>Each call to <code>RLEIterator.next(int n)</code> will have <code>1 &lt;= n &lt;= 10^9</code>.</li>
</ol>
<p>直接展开成序列可能会占用很大的空间，因此可以给<code>RLEIterator</code>分配一个光标<code>cur</code>表示现在遍历到的位置，考虑到初始化以后就不再进行数据的添加操作，那么可以改变偶数<code>i</code>的<code>A[i]</code>计数以表示还有多少<code>A[i+1]</code>没被访问到。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLEIterator</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = A</span><br><span class="line">        self.cur = <span class="number">0</span></span><br><span class="line">        self.len = len(A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.cur &lt; self.len:</span><br><span class="line">            <span class="keyword">if</span> self.A[self.cur] &gt;= n:</span><br><span class="line">                self.A[self.cur] -= n</span><br><span class="line">                <span class="keyword">return</span> self.A[self.cur + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n -= self.A[self.cur]</span><br><span class="line">                self.cur += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RLEIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RLEIterator(A)</span></span><br><span class="line"><span class="comment"># param_1 = obj.next(n)</span></span><br></pre></td></tr></table></figure></p>
<h2>Online Stock Span</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/online-stock-span/</p>
<blockquote>
<p>Write a class <code>StockSpanner</code> which collects daily price quotes for some stock, and returns the span of that stock's price for the current day.</p>
</blockquote>
<blockquote>
<p>The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price.</p>
</blockquote>
<blockquote>
<p>For example, if the price of a stock over the next 7 days were <code>[100, 80, 60, 70, 60, 75, 85]</code>, then the stock spans would be <code>[1, 1, 1, 2, 1, 4, 6]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S = StockSpanner() is initialized.  Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br><span class="line"></span><br><span class="line">Note that (for example) S.next(75) returned 4, because the last 4 prices</span><br><span class="line">(including today&apos;s price of 75) were less than or equal to today&apos;s price.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Calls to <code>StockSpanner.next(int price)</code> will have <code>1 &lt;= price &lt;= 10^5</code>.</li>
<li>There will be at most <code>10000</code> calls to <code>StockSpanner.next</code> per test case.</li>
<li>There will be at most <code>150000</code> calls to <code>StockSpanner.next</code> across all test cases.</li>
<li>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</li>
</ol>
<p>对于每个<code>A[i]</code>，span即最近的大于<code>A[i]</code>的值到<code>A[i]</code>的距离。当然对于<code>A[0]</code>，这个最近的较大值可以看成在<code>-1</code>位置的一个虚拟的元素。如果是一次性给出一个序列，可以按照类似于<a href="http://notebook.xyli.me/LeetCode/LC891-alter/#%E5%8D%95%E8%B0%83%E6%A0%88">LC891的变体：求所有连续子集的极差之和</a>提到的做法维护一个单调栈，但这里的元素却是实时添加的，如果每次都为新添加的<code>price</code>遍历整个序列，会导致很大的时间开销。所以可以这样改进：维护一个<code>pre</code>列表，<code>pre[i]</code>在下标<code>i</code>之前超过<code>A[i]</code>的最近元素的坐标，当添加新的<code>price</code>前，先与<code>A[-1]</code>比较大小，如果<code>A[-1]&lt;=price</code>再把坐标从<code>len(A)-1</code>迭代为<code>pre[len(A)-1]</code>进行比较，直至第一次找到使得<code>A[i]&gt;price</code>的<code>i</code>，再把<code>price</code>放进列表，并把它的对应前驱<code>pre</code>设置为<code>i</code>放入<code>pre</code>列表。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A = []</span><br><span class="line">        self.pre = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, price)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(self.A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.A[i] &gt; price:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i = self.pre[i]</span><br><span class="line"></span><br><span class="line">        self.A.append(price)</span><br><span class="line">        self.pre.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(self.A) - i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = StockSpanner()</span></span><br><span class="line"><span class="comment"># param_1 = obj.next(price)</span></span><br></pre></td></tr></table></figure></p>
<h2>Numbers At Most N Given Digit Set</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/numbers-at-most-n-given-digit-set/</p>
<blockquote>
<p>We have a <strong>sorted</strong> set of digits <code>D</code>, a non-empty subset of <code>{'1','2','3','4','5','6','7','8','9'}</code>.  (Note that <code>'0'</code> is not included.)</p>
</blockquote>
<blockquote>
<p>Now, we write numbers using these digits, using each digit as many times as we want.  For example, if <code>D = {'1','3','5'}</code>, we may write numbers such as <code>'13'</code>, <code>'551'</code>, <code>'1351315'</code>.</p>
</blockquote>
<blockquote>
<p>Return the number of positive integers that can be written (using the digits of <code>D</code>) that are less than or equal to <code>N</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: D = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], N = 100</span><br><span class="line">Output: 20</span><br><span class="line">Explanation:</span><br><span class="line">The 20 numbers that can be written are:</span><br><span class="line">1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: D = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], N = 1000000000</span><br><span class="line">Output: 29523</span><br><span class="line">Explanation:</span><br><span class="line">We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,</span><br><span class="line">81 four digit numbers, 243 five digit numbers, 729 six digit numbers,</span><br><span class="line">2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.</span><br><span class="line">In total, this is 29523 integers that can be written using the digits of D.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>D</code> is a subset of digits <code>'1'-'9'</code> in sorted order.</li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>假设<code>N</code>是一个<code>n</code>位数，毫无疑问任意构造<code>1</code>到<code>n-1</code>位数一定满足<code>&lt;=N</code>，从<code>d</code>个数组合出的有<code>d^i</code>个。</p>
<p>接下来只需要考虑从<code>D</code>构造满足<code>&lt;=N</code>的<code>n</code>位数。首先找到有<code>D</code>有多数个数字是小于<code>N</code>的首位的，假设为<code>k</code>，都可以安排在首位，剩下的<code>n-1</code>位就可以随意组合，这里就可以找到<code>k*d^(n-1)</code>个数。如果<code>N</code>的首位也在<code>D</code>中，那么就可以递归的考虑可以由<code>D</code>组合出多少个小于去掉首位的<code>N</code>的<code>n-1</code>为数，这里特别注意一下，如果去掉首位后这个数字以<code>0</code>开头，那么不能从<code>D</code>构造出小于新数字的<code>n-1</code>位数，就可以直接跳到递归出口了，当然，另一个递归出口是<code>N</code>只有一位时，这个数字还存在于<code>D</code>，可以直接算作一个取到<code>=</code>的结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">atMostNGivenDigitSet</span><span class="params">(self, D, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type D: List[str]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = len(D)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Ndigits</span><span class="params">(x)</span>:</span> <span class="comment">#return amount of the nums &lt; x, where nums have equal digits with x</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            n = len(str(x))</span><br><span class="line">            i = bisect.bisect_left(D, str(x)[<span class="number">0</span>])</span><br><span class="line">            res += i * d**(n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i &lt; d <span class="keyword">and</span> D[i] == str(x)[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> str(x)[<span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                        res += Ndigits(int(str(x)[<span class="number">1</span>:]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(d**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(str(N)))) + Ndigits(N)</span><br></pre></td></tr></table></figure></p>
<h2>Valid Permutations for DI Sequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/valid-permutations-for-di-sequence/</p>
<blockquote>
<p>We are given <code>S</code>, a length <code>n</code> string of characters from the set <code>{'D', 'I'}</code>. (These letters stand for &quot;decreasing&quot; and &quot;increasing&quot;.)</p>
</blockquote>
<blockquote>
<p>A valid permutation is a permutation <code>P[0], P[1], ..., P[n]</code> of integers <code>{0, 1, ..., n}</code>, such that for all i:</p>
</blockquote>
<ul>
<li>If <code>S[i] == 'D'</code>, then <code>P[i] &gt; P[i+1]</code>, and;</li>
<li>If <code>S[i] == 'I'</code>, then <code>P[i] &lt; P[i+1]</code>.</li>
</ul>
<blockquote>
<p>How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;DID&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The 5 valid permutations of (0, 1, 2, 3) are:</span><br><span class="line">(1, 0, 3, 2)</span><br><span class="line">(2, 0, 3, 1)</span><br><span class="line">(2, 1, 3, 0)</span><br><span class="line">(3, 0, 2, 1)</span><br><span class="line">(3, 1, 2, 0)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>S</code> consists only of characters from the set <code>{'D', 'I'}</code>.</li>
</ol>
<p>还是试着用动态规划去解决。<code>dp[i][j]</code>表示当<code>P</code>前排到第<code>i</code>位时，如果第<code>i</code>位元素的数值在剩下的所有元素中排到第<code>j</code>位，共有多少种排法。那么当你排到第<code>i+1</code>位时，如果<code>S[i]=='D'</code>，第<code>i+1</code>位必须小于第<code>i</code>位，如果第<code>i+1</code>位大小在之后的元素能排到第<code>j</code>位，那么第<code>i</code>位的值的大小在剩下的元素中必须至少排在第<code>j+1</code>位，因此<code>dp[i+1][j]</code>是<code>dp[i][j+1:]</code>的和；同理，当<code>S[i]=='I'</code>时，为了保证第<code>i+1</code>位大于第<code>i</code>为，第<code>i</code>位在之后的元素中也至多只能排到第<code>j</code>大，<code>dp[i+1][j]</code>是<code>dp[i][:j+1]</code>的和。排到最后一位时，这一位在剩下的元素中必然只能插入到第0位，因此最后结果就是<code>dp[-1][0]</code>的值。</p>
<p>以example 1的输入<code>&quot;DID&quot;</code>为例</p>
<table>
<thead>
<tr>
<th style="text-align:left">j\i</th>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1:<code>(0)</code></td>
<td style="text-align:left">3:<code>(30)</code>,<code>(20)</code>,<code>(10)</code></td>
<td style="text-align:left">3:<code>(301)</code>,<code>(201)</code>,<code>(102)</code></td>
<td style="text-align:left">5: <code>(3021)</code>,<code>(2031)</code>,<code>(1032)</code>,<code>(3120)</code>,<code>(2130)</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1:<code>(1)</code></td>
<td style="text-align:left">2:<code>(31)</code>,<code>(21)</code></td>
<td style="text-align:left">5:<code>(302)</code>,<code>(203)</code>,<code>(103)</code>,<code>(312)</code>,<code>(213)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1:<code>(2)</code></td>
<td style="text-align:left">1:<code>(32)</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">1:<code>(3)</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>直球编程得到：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPermsDISequence</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(S) + <span class="number">1</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n] + [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i] == <span class="string">'D'</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n - i - <span class="number">1</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (sum(dp[i][j + <span class="number">1</span>:])) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n - i - <span class="number">1</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (sum(dp[i][:j + <span class="number">1</span>])) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>这样写虽然能通过，但众所周知这里存在着大量的重复计算和存储导致了$o(n^3)$的时间复杂度和$o(n^2)$的空间复杂度，我们可以稍作调整写成
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPermsDISequence</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'D'</span>:</span><br><span class="line">                dp = dp[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                    dp[i - <span class="number">1</span>] = (dp[i - <span class="number">1</span>] + dp[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp = dp[:<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">1</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>使得时间复杂度降低到$o(n^2)$同时空间复杂度降低到$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-101/" data-id="cjuh9jwr90009fww3uhza7c8r" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-represent-digital-circuits-simulator" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/represent-digital-circuits-simulator/" class="article-date"><time datetime="2018-09-07T13:57:19.180Z" itemprop="datePublished">2018-09-07</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>最近闲暇时在阅读的<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a>一书&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，在介绍使用可变数据结构建模时，首先引入了队列（queue）和表（table）两个经典的数据结构实现作为基础，又在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_sec_3.3.4" target="_blank" rel="noopener">3.3.4  A Simulator for Digital Circuits</a>试图用scheme实现一个数字电路的仿真。</p>
<p>&lt;!-- more --&gt;</p>
<p>根据编书结构来看，3.3.4确实算不上什么重要的部分，对于此书的学习路线来说甚至无足轻重到可以直接跳过，只当是前文提到的可变的，复合的数据结构应用在建模中的一次实战；然而就<strong>数字电路模拟</strong>这个应用场景本身来说，也并不能称得上是一个贴切的例子，这里提供的实现与真实世界中硬件电路的做法几乎没有关系；更恼人的是，这个部分的内容很好的根据了抽象屏障（abstract barrier）进行了自顶而下（top-down）的讲解，对于部分像我这样喜欢从底层开始动手实验和理解的读者来说，如此的解释顺序无异于灾难。于是这个部分的内容对我来说，便成为了想读却下手困难且不值得，想放弃又心有不甘觉得可惜的鸡肋。</p>
<p>但其实这部分读懂了又觉得还是有点意思的，就像<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-16.html#%25_sec_2.3.2" target="_blank" rel="noopener">2.3.2  Example: Symbolic Differentiation</a>这个例子，虽然偏离实际但确实能极大提升对于递归的理解。从最底层开始亲自实现一遍数字电路也能很好的帮助我们去理解数据结构（data structure），求值环境（eval environment）和局部状态（local state）等概念。而且无论中英文网络上有关这部分的详解资料都不多，所以我决定自己动手写一篇短文带领所有可能在此遇到问题的人突破讲解材料的限制，拉住我伸出的手登上高处，看一看山下雄伟奇异的景色。理解这个有趣的例子，也同样是提升自信的一个途径，不像现实世界中其他优秀成功的人，我只是一个又丑又穷的底层失败者，所以读懂一个数字电路模拟实现已经是让我兴奋不已急于分享的喜事，当然对在座的优秀的，现实充实的读者们来说这可能只是微小的收获感，可哪怕只要有一个人能从我微小的贡献中受益，我也觉得是非常令我幸福的事了。</p>
<p>好了，接下来我们开始从零开始一层层往上用scheme实现一个完整的数字电路模拟器。</p>
<h2>Agenda</h2>
<p>我不知道该怎么翻译这个词比较合适，这里比较贴切的意思应该是<strong>议程</strong>，也有把这个对象形容成schedule的。因为我们最终要实现的是一个事件驱动的模拟（event-driven simulation）程序，通俗来说就是每当某个事件被添加到模拟过程时，才会触发电路的一些变化。创建一个<code>agenda</code>等于开始一个模拟过程，之后的任何操作都是对于这个<code>agenda</code>对象的操作。如果要你自己不限语言，而且不告诉你要实现的这个对象名叫<code>agenda</code>，凭着轮廓写这么一个东西，很多人大概会写成形如这样的（以C#为例）：</p>
<p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">simulation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Simulator</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> currentTime &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simulator</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            Name = name;</span><br><span class="line">            currentTime= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> time, <span class="keyword">string</span> action</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="comment">/* ...add some events... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Other properties, methods, events...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title">simulation</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            Simulator s1=<span class="keyword">new</span> Simulator(<span class="string">"first_simulator"</span>);   <span class="comment">// start a simulation</span></span><br><span class="line">            s1.<span class="keyword">add</span>(<span class="number">1</span>,<span class="string">"shut down"</span>);</span><br><span class="line">            <span class="comment">//other operations</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为完成上述任务的数据结构，或者说对象，在很多人的直观理解中应该被称为simulator~~（笑）~~而agenda只是更具体的概括了这个simulator的类型，也就是这个simulator的内容到底是如何实现的，原来是通过存储和执行一系列时刻-动作对(time-action pair)来完成模拟的。请忘掉上面所写的残破的代码示例，接下来认真考虑该如何以scheme实现<code>agenda</code>：</p>
<p>首先考虑这个时刻-动作对应关系应该如何表示：如同我们现实生活中的日程表，会记录每个时刻需要完成的事务。这里直接定义数据结构<code>segment</code>是一个包含一个数字（<code>time</code>即时刻）和一个队列（<code>queue</code>即任务列表）的对。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-time-segment</span> time queue)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> time queue))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">segment-time</span> s) (<span class="name"><span class="builtin-name">car</span></span> s))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">segment-queue</span> s) (<span class="name"><span class="builtin-name">cdr</span></span> s))</span><br></pre></td></tr></table></figure></p>
<p>如此一来，<code>agenda</code>可以被定义为<code>segment</code>的一维表（one-dimensional table）结构，而且表中这些项会按照<code>time</code>排序，换个角度来看，<code>segement</code>这种结构本质就是一种key-value对。另外，<code>agenda</code>会存储现在的时间<code>current-time</code>(最后进行的事件的时间)作为表的头部，而不同于原书在之前介绍的用<code>&quot;*table*&quot;</code>之类的表的名字作为哑元表头。新建的<code>agenda</code>还没有被添加任何事件时，没有任何<code>segement</code>在内，<code>current-time</code>被初始化为<code>0</code>：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-agenda</span>) (<span class="name"><span class="builtin-name">list</span></span> <span class="number">0</span>)) <span class="comment">;returns a new empty agenda</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">current-time</span> agenda) (<span class="name"><span class="builtin-name">car</span></span> agenda))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-current-time!</span> agenda time)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-car!</span></span> agenda time))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">segments</span> agenda) (<span class="name"><span class="builtin-name">cdr</span></span> agenda))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-segments!</span> agenda segments)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-cdr!</span></span> agenda segments))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-segment</span> agenda) (<span class="name"><span class="builtin-name">car</span></span> (<span class="name">segments</span> agenda)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">rest-segments</span> agenda) (<span class="name"><span class="builtin-name">cdr</span></span> (<span class="name">segments</span> agenda)))</span><br></pre></td></tr></table></figure></p>
<p>那么用来检查<code>agenda</code>是否为<em>逻辑上</em>的空对象的<code>empty-agenda?</code>就可以通过检查表头之后的<code>segements</code>是否为空来实现了。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">empty-agenda?</span> agenda) <span class="comment">; is true if the specified agenda is empty</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">null?</span></span> (<span class="name">segments</span> agenda)))</span><br></pre></td></tr></table></figure></p>
<p>向<code>agenda</code>添加动作<code>action</code>需要检查是否为空：</p>
<ul>
<li>如果是，为这个<code>action</code>和<code>time</code>构造一个<code>segement</code>，并把这个<code>segement</code>放入<code>agenda</code>的<code>segements</code>部分。</li>
<li>否则，扫描表中每个<code>segement</code>的<code>time</code>值
<ul>
<li>如果发现指定时刻（<code>action</code>需要被添加的时刻）已经存在，那么把<code>action</code>直接添加到这个与<code>time</code>关联的<code>queue</code>中即可。</li>
<li>如果已经扫描到比指定时刻更晚的<code>time</code>值，说明指定时刻不在<code>segements</code>中，那么为这个<code>action</code>和指定<code>time</code>创建一个新的<code>segement</code>并插入到这个被扫描到的<code>segement</code>之前。</li>
<li>如果已经扫描到了<code>agenda</code>末尾，那么也说明指定时刻不在<code>segements</code>中，还是创建一个新的<code>segement</code>把这条记录放到<code>agenda</code>的末尾。</li>
</ul>
</li>
</ul>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-to-agenda!</span> time action agenda)</span><br><span class="line"><span class="comment">;modifies the agenda by adding the given action procedure to be run at the specified time.</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">belongs-before?</span> segments) <span class="comment">;return true if our appointed time **isn't** in segements</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">null?</span></span> segments)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> time (<span class="name">segment-time</span> (<span class="name"><span class="builtin-name">car</span></span> segments)))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-new-time-segment</span> time action) <span class="comment">;create a new segment for our time and action</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">q</span> (<span class="name">make-queue</span>)))</span><br><span class="line">      (<span class="name">insert-queue!</span> q action)</span><br><span class="line">      (<span class="name">make-time-segment</span> time q)))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-to-segments!</span> segments)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">segment-time</span> (<span class="name"><span class="builtin-name">car</span></span> segments)) time)</span><br><span class="line">        (<span class="name">insert-queue!</span> (<span class="name">segment-queue</span> (<span class="name"><span class="builtin-name">car</span></span> segments))</span><br><span class="line">                       action) <span class="comment">;insert action into the queue our time associated</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">rest</span> (<span class="name"><span class="builtin-name">cdr</span></span> segments)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">belongs-before?</span> rest)</span><br><span class="line">              (<span class="name"><span class="builtin-name">set-cdr!</span></span></span><br><span class="line">               segments</span><br><span class="line">               (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-new-time-segment</span> time action)</span><br><span class="line">                     (<span class="name"><span class="builtin-name">cdr</span></span> segments))) <span class="comment">;insert new segement before the later or just at the end of agenda</span></span><br><span class="line">              (<span class="name">add-to-segments!</span> rest)))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">segments</span> (<span class="name">segments</span> agenda)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">belongs-before?</span> segments) <span class="comment">;check if the agenda is null or just contains the later segements</span></span><br><span class="line">        (<span class="name">set-segments!</span></span><br><span class="line">         agenda</span><br><span class="line">         (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-new-time-segment</span> time action)</span><br><span class="line">               segments)) <span class="comment">;insert new segement at the head of segements</span></span><br><span class="line">        (<span class="name">add-to-segments!</span> segments))))</span><br></pre></td></tr></table></figure></p>
<p>可以明显的看出实现的细节上与上面描述的判定流程并不完全一致，比如最后两种情况的操作实际上是合并为<code>belongs-before?</code>，再比如检查<code>agenda</code>是否为空的操作也被合并到第一次调用<code>belongs-before?</code>中。当然，可能引起误解的部分我都已经在上面的代码中给了注释，有兴趣或者疑惑的朋友可以详细看一下。</p>
<p>删除<code>agenda</code>的第一项指删除第一个<code>segement</code>的<code>queue</code>的第一个<code>action</code>，并检查操作完成这个<code>segement</code>的<code>queue</code>是否为空，如果为空，则没有必要保留这个<code>segement</code>了。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">remove-first-agenda-item!</span> agenda) <span class="comment">;modifies the agenda by removing the first item</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">q</span> (<span class="name">segment-queue</span> (<span class="name">first-segment</span> agenda))))</span><br><span class="line">    (<span class="name">delete-queue!</span> q)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">empty-queue?</span> q)</span><br><span class="line">      (<span class="name">set-segments!</span> agenda (<span class="name">rest-segments</span> agenda)))))</span><br></pre></td></tr></table></figure></p>
<p>当我们在诸如开始处理模拟等程序中，取<code>agenda</code>的第一项时，除了要读出第一个<code>segement</code>的<code>queue</code>中第一个元素，还需要把当前时间<code>current-time</code>设置为这一项<code>action</code>发生的时间
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-agenda-item</span> agenda) <span class="comment">;returns the first item on the agenda</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">empty-agenda?</span> agenda)</span><br><span class="line">  (<span class="name">error</span> <span class="string">"Agenda is empty: FIRST-AGENDA-ITEM"</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">first-seg</span> (<span class="name">first-segment</span> agenda)))</span><br><span class="line">    (<span class="name">set-current-time!</span> agenda</span><br><span class="line">                      (<span class="name">segment-time</span> first-seg))</span><br><span class="line">    (<span class="name">front-queue</span> (<span class="name">segment-queue</span> first-seg)))))</span><br></pre></td></tr></table></figure></p>
<h3>The-agenda</h3>
<p>现在假设我们通过
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> the-agenda (<span class="name">make-agenda</span>))</span><br></pre></td></tr></table></figure></p>
<p>创建了一个新的，用于开始我们这次模拟的实例<code>the-agenda</code>，把所有需要完成的仿真行为添加到这个<code>the-agenda</code>中，所有的模拟都通过调用<code>the-agenda</code>相关程序实现。</p>
<p>很容易想象一个已经完成的数字电路应该具有这样的特性：</p>
<blockquote>
<p>给出一些输入信号，在一定<strong>延迟时间</strong>后得到输出信号</p>
</blockquote>
<p>&lt;a name=&quot;after-delay&quot;&gt;&lt;/a&gt;</p>
<p>而延迟时间因电路而异，这里暂时先不讨论，只讨论<strong>延迟</strong>的性质如何通过<code>the-agenda</code>模拟：利用带有时间参数<code>delay</code>和过程参数<code>action</code>的<code>after-delay</code>过程，使得<code>action</code>在<code>delay</code>时间后才被执行，那么直接的做法便是把<code>action</code>添加到<code>the-agenda</code>的当前时间延迟后的某个时间的执行队列：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">after-delay</span> delay action)</span><br><span class="line">  (<span class="name">add-to-agenda!</span> (<span class="name"><span class="builtin-name">+</span></span> delay (<span class="name">current-time</span> the-agenda))</span><br><span class="line">                  action</span><br><span class="line">                  the-agenda))</span><br></pre></td></tr></table></figure></p>
<p>开始我们的模拟进程需要一个<code>propagate</code>过程来按照时间和队列顺序执行<code>the-agenda</code>中的所有操作。当模拟运行时，不断的会有新的指令被添加到<code>the-agenda</code>，<code>propagate</code>就会一直持续进行直至没有未被执行的操作留在<code>the-agenda</code>为止。</p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Note</h4>
<p>这里暂时还没能实现监听器来实时监听事件的添加，所以原文中虽然给的是很具有迷惑性的说法</p>
<blockquote>
<p>In general, as the simulation runs, new items will be added to the agenda, and <code>propagate</code> will continue the simulation as long as there are items on the agenda</p>
</blockquote>
<p>但实际上我们可以看到后面的实现中，每当有新的操作被添加，完成上述任务的方法是紧随其后再调用一次<code>(propagate)</code>的伪实时监听。</p>
</div></p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">propagate</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">empty-agenda?</span> the-agenda)</span><br><span class="line">      <span class="symbol">'done</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">first-item</span> (<span class="name">first-agenda-item</span> the-agenda)))</span><br><span class="line">        (<span class="name">first-item</span>)</span><br><span class="line">        (<span class="name">remove-first-agenda-item!</span> the-agenda)</span><br><span class="line">        (<span class="name">propagate</span>))))</span><br></pre></td></tr></table></figure></p>
<p>每个事件被执行后都被移出了<code>the-agenda</code>，防止多次调用<code>(propagate)</code>造成的重复执行。</p>
<h2>Wire</h2>
<p>整个数字电路模型的基本原件——导线是数字信号的载体，而数字信号只有两种可能的取值，高电平<code>1</code>和低电平<code>0</code>。除此之外，组成电路的还有我们之后会讨论的<a href="#Function-box">功能部件（function box）</a>，不同的导线可以接入这些部件作为输入，也可以作为输出。</p>
<p>我们先来构造一种计算对象<code>wire</code>来承载数字信号，用于表示导线。这种数据结构需要提供这些操作的接口：&lt;a name=&quot;wire-method&quot;&gt;&lt;/a&gt;</p>
<ul>
<li><code>(get-signal &lt;wire&gt;)</code> 得到这根导线现在承载的数字信号值</li>
<li><code>(set-signal! &lt;wire&gt; &lt;new value&gt;)</code> 改变它的值为指定值</li>
<li>&lt;a name=&quot;add-action!&quot;&gt;&lt;/a&gt;<code>(add-action! &lt;wire&gt; &lt;procedure of no arguments&gt;)</code>将某个过程绑定到这根导线上，使得每当这根导线上的信号值发生改变的同时触发这个过程的执行。这些无参数的过程也是非常特殊的过程，执行时会与其他导线发生通信。</li>
</ul>
<p>考虑如何设计数据结构<code>wire</code>时，我们可以像<code>agenda</code>一样把它想象成一个存储数据的结构，那么只需要存放两个局部状态变量</p>
<ul>
<li><code>signal-value</code> 一个取值为0或1的整数，表示这根导线上现在的数字信号值</li>
<li><code>action-procedures</code> 一个<code>list</code>，存放所有被绑定到这根导线上的过程</li>
</ul>
<p>直接的做法是把两个变量打包用<code>cons</code>打包成一个<code>pair</code>然后写一些把它作为参数的<code>get/set</code>操作，但原书中给出的实现示例是message-passing风格的，即构造完<code>wire</code>后返回一个带有本地局部状态变量的<code>dispatch</code>函数，它通过参数选择适当的局部函数返回。创建一个新的导线的命令<code>(make-wire)</code>可以写为如下过程：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-wire</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">signal-value</span> <span class="number">0</span>) (<span class="name">action-procedures</span> '()))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-my-signal!</span> new-value)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">=</span></span> signal-value new-value))</span><br><span class="line">          (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name"><span class="builtin-name">set!</span></span> signal-value new-value)</span><br><span class="line">                 (<span class="name">call-each</span> action-procedures)) <span class="comment">;change value of signal will lead to the call of every procedures added to the wire</span></span><br><span class="line">          <span class="symbol">'done</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accept-action-procedure!</span> proc)</span><br><span class="line">      (<span class="name"><span class="builtin-name">set!</span></span> action-procedures (<span class="name"><span class="builtin-name">cons</span></span> proc action-procedures))</span><br><span class="line">      (<span class="name">proc</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> m)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> m <span class="symbol">'get-signal</span>) signal-value)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> m <span class="symbol">'set-signal!</span>) set-my-signal!)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> m <span class="symbol">'add-action!</span>) accept-action-procedure!)</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Unknown operation -- WIRE"</span> m))))</span><br><span class="line">    dispatch))</span><br></pre></td></tr></table></figure></p>
<p><code>set-my-signal!</code>会先检查当前的信号值是否需要被改变，如果需要才会重新设置<code>signal-value</code>并调用所有被绑定到导线上的无参过程。调用整个<code>action-procedures</code>用到的过程<code>call-each</code>定义如下：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">call-each</span> procedures)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> procedures)</span><br><span class="line">      <span class="symbol">'done</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">        ((<span class="name"><span class="builtin-name">car</span></span> procedures))</span><br><span class="line">        (<span class="name">call-each</span> (<span class="name"><span class="builtin-name">cdr</span></span> procedures)))))</span><br></pre></td></tr></table></figure></p>
<p>这个函数与scheme原语<code>for-each</code>以及common-lisp原语<code>mapc</code>的行为有部分相似之处，也可以这样定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">call-each</span> procedures)</span><br><span class="line">  (<span class="name"><span class="builtin-name">for-each</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (proc) (<span class="name">proc</span>)) procedures))</span><br></pre></td></tr></table></figure></p>
<p>另外需要特别注意的是，我们看到<code>accept-action-procedure!</code>每次在执行添加<code>proc</code>命令后，立刻又调用了一次新添加的过程<code>(proc)</code>，如果不进行这个操作而只是简单的写成
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accept-action-procedure!</span> proc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set!</span></span> action-procedures</span><br><span class="line">        (<span class="name"><span class="builtin-name">cons</span></span> proc action-procedures)))</span><br></pre></td></tr></table></figure></p>
<p>而不调用一下刚被添加的过程<code>proc</code>，那么<code>proc</code>永远不会被执行，<code>the-agenda</code>也永远不会不会被添加任何<code>action</code>，所有导线上的信号都始终为<code>0</code>，这个模拟毫无意义。</p>
<p>为了使对于<code>wire</code>的操作更加顺应用户的使用习惯，还需要再规定一些语法糖把返回<code>dispatch</code>函数进行一番包装得到我们<a href="#wire-method">上文</a>提出最终需要实现的三个函数：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-signal</span> wire)</span><br><span class="line">  (<span class="name">wire</span> <span class="symbol">'get-signal</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-signal!</span> wire new-value)</span><br><span class="line">  ((<span class="name">wire</span> <span class="symbol">'set-signal!</span>) new-value))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-action!</span> wire action-procedure)</span><br><span class="line">  ((<span class="name">wire</span> <span class="symbol">'add-action!</span>) action-procedure))</span><br></pre></td></tr></table></figure></p>
<p>这种风格的函数原型会更加符合大多数程序设计者，尤其是经常接触面向对象编程者的思维习惯：比如当我们使用<code>(wire 'get-signal)</code>时会把<code>wire</code>想象成一个把<code>'get-signal</code>指令作为参数被调用的<strong>过程</strong>，而<code>(get-signal wire)</code>会让人更倾向于把<code>wire</code>当成一个<strong>数据对象</strong>，被当成输出传入到<code>get-signal</code>过程。当然如上文所言，这只是一个语法糖，两个过程实质没什么区别。如果在一种程序设计语言中过程可以被当成数据对象被处理，即函数式编程的一大特征：函数/过程也是一等公民，那么你完全可以根据自己的习惯，自由的选择编程风格使之更像过程或者对象。</p>
<p>现在再来想象一下我们需要完成的数字电路：每根导线上的信号会随着时间变化，会被添加进电路并，会不断的被连接到新设备。导线毫无疑问是可变的数据对象，我们用局部状态变量（<code>signal-value</code>和<code>action-procedures</code>）的赋值来模拟这种行为，每当有新的导线被创建，就会有一组新的局部状态变量被分配，通过导线构造时返回的接口过程<code>dispatch</code>可以对该导线进行操作，用来这些新的局部状态变量来捕获电路环境的变化。</p>
<p>一根导线可以同时被连接到不同的设备，多根导线也可以被连接到同一个设备。因此，一个设备交互而引发的某根导线上的信号变化，可能会引发设备上连接的其他导线上的信号变化，进而引起更多的导线信号变化。在连接建立完成后，导线通过调用<code>action-procedure</code>向邻接的导线通信，告知信号的变化。</p>
<h3>Probe</h3>
<p>为了观察模拟运行的全过程，我们需要一些辅助工具来显示导线上数字信号值的变化。为了达到这个目的，需要在导线上放置一个“探针”<code>probe</code>，可以把它想象成一个外接的电位表，每当示数发生变化时立刻发起一个通知，并显示此刻的新信号值，当前时间以及它自己的ID（为了区分这是放置在哪根导线上的<code>probe</code>），相当于一个监视器的角色&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">probe</span> name wire)</span><br><span class="line">  (<span class="name">add-action!</span> wire</span><br><span class="line">               (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                 (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> name)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> <span class="string">" "</span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> (<span class="name">current-time</span> the-agenda))</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"  New-value = "</span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> (<span class="name">get-signal</span> wire))</span><br><span class="line">                 (<span class="name"><span class="builtin-name">newline</span></span>))))</span><br></pre></td></tr></table></figure></p>
<p>这个过程是给<code>wire</code>安排一个名为<code>name</code>的<code>probe</code>，其中的lambda表达式引导的可以看成一个格式化输出打印过程，通过<code>add-action!</code>被绑定到了<code>wire</code>上，<code>wire</code>的信号发生改变时会被调用以打印这个信号变化。这个打印过程也是我们到此为止第一次接触到的，前文所说的，可以被添加的<code>action-procedures</code>的特殊的无参过程。</p>
<p><code>probe</code>的使用场合为：模拟开始前，每次创建新的导线时，再新导线上绑定一个探针（通常与导线同名），用以观察信号的变化。当然，承载原始输入信号的导线没有太大必要被监视，但为了获取完整的模拟结果，也可以对它们放置探针。</p>
<h2>Function box</h2>
<p>功能部件的表现如它的名字function，将一些信号作为输入，并输出一些信号。不过有一点不同于数学中定义的函数概念：从接受输入到给出会存在一定的延迟，这倒是更像我们在编程中用到的函数实现，毕竟函数计算存在延迟，实质上也是因为电路信号的处理存在延迟。</p>
<p>因此不妨把这些部件和我们之前接触到的函数一样抽象成一个黑盒，我们不知道它是如何实现的，但是知道该怎么用，比如我们接下来要实现的<em>and运算器</em>在现实中就被做成一个74LS08芯片，虽然对芯片内部一无所知，但这并不妨碍我们根据手册知道哪几个针脚接输入，哪几个针脚接输出，然后直接使用。</p>
<p>但我们的模拟不满足于仅仅根据文档调用模拟function box的function，而是设计实现这些function，如同编程一样，从primitives开始进行实现，再用这些primitive function box去完成更复杂的box的定义。</p>
<h3>Primitive function box</h3>
<p>模拟器内所有的功能部件都可以基于这三种基本的部件实现：</p>
<ol>
<li><strong>非</strong>（inverter）：对一个输入信号取非，在延迟时间后返回</li>
<li><strong>与门</strong>（and-gate）: 对两个输入信号进行逻辑与运算，当且仅当两个输入都为1时，在延迟时间后返回1，否则为0</li>
<li><strong>或门</strong>（or-gate）: 对两个输入信号进行逻辑或运算，当且仅当两个输入都为0时，在延迟时间后返回0，否则为1</li>
</ol>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/primitive-functions.png?inline=false" alt="三种基本元件的符号表示"></p>
<p>我们可以先试着实现一个<code>inverter</code>。逻辑非运算<code>(logical-not s)</code>的定义不难编写，需要考虑的是<code>input</code>和<code>output</code>怎样体现这种通过<code>inverter</code>绑定的关联，即每当<code>input</code>导线上的信号值发生改变时，<code>output</code>也需要随之被改变，这也就是<a href="#add-action!"><code>add-action!</code></a>过程的用武之地了：在<code>input</code>导线上添加一个改变<code>output</code>为<code>input</code>的非值的过程</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inverter</span> input output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">invert-input</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">new-value</span> (<span class="name">logical-not</span> (<span class="name">get-signal</span> input))))</span><br><span class="line">      (<span class="name">after-delay</span> inverter-delay</span><br><span class="line">                   (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                     (<span class="name">set-signal!</span> output new-value))))) <span class="comment">;output signal changes after one inverter-delay</span></span><br><span class="line">  (<span class="name">add-action!</span> input invert-input)</span><br><span class="line">  <span class="symbol">'ok</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">logical-not</span> s)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> s <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> s <span class="number">1</span>) <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s))))</span><br></pre></td></tr></table></figure></p>
<p>被添加到<code>input</code>的实际上是一个<a href="#after-delay"><code>after-delay</code></a>过程，<code>inverter-delay</code>是个根据不同环境由用户自己定义的inverter电路的延迟数值，lambda表达式定义的命令，即设置<code>output</code>为新的结果通过<code>after-delay</code>被添加到<a href="#The-agenda"><code>the-agenda</code></a>。</p>
<p><code>and-gate</code>的实现稍微复杂一些，两个输入的信号值都会影响输出信号。同样这里规定<code>and-gate</code>本身的延迟为某个常数<code>and-gate-delay</code></p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">and-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">and-action-procedure</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">new-value</span></span><br><span class="line">          (<span class="name">logical-and</span> (<span class="name">get-signal</span> a1) (<span class="name">get-signal</span> a2))))</span><br><span class="line">      (<span class="name">after-delay</span></span><br><span class="line">        and-gate-delay</span><br><span class="line">        (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">set-signal!</span> output new-value)))))</span><br><span class="line">  (<span class="name">add-action!</span> a1 and-action-procedure)</span><br><span class="line">  (<span class="name">add-action!</span> a2 and-action-procedure)</span><br><span class="line">  <span class="symbol">'ok</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">logical-and</span> s1 s2)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">1</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">1</span>)) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">0</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">0</span>)) <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s1 s2))))</span><br></pre></td></tr></table></figure></p>
<p>类似地，可以定义<code>or-gate</code>为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">or-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">or-action-procedure</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">new-value</span></span><br><span class="line">           (<span class="name">logical-or</span> (<span class="name">get-signal</span> a1) (<span class="name">get-signal</span> a2))))</span><br><span class="line">      (<span class="name">after-delay</span></span><br><span class="line">       or-gate-delay</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">set-signal!</span> output new-value)))))</span><br><span class="line">  (<span class="name">add-action!</span> a1 or-action-procedure)</span><br><span class="line">  (<span class="name">add-action!</span> a2 or-action-procedure)</span><br><span class="line">  <span class="symbol">'ok</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">logical-or</span> s1 s2)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">0</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">0</span>)) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">1</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">1</span>)) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s1 s2))))</span><br></pre></td></tr></table></figure></p>
<hr>
<p>众所周知，根据De Morgan定律$$A+B= \overline{\bar A \cdot \bar B}$$<code>or-get</code>也同样可以利用已经定义好的<code>inverter</code>和<code>and-gate</code>进行构造，这同时也是<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.29" target="_blank" rel="noopener">习题3.29</a>要求完成的内容</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">or-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">a1-inv</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">a2-inv</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">temp</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">inverter</span> a1 a1-inv)</span><br><span class="line">    (<span class="name">inverter</span> a2 a2-inv)</span><br><span class="line">    (<span class="name">and-gate</span> a1-inv a2-inv temp)</span><br><span class="line">    (<span class="name">inverter</span> temp output)))</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们第一次利用两种primitives构造出一个“更复杂”的box，遵循如上定义的<code>or-gate</code>具有2<code>inverter-delay</code>+<code>and-delay</code>的延迟。接下来，我们还会用类似于组合出<code>or-gate</code>的思路，去构造一些更复杂的功能部件。</p>
<h3>Half-adder</h3>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/half-adder.png?inline=false" alt="一位半加器电路"></p>
<p>如图所示，半加器（half-adder）由一个<code>or-gate</code>，两个<code>and-gate</code>和一个<code>inverter</code>组成，它的功能是接受两个1位的数字信号$A$和$B$，产生两个输出$S$和$C$，$S$表示和（sum），$C$表示进位（carry），需要满足如下的逻辑关系：
$$ \begin{align}
S &amp;=A \cdot \bar B + \bar A \cdot B \\
C &amp;= A \cdot B
\end{align}$$直接按照图中电路搭建也是可行方案之一，这里的<code>a</code>,<code>b</code>,<code>s</code>,<code>c</code>均为图上相应符号位置的<code>wire</code>对象
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">half-adder</span> a b s c) <span class="comment">;input: a,b output:s,c</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">d</span> (<span class="name">make-wire</span>)) (<span class="name">e</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">or-gate</span> a b d) <span class="comment">;d=a+b</span></span><br><span class="line">    (<span class="name">and-gate</span> a b c) <span class="comment">;c=ab</span></span><br><span class="line">    (<span class="name">inverter</span> c e) <span class="comment">;e=c'=(ab)'=a'+b'</span></span><br><span class="line">    (<span class="name">and-gate</span> d e s) <span class="comment">;s=ed=(a+b)(a'+b')=ab'+a'b</span></span><br><span class="line">    <span class="symbol">'ok</span>))</span><br></pre></td></tr></table></figure></p>
<p>计算整个电路的延迟只需按照寻找关键路径的方法&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;找到使延迟最大的路径，拓扑排序后$C \to E \to S$，只要考虑得到$S$的路径：</p>
<ul>
<li>$A,B \to C$: <code>and-gate-delay</code></li>
<li>$A,B \to D$: <code>or-gate-delay</code></li>
<li>$A,B (\to C) \to E$: <code>and-gate-delay</code>+<code>inverter-gate-delay</code></li>
<li>$A,B (\to D)/(\to E) \to S$: <code>max</code>(<code>and-gate-delay</code>+<code>inverter-gate-delay</code>,<code>or-gate-delay</code>)+<code>and-gate-delay</code></li>
</ul>
<p>&lt;a name=&quot;half-adder-delay&quot;&gt;&lt;/a&gt;
总延迟<code>half-adder-delay</code>为<code>max</code>(<code>and-gate-delay</code>+<code>inverter-gate-delay</code>,<code>or-gate-delay</code>)+<code>and-gate-delay</code></p>
<h3>Full-adder</h3>
<p>前面我们把半加器封装成了类似于电路元件的<code>half-adder</code>，以便直接利用<code>half-adder</code>组装其他电路，比如接下来将介绍的一位全加器(full-adder)
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/full-adder.png?inline=false" alt="一位全加器电路">
就是由两个<code>half-adder</code>和一个<code>or-gate</code>组成的，是加法运算电路的基本原件。相比<code>half-adder</code>，增加一个输入位$C_{\text{in}}$表示上一位的进位，$A$和$B$依然表示此位的两个输入位，得到输出：和$SUM$与下一位的进位$C_{\text{out}}$，需要满足关系$$\begin{align}
SUM &amp;=A \cdot \bar B \cdot \bar C_{\text{in}} + \bar A \cdot B \cdot \bar C_{\text{in}} + \bar A \cdot \bar B \cdot C_{\text{in}} \\
C_{\text{out}} &amp; = A \cdot B + A  \cdot C_{\text{in}} +  B \cdot C_{\text{in}}
\end{align}$$同样我们直接按照图中的电路搭建<code>full-adder</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">full-adder</span> a b c-in sum c-out)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">s</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">c1</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">c2</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">half-adder</span> b c-in s c1)<span class="comment">; s=b(c-in)'+b'(c-in) c1=b(c_in)</span></span><br><span class="line">    (<span class="name">half-adder</span> a s sum c2)</span><br><span class="line">    <span class="comment">;sum=as'+a's=a(b(c-in)+b'(c-in)')+a'(b(c-in)'+b'(c-in))</span></span><br><span class="line">    <span class="comment">;sum=ab(c-in)+ab'(c-in)'+a'b(c-in)'+a'b'(c-in)</span></span><br><span class="line">    <span class="comment">;c2=as=ab(c-in)'+ab'(c-in)</span></span><br><span class="line">    (<span class="name">or-gate</span> c1 c2 c-out)</span><br><span class="line">    <span class="comment">;c-out=c1+c2=b(c_in)+ab(c-in)'+ab'(c-in)</span></span><br><span class="line">    <span class="comment">;c-out=b(c_in)+(ab(c_in)+ab(c-in)')+(ab(c_in)+ab'(c-in))</span></span><br><span class="line">    <span class="comment">;c-out=b(c_in)+ab+a(c_in)</span></span><br><span class="line">    <span class="symbol">'ok</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里不再详细给出总延迟的详细分析过程，感兴趣的读者可以仿照上文的方法计算，$C_{\text{out}}$的延迟为<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>,$SUM$的延迟为2<code>half-adder-delay</code>，那么全加器的总延迟<code>full-adder-delay</code>=2<a href="#half-adder-delay"><code>half-adder-delay</code></a></p>
<h3>Ripple-carry adder</h3>
<p>同样，接下来我们可以用<code>full-adder</code>组建更加复杂的电路，比如完成n位加法运算的电路——串行进位加法器（ripple-carry adder）
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/ripple-carry.png?inline=false" alt="串行进位加法器电路，FA表示全加器（full adder）">
这是对两个n位二进制$A$和$B$进行平行加法运算的最简单的电路，n个全加器级联，将$A_1,A_2,\ldots,A_n$从高到低最为$A$的各位输入，$B_1,B_2,\ldots,B_n$从高到低最为$B$的各位输入，生成的$S_1,S_2,\ldots,S_n$组成加法运算的结果，当然还附带着进位$C$。我们设计的<code>ripple-carry-adder</code>的四个参数</p>
<ul>
<li><code>a</code>: 一个由<code>n</code>个<code>wire</code>组成的<code>list</code>，从高到低表示被加数$A$的每一位的值</li>
<li><code>b</code>: 一个由<code>n</code>个<code>wire</code>组成的<code>list</code>，从高到低表示加数$B$的每一位的值</li>
<li><code>s</code>: 一个由<code>n</code>个<code>wire</code>组成的<code>list</code>，从高到低表示和$S$的每一位的值</li>
<li><code>c</code>: <code>wire</code>，表示最终进位$C$的值</li>
</ul>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-adder</span> a b s c)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">c-in</span> (<span class="name">make-wire</span>)))</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> a)) <span class="comment">;if it is the last bit</span></span><br><span class="line">          (<span class="name">set-signal!</span> c-in <span class="number">0</span>) <span class="comment">;c-in is set to be 0</span></span><br><span class="line">          (<span class="name">ripple-carry-adder</span> (<span class="name"><span class="builtin-name">cdr</span></span> a) (<span class="name"><span class="builtin-name">cdr</span></span> b) (<span class="name"><span class="builtin-name">cdr</span></span> s) c-in))</span><br><span class="line">          <span class="comment">;otherwise,c-in should be the c-out from lower bits</span></span><br><span class="line">        (<span class="name">full-adder</span> (<span class="name"><span class="builtin-name">car</span></span> a) (<span class="name"><span class="builtin-name">car</span></span> b) c-in (<span class="name"><span class="builtin-name">car</span></span> s) c)))</span><br></pre></td></tr></table></figure></p>
<p>$C_{k}$的延迟只来自于$C_{k+1}$的输入延迟和半加器的继位运算结果，信号传播到达$C_{k}$的延迟<code>Ck-delay</code>可以写为<code>Ck+1-delay</code>+<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>，<code>Cn-delay</code>为0，累加得到到$C$（即$C_0$）的延迟为<code>n</code>*(<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>)</p>
<p>而每个$S_{k}$的延迟也只取决于$C_{k+1}$的输入延迟和半加器的和运算结果，信号传播到<code>$S\_{k}$</code>的延迟<code>Sk-delay</code>可以写为<code>Ck+1-delay</code>+<code>full-adder-delay</code>，最后传播到达$S_1$的延迟为<code>(n-1)</code>*(<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>)+<code>full-adder-delay</code></p>
<p>我们在分析全加器总延迟时已经得到<code>full-adder-delay</code>大于<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>的结论，那么这里也可以得出这样的结论：串行进位加法器的总延迟为<code>(n-1)</code>*(<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>)+<code>full-adder-delay</code></p>
<p>习题中也要求过用三种基本元件的延迟来表示这个电路的总延迟，按照上面的分析可以直观的写为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> half-adder-delay</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">max</span></span> (<span class="name"><span class="builtin-name">+</span></span> and-gate-delay inverter-delay)</span><br><span class="line">          or-gate-delay)</span><br><span class="line">     and-gate-delay))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> full-adder-delay</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> half-adder-delay))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-c</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-c-iter</span> k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> k n)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> or-gate-delay</span><br><span class="line">           and-gate-delay</span><br><span class="line">           half-adder-delay</span><br><span class="line">           (<span class="name">ripple-carry-c-iter</span> (<span class="name"><span class="builtin-name">+</span></span> k <span class="number">1</span>)))))</span><br><span class="line">  (<span class="name">ripple-carry-c-iter</span> <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-s</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">ripple-carry-c</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>) full-adder-delay)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-adder-delay</span> n)</span><br><span class="line">  (<span class="name">ripple-carry-s</span> n))</span><br></pre></td></tr></table></figure></p>
<h2>A sample simulation</h2>
<p>通过前面的工作，我们已经搭建好了一个数字电路模拟的环境。接下来可以像我们在现实中的实验环境一样，自由的取用导线和元件搭建电路，改变输入，观测输出。我也已经把以上代码连同需要用到的更底层的queue定义打包写到了<a href="https://gist.github.com/Lixinyi-DUT/8a63a3005ae7814ece306e6dc12480f7" target="_blank" rel="noopener">digital-circuits-package.scm</a>，你可以使用一些可视化的在线scheme REPL工具如<a href="https://scheme-legacy.apps.cs61a.org/" target="_blank" rel="noopener">Scheme Interpreter and Visualizer</a>或<a href="https://scheme-legacy.apps.cs61a.org/editor.html" target="_blank" rel="noopener">Editor</a>，通过命令</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">download</span> <span class="symbol">'8a63a3005ae7814ece306e6dc12480f7</span>)</span><br></pre></td></tr></table></figure></p>
<p>直接下载安装上文搭建的环境。在这个环境中，你可以通过<code>make-wire</code>增加导线，用<code>probe</code>进行监视，直接调用<code>inverter</code>,<code>and-gate</code>,<code>or-gate</code>，<code>half-adder</code>，<code>full-adder</code>连接出新的电路，用<code>set-signal!</code>改变输入信号值。除此之外，它们本来就是非常优秀的可视化工具，你还可以在一步步搭建电路的同时用
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">draw-pair</span> the-agenda)</span><br><span class="line">(<span class="name">visualize</span> (<span class="name">half-adder</span> a b s c))</span><br><span class="line">(<span class="name">diagram</span>)</span><br></pre></td></tr></table></figure></p>
<p>等命令去观察这个管理模拟进程的<code>agenda</code>本质上是一个什么样的数据结构，半加器电路的连接一步步会进行哪些操作，整个执行环境的变量又是如何被绑定的……更多用法还请根据需求自行开发。</p>
<p>当然，在国内有时可能会因为一些众所周知的原因无法使用上述工具，不过没关系，一步步跟着上面的解释慢慢写就可以了。接下来直接用原书上给出的一个简单的例子来结束本文，至此终于有始有终的带着大家看到我们辛辛苦苦写的模型第一次得到了应用。</p>
<p>首先根据你的需求设置三种基本元件的延迟时间，并初始化<code>the-agenda</code>：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> inverter-delay <span class="number">2</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> and-gate-delay <span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> or-gate-delay <span class="number">5</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> the-agenda (<span class="name">make-agenda</span>))</span><br></pre></td></tr></table></figure></p>
<p>我们准备模拟一个简单的半加器的行为，于是先新建四根导线
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> input-1 (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> input-2 (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> sum (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> carry (<span class="name">make-wire</span>))</span><br></pre></td></tr></table></figure></p>
<p>为了观察输出，在两个输出位安置<a href="#Probe"><code>probe</code></a>并随即打印示数
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">probe</span> <span class="symbol">'sum</span> sum)</span><br><span class="line"><span class="comment">;sum 0  New-value = 0</span></span><br><span class="line"></span><br><span class="line">(<span class="name">probe</span> <span class="symbol">'carry</span> carry)</span><br><span class="line"><span class="comment">;carry 0  New-value = 0</span></span><br></pre></td></tr></table></figure></p>
<p>把它们通过半加器连接
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">half-adder</span> input-1 input-2 sum carry)</span><br><span class="line"><span class="comment">;ok</span></span><br></pre></td></tr></table></figure></p>
<p>此时改变输入信号<code>input-1</code>的值为1，在一个<code>half-adder-delay</code>后不出所望，<code>sum</code>探针通知<code>sum</code>的值已经改变为1了
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-signal!</span> input-1 <span class="number">1</span>)</span><br><span class="line"><span class="comment">;done</span></span><br><span class="line">(<span class="name">propagate</span>)</span><br><span class="line"><span class="comment">;sum 8 New-value = 1</span></span><br><span class="line"><span class="comment">;done</span></span><br></pre></td></tr></table></figure></p>
<p>注意当前模拟时间为第8个单元，现在再改变输入信号<code>input-2</code>的值为1，可以看到在一个<code>or-gate-delay</code>后<code>carry</code>位发生了改变了，从输入改变开始一个<code>half-adder-delay</code>后<code>sum</code>位输出也发生了改变：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-signal!</span> input-2 <span class="number">1</span>)</span><br><span class="line"><span class="comment">; done</span></span><br><span class="line"></span><br><span class="line">(<span class="name">propagate</span>)</span><br><span class="line"><span class="comment">; carry 11  New-value = 1</span></span><br><span class="line"><span class="comment">; sum 16  New-value = 0</span></span><br><span class="line"><span class="comment">; done</span></span><br></pre></td></tr></table></figure></p>
<h2>Summary</h2>
<p>至此，整个章节的内容可以说是全部覆盖了。在这篇文章中，我们定义了一个特殊的一维表<code>agenda</code>来管理整个模拟的进程，用封装了本地状态的<code>wire</code>模拟了信号载体导线的行为，根据逻辑实现了各种功能元件的连接模拟。</p>
<p>对于实际应用来说，我们至此所做的算不上什么有意义的工作，但通过一步步编写设计去思考它们的应用场景，也会开始逐渐感觉到编程是很有趣的事，用函数式编程语言去完成之前用面向对象编程语言实现的任务尤甚。</p>
<p>希望我的这篇文章能帮助正在困惑的你跨过可变数据建模理解上的障碍，带领正在无聊的你发现一个更有意思的世界。</p>
<blockquote>
<p>祝你早日找到住在计算机中的神灵</p>
</blockquote>
<p>也祝我。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;虽然MIT已经提供了html形式的全文开源，但为了获取更好的阅读体验，推荐下载&lt;a href=&quot;https://github.com/sarabander/sicp-pdf&quot;&gt;这个排版精美的非官方电子版&lt;/a&gt;或&lt;a href=&quot;https://xuanji.appspot.com/isicp/index.html&quot;&gt;在线交互版&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;SICP全书倾向于在display函数的第一个指令放置&lt;code&gt;(newline)&lt;/code&gt;但经常忽略在打印完成后使用&lt;code&gt;(newline)&lt;/code&gt;给其他命令空间，我们可以看到前面的&lt;code&gt;'done'&lt;/code&gt;之前都没有用&lt;code&gt;(newline)&lt;/code&gt;刷新，如果用原始版本的&lt;code&gt;probe&lt;/code&gt;定义，可能会造成显示混乱，为此我在最后一行添加了一个&lt;code&gt;(newline)&lt;/code&gt;使输出更符合读者的观感。&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://en.wikipedia.org/wiki/Critical_path_method&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/represent-digital-circuits-simulator/" data-id="cjuh9jxb6005tfww3lb9xfcbr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字电路/">数字电路</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-100" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-100/" class="article-date"><time datetime="2018-09-02T12:17:41.957Z" itemprop="datePublished">2018-09-02</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-100</p>
<p>&lt;!-- more --&gt;</p>
<h2>Monotonic Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/monotonic-array/</p>
<blockquote>
<p>An array is <em>monotonic</em> if it is either monotone increasing or monotone decreasing.</p>
</blockquote>
<blockquote>
<p>An array <code>A</code> is monotone increasing if for all <code>i &lt;= j</code>, <code>A[i] &lt;= A[j]</code>.  An array <code>A</code> is monotone decreasing if for all <code>i &lt;= j</code>, <code>A[i] &gt;= A[j]</code>.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the given array <code>A</code> is monotonic.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [6,5,4,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4,5]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ol>
<p>判断单调性，似乎没什么复杂的地方。我这里把单调增和减分为两种情况进行讨论，在遇到第一对相邻且不等的数时确定增减。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mono = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> mono &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                mono = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[i] &lt; A[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> mono &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                mono = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Increasing Order Search Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/increasing-order-search-tree/</p>
<blockquote>
<p>Given a tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \</span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given tree will be between <code>1</code> and <code>100</code>.</li>
<li>Each node will have a unique integer value from <code>0</code> to <code>1000</code>.</li>
</ol>
<p>中序遍历一次得到从左至右所有结点的值，再根据这个结果重新组装一个新的，只有右子树的二叉树，没办法，我们没文化的人就是这个样子。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> in_order(r.left) + [r.val] + in_order(r.right)</span><br><span class="line"></span><br><span class="line">        vals = in_order(root)</span><br><span class="line">        res = TreeNode(vals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(vals) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        p = res</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> vals[<span class="number">1</span>:]:</span><br><span class="line">            p.right = TreeNode(v)</span><br><span class="line">            p = p.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Bitwise ORs of Subarrays</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/bitwise-ors-of-subarrays/</p>
<blockquote>
<p>We have an array <code>A</code> of non-negative integers.</p>
</blockquote>
<blockquote>
<p>For every (contiguous) subarray <code>B = [A[i], A[i+1], ..., A[j]]</code> (with <code>i &lt;= j</code>), we take the bitwise OR of all the elements in <code>B</code>, obtaining a result <code>A[i] | A[i+1] | ... | A[j]</code>.</p>
</blockquote>
<blockquote>
<p>Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">There is only one possible result: 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].</span><br><span class="line">These yield the results 1, 1, 2, 1, 3, 3.</span><br><span class="line">There are 3 unique values, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">The possible results are 1, 2, 3, 4, 6, and 7.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
</ol>
<p>所有<code>A[i]</code>参与得到的或运算结果（包括<code>A[i]</code>），才可能继续和<code>A[i+1]</code>进行或运算并计入结果。那不妨用一个hashset保留在第<code>i</code>轮得到的结果，在<code>i+1</code>轮时直接计算<code>A[i+1]</code>与这些值的或运算结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarrayBitwiseORs</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = set()</span><br><span class="line">        new_res = set()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            new_res = &#123;x | y <span class="keyword">for</span> y <span class="keyword">in</span> new_res&#125;</span><br><span class="line">            new_res.add(x)</span><br><span class="line">            res |= new_res</span><br><span class="line">        <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure></p>
<h2>Orderly Queue</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/orderly-queue/</p>
<blockquote>
<p>A string <code>S</code> of lowercase letters is given.  Then, we may make any number of moves.</p>
</blockquote>
<blockquote>
<p>In each move, we choose one of the first <code>K</code> letters (starting from the left), remove it, and place it at the end of the string.</p>
</blockquote>
<blockquote>
<p>Return the lexicographically smallest string we could have after any number of moves.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;cba&quot;, K = 1</span><br><span class="line">Output: &quot;acb&quot;</span><br><span class="line">Explanation:</span><br><span class="line">In the first move, we move the 1st character (&quot;c&quot;) to the end, obtaining the string &quot;bac&quot;.</span><br><span class="line">In the second move, we move the 1st character (&quot;b&quot;) to the end, obtaining the final result &quot;acb&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;baaca&quot;, K = 3</span><br><span class="line">Output: &quot;aaabc&quot;</span><br><span class="line">Explanation:</span><br><span class="line">In the first move, we move the 1st character (&quot;b&quot;) to the end, obtaining the string &quot;aacab&quot;.</span><br><span class="line">In the second move, we move the 3rd character (&quot;c&quot;) to the end, obtaining the final result &quot;aaabc&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= S.length &lt;= 1000</code></li>
<li><code>S</code> consists of lowercase letters only.</li>
</ol>
<p>当<code>K&gt;1</code>时，相邻元素<code>S[i]</code>和<code>S[i+1]</code>可以在调到首尾后通过两次操作交换相对位置，即有一字符串<code>xxxx[ab]xxx</code>可以通过如下几步改变为<code>xxxx[ba]xxx</code>:</p>
<ul>
<li><code>xxxx[ab]xxx</code></li>
<li><code>[ab]xxxxxxx</code> 不断把第一位调换到末尾</li>
<li><code>[a]xxxxxxx[b]</code> 把第二位调换到末尾</li>
<li><code>xxxxxxx[ba]</code> 把第一位调换到末尾</li>
<li><code>xxxx[ba]xxx</code> 不断把第一位调换到末尾</li>
</ul>
<p>即相邻元素之间可以任意调换，那么等效于字符串所有字符就可以以任意顺序打乱重排，进行一次排序即可找到最小的串。</p>
<p>当<code>K=1</code>时，对于每个<code>i</code>考虑<code>S[i:]+S[:i]</code>即当<code>S[i]</code>作为第一个字符的情况即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orderlyQueue</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min([S[i:] + S[:i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S))])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S = list(S)</span><br><span class="line">            S.sort()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(S)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-100/" data-id="cjuh9jwr30007fww3j0mmkgg4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-99" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-99/" class="article-date"><time datetime="2018-08-26T10:22:58.908Z" itemprop="datePublished">2018-08-26</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-99</p>
<p>&lt;!-- more --&gt;</p>
<h2>Surface Area of 3D Shapes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/surface-area-of-3d-shapes/</p>
<blockquote>
<p>On a <code>N * N</code> grid, we place some <code>1 * 1 * 1</code> cubes.</p>
</blockquote>
<blockquote>
<p>Each value <code>v = grid[i][j]</code> represents a tower of <code>v</code> cubes placed on top of grid cell <code>(i, j)</code>.</p>
</blockquote>
<blockquote>
<p>Return the total surface area of the resulting shapes.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 34</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ol>
<p>这题与<a href="https://leetcode.com/problems/projection-area-of-3d-shapes/description/" target="_blank" rel="noopener">Projection Area of 3D Shapes</a>仅要求的求投影面积有所不同，因为存在凹的图形，所以依靠求投影的方法可能会失效。当然平行于<code>xy</code>平面部分的表面积还可以用原来的方法。我这里用一种比较直接的方法计算左侧露出的面积：对于每一排的tower，未被前排遮挡的高度即裸露出来形成表面积的部分。同理，一共需要从左到右，从右到左，从前到后，从后到前分别计算四次露出的面积：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surfaceArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(grid)</span><br><span class="line">        back = sum(v <span class="keyword">for</span> v <span class="keyword">in</span> grid[<span class="number">0</span>])</span><br><span class="line">        front = sum(v <span class="keyword">for</span> v <span class="keyword">in</span> grid[<span class="number">-1</span>])</span><br><span class="line">        left = sum(grid[j][<span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">        right = sum(grid[j][<span class="number">-1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">        base = sum(v &gt; <span class="number">0</span> <span class="keyword">for</span> r <span class="keyword">in</span> grid <span class="keyword">for</span> v <span class="keyword">in</span> r) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N - <span class="number">1</span>):</span><br><span class="line">            back += sum(max(grid[i + <span class="number">1</span>][j] - grid[i][j], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">            front += sum(max(grid[N - <span class="number">2</span> - i][j] -</span><br><span class="line">                             grid[N - <span class="number">1</span> - i][j], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">            left += sum(max(grid[j][i + <span class="number">1</span>] - grid[j][i], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">            right += sum(max(grid[j][N - <span class="number">2</span> - i] - grid[j]</span><br><span class="line">                             [N - <span class="number">1</span> - i], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> front + back + left + right + base</span><br></pre></td></tr></table></figure></p>
<h2>Groups of Special-Equivalent Strings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/groups-of-special-equivalent-strings/</p>
<blockquote>
<p>You are given an array <code>A</code> of strings.</p>
</blockquote>
<blockquote>
<p>Two strings <code>S</code> and <code>T</code> are <em>special-equivalent</em> if after any number of <em>moves</em>, <code>S == T</code>.</p>
</blockquote>
<blockquote>
<p>A move consists of choosing two indices <code>i</code> and <code>j</code> with <code>i % 2 == j % 2</code>, and swapping <code>S[i]</code> with <code>S[j]</code>.</p>
</blockquote>
<blockquote>
<p>Now, a group of <em>special-equivalent</em> strings from <code>A</code> is a non-empty subset of <code>A</code> such that any string not in <code>A</code> is not special-equivalent with any string in A.</p>
</blockquote>
<blockquote>
<p>Return the number of groups of special-equivalent strings from <code>A</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 groups [&quot;aa&quot;], [&quot;bb&quot;], [&quot;ab&quot;], [&quot;ba&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[i].length &lt;= 20</code></li>
<li>All <code>A[i]</code> have the same length.</li>
<li>All <code>A[i]</code> consist of only lowercase letters.</li>
</ol>
<p>这里的<em>special-equivalent</em>指<code>S</code>和<code>T</code>的奇数位字符组成的集合相同，偶数位字符组成的集合也相同。对于长度大于2的字符串，即<code>sorted(S[0::2])==sorted(T[0::2]) and sorted(S[1::2])==sorted(T[1::2])</code>，对于长度为<code>1</code>或<code>2</code>的字符串，直接检查是否为相等。通常的两层遍历开销太大，可以先删去重复元素，再建立一个<code>dict</code>存放偶数位字符集合相同的字符串，对每个字符串找到偶数位相同集合的字符串，检查其中是否还有奇数位相同的，如果有则该字符串不可能独立成新的组。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecialEquivGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d_even = &#123;&#125;</span><br><span class="line">        A = list(set(A))</span><br><span class="line">        res = len(A)</span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>] &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i, w <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            even = tuple(sorted(A[i][<span class="number">0</span>::<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">if</span> even <span class="keyword">in</span> d_even:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d_even[even]:</span><br><span class="line">                    <span class="keyword">if</span> sorted(A[i][<span class="number">1</span>::<span class="number">2</span>]) == sorted(A[j][<span class="number">1</span>::<span class="number">2</span>]):</span><br><span class="line">                        res -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                d_even[even].append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d_even[even] = [i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>All Possible Full Binary Trees</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/all-possible-full-binary-trees/</p>
<blockquote>
<p>A <em>full binary tree</em> is a binary tree where each node has exactly 0 or 2 children.</p>
</blockquote>
<blockquote>
<p>Return a list of all possible full binary trees with <code>N</code> nodes.  Each element of the answer is the root node of one possible tree.</p>
</blockquote>
<blockquote>
<p>Each <code>node</code> of each tree in the answer <strong>must</strong> have <code>node.val = 0</code>.</p>
</blockquote>
<blockquote>
<p>You may return the final list of trees in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 20</code></li>
</ol>
<p>很显然</p>
<ol>
<li>当<code>N</code>为偶数时，不存在满二叉树</li>
<li>当<code>N==1</code>时，独立的根结点可以形成一个满二叉树</li>
<li>当<code>N&gt;=3</code>时，根结点下有两棵子树，左子树的结点数可以为<code>&lt;N</code>的任意奇数<code>i</code>，右子树的结点数则为<code>N-1-i</code></li>
</ol>
<p>这个问题满足递归定义，比较值得注意的是左右子树相同时应该避免重复计入，以及<code>&lt;N</code>的子问题会被讨论多次所以需要暂时把结果存储起来访问。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    dp = &#123;<span class="number">1</span>: set([TreeNode(<span class="number">0</span>)])&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPossibleFBT</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [TreeNode(<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, N + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            self.dp[i] = set()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> self.dp[j]:</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> self.dp[i - <span class="number">1</span> - j]:</span><br><span class="line">                        r = TreeNode(<span class="number">0</span>)</span><br><span class="line">                        r.left = left</span><br><span class="line">                        r.right = right</span><br><span class="line">                        self.dp[i].add(r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(self.dp[N])</span><br></pre></td></tr></table></figure></p>
<h2>Maximum Frequency Stack</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/maximum-frequency-stack/</p>
<blockquote>
<p>Implement <code>FreqStack</code>, a class which simulates the operation of a stack-like data structure.</p>
</blockquote>
<blockquote>
<p><code>FreqStack</code> has two functions:</p>
</blockquote>
<blockquote>
<ul>
<li><code>push(int x)</code>, which pushes an integer <code>x</code> onto the stack.</li>
</ul>
</blockquote>
<ul>
<li><code>pop()</code>, which <strong>removes</strong> and returns the most frequent element in the stack.
<ul>
<li>If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">Output: [null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line">Explanation:</span><br><span class="line">After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 5, as 5 is the most frequent.</span><br><span class="line">The stack becomes [5,7,5,7,4].</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.</span><br><span class="line">The stack becomes [5,7,5,4].</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 5.</span><br><span class="line">The stack becomes [5,7,4].</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 4.</span><br><span class="line">The stack becomes [5,7].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Calls to <code>FreqStack.push(int x)</code> will be such that <code>0 &lt;= x &lt;= 10^9</code>.</li>
<li>It is guaranteed that <code>FreqStack.pop()</code> won't be called if the stack has zero elements.</li>
<li>The total number of <code>FreqStack.push</code> calls will not exceed <code>10000</code> in a single test case.</li>
<li>The total number of <code>FreqStack.pop</code> calls will not exceed <code>10000</code> in a single test case.</li>
<li>The total number of <code>FreqStack.push</code> and <code>FreqStack.pop</code> calls will not exceed 150000 across all test cases.</li>
</ol>
<p>因为时间原因，我做的比较草率，没有事实上在栈里面删除被弹出的元素。</p>
<p>这里维护了一个放置元素的列表<code>stack</code>，记录每个元素出现的频数的字典<code>fre</code>，和一个返回当前最大频数元素的堆<code>q</code>。</p>
<p>每次把元素<code>x</code>压入栈中，就把当前状态，即当前<code>x</code>出现的频数<code>fre[x]</code>和它最后一次出现的位置（列表尾部<code>i</code>）组成对压入一个最大堆中（因为<code>heapq</code>实现的是最小堆所以我这里给两个数值都取了负）。每次进行弹栈操作时，从堆中取出最大频数（下标）的元素弹出并在<code>fre</code>更新。一旦从堆中弹出，坐标<code>i</code>不会再次被压入，新压入的元素的下标也总与旧元素的相对顺序保持与栈内一致。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.fre = &#123;&#125;</span><br><span class="line">        self.q = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.fre[x] = self.fre.get(x, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heapq.heappush(self.q, (-self.fre[x], -len(self.stack) + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(self.stack)</span><br><span class="line">        max_fre, i = heapq.heappop(self.q)</span><br><span class="line">        self.fre[self.stack[-i]] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = FreqStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br></pre></td></tr></table></figure></p>
<p>当然这题虽然看上去简单，但我一开始真的懒得动脑子就直球<code>pop()</code>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max_fre = max(range(n), key=<span class="keyword">lambda</span> x: (self.stack.count(self.stack[x]), x))</span><br><span class="line"><span class="keyword">return</span> self.stack.pop(max_fre)</span><br></pre></td></tr></table></figure></p>
<p>或者绞尽脑汁去维护相同元素组成的字典列表之类的，肯定是要TLE的，没办法，我们没文化的人就是这个样子.jpg</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-99/" data-id="cjuh9jx7s004ifww31lbznvng" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LC891-alter" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LC891-alter/">LC891的变体：求所有连续子集的极差之和</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LC891-alter/" class="article-date"><time datetime="2018-08-21T10:42:08.213Z" itemprop="datePublished">2018-08-21</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在上周日的<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-98/">Weekly Contest 98 </a>中的压轴题<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-98/#Sum-of-Subsequence-Widths">Sum of Subsequence Widths</a>(以下简称母题)题解中我特意强调了这里的subsequence只是子集，并不要求所有元素之间的连续，所以做起来会更容易。今天志成<a href="https://weibo.com/5346379929" target="_blank" rel="noopener"><i class="fa fa-weibo"></i> @_FollowYourHeart_</a>问了个很好的问题：如果题目改成连续子集应该怎么做比较好？</p>
<p>&lt;!-- more --&gt;</p>
<h2>问题背景</h2>
<p>有一个整数数组<code>A</code>，其中的元素不保证不相同。对一个非空数组来说，宽度定义为该集合的最大值减去最小值的结果，求<code>A</code>的所有连续子数组的宽度之和。</p>
<p>这里的连续子数组指对于任意$1 \le i \le j \le n$，从<code>A</code>取下标从$i$到$j$的任意子数组，这里标记为$A[i:j]$（注意这个符号区别于部分编程语言的从0开始计数索引以及不包含上界的切片标记<code>A[i:j]</code>）</p>
<p>母题中给的Example 1输入<code>[2,1,3]</code>包含的连续子数组只有<code>[2],[1],[3],[2,1],[1,3],[2,1,3]</code>而没有原来的<code>[2,3]</code></p>
<p>整个问题要求的就是$$\sum\limits_{i = 1}^n {\sum\limits_{j = i}^n {\max (A[i:j]) - \min (A[i:j])} }$$众所周知，当$i=j$即子数组长度为1时，宽度（极差）为0，所以可以只考虑$i&lt;j$的情况，把上式进一步改写为$$\sum\limits_{i = 1}^{n-1} {\sum\limits_{j = i+1}^n {\max (A[i:j]) - \min (A[i:j])} }$$对于Example 1来说只需要考虑子数组<code>[2,1],[1,3],[2,1,3]</code>宽度，分别为<code>1,2,2</code>，最终结果为<code>5</code></p>
<h2>暴力搜索</h2>
<p>最直接的方法，根据上式的两个求和标记直接写一个二层循环进行求和：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_naive</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">            res += max(A[i:j + <span class="number">1</span>]) - min(A[i:j + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>内层循环也分别求两次最值，所以时间复杂度很显然是$o(n^3)$</p>
<h2>直觉的改进</h2>
<p>因为内层循环的存在，子数组都是逐个扩大的，所以利用<code>min</code>和<code>max</code>函数对子数组进行求最值的操作是多余的，完全可以维护两个临时变量作为当前的最大值和最小值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_improved</span><span class="params">(A)</span>:</span></span><br><span class="line">    n=len(A)</span><br><span class="line">    res=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        min_num,max_num=A[i],A[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">            min_num,max_num=min(min_num,A[j]),max(max_num,A[j])</span><br><span class="line">            res+=max_num-min_num</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这样就可以把时间复杂度降低到$o(n^2)$了</p>
<h2>排序+缩小搜索范围</h2>
<p>和母题一样，接下来可以试着考虑一下每一对$A[i],A[j]$作为最小值和最大值的子数组有多少个，即$A[j]-A[i]$被加了多少次，正如我在母题的题解里面所说的它们扮演了什么角色？</p>
<p>首先我们来看整个<code>A</code>数组的最大值和最小值，记它们的下标分别为$x$和$y$，它们规定了多少个连续子数组的极差呢？为了方便讨论，我们假设$x&lt;y$，即同时包含这两个数的最小子数组为$A[x:y]$，而$A[y]-A[x]$已经是<code>A</code>的最大宽度了，所有包含$A[x:y]$的子数组的宽度也都是$A[y]-A[x]$，这些数组的起点最小为1最大为$x$，终点最小为$y$最大为$n$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/5.png" alt="绿色部分为上面提到的最小子数组，宽度为A[y]-A[x]的所有子数组必须包含全部的绿色部分，除此之外可以包含从x开始向左任意长度的灰色部分，也可以同时包含y开始向右任意长度的灰色部分"></p>
<p>那么一共有$x(n-y+1)$个连续子数组的宽度为$A[y]-A[x]$，接下来我们可以试着逐渐缩小目标宽度，不妨从减小最大值开始入手：</p>
<p>假设$A[y']$是<code>A</code>的第二大值，仅次于$A[y]$，有多少子数组是以$A[y]-A[x]$作为宽度的？</p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 1</h4>
<p>首先考虑一种比较简单的情况，$y'&gt;y$</p>
<p>这时所有同时包含$A[x]$和$A[y']$的连续子数组（即使是最小的$A[x:y']$）必然包括$A[y]$，那么这些数组的宽度则以$A[y]-A[x]$进行计算，所以宽度为$A[y']-A[x]$的连续子数组不存在。</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 2</h4>
<p>当$y'&lt;y$时，我们继续沿用上面为了方便讨论的规定最大值的坐标大于最小值的坐标，即$y'&gt;x$</p>
<p>我们知道以二者的差为宽度的子数组一定同时包含这两个元素，但同时多了一个限制：数组的最大值不能超过$A[y']$，即数组的重点下标必须小于$y$，结合前文整理一下，这些数组的起点最小为1最大为$x$，重点最小为$y$最大为$y'-1$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/6.png" alt="子数组必须包含绿色部分的全部，从绿色部分开始延伸的任意长度的灰色部分，但不能延伸到任何红色的部分"></p>
<p>共有$x(y-y')$个连续子数组。</p>
</div></p>
<p>当$x$不变时，随着连续取更小的$A[y']$，为了保证$A[y']$是子数组中的最大值，子数组不能“横跨”的坐标值也越来越多。即使去掉$y_i&gt;x$的假设，也可以理解这个缩小范围的原理，无论是上界也好，下界也好，每次落到这个区间内的$y$都会带来一次边界的更新，使得下一个需要用来计算宽度的$y$所能落到的下标区间越来越狭窄。</p>
<p>不妨跳出上面的全局最值的局限，考虑对于任意满足$A[x]&lt;A[y]$的$x$和$y$，如何找出所有以$A[y]-A[x]$为宽度的连续子数组？那么上文对于全局最值的讨论其实也解决了这个问题的一部分，即当我们知道以$A[x]$为最小值，$A[y]$为最大值的最大长度连续数组时我们就可以用上面的方法计算了。假设这个最大数组的起点为$s+1$，终点为$e-1$（$s$和$e$分别在代码中变量名为<code>start</code>和<code>end</code>），也就是$A[s]$和$A[e]$一定是小于$A[x]$或大于$A[y]$的值，而$A[s+1:e-1]$一定落在$A[x]$与$A[y]$之间。那么以$A[y]-A[x]$为宽度的子数组下标的起点为$[s+1,x]$，终点为$[y,e-1]$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/7.png" alt="左右都不可以延伸到红色部分"></p>
<p>固定$x$不变时，根据上文的讨论，可以按照$A[y]$的降序取$y$，落在区间$[s+1,e-1]$时完成计算后，如果$y &lt; x$则更新$s$的值为$y$，如果$y&gt;x$则更新$e$的值为$y$。</p>
<p>&lt;a name=&quot;boundupdate&quot;&gt;&lt;/a&gt;
对每轮$x$取值开始之前，需要先找准边界保证$A[x]$就是这个最大长度区间的最小值，那么可以先按照$A[x]$升序排序，在之前取过的$x'$中小于当前$x$的最大$x'$即为$s$，大于当前$x$的最小$y'$即为$e$，直观上来说这是两个距离$x$ <strong>最近</strong> 的且满足$A[x']&lt;A[x]$的下标。</p>
<p>当然，$s$和$e$需要分别被初始化为比第一个下标更小1的值，以及比最后一个下标更大1的值，这样可以保证在还没有更新边界时，所有元素都被包含在了需要搜索的范围内。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    pos = sorted(range(n), key=<span class="keyword">lambda</span> i: A[i])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        x = pos[i]</span><br><span class="line">        start = max([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &lt; x] + [<span class="number">-1</span>])</span><br><span class="line">        end = min([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &gt; x] + [n])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            y = pos[j]</span><br><span class="line">            <span class="keyword">if</span> y &gt; end <span class="keyword">or</span> y &lt; start:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; y:</span><br><span class="line">                res += (end - y) * (x - start) * (A[y] - A[x])</span><br><span class="line">                end = y</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (end - x) * (y - start) * (A[y] - A[x])</span><br><span class="line">                start = y</span><br><span class="line">            <span class="keyword">if</span> end - start == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>
<h2>伪单遍遍历*</h2>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt; 8/22更新内容</h4>
<p>本小节为8/22看到志成回复给我他的想法：找到每个元素在哪些区间内是最大值/最小值，方法是对每个<code>A[i]</code>维护两个个单调栈，分别向左和向右找到第一个大于/小于<code>A[i]</code>的坐标<code>s</code>和<code>e</code>，那么<code>A[i]</code>就只在<code>(i-s)*(e-i)</code>个区间作为最大值/最小值。</p>
</div></p>
<p>其实这个找<code>A[i]</code>被加多少次和被减多少次的思路是最接近母题最终解法(sort + one pass)的，那就索性不用单调栈了，~~其实是我实在太懒了不想费脑子写，~~直接按照母题写单次遍历了。</p>
<p>在上文我们提到每轮外层循环开始对每个$x$更新$s$和$e$的<a href="#boundupdate">规则</a>，这是为了保证$x$在内层循环开始前是$[s+1,e-1]$内所有包含$x$的区间的最小值。其实这里如果要保证某个$x$是某个范围内所有包含$x$的子集的最大值也是同理，按$A[i]$照降序排序，对每个$A[i]$找到在$i$左边的小于$i$的最大值作为$s$，当然这里是为了保证$A[i]$为最大值$A[y]$所以为了区分前文把这个$s$记作$s_y$，前文的那个使得$A[i]$最小的$s$记作$s_x$；同理找到在$i$左边且大于$i$的最小值作为$e_y$，那么就容易计算$A[i]$一共被加了多少次和减了多少次。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_one_pass</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    pos = sorted(range(n), key=<span class="keyword">lambda</span> i: A[i])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(pos):</span><br><span class="line">        s_x = max([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &lt; v] + [<span class="number">-1</span>])</span><br><span class="line">        e_x = min([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &gt; v] + [n])</span><br><span class="line">        s_y = max([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[i:] <span class="keyword">if</span> p &lt; v] + [<span class="number">-1</span>])</span><br><span class="line">        e_y = min([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[i:] <span class="keyword">if</span> p &gt; v] + [n])</span><br><span class="line">        res += ((e_y - v) * (v - s_y) - (e_x - v) * (v - s_x)) * A[v]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>虽然看上去有点像母题优雅的one pass，但实际上循环体里面的求最值依然$o(n)$遍历不可避，所以最终还是$o(n^2)$的时间复杂度和$o(n)$的空间复杂度。</p>
<h2>单调栈</h2>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-gift&quot;&gt;&lt;/i&gt; 8/24 重要更新</h4>
<p>志成已经在评论区给出了详细的解释和实现，<em><s>蠢萌，不</s></em> 蠢而不萌的废物本人我艰难地看完，后知后觉的感叹这确实是一个巧妙的$o(n)$方法。详细讨论见评论区，再次感谢志成大佬~</p>
</div></p>
<p>还是我们之前所说找<code>A[i]</code>在多大范围内是最小值。先看一侧，也就是在<code>A[i]</code>右边大于<code>A[i]</code>值的最小坐标。</p>
<p>单调栈是一个保证自顶而下单调递增或者递减的栈，维护这个栈只需要（假设自顶而下递减，即栈顶为最大元素）：</p>
<ol>
<li>如果当前元素小于栈顶，则弹出元素直至当前元素大于栈顶并进入<code>2</code></li>
<li>如果当前元素大于栈顶，则直接压入栈内</li>
</ol>
<p>当我们进行一次对<code>A</code>的正序遍历，对每个元素<code>A[i]</code>来说，弹栈至满足要求<code>2</code>的时候，当前栈顶的元素也是左边最近的大于<code>A[i]</code>的值，即前文使用的<code>s_x</code>，这个思路是志成的实现中所使用的，我在实现的写法上与他略有不同：对于所有这些被弹出的元素<code>A[j]</code>，令它们被弹出的<code>A[i]</code>是右边距离它们最近的比它们大的值，所以在弹栈操作时每弹出一个就可以更新<code>j</code>下标的<code>e_x</code>为<code>i</code>。当然不要忘记最后还没有被弹出的元素，他们右边最近的更小值不存在，可以统一更新为<code>n</code>。如此一来，每个元素至多被压入或者弹出一次，即每次遍历中维护整个<code>mono_stack</code>的总开销为$o(n)$。</p>
<p>通过遍历顺序和单调栈单调性的改变，四次$o(n)$的线性扫描就可以得到每个下标的<code>s_x</code>,<code>e_x</code>,<code>s_y</code>和<code>e_y</code>了。最后的再来第五次遍历，根据上文的公式计算每个<code>A[i]</code>在结果中被加减过了多少次。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_mono_stack</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    s_x, s_y, e_x, e_y = [<span class="number">-1</span>] * n, [<span class="number">-1</span>] * n, [n] * n, [n] * n</span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &gt;= A[i]:</span><br><span class="line">            e_x[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &gt; A[i]:</span><br><span class="line">            s_x[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &lt;= A[i]:</span><br><span class="line">            e_y[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &lt; A[i]:</span><br><span class="line">            s_y[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, v) <span class="keyword">in</span> enumerate(A):</span><br><span class="line">        res += ((e_y[i] - i) * (i - s_y[i]) - (e_x[i] - i) * (i - s_x[i])) * v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>除此以外，我在评论区的讨论也提到过，比较麻烦的一点就是不保证<code>A</code>内所有元素<strong>不重复</strong>，所以在单调栈弹栈时的比较运算是否该取等号这个问题上需要格外谨慎。在正序和逆序遍历中同时取等号或者同时不取会导致被重复计算或忽略，所以需要在同一个方向上保留等号，而在另一个方向上不保留，也就是说上面对于操纵<code>mono_stack</code>的四个<code>for</code>循环中<code>while</code>语句的符号只能是<code>&gt;=,&gt;,&lt;=,&lt;</code>或<code>&gt;,&gt;=,&lt;,&lt;=</code>。</p>
<h2>总结</h2>
<p>三种方法都可以保证输出正确的结果，比如使用随机测试用例&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">868</span>, <span class="number">1380</span>, <span class="number">63</span>, <span class="number">948</span>, <span class="number">1065</span>, <span class="number">796</span>, <span class="number">1130</span>, <span class="number">895</span>, <span class="number">1371</span>, <span class="number">1170</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看到三个函数的输出结果都为<code>37672</code>，虽然花费了巨大的笔墨讲解第三种方法，但实际上从复杂度来看相较前两者似乎没有什么优势。不过这样的解法看上去比较舒服的地方，至少相对前两种方法里线性等宽的遍历，它可以仅在几次循环中就大幅度缩小下一轮需要遍历的范围，直觉上让人感觉轻松的多~~（有吗？笑）~~。</p>
<p>相比被更改前的母题，这个问题的处理其实麻烦的多，我试着和其他人讨论，搜索现有资料，都没有找到特别巧妙的方法，也很可能是我的能力太有限，总之有<strong>任何</strong>可能的想法欢迎在评论或者邮件提出。母题没有<strong>连续</strong>的限定，同样使用暴力搜索时需要的开销为$o(2^n)$看上去更复杂，但实际在没有连续这个限制时，数组元素之间的顺序是没有意义的，所以母题可以在排序后只考虑每个元素和哪些元素的组合是被加，哪些是被减，但在这里却必须考虑每个元素在原数组中的位置，它与任何一个元素的组合里面能不能含有其他元素，所以无法放开手脚去做，我只能这么畏畏缩缩地用了这样一个既不效率又不优雅的算法。</p>
<p>总之，谢谢志成提出的好问题。也希望这篇文章能够抛砖引玉，读者能提供出更漂亮的方法&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;使用 http://spojtoolkit.com/TestCaseGenerator/ 生成的随机数组&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;联动相关公众号推文&lt;a href=&quot;https://mp.weixin.qq.com/s/31cXvvpes4U4-qsAu7ZsgA&quot;&gt;睡前故事：从子数组到连续子数组，求极差之和变容易了吗？&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LC891-alter/" data-id="cjuh9jwqv0006fww3d85f6zwg" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-98" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-98/">LeetCode Weekly Contest 98</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-98/" class="article-date"><time datetime="2018-08-19T08:31:59.547Z" itemprop="datePublished">2018-08-19</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>睡眠太差6点惊醒过来，回笼觉有点睡过头外加有人临时约饭所以现场只做了3题，回来补完全部。整体算比较简单的一期题了。</p>
<p><s>所以说醒了就别睡了，早点起来看书搬砖，不然真耽误事</s></p>
<p>https://leetcode.com/contest/weekly-contest-98/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Fair Candy Swap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-98/problems/fair-candy-swap/</p>
<blockquote>
<p>Alice and Bob have candy bars of different sizes: <code>A[i]</code> is the size of the <code>i</code>-th bar of candy that Alice has, and <code>B[j]</code> is the size of the <code>j</code>-th bar of candy that Bob has.</p>
</blockquote>
<blockquote>
<p>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)</p>
</blockquote>
<blockquote>
<p>Return an integer array <code>ans</code> where <code>ans[0]</code> is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.</p>
</blockquote>
<blockquote>
<p>If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1], B = [2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], B = [2,3]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2], B = [1,3]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,5], B = [2,4]</span><br><span class="line">Output: [5,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= B.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 100000</code></li>
<li><code>1 &lt;= B[i] &lt;= 100000</code></li>
<li>It is guaranteed that Alice and Bob have different total amounts of candy.</li>
<li>It is guaranteed there exists an answer.</li>
</ol>
<p>如果存在一个<code>A[i]</code>与<code>B[j]</code>交换后可以使得<code>A</code>和<code>B</code>的总数相等，那么有<code>sum(A)-A[i]+B[j]=sum(B)-B[j]+A[i]</code>，即<code>B[j]=(sum(B)-sum(A))/2+A[i]</code>，只需遍历<code>A[i]</code>寻找<code>B</code>是否包含<code>B[j]=(sum(B)-sum(A))/2+A[i]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fairCandySwap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        S_A,S_B=sum(A),sum(B)</span><br><span class="line">        A,B=set(A),set(B)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            y=(S_B-S_A)/<span class="number">2</span>+x</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> B:</span><br><span class="line">                <span class="keyword">return</span> [x,y]</span><br></pre></td></tr></table></figure></p>
<h2>Find and Replace Pattern</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-98/problems/find-and-replace-pattern/</p>
<blockquote>
<p>You have a list of <code>words</code> and a <code>pattern</code>, and you want to know which <code>words</code> in words matches the pattern.</p>
</blockquote>
<blockquote>
<p>A word matches the pattern if there exists a permutation of letters <code>p</code> so that after replacing every letter <code>x</code> in the pattern with <code>p(x)</code>, we get the desired word.</p>
</blockquote>
<blockquote>
<p><em>(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)</em></p>
</blockquote>
<blockquote>
<p>Return a list of the <code>words</code> in words that match the given pattern.</p>
</blockquote>
<blockquote>
<p>You may return the answer in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;</span><br><span class="line">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class="line">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;.</span><br><span class="line">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class="line">since a and b map to the same letter.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= words.length &lt;= 50</code></li>
<li><code>1 &lt;= pattern.length = words[i].length &lt;= 20</code></li>
</ol>
<p>对于<code>words</code>中的每个<code>w</code>字符集，直接检查<code>w</code>和<code>p</code>之间是否为双射可能有些麻烦，但可以先检查<code>w-&gt;p</code>是否为映射/函数，再反过来检查<code>p-&gt;w</code>是否也为映射/函数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAndReplacePattern</span><span class="params">(self, words, pattern)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_map</span><span class="params">(w, p)</span>:</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> (i, s) <span class="keyword">in</span> enumerate(w):</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> d:</span><br><span class="line">                    <span class="keyword">if</span> d[s] != p[i]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[s] = p[i]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> is_map(w, pattern) <span class="keyword">and</span> is_map(pattern, w)]</span><br></pre></td></tr></table></figure></p>
<h2>Construct Binary Tree from Preorder and Postorder Traversal</h2>
<p>原题地址  https://leetcode.com/contest/weekly-contest-98/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</p>
<blockquote>
<p>Return any binary tree that matches the given preorder and postorder traversals.</p>
</blockquote>
<blockquote>
<p>Values in the traversals <code>pre</code> and <code>post</code> are distinct positive integers.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li>
<li><code>pre[]</code> and <code>post[]</code> are both permutations of <code>1, 2, ..., pre.length</code>.</li>
<li>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</li>
</ol>
<p><s>给出任意两种遍历的顺序构造二叉树，应该是比父母的关切之语见得还要多的数据结构习题了</s></p>
<p>子树的根结点在<code>pre</code>中是第一个元素，在<code>post</code>中是最后一个元素，所以可以很轻松的分离出根结点，接下来只要分离出<code>pre[1:]</code>和<code>post[:-1]</code>中哪些内容是左子树，哪些内容是右子树，就可以递归构造整个二叉树了。</p>
<p>由于先遍历的特征，<code>pre[1:]</code>的第一个元素必然为第一个子树（默认为左子树）的根结点，这个元素在<code>post[:-1]</code>之前的所有元素则是整个子树的全部内容，这样就可以轻松分割出左右子树。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span><span class="params">(self, pre, post)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pre: List[int]</span></span><br><span class="line"><span class="string">        :type post: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) &gt; <span class="number">1</span>:</span><br><span class="line">            i = post.index(pre[<span class="number">1</span>])</span><br><span class="line">            root.left = self.constructFromPrePost(</span><br><span class="line">                pre[<span class="number">1</span>:(i + <span class="number">2</span>)], post[:(i + <span class="number">1</span>)])</span><br><span class="line">            root.right = self.constructFromPrePost(</span><br><span class="line">                pre[(i + <span class="number">2</span>):], post[(i + <span class="number">1</span>):<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2>Sum of Subsequence Widths</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-98/problems/sum-of-subsequence-widths/</p>
<blockquote>
<p>Given an array of integers <code>A</code>, consider all non-empty subsequences of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>For any sequence S, let the width of S be the difference between the maximum and minimum element of S.</p>
</blockquote>
<blockquote>
<p>Return the sum of the widths of all subsequences of A.</p>
</blockquote>
<blockquote>
<p>As the answer may be very large, <strong>return the answer modulo 10^9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].</span><br><span class="line">The corresponding widths are 0, 0, 0, 1, 1, 2, 2.</span><br><span class="line">The sum of these widths is 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>1 &lt;= A[i] &lt;= 20000</code></li>
</ol>
<p>我一开始误解了题意把subsequences当成了连续子集去做，做完以后WA了才发现只要把subsequences当成普通的子集去考虑就可以了，反正极差不会因为元素顺序改变，没有连续取值的要求，那么相对来说问题就简单多了。</p>
<p>对于每一对<code>A[i]&lt;A[j]</code>，找到所有<code>A[i]</code>为最小值，<code>A[j]</code>为最大值的子集：这个子集必须包含<code>A[i]</code>和<code>A[j]</code>，但不能包含任何小于<code>A[i]</code>或者大于<code>A[j]</code>的元素，不妨先将<code>A</code>进行降序排序，那么就容易得知有<code>j-i-1</code>个元素的大小在<code>A[i]</code>和<code>A[j]</code>之间，取这些元素全集的所有子集数即<code>2^(j-i-1)</code>，那么一共有这么多subsequences的宽度是<code>A[j]-A[i]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubseqWidths</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                res = (res + (<span class="number">2</span>**(j - i - <span class="number">1</span>)) * (A[j] - A[i])) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这个$o(n^2)$的写法不出意外的TLE，因为存在比较运算，排序总是不可避免的，只能从那个循环下手看看能不能减小遍历开销。把上述的二层的循环展开写出来，观察每个<code>A[i]</code>出现的次数，换一个视角去从每个<code>A[i]</code>考虑：</p>
<p>对于<code>j&gt;i</code>的任意<code>A[j]</code>来说，<code>A[i]</code>是最值为<code>A[i],A[j]</code>的子集的最小值，在全局的返回值中扮演一个被减去的角色，更具体来说需要被减去<code>2^(n-1-i)</code>次，因为有<code>n-1-i</code>个元素大于<code>i</code>，并且它们都能和<code>i</code>构造出<code>2^(j-i-1)</code>个子集。当然更直观的解释是，只有在<code>A[i+1:]</code>的<code>2^(n-1-i)</code>个子集加入<code>A[i]</code>时，<code>A[i]</code>作为整个子集的最小值被减去。同理，<code>A[i]</code>也会被加<code>2^i</code>次，这样看来，很容易写出一个只遍历一次的解法，另外，为了提高计算效率，可以用1的位移代替底数为2的幂运算，否则仍然有TLE的风险。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubseqWidths</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            pos = (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">            neg = (i &lt;&lt; (n - <span class="number">1</span> - i))</span><br><span class="line">            res = (res + (pos - neg) * A[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-98/" data-id="cjuh9jx7g004gfww3aomhrjz3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-97" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-97/">LeetCode Weekly Contest 97</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-97/" class="article-date"><time datetime="2018-08-12T14:16:00.129Z" itemprop="datePublished">2018-08-12</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-97</p>
<p>&lt;!-- more --&gt;</p>
<h2>Uncommon Words from Two Sentences</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/uncommon-words-from-two-sentences/</p>
<blockquote>
<p>We are given two sentences <code>A</code> and <code>B</code>.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.)</p>
</blockquote>
<blockquote>
<p>A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p>
</blockquote>
<blockquote>
<p>Return a list of all uncommon words.</p>
</blockquote>
<blockquote>
<p>You may return the list in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">Output: [&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">Output: [&quot;banana&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 200</code></li>
<li><code>0 &lt;= B.length &lt;= 200</code></li>
<li><code>A</code> and <code>B</code> both contain only spaces and lowercase letters.</li>
</ol>
<p>找到在<code>A+B</code>中只一共出现过一次的词</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncommonFromSentences</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        words = A.split() + B.split()</span><br><span class="line">        seen = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> words:</span><br><span class="line">            w = words.pop()</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(w)</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> words:</span><br><span class="line">                    res.append(w)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Spiral Matrix III</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/spiral-matrix-iii/</p>
<blockquote>
<p>On a 2 dimensional grid with <code>R</code> rows and <code>C</code> columns, we start at <code>(r0, c0)</code> facing east.</p>
</blockquote>
<blockquote>
<p>Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.</p>
</blockquote>
<blockquote>
<p>Now, we walk in a clockwise spiral shape to visit every position in this grid.</p>
</blockquote>
<blockquote>
<p>Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)</p>
</blockquote>
<blockquote>
<p>Eventually, we reach all <code>R * C</code> spaces of the grid.</p>
</blockquote>
<blockquote>
<p>Return a list of coordinates representing the positions of the grid in the order they were visited.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://image.ibb.co/b8y6zT/example_1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 5, C = 6, r0 = 1, c0 = 4</span><br><span class="line">Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://image.ibb.co/bGVEm8/example_2.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
<p>注意一下螺旋线的方向向量顺序分别为<code>(0,1),(1,0),(0,-1),(-1,0)</code>，每转换两次方向步长增加1，这样可以保证不会重复访问，那么终止条件就是简单的访问到<code>R * C</code>个位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralMatrixIII</span><span class="params">(self, R, C, r0, c0)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :type C: int</span></span><br><span class="line"><span class="string">        :type r0: int</span></span><br><span class="line"><span class="string">        :type c0: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>)]</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        steps = <span class="number">1</span></span><br><span class="line">        res = [(r0, c0)]</span><br><span class="line">        visited = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> visited &lt; R * C:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">                r0, c0 = r0 + directions[d][<span class="number">0</span>], c0 + directions[d][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= r0 &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= c0 &lt; C:</span><br><span class="line">                    visited += <span class="number">1</span></span><br><span class="line">                    res.append((r0, c0))</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            steps += ((d + <span class="number">1</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Possible Bipartition</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/possible-bipartition/</p>
<blockquote>
<p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of any size.</p>
</blockquote>
<blockquote>
<p>Each person may dislike some other people, and they should not go into the same group.</p>
</blockquote>
<blockquote>
<p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered a and b into the same group.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 2000</code></li>
<li><code>0 &lt;= dislikes.length &lt;= 10000</code></li>
<li><code>1 &lt;= dislikes[i][j] &lt;= N</code></li>
<li><code>dislikes[i][0] &lt; dislikes[i][1]</code></li>
<li>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j].</code></li>
</ol>
<p>二分图问题也是k-coloring问题&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;的一个特殊形式，而且有相对更容易更直接的做法，将边<code>(i,j)</code>的两个端点染成不同的颜色并标记对立：如果<code>i</code>和<code>j</code>本来就同色则直接判断不可能；如果只有一个端点已经被标记过，则把另一个端点标记为与之相对的颜色；如果两个端点都已经被标记过，则分别将一个每个点的色集合并到另一个点对立的色集中。</p>
<p><s>以及其实这里的参数<code>N</code>没有什么用处</s></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N, dislikes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type dislikes: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        color = &#123;&#125;</span><br><span class="line">        counter = <span class="number">1</span></span><br><span class="line">        groups = collections.defaultdict(set)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">not</span> <span class="keyword">in</span> color) <span class="keyword">and</span> (b <span class="keyword">not</span> <span class="keyword">in</span> color):</span><br><span class="line">                color[a], color[b] = counter, -counter</span><br><span class="line">                groups[counter].add(a)</span><br><span class="line">                groups[-counter].add(b)</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> color:</span><br><span class="line">                c = color[a]</span><br><span class="line">                <span class="keyword">if</span> b <span class="keyword">in</span> color:</span><br><span class="line">                    <span class="keyword">if</span> c == color[b]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">if</span> c + color[b] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    groups[-color[b]].update(groups[c])</span><br><span class="line">                    groups[color[b]].update(groups[-c])</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> groups[c]:</span><br><span class="line">                        color[i] = -color[b]</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> groups[-c]:</span><br><span class="line">                        color[i] = color[b]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    color[b] = -c</span><br><span class="line">                    groups[-c].add(b)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                color[a] = -color[b]</span><br><span class="line">                groups[-color[b]].add(a)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Super Egg Drop</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/super-egg-drop/</p>
<blockquote>
<p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from <code>1</code> to <code>N</code>.</p>
</blockquote>
<blockquote>
<p>Each egg is identical in function, and if an egg breaks, you cannot drop it again.</p>
</blockquote>
<blockquote>
<p>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than <code>F</code> will break, and any egg dropped at or below floor <code>F</code> will not break.</p>
</blockquote>
<blockquote>
<p>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with <code>1 &lt;= X &lt;= N</code>).</p>
</blockquote>
<blockquote>
<p>Your goal is to know <strong>with certainty</strong> what the value of <code>F</code> is.</p>
</blockquote>
<blockquote>
<p>What is the minimum number of moves that you need to know with certainty what <code>F</code> is, regardless of the initial value of <code>F</code>?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 1, N = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.</span><br><span class="line">Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.</span><br><span class="line">If it didn&apos;t break, then we know with certainty F = 2.</span><br><span class="line">Hence, we needed 2 moves in the worst case to know what F is with certainty.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 2, N = 6</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 3, N = 14</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= 100</code></li>
<li><code>1 &lt;= N &lt;= 10000</code></li>
</ol>
<p>当<code>K=1</code>时，即只有一个鸡蛋，那只能老实一点从第0层开始一层一层试探着扔蛋，找到<code>F</code>前的最大次数为<code>N</code></p>
<p>当<code>K&gt;1</code>时，可以尝试着把问题分而治之：先在第<code>i</code>层扔一个鸡蛋，如果碎了用剩下的<code>K-1</code>个蛋在第0层到第i层间确定这个<code>F</code>；如果没碎，则用<code>K</code>个蛋在第<code>i+1</code>层到第<code>N</code>层之间确定这个<code>F</code>。</p>
<p>那么这里很明显存在一个可以适用动态规划的关系，假设<code>dp[n][k]</code>表示<code>K=k,N=n</code>时的确认<code>F</code>所需要的最小次数，<code>i</code>为满足<code>1&lt;i&lt;n-1</code>的所有可能取值，则有：$$dp[n][k]=1+\mathop {\min}\limits_i (\max(dp[i][k - 1] + dp[n - (i + 1)][k]))$$</p>
<p>这里很自然的根据上面的关系写出一个$o(N^2K)$的解法：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[i] * (K + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                    dp[n][k] = min(</span><br><span class="line">                        dp[n][k], <span class="number">1</span> + max(dp[i][k - <span class="number">1</span>], dp[n - (i + <span class="number">1</span>)][k]))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>众所周知这是肯定会TLE的。接下来观察<code>dp</code>或者直接理解题意，会注意到一些关系：</p>
<ul>
<li><code>dp[i][2]==2</code></li>
<li>当<code>i&lt;j</code>时，<code>dp[i][k]&lt;=dp[j][k]</code></li>
</ul>
<p>随着<code>i</code>的增大，<code>dp[i][k-1]</code>增大，而<code>dp[n-(i+1)][k]</code>减小，所以令<code>dp[n][k]</code>最小的<code>i</code>一定是<code>[1,n-1]</code>中间使得两者大小相似的值。但<code>i</code>增加1时，<code>dp[i][k-1]</code>和<code>dp[n-(i+1)][k]</code>的值的变化都是不超过1的，所以找到第一个使得<code>dp[i][k-1]&gt;=dp[n-(i+1)][k]</code>的<code>i</code>即为这个最优取值。</p>
<p>而且随着<code>n</code>的增大，这个最优的<code>i</code>值也会增大。对于每一个<code>n</code>，<code>i</code>也可以从上一个<code>n</code>的最优<code>i</code>开始遍历，而不是再从0开始，这样使得对于每个<code>k</code>，至多完成一次<code>[0,N]</code>间的遍历就可以找到所有<code>n</code>的对应最优<code>i</code>，这样就可以把复杂度降到$o(NK)$了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[i] * (K + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k - <span class="number">1</span>] &gt;= dp[n - (i + <span class="number">1</span>)][k]:</span><br><span class="line">                        dp[n][k] = <span class="number">1</span> + dp[i][k - <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;http://web.math.princeton.edu/math_alive/5/Notes2.pdf&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-97/" data-id="cjuh9jx7b004efww3mb0rrb6p" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li class="active"><span class="page-number">5</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-number" href="/page/7/">7</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/6/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
