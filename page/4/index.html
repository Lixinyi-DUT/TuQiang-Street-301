<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/4/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-76" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-76/">LeetCode Weekly Contest 76</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-76/" class="article-date"><time datetime="2018-03-18T13:51:31.062Z" itemprop="datePublished">2018-03-18</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>说个好消息，这个域名我又续费了一年<s>好在有优惠码所以省了顿饭钱啦hhhh但还是肉疼</s>，所以我还得再写一年呢。另外我还开了个微信公众号搬运和分享我的内容，直接搜索<code>yangzhou-301</code>或者扫二维码。顺便在这里打广告招收编辑和创作者，我要更专注的学习和生产内容嘛。</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode_for_yangzhou_301.jpg" alt="扬州计划"></p>
<p>好吧，废话完了直接看这周的题吧。</p>
<p>https://leetcode.com/contest/weekly-contest-76/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Similar RGB Color</h2>
<blockquote>
<p>In the following, every capital letter represents some hexadecimal digit from <code>0</code> to <code>f</code>.</p>
</blockquote>
<blockquote>
<p>The red-green-blue color <code>&quot;#AABBCC&quot;</code> can be written as <code>&quot;#ABC&quot;</code> in shorthand.  For example, <code>&quot;#15c&quot;</code> is shorthand for the color <code>&quot;#1155cc&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Now, say the similarity between two colors <code>&quot;#ABCDEF&quot;</code> and <code>&quot;#UVWXYZ&quot;</code> is <code>-(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2</code>.</p>
</blockquote>
<blockquote>
<p>Given the color <code>&quot;#ABCDEF&quot;</code>, return a 7 character color that is most similar to <code>#ABCDEF</code>, and has a shorthand (that is, it can be represented as some <code>&quot;#XYZ&quot;</code></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: color = &quot;#09f166&quot;</span><br><span class="line">Output: &quot;#11ee66&quot;</span><br><span class="line">Explanation:  </span><br><span class="line">The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.</span><br><span class="line">This is the highest among any shorthand color.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>color</code> is a string of length <code>7</code>.</li>
<li><code>color</code>is a valid RGB color: for <code>i &gt; 0</code>, <code>color[i]</code> is a hexadecimal digit from <code>0</code> to <code>f</code></li>
<li>Any answer which has the same (highest) similarity as the best answer will be accepted.</li>
<li>All inputs and outputs should use lowercase letters, and the output is 7 characters.</li>
</ol>
<p>可以缩写的形式要求三个颜色的数值都是17的整数倍，那么找距离每个颜色最近的在<code>[0,255]</code>范围内的<code>17*n</code>即可，这里是用模17的余数判断：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">similarRGB</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type color: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="string">'#'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>):</span><br><span class="line">            c=int(color[i:i+<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">            r=c%<span class="number">17</span></span><br><span class="line">            <span class="keyword">if</span> r&lt;=<span class="number">8</span>:</span><br><span class="line">                res+=hex(max(<span class="number">0</span>,c-r))[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res+=hex(min(<span class="number">17</span>*<span class="number">15</span>,c-r+<span class="number">17</span>))[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Swaps To Make Sequences Increasing</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-76/problems/minimum-swaps-to-make-sequences-increasing/</p>
<blockquote>
<p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p>
</blockquote>
<blockquote>
<p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.  Note that both elements are in the same index position in their respective sequences.</p>
</blockquote>
<blockquote>
<p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.  (A sequence is strictly increasing if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p>
</blockquote>
<blockquote>
<p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,5,4], B = [1,2,3,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Swap A[3] and B[3].  Then the sequences are:</span><br><span class="line">A = [1, 3, 5, 7] and B = [1, 2, 3, 4]</span><br><span class="line">which are both strictly increasing.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A, B</code> are arrays with the same length, and that length will be in the range <code>[1, 1000]</code>.</li>
<li><code>A[i], B[i]</code> are integer values in the range <code>[0, 2000]</code>.</li>
</ol>
<p>在进行一轮线性扫描时，决定是否交换<code>A</code>和<code>B</code>的元素取决于<code>A[i]</code>,<code>A[i+1]</code>,<code>B[i]</code>和<code>B[i+1]</code>之间的关系，分开讨论<code>A[i]&amp;B[i]</code>是否交换，对<code>A[i+1]&amp;B[i+1]</code>是否需要交换及代价的影响，这样的思路很适合考虑动态规划。在动态规划的逻辑上清晰的解释可以见<a href="https://leetcode.com/articles/minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">官方题解</a>和<a href="https://t.co/5Tjz0p69Ve" target="_blank" rel="noopener">Python 14-line O(1) space O(n) time DP solution</a>，简要的来说参见我的代码：</p>
<ul>
<li><code>pre_swap</code>:<code>A[i]</code>和<code>B[i]</code>交换使得到<code>A[0-i]</code>和<code>B[0-i]</code>递增的代价</li>
<li><code>pre_unswap</code>:<code>A[i]</code>和<code>B[i]</code>不交换使得到<code>A[0-i]</code>和<code>B[0-i]</code>递增的代价</li>
<li><code>cur_swap</code>:<code>A[i+1]</code>和<code>B[i+1]</code>交换使得到<code>A[0-i+1]</code>和<code>B[0-i+1]</code>递增的代价</li>
<li><code>cur_unswap</code>:<code>A[i+1]</code>和<code>B[i+1]</code>不交换使得到<code>A[0-i+1]</code>和<code>B[0-i+1]</code>递增的代价</li>
</ul>
<p>当<code>A[i+1]&gt;A[i]</code>且<code>B[i+1]&gt;B[i]</code>时，要保证数组的<code>0-i+1</code>位递增，要么第<code>i</code>和<code>i+1</code>位都进行交换，要么都不进行交换，那么<code>cur_unswap=min(cur_unswap,pre_unswap)</code>而<code>cur_swap=min(cur_swap,pre_swap+1)</code></p>
<p>当<code>A[i+1]&gt;B[i]</code>且<code>B[i+1]&gt;A[i]</code>时（注意这个情况可以和上面同时存在，所以只是在原来的基础上再增加一种缩小代价的可能性），要保证数组的<code>0-i+1</code>位递增，可以只换<code>i</code>和<code>i+1</code>其中的一组，如果换的是<code>i</code>那么<code>i+1</code>不换所以有<code>cur_unswap=min(cur_unswap,pre_swap)</code>，反之如果换的是<code>i+1</code>而保持<code>i</code>不变则有<code>cur_swap=min(cur_swap,pre_unswap+1)</code></p>
<p>而每个<code>cur_swap</code>的最大值为数组<code>0-i+1</code>的长度<code>i+2</code>，<code>cur_unswap</code>的最大值为数组<code>0-i</code>的长度<code>i+1</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre_swap,pre_unswap=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            cur_swap,cur_unswap=i+<span class="number">2</span>,i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[i]&lt;A[i+<span class="number">1</span>] <span class="keyword">and</span> B[i]&lt;B[i+<span class="number">1</span>]:</span><br><span class="line">                cur_swap=min(cur_swap,pre_swap+<span class="number">1</span>)</span><br><span class="line">                cur_unswap=min(cur_unswap,pre_unswap)</span><br><span class="line">            <span class="keyword">if</span> A[i]&lt;B[i+<span class="number">1</span>] <span class="keyword">and</span> B[i]&lt;A[i+<span class="number">1</span>]:</span><br><span class="line">                cur_swap=min(cur_swap,pre_unswap+<span class="number">1</span>)</span><br><span class="line">                cur_unswap=min(cur_unswap,pre_swap)</span><br><span class="line">            pre_swap,pre_unswap=cur_swap,cur_unswap</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(pre_swap,pre_unswap)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>
<h2>Find Eventual Safe States</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-76/problems/find-eventual-safe-states/</p>
<blockquote>
<p>n a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
</blockquote>
<blockquote>
<p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number <code>K</code> so that for any choice of where to walk, we must have stopped at a terminal node in less than <code>K</code> steps.</p>
</blockquote>
<blockquote>
<p>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
</blockquote>
<blockquote>
<p>The directed graph has <code>N</code> nodes with labels <code>0, 1, ..., N-1</code>, where <code>N</code> is the length of <code>graph</code>.  The graph is given in the following form: <code>graph[i]</code> is a list of labels <code>j</code> such that <code>(i, j)</code> is a directed edge of the graph.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>graph</code> will have length at most <code>10000</code>.</li>
<li>The number of edges in the graph will not exceed <code>32000</code>.</li>
<li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li>
</ol>
<p>无非就是保证从这个结点出发不会进入回路。可以试试找回路常用的拓扑排序法，从出度为0的结点开始删去结点与其所有入边，循环操作至不存在出度为0的结点，删去的所有结点都是安全的。为了找到所有入边可以一开始对邻接表进行逆转操作，记录每个结点的所有入边，这样在删去入边时会高效一些。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[i <span class="keyword">for</span> (i,e) <span class="keyword">in</span> enumerate(graph) <span class="keyword">if</span> <span class="keyword">not</span> e]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        in_edges=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(graph))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,edges <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> edges:</span><br><span class="line">                in_edges[j].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> in_edges[node]:</span><br><span class="line">                graph[i].remove(node)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> graph[i]:</span><br><span class="line">                    res.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N+E)$，空间复杂度为$o(N)$，其中$N$为结点数，$E$为边数</p>
<h2>Bricks Falling When Hit</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-76/problems/bricks-falling-when-hit/</p>
<blockquote>
<p>We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p>
</blockquote>
<blockquote>
<p>We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</p>
</blockquote>
<blockquote>
<p>Return an array representing the number of bricks that will drop after each erasure in sequence.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">grid = [[1,0,0,0],[1,1,1,0]]</span><br><span class="line">hits = [[1,0]]</span><br><span class="line">Output: [2]</span><br><span class="line">Explanation:</span><br><span class="line">If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">grid = [[1,0,0,0],[1,1,0,0]]</span><br><span class="line">hits = [[1,1],[1,0]]</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation:</span><br><span class="line">When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of rows and columns in the grid will be in the range [1, 200].</li>
<li>The number of erasures will not exceed the area of the grid.</li>
<li>It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.
An erasure may refer to a location with no brick - if it does, no bricks drop.</li>
</ol>
<p>首先需要理解一下题意，不会掉下来的砖是指第0层的砖（天花板）和与第0层砖连通的砖块。可以说只有有结点在第0层的连通分支中的砖块可以保留，其他砖块都会掉落。正向地去考虑删去每块砖可能不容易，那么可以像<a href="https://leetcode.com/problems/bricks-falling-when-hit/discuss/119829/Python-Solution-by-reversely-adding-hits-bricks-back" target="_blank" rel="noopener">这里</a>提到的思路，逆向的去添加<code>hits</code>中的砖块，看看每次添加可以让<code>grid</code>增加多少砖块。这样一来，可以从增加的<code>hit</code>出发进行DFS更容易找出有多少砖块通过这块砖被连接到了“天花板”。</p>
<p>我们先去掉<code>hits</code>中所有的砖块（指定位置为空的标记为<code>-1</code>，在之后重新添加的过程中这个<code>hit</code>对应的结果直接返回0），再从天花板开始做DFS，找到所有不会掉落的砖块并进行标记，再从后往前依次添加<code>hits</code>中的砖块，并以当前添加的这个砖块为根结点做DFS找到新的不会掉落的砖块数量，就是这次<code>hit</code>的对应掉落砖块数，即返回结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitBricks</span><span class="params">(self, grid, hits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :type hits: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adj=[(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        m,n=len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                grid[i][j]=<span class="number">2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+sum([dfs(i+dx,j+dy) <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> adj])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_fixed</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i==<span class="number">0</span> <span class="keyword">or</span> any([<span class="number">0</span>&lt;=i+dx&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j+dy&lt;n <span class="keyword">and</span> grid[i+dx][j+dy]==<span class="number">2</span> <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> adj])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> hits:</span><br><span class="line">            grid[i][j]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dfs(<span class="number">0</span>,j)</span><br><span class="line"></span><br><span class="line">        res=[<span class="number">0</span>]*len(hits)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(hits)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            i,j=hits[k]</span><br><span class="line">            grid[i][j]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">1</span> <span class="keyword">and</span> is_fixed(i,j):</span><br><span class="line">                res[k]=dfs(i,j)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>总共需要进行<code>o(m+len(hits))</code>次DFS</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-76/" data-id="cjm54ylkk0025fkw3v2321qrz" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-75" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-75/">LeetCode Weekly Contest 75</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-75/" class="article-date"><time datetime="2018-03-11T14:02:22.262Z" itemprop="datePublished">2018-03-11</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这一天终于要到来了，这个域名也马上到期了。正如之前所说，写到最后一刻吧。直接看题：</p>
<p>https://leetcode.com/contest/weekly-contest-75/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Rotate String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/rotate-string/</p>
<blockquote>
<p>We are given two strings, <code>A</code> and <code>B</code>.</p>
</blockquote>
<blockquote>
<p>A shift on <code>A</code> consists of taking string <code>A</code> and moving the leftmost character to the rightmost position. For example, if <code>A = 'abcde'</code>, then it will be <code>'bcdea'</code> after one shift on <code>A</code>. Return <code>True</code> if and only if <code>A</code>can become <code>B</code> after some number of shifts on <code>A</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &apos;abcde&apos;, B = &apos;cdeab&apos;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &apos;abcde&apos;, B = &apos;abced&apos;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code> and <code>B</code> will have length at most 100.</li>
</ol>
<p>这个问题本质就是字符串的“左移”，我的直觉做法是找到<code>A[0]</code>或者<code>A[-1]</code>在<code>B</code>的位置，然后把<code>B</code>分割成两个子串，分别找到这两个子串在<code>A</code>中的对应：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,n=<span class="number">0</span>,len(A)</span><br><span class="line">        <span class="keyword">while</span> A[<span class="number">0</span>] <span class="keyword">in</span> B[i:]:</span><br><span class="line">            sp=B.index(A[<span class="number">0</span>],i)</span><br><span class="line">            <span class="keyword">if</span> B[sp:]==A[<span class="number">0</span>:n-sp] <span class="keyword">and</span> B[:sp]==A[n-sp:]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            i=sp+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(1)$</p>
<h2>All Paths From Source to Target</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/all-paths-from-source-to-target</p>
<blockquote>
<p>Given a directed, acyclic graph of <code>N</code> nodes.  Find all possible paths from node <code>0</code> to node <code>N-1</code>, and return them in any order.</p>
</blockquote>
<blockquote>
<p>The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [3], [3], []]</span><br><span class="line">Output: [[0,1,3],[0,2,3]]</span><br><span class="line">Explanation: The graph looks like this:</span><br><span class="line">0---&gt;1</span><br><span class="line">|    |</span><br><span class="line">v    v</span><br><span class="line">2---&gt;3</span><br><span class="line">There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the graph will be in the range <code>[2, 15]</code>.</li>
<li>You can print different paths in any order, but you should keep the order of nodes inside one path.</li>
</ol>
<p>直接用递归实现DFS即可</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path)</span>:</span></span><br><span class="line">            root=path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">if</span> i==len(graph)<span class="number">-1</span>:</span><br><span class="line">                        res.append(path+[i])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dfs(path+[i])</span><br><span class="line"></span><br><span class="line">        dfs([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度为$o(E)$，$E$为图的边集大小</p>
<h2>Champagne Tower</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/champagne-tower/</p>
<blockquote>
<p>We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.</p>
</blockquote>
<blockquote>
<p>Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)</p>
</blockquote>
<blockquote>
<p>For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.</p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png" alt=""></p>
</blockquote>
<blockquote>
<p>Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: poured = 1, query_glass = 1, query_row = 1</span><br><span class="line">Output: 0.0</span><br><span class="line">Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: poured = 2, query_glass = 1, query_row = 1</span><br><span class="line">Output: 0.5</span><br><span class="line">Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>poured</code> will be in the range of <code>[0, 10 ^ 9]</code>.</li>
<li><code>query_glass</code> and <code>query_row</code> will be in the range of <code>[0, 99]</code>.</li>
</ol>
<p>有点类似于动态规划，先把<code>poured</code>全算到最顶端的杯子，每层杯子溢出的酒再算到下一层。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">champagneTower</span><span class="params">(self, poured, query_row, query_glass)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type poured: int</span></span><br><span class="line"><span class="string">        :type query_row: int</span></span><br><span class="line"><span class="string">        :type query_glass: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row=[[<span class="number">0</span>]*(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(query_row+<span class="number">1</span>)]</span><br><span class="line">        row[<span class="number">0</span>][<span class="number">0</span>]=poured</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(query_row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> row[i][j]&gt;<span class="number">1</span>:</span><br><span class="line">                    row[i+<span class="number">1</span>][j]+=(row[i][j]<span class="number">-1</span>)/<span class="number">2.0</span></span><br><span class="line">                    row[i+<span class="number">1</span>][j+<span class="number">1</span>]+=(row[i][j]<span class="number">-1</span>)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> min(row[query_row][query_glass],<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度也为$o(n^2)$，这里的$n$是指<code>query_row</code>，当然实际上的实现也可以用两个一维数组互相迭代，也就是空间复杂度可以减小到$o(n)$，我为了方便写所以用了一个二维数组。</p>
<h2>Smallest Rotation with Highest Score</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/smallest-rotation-with-highest-score/</p>
<blockquote>
<p>Given an array <code>A</code>, we may rotate it by a non-negative integer <code>K</code> so that the array becomes <code>A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]</code>.  Afterward, any entries that are less than or equal to their index are worth 1 point.</p>
</blockquote>
<blockquote>
<p>For example, if we have <code>[2, 4, 1, 3, 0]</code>, and we rotate by <code>K = 2</code>, it becomes <code>[1, 3, 0, 2, 4]</code>.  This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point].</p>
</blockquote>
<blockquote>
<p>Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 3, 1, 4, 0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:  </span><br><span class="line">Scores for each K are listed below:</span><br><span class="line">K = 0,  A = [2,3,1,4,0],    score 2</span><br><span class="line">K = 1,  A = [3,1,4,0,2],    score 3</span><br><span class="line">K = 2,  A = [1,4,0,2,3],    score 3</span><br><span class="line">K = 3,  A = [4,0,2,3,1],    score 4</span><br><span class="line">K = 4,  A = [0,2,3,1,4],    score 3</span><br><span class="line">So we should choose K = 3, which has the highest score.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 0, 2, 4]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:  A will always have 3 points no matter how it shifts.</span><br><span class="line">So we will choose the smallest K, which is 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code> will have length at most <code>20000</code>.</li>
<li><code>A[i]</code> will be in the range <code>[0, A.length]</code>.</li>
</ol>
<p>没有太大必要去关注<code>K=0</code>时的 <code>score</code>具体是多少，或者说任何<code>K</code>值下的<code>score</code>都不重要，要找的只是<code>score</code>最大时的<code>K</code>取值，那么需要记录的只有每个<code>K</code>值相比前一个的变化值。</p>
<p>首先，<code>K</code>每增加1时，上一个<code>A[0]</code>就会变成下一个数组的<code>A[N-1]</code>，满足<code>A[N-1]&lt;=N-1</code>，除非对于上一个数组来说<code>A[0]=0</code>所以本来就满足<code>A[0]&lt;=0</code>，否则，因为这样“旋转”每次会增加一分。</p>
<p>接下来，我们思考什么时候会减分。当<code>K=(i-A[i])%N</code>时会有<code>A[i]=(i-K)%N</code><s>(这不是废话吗)</s>，即在这个旋转操作后，<code>A[i]</code>左移到了<code>A[i-K]</code>的位置，此时有<code>A[i-k]=(i-K)%N</code>，由于<code>K</code>的取值范围是由1到<code>N-1</code>递增的，这也是这个元素在回到数组末尾前最后一次满足值小于等于索引，所以每当<code>K=(i-A[i]+1)%N</code>，都会因为<code>A[i]</code>丢掉一分。</p>
<p>当然我这样的描述有点冗余，当前数组第一个元素为0时，再进行下一次旋转，会因为<code>K=(i-A[i]+1)%N</code>失去1分，但是同样会因为回到数组末尾重新得到1分，所以实际上<code>A[i]=0</code>在回到数组末尾时对<code>score</code>没有影响，情况已经被上面两种情形覆盖了。</p>
<p>所以再次强调不要去在意一开始的<code>score[0]</code>到底是多少，只需要在意每个<code>K</code>在此基础上的得分变化，因为上面两种情况的讨论都是讨论<code>K=i+1</code>时相对于前一个值<code>K=i</code>时的变化，所以只需计算<code>score[i+1]=score[i]+changes[i+1]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bestRotation</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        changes=[<span class="number">1</span>]*len(A)</span><br><span class="line">        score=[<span class="number">0</span>]*len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            changes[(i-A[i]+<span class="number">1</span>)%len(A)] -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            score[i]=score[i<span class="number">-1</span>]+changes[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score.index(max(score))</span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度为$o(N)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-75/" data-id="cjm54ylht001bfkw33jfp1fr6" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-74" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-74/">LeetCode Weekly Contest 74</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-74/" class="article-date"><time datetime="2018-03-04T15:35:23.283Z" itemprop="datePublished">2018-03-04</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>没什么好说的，直接看题。</p>
<p>https://leetcode.com/contest/weekly-contest-74/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Valid Tic-Tac-Toe State</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/valid-tic-tac-toe-state/</p>
<blockquote>
<p>A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.</p>
</blockquote>
<blockquote>
<p>The board is a 3 x 3 array, and consists of characters <code>&quot; &quot;</code>, <code>&quot;X&quot;</code>, and <code>&quot;O&quot;</code>.  The <code>&quot; &quot;</code> character represents an empty square.</p>
</blockquote>
<blockquote>
<p>Here are the rules of Tic-Tac-Toe:</p>
</blockquote>
<blockquote>
<ul>
<li>Players take turns placing characters into empty squares (&quot; &quot;).</li>
</ul>
</blockquote>
<ul>
<li>The first player always places &quot;X&quot; characters, while the second player always places &quot;O&quot; characters.</li>
<li>&quot;X&quot; and &quot;O&quot; characters are always placed into empty squares, never filled ones.</li>
<li>The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.</li>
<li>The game also ends if all squares are non-empty.</li>
<li>No more moves can be played if the game is over.
<strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [&quot;O  &quot;, &quot;   &quot;, &quot;   &quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first player always plays &quot;X&quot;.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: board = [&quot;XOX&quot;, &quot; X &quot;, &quot;   &quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Players take turns making moves.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: board = [&quot;XXX&quot;, &quot;   &quot;, &quot;OOO&quot;]</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: board = [&quot;XOX&quot;, &quot;O O&quot;, &quot;XOX&quot;]</span><br><span class="line">Output: true</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board</code> is a length-3 array of strings, where each string <code>board[i]</code> has length 3.</li>
<li>Each <code>board[i][j]</code> is a character in the set <code>{&quot; &quot;, &quot;X&quot;, &quot;O&quot;}</code>.</li>
</ol>
<p>题目问的是游戏过程中是否会出现给出的<code>board</code>情景，不涉及算法问题，理清游戏的规则就好。首先，轮流保证了<code>X</code>和<code>O</code>的数量差值永远不会大于1，而且由于<code>X</code>先执，所以如果有多出的1个也必须是<code>X</code>。如果游戏出现了一方获胜的结局，那么需要满足：</p>
<p>因为轮流的顺序，如果是执<code>X</code>方获胜，则需要满足<code>X</code>三连以及<code>X-O==1</code>，同理，如果执<code>O</code>方获胜则需要<code>O</code>三连以及<code>X==O</code>。所以不存在同时获胜的可能性，因为九宫格和<code>X-O&lt;=1</code>的限制，也不会出现一方有多个三连的可能性。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTicTacToe</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x_r=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        o_r=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        x_c=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        o_c=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        x_d=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        o_d=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        x,o=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'X'</span>:</span><br><span class="line">                    x+=<span class="number">1</span></span><br><span class="line">                    x_r[i]+=<span class="number">1</span></span><br><span class="line">                    x_c[j]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i==j:</span><br><span class="line">                        x_d[<span class="number">0</span>]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i+j==<span class="number">2</span>:</span><br><span class="line">                        x_d[<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'O'</span>:</span><br><span class="line">                    o+=<span class="number">1</span></span><br><span class="line">                    o_r[i]+=<span class="number">1</span></span><br><span class="line">                    o_c[j]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i==j:</span><br><span class="line">                        o_d[<span class="number">0</span>]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i+j==<span class="number">2</span>:</span><br><span class="line">                        o_d[<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> o&gt;x <span class="keyword">or</span> x-o&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> x_r+x_c+x_d <span class="keyword">and</span> x-o!=<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> o_r+o_c+o_d <span class="keyword">and</span> x!=o:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Number of Matching Subsequences</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/number-of-matching-subsequences/</p>
<blockquote>
<p>Given string <code>S</code> and a dictionary of words words, find the number of <code>words[i]</code> that is a subsequence of <code>S</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S = &quot;abcde&quot;</span><br><span class="line">words = [&quot;a&quot;, &quot;bb&quot;, &quot;acd&quot;, &quot;ace&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three words in words that are a subsequence of S: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>All words in words and <code>S</code> will only consists of lowercase letters.</li>
<li>The length of <code>S</code> will be in the range of <code>[1, 50000]</code>.</li>
<li>The length of <code>words</code> will be in the range of <code>[1, 5000]</code>.</li>
<li>The length of <code>words[i]</code> will be in the range of <code>[1, 50]</code>.</li>
</ol>
<p>题目的逻辑不难，但因为<code>S</code>和<code>words</code>的大小客观，直接上去按照题意写容易TLE。先用字典记录<code>S</code>中的字符出现的索引，再对<code>words[i]</code>中每个字符在字典中二分查找是否存在比上一个索引更大的索引值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span><span class="params">(self, S, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">26</span>)]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            d[ord(c)-ord(<span class="string">'a'</span>)].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            last=<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">                x=bisect.bisect(d[ord(c)-ord(<span class="string">'a'</span>)],last)</span><br><span class="line">                <span class="keyword">if</span> x==len(d[ord(c)-ord(<span class="string">'a'</span>)]):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                last=d[ord(c)-ord(<span class="string">'a'</span>)][x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(words)-res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为<code>o(len(S)+sum(len(word[i])))</code>，空间复杂度为<code>o(len(S))</code></p>
<h2>Number of Subarrays with Bounded Maximum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/number-of-subarrays-with-bounded-maximum/</p>
<blockquote>
<p>We are given an array <code>A</code> of positive integers, and two positive integers <code>L</code> and <code>R</code> (<code>L &lt;= R</code>).</p>
</blockquote>
<blockquote>
<p>Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least <code>L</code> and at most <code>R</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [2, 1, 4, 3]</span><br><span class="line">L = 2</span><br><span class="line">R = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>L, R  and <code>A[i]</code> will be an integer in the range <code>[0, 10^9]</code>.</li>
<li>The length of <code>A</code> will be in the range of <code>[1, 50000]</code>.</li>
</ol>
<p>理解题目的contiguous指的是在原列表的顺序，和正数大小是否连续无关。我们先进行线性扫描，假设遇到不符合题意的即<code>&gt;R</code>的元素为<code>A[i]</code>，之后遇到的任意符合<code>L&lt;=A[j]&lt;R</code>，都可以组成符合要求的<code>A[i+1]-A[j]</code>最长子数组，其子数组<code>A[k]-A[j]</code>（<code>i+1&lt;=k&lt;=j</code>）也是都是符合题意的，所有公有<code>j-i</code>个子数组。当再次出现<code>&gt;R</code>的元素时更新<code>i</code>和<code>j</code>值再次累加即可。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(self, A, L, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,left,right=<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> (i,num) <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> num&gt;R:</span><br><span class="line">                left=i</span><br><span class="line">            <span class="keyword">if</span> num&gt;=L:</span><br><span class="line">                right=i</span><br><span class="line">            res+=right-left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>毫无疑问，线性扫描的时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>
<h2>Preimage Size of Factorial Zeroes Function</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/preimage-size-of-factorial-zeroes-function/</p>
<blockquote>
<p>Let <code>f(x)</code> be the number of zeroes at the end of <code>x!</code>. (Recall that <code>x! = 1 * 2 * 3 * ... * x</code>, and by convention, <code>0! = 1</code>.)</p>
</blockquote>
<blockquote>
<p>For example,<code>f(3) = 0</code> because <code>3! = 6</code> has no zeroes at the end, while<code>f(11) = 2</code> because <code>11! = 39916800</code> has <code>2</code> zeroes at the end. Given <code>K</code>, find how many non-negative integers <code>x</code> have the property that <code>f(x) = K</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 0</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 5</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no x such that x! ends in K = 5 zeroes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>K</code> will be an integer in the range <code>[0, 10^9]</code>.</li>
</ol>
<p>我们不妨反过来看这个问题，已知了$x$如何求$f(x)$？这个问题简单的多，只要数这个阶乘里面包含多少<code>2</code>和<code>5</code>，众所周知，阶乘里面的<code>2</code>多于<code>5</code>，所以有多少个<code>5</code>就等同于末位有多少<code>0</code>。<code>[1,x]</code>一共有多少个5也很容易计算
$$f\left( x \right) = x/5 + x/{5^2} +  \cdots  + x/{5^n} = \sum\limits_{i = 1}^n {x/{5^i}}$$
容易观察出$g(x)$和$x$模$5$余数无关，也就是说每个$g(x)$可以对应5个不同的$x$，所以给定<code>K</code>值后要找有多少个<code>x</code>要么有5个要么有0个。
接下来把$x$写成某种五进制数形式：
$$x = {a_0} + 5{a_1} + {5^2}{a_2} +  \cdots  + {5^n}{a_n} = \sum\limits_{i = 0}^n {5^i}{a_i}$$
其中各项系数$0 \le a_i \le 4$，$f(x)$重写为$$\begin{align}
f\left( x \right) &amp;= \sum\limits_{i = 1}^n {5^{i - 1}{a_i}}  + \sum\limits_{i = 2}^n {5^{i - 2}{a_i} + }  \cdots  + a_n \\
&amp; = a_1 + (1 + 5){a_2} + (1 + 5 + 5^2)a_3 +  \cdots  + {a_n}\sum\limits_{i = 1}^n {5^{i - 1}}
\end{align}
$$可以通过预先计算$a_i$前各项系数$\sum\limits_{j = 0}^i {5^{i - 1}}$然后从最大的项开始对$f(x)=K$取模，找出是否存在符合$0 \le a_i \le 4$约束的$a_i$，如果不存在即说明这个$K$并不在$f(x)$的值域，返回0</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preimageSizeFZF</span><span class="params">(self, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=int(math.floor(math.log(<span class="number">10</span>**<span class="number">9</span>/<span class="number">4</span>,<span class="number">5</span>)))+<span class="number">1</span></span><br><span class="line">        coef=[sum([<span class="number">5</span>**j <span class="keyword">for</span> j <span class="keyword">in</span> range(n-i)]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coef:</span><br><span class="line">            <span class="keyword">if</span> K/c &gt;=<span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            K%=c</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>我在上面的分析中始终没有提到这个最高次$n$如何确定，根据公式来看$${5^n}{a_n} \le K$$那么简单地取一个<code>K/4</code>在5为底的对数取整，当然这只是<code>n</code>的大小，实际多项式的项数为<code>n+1</code>，那么容易得出算法的时间度为$o(n)$，我在实现上使用了列表存放系数所以空间复杂度$o(n)$，实际上$o(1)$足够。当然我为了避免计算<code>K</code>在边界和零点的各种复杂情况，为了快速把题先做出来，直接按照<code>K</code>的最大值<code>10^9</code>放进去算了，好在数据不大，代码中的<code>n</code>（实际上是<code>n+1</code>）只有13而已。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-74/" data-id="cjm54yli2001efkw3nmbsxw5l" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-73" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-73/">LeetCode Weekly Contest 73</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-73/" class="article-date"><time datetime="2018-02-25T15:29:39.742Z" itemprop="datePublished">2018-02-25</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>感谢每一个看到这里的读者的关注，总之这周我过的非常高兴hhhhh，是的，虽然我本质的失败人士身份没改变，但这周真的特别幸福，与周赛本身无关。这周的题整体并不难，主要也是偏重算法（或许叫算术更好）</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-73/</p>
<h2>Rotated Digits</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/rotated-digits/</p>
<blockquote>
<p>X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number.</p>
</blockquote>
<blockquote>
<p>Now given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">There are four good numbers in the range [1, 10] : 2, 5, 6, 9.</span><br><span class="line">Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>N</code>  will be in range <code>[1, 10000]</code>.</li>
</ol>
<p>各个位数为<code>0,1,8,2,5,6,9</code>且不全为<code>0,1,8</code>即符合要求，我我没文化就直接转成字符串上去直接做了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatedDigits</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        valid_set_self=[<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'8'</span>]</span><br><span class="line">        valid_set_diff=[<span class="string">'2'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> all([(i <span class="keyword">in</span> valid_set_self) <span class="keyword">for</span> i <span class="keyword">in</span> str(num)]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> all([(i <span class="keyword">in</span> valid_set_self+valid_set_diff) <span class="keyword">for</span> i <span class="keyword">in</span> str(num)]):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$</p>
<h2>Escape The Ghosts</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/escape-the-ghosts/</p>
<blockquote>
<p>You are playing a simplified Pacman game. You start at the point <code>(0, 0)</code>, and your destination is <code>(target[0], target[1])</code>. There are several ghosts on the map, the i-th ghost starts at <code>(ghosts[i][0], ghosts[i][1])</code>.</p>
</blockquote>
<blockquote>
<p>Each turn, you and all ghosts simultaneously <em>may</em> move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.</p>
</blockquote>
<blockquote>
<p>You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.</p>
</blockquote>
<blockquote>
<p>Return True if and only if it is possible to escape.</p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">ghosts = [[1, 0], [0, 3]]</span><br><span class="line">target = [0, 1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">ghosts = [[1, 0]]</span><br><span class="line">target = [2, 0]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line">Input:</span><br><span class="line">ghosts = [[2, 0]]</span><br><span class="line">target = [1, 0]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The ghost can reach the target at the same time as you.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>All points have coordinates with absolute value &lt;= <code>10000</code>.</li>
<li>The number of ghosts will not exceed <code>100</code>.</li>
</ol>
<p>理解题意要考虑的是<code>ghost</code>在所有方向运动，而玩家需要在所有的可能性下找到一条不遇上<code>ghost</code>就到达终点的路。但这里并不适用任何寻路算法，要考虑的只有是不是有<code>ghost</code>比你离终点更近，只要它更近就可以在到达终点之后折回到你去终点的路。根据游戏的移动路径这里的“近”指的是Manhattan距离。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">escapeGhosts</span><span class="params">(self, ghosts, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ghosts: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m=abs(target[<span class="number">0</span>])+abs(target[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> ghosts:</span><br><span class="line">            <span class="keyword">if</span> abs(x-target[<span class="number">0</span>])+abs(y-target[<span class="number">1</span>])&lt;=m:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，这里的<code>n</code>指<code>ghost</code>的数量。</p>
<h2>Custom Sort String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/custom-sort-string/</p>
<blockquote>
<p><code>S</code> and <code>T</code> are strings composed of lowercase letters. In <code>S</code>, no letter occurs more than once.</p>
</blockquote>
<blockquote>
<p><code>S</code> was sorted in some custom order previously. We want to permute the characters of <code>T</code> so that they match the order that <code>S</code> was sorted. More specifically, if <code>x</code> occurs before <code>y</code> in <code>S</code>, then <code>x</code> should occur before <code>y</code> in the returned string.</p>
</blockquote>
<blockquote>
<p>Return any permutation of <code>T</code> (as a string) that satisfies this property.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S = &quot;cba&quot;</span><br><span class="line">T = &quot;abcd&quot;</span><br><span class="line">Output: &quot;cbad&quot;</span><br><span class="line">Explanation:</span><br><span class="line">&quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;.</span><br><span class="line">Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> has length at most <code>26</code>, and no character is repeated in <code>S</code>.</li>
<li><code>T</code> has length at most <code>200</code>.</li>
<li><code>S</code> and <code>T</code> consist of lowercase letters only.</li>
</ol>
<p>没什么好说的，我本人没文化，也不太会写什么排序，直接就在<code>sorted</code>的<code>key</code>参数上指定按照<code>S</code>的索引值排序了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">customSortString</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(sorted(list(T),key=<span class="keyword">lambda</span> c: S.index(c) <span class="keyword">if</span> c <span class="keyword">in</span> S <span class="keyword">else</span> len(T)))</span><br></pre></td></tr></table></figure></p>
<p>显然时间复杂度就是<code>sorted</code>函数本身的$o(n \log n)$</p>
<p>如果真的按照题意用比较naive的方法去做的话，也是同理，元素的key值按照<code>S</code>去写排序算法，不过排序算法的复杂度天花板就是这样了，我暂时也没想到什么特别好的方法。</p>
<h2>Domino and Tromino Tiling</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/domino-and-tromino-tiling/</p>
<blockquote>
<p>We have two types of tiles: a 2x1 domino shape, and an &quot;L&quot; tromino shape. These shapes may be rotated.</p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XX  &lt;- domino</span><br><span class="line"></span><br><span class="line">XX  &lt;- &quot;L&quot; tromino</span><br><span class="line">X</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p>(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The five different ways are listed below, different letters indicates different tiles:</span><br><span class="line">XYZ XXZ XYY XXY XYY</span><br><span class="line">XYZ YYZ XZZ XYY XXY</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>N  will be in range <code>[1, 1000]</code>.</li>
</ol>
<p>很典型的动态规划，递推式<code>dp[n]=2*dp[n-1]+dp[n-3]</code>的推导可以见<a href="https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116664/Schematic-explanation-of-two-equivalent-DP-recurrence-formula" target="_blank" rel="noopener">这个讨论</a>，周赛为了赶时间先xjb写提交上了再说</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilings</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">        m=<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp=[<span class="number">0</span>]*N</span><br><span class="line">        dp[<span class="number">0</span>],dp[<span class="number">1</span>],dp[<span class="number">2</span>]=<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,N):</span><br><span class="line">            dp[i]=(<span class="number">2</span>*dp[i<span class="number">-1</span>]+dp[i<span class="number">-3</span>])%m</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度都为$o(N)$，但是正如我之前所说，这种一维的索引差值不大的动态规划，不需要额外浪费空间，3个变量迭代着也行。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-73/" data-id="cjm54ylhm0018fkw3khwtppza" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-72" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-72/">LeetCode Weekly Contest 72</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-72/" class="article-date"><time datetime="2018-02-18T13:01:08.646Z" itemprop="datePublished">2018-02-18</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新年快乐！这几天都会在图书馆专心学习，直到天气回暖吧。因为之前的不学无术不但坑了自己，也给别人带来了困扰。我不会再犯相同的错误了，我将专注学习和输出一些真正有价值的东西。</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-72/</p>
<h2>Letter Case Permutation</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/letter-case-permutation/</p>
<blockquote>
<p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a1b2&quot;</span><br><span class="line">Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">Input: S = &quot;3z4&quot;</span><br><span class="line">Output: [&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class="line"></span><br><span class="line">Input: S = &quot;12345&quot;</span><br><span class="line">Output: [&quot;12345&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> will be a string with length at most <code>12</code>.</li>
<li><code>S</code> will consist only of letters or digits.</li>
</ol>
<p>思路很简单，遍历字符串找到字母然后将所有已有结果进行该字母大小写的转换再放入结果，所以最后返回的列表长度必然为<code>2^n</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[S]</span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            <span class="keyword">if</span> c.isalpha():</span><br><span class="line">                temp=[]</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">                    base=s[:i]+c.swapcase()+s[i+<span class="number">1</span>:] <span class="keyword">if</span> i&lt;len(S) <span class="keyword">else</span> s[:i]+c.swapcase()</span><br><span class="line">                    temp.append(base)</span><br><span class="line">                res+=temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>在最坏情况下，时间复杂度为$o(n)$，空间复杂度为$o(2^n)$</p>
<h2>Is Graph Bipartite?</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/is-graph-bipartite/</p>
<blockquote>
<p>Given a <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
</blockquote>
<blockquote>
<p>Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
</blockquote>
<blockquote>
<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists.  Each node is an integer between <code>0</code> and <code>graph.length - 1</code>.  There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn't contain any element twice.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent ubsets.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>graph</code> will have length in range <code>[1, 100]</code>.</li>
<li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li>
<li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li>
</ol>
<p>注意一下<code>graph</code>实际上是一个邻接表而非边集。可以尝试用DFS标记节点，将相邻节点标记为两个不同的集合。没有必要纠结新访问的根结点放到哪个集合，实际上是等价的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(graph)</span><br><span class="line">        color=[<span class="number">-1</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">                <span class="keyword">if</span> color[i]==color[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> color[j]&lt;<span class="number">0</span>:</span><br><span class="line">                    color[j]=<span class="number">1</span>-color[i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dfs(j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> color[i]&lt;<span class="number">0</span>:</span><br><span class="line">                color[i]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度与边数线性相关，空间复杂度与节点数线性相关。</p>
<h2>Cheapest Flights Within K Stops</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/cheapest-flights-within-k-stops/</p>
<blockquote>
<p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code> and arrives at <code>v</code> with a price w.</p>
</blockquote>
<blockquote>
<p>Now given all the cities and fights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 1</span><br><span class="line">Output: 200</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt="">
<strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 0</span><br><span class="line">Output: 500</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes <code>n</code> will be in range <code>[1, 100]</code>, with nodes labeled from <code>0</code> to <code>n - 1</code>.</li>
<li>The size of <code>flights</code> will be in range <code>[0, n * (n - 1) / 2]</code>.</li>
<li>The format of each flight will be <code>(src, dst, price)</code>.</li>
<li>The price of each flight will be in the range <code>[1, 10000]</code>.</li>
<li><code>k</code> is in the range of <code>[0, n - 1]</code>.</li>
<li>There will not be any duplicated flights or self cycles.</li>
</ol>
<p>非常典型的单源最短路径，我们没文化的人就直接用Dijkstra算法解决了，增加一个字段去记录源结点到当前结点经过的结点数，第一次取出最近的结点为目标结点且经过的结点数小于<code>K</code>即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n, flights, src, dst, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type flights: List[List[int]]</span></span><br><span class="line"><span class="string">        :type src: int</span></span><br><span class="line"><span class="string">        :type dst: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        h=[(<span class="number">0</span>,src,<span class="number">0</span>)]</span><br><span class="line">        d=dict(&#123;src:<span class="number">0</span>&#125;)</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            dist,node,p=heapq.heappop(h)</span><br><span class="line">            <span class="keyword">if</span> node==dst <span class="keyword">and</span> p&lt;=K+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> dist</span><br><span class="line">            <span class="keyword">for</span> [i,j,price] <span class="keyword">in</span> flights:</span><br><span class="line">                <span class="keyword">if</span> i==node:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> d <span class="keyword">or</span> d[j]&gt;d[i]+price:</span><br><span class="line">                        d[j]=d[i]+price</span><br><span class="line">                        heapq.heappush(h,(d[j],j,p+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(n)$</p>
<h2>K-th Smallest Prime Fraction</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/k-th-smallest-prime-fraction/</p>
<blockquote>
<p>A sorted list <code>A</code> contains 1, plus some number of primes.  Then, for every p &lt; q in the list, we consider the fraction p/q.</p>
</blockquote>
<blockquote>
<p>What is the <code>K</code>-th smallest fraction considered?  Return your answer as an array of ints, where <code>answer[0] = p</code> and <code>answer[1] = q</code>.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1, 2, 3, 5], K = 3</span><br><span class="line">Output: [2, 5]</span><br><span class="line">Explanation:</span><br><span class="line">The fractions to be considered in sorted order are:</span><br><span class="line">1/5, 1/3, 2/5, 1/2, 3/5, 2/3.</span><br><span class="line">The third fraction is 2/5.</span><br><span class="line"></span><br><span class="line">Input: A = [1, 7], K = 1</span><br><span class="line">Output: [1, 7]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code> will have length between <code>2</code> and <code>2000</code>.</li>
<li>Each <code>A[i]</code> will be between <code>1</code> and <code>30000</code>.</li>
<li><code>K</code> will be between <code>1</code> and<code>A.length * (A.length + 1) / 2</code>.</li>
</ol>
<p>参考<a href="https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115538/Python-solution-using-Binary-Search" target="_blank" rel="noopener">Python solution using Binary Search</a>提到的二分查找策略。<code>A</code>是有序列表，找到<code>A[i]/m</code>在<code>A</code>中的插入位置，在<code>A[i]/m</code>右边的<code>A</code>的元素<code>A[j]</code>，因为有<code>A[i]/m &lt; A[j]</code>，所以<code>A[i]/A[j] &lt; m</code>,那么<code>border</code>求和得到的<code>cur</code>就是小于<code>m</code>的分数的个数，使用二分法不断调整<code>m</code>的大小使之接近最后想要的那个分数。最后，当<code>cur==K</code>时，恰好有<code>K</code>个<code>A[i]/A[j] &lt; m</code>，<code>border</code>中的元素<code>j</code>即为对于每个<code>i</code>来说满足<code>A[i]/A[j] &lt; m</code>时<code>A[i]/A[j]</code>最大的值，那么找到最大的那个<code>A[i]/A[j]</code>就是找到了第<code>K</code>个分数。至于实现的问题，因为题中已经保证了<code>A</code>中元素不重复，所以不需要另外考虑<code>bisect</code>的方向，以及最后注意一下精度问题，<code>l,r,m</code>都是<code>[0,1]</code>之间的数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallestPrimeFraction</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l, r, N = <span class="number">0</span>, <span class="number">1</span>, len(A)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            m = (l + r) / <span class="number">2.0</span></span><br><span class="line">            border = [bisect.bisect(A, A[i] / m) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">            cur = sum(N - i <span class="keyword">for</span> i <span class="keyword">in</span> border)</span><br><span class="line">            <span class="keyword">if</span> cur &gt; K:</span><br><span class="line">                r = m</span><br><span class="line">            <span class="keyword">elif</span> cur &lt; K:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> max([(A[i], A[j]) <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(border) <span class="keyword">if</span> j &lt; N], key=<span class="keyword">lambda</span> x: float(x[<span class="number">0</span>]) / x[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>除了二分查找以外，比较典型的解法如优先队列可以参阅<a href="https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115531/C++-9lines-priority-queue" target="_blank" rel="noopener">其他讨论</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-72/" data-id="cjm54ylh10014fkw3kja8y8bm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-71" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-71/">LeetCode Weekly Contest 71</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-71/" class="article-date"><time datetime="2018-02-11T10:34:39.539Z" itemprop="datePublished">2018-02-11</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>预祝各位新春快乐！今天本来在图书馆准备打的周赛，结果做完三道题后赶上午休，被管理员轰出去了。作为码渣正好借口休息，我心也是够大的直接出去吃饭了（我是反面教材，请大家不要有样学样），剩下那道等回来继续做。整体不难，不涉及什么特别复杂的算法。</p>
<p>https://leetcode.com/contest/weekly-contest-71/</p>
<p>提醒一下大家想跟着水周赛的，千万不要忘记提前Register，我不知道是我穷疯了还是LeetCode穷疯了，周赛题都开始突然收费了，不想花钱的话只能保证每周都要Register一下，哪怕Register了以后当天没完成，一周内还是可以免费做的。<s>我们穷人就是这个样子的，不服请打钱</s></p>
<p>&lt;!-- more --&gt;</p>
<h2>Minimum Distance Between BST Nodes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-71/problems/minimum-distance-between-bst-nodes/</p>
<blockquote>
<p>Given a Binary Search Tree (BST) with the root node <code>root</code>, return the minimum difference between the values of any two different nodes in the tree.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,6,1,3,null,null]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Note that root is a TreeNode object, not an array.</span><br><span class="line"></span><br><span class="line">The given tree [4,2,6,1,3,null,null] is represented by the following diagram:</span><br><span class="line"></span><br><span class="line">          4</span><br><span class="line">        /   \</span><br><span class="line">      2      6</span><br><span class="line">     / \    </span><br><span class="line">    1   3  </span><br><span class="line"></span><br><span class="line">while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The size of the BST will be between <code>2</code> and <code>100</code>.</li>
<li>The BST is always valid, each node's value is an integer, and each node's value is different.</li>
</ol>
<p>我思维比较Naive，直接中序遍历，然后找相邻数之间的最小差值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDiffInBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vals=[]</span><br><span class="line">        res=sys.maxint</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                in_order(root.left)</span><br><span class="line">                vals.append(root.val)</span><br><span class="line">                in_order(root.right)</span><br><span class="line"></span><br><span class="line">        in_order(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(vals)<span class="number">-1</span>):</span><br><span class="line">            res=min(res,vals[i+<span class="number">1</span>]-vals[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>显然时间和空间复杂度都是$o(n)$，当然一开始我想的是先找每个结点的左子树的最大值和右子树的最小值，与结点值比较，递归找出最小差值，但想想写起来麻烦，赶时间就用了上面简单粗暴的笨办法。</p>
<h2>Rabbits in Forest</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-71/problems/rabbits-in-forest/</p>
<blockquote>
<p>In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those <code>answers</code> are placed in an array.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of rabbits that could be in the forest.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: answers = [1, 1, 2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The two rabbits that answered &quot;1&quot; could both be the same color, say red.</span><br><span class="line">The rabbit than answered &quot;2&quot; can&apos;t be red or the answers would be inconsistent.</span><br><span class="line">Say the rabbit that answered &quot;2&quot; was blue.</span><br><span class="line">Then there should be 2 other blue rabbits in the forest that didn&apos;t answer into the array.</span><br><span class="line">The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&apos;t.</span><br><span class="line"></span><br><span class="line">Input: answers = [10, 10, 10]</span><br><span class="line">Output: 11</span><br><span class="line"></span><br><span class="line">Input: answers = []</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>answers</code> will have length at most <code>1000</code>.</li>
<li>Each <code>answers[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<p>先考虑一个情况即有13只兔子声称有其他13只兔子和它自己同色，很显然我们知道这里面至少有1只和其他12只是不同色的，这里面至少有2种毛色和14只兔子。假设有<code>r</code>只兔子都说除了自己以外还有<code>nums</code>只兔子和自己同色，那么这里至少有<code>(r-1)/(nums+1)+1</code>种毛色，每种至少有<code>nums+1</code>只兔子，说出不同<code>nums</code>的兔子们又必然不同色，所以很容易有
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRabbits</span><span class="params">(self, answers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type answers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        <span class="keyword">return</span> sum([(int((r<span class="number">-1</span>)/(nums+<span class="number">1</span>))+<span class="number">1</span>)*(nums+<span class="number">1</span>) <span class="keyword">for</span> (nums,r) <span class="keyword">in</span> collections.Counter(answers).items()])</span><br></pre></td></tr></table></figure></p>
<p>时间和空间代价也是线性的。</p>
<h2>Reaching Points</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-71/problems/reaching-points/</p>
<blockquote>
<p>A move consists of taking a point <code>(x, y)</code> and transforming it to either <code>(x, x+y)</code> or <code>(x+y, y)</code>.</p>
</blockquote>
<blockquote>
<p>Given a starting point <code>(sx, sy)</code> and a target point <code>(tx, ty)</code>, return True if and only if a sequence of moves exists to transform the point <code>(sx, sy)</code> to <code>(tx, ty)</code>. Otherwise, return <code>False</code>.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: sx = 1, sy = 1, tx = 3, ty = 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">One series of moves that transforms the starting point to the target is:</span><br><span class="line">(1, 1) -&gt; (1, 2)</span><br><span class="line">(1, 2) -&gt; (3, 2)</span><br><span class="line">(3, 2) -&gt; (3, 5)</span><br><span class="line"></span><br><span class="line">Input: sx = 1, sy = 1, tx = 2, ty = 2</span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Input: sx = 1, sy = 1, tx = 1, ty = 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>sx, sy, tx, ty</code> will all be integers in the range <code>[1, 10^9]</code>.</li>
</ol>
<p>想清楚以后解法本身不难，我是一开始直接用递归辗转相减，但这会超过递归的最大深度，于是我改成迭代，增加了<code>tx==sx</code>和<code>ty==sy</code>时直接判断<code>(ty-sy)</code>和<code>(tx-sx)</code>语句以后可以通过：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachingPoints</span><span class="params">(self, sx, sy, tx, ty)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type sx: int</span></span><br><span class="line"><span class="string">        :type sy: int</span></span><br><span class="line"><span class="string">        :type tx: int</span></span><br><span class="line"><span class="string">        :type ty: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        <span class="keyword">while</span> tx&gt;<span class="number">0</span> <span class="keyword">and</span> ty&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> tx==sx <span class="keyword">and</span> ty==sy:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> tx==sx: <span class="comment">#cut down runtime for special cases</span></span><br><span class="line">                <span class="keyword">return</span> ty&gt;sy <span class="keyword">and</span> (ty-sy)%sx==<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> ty==sy:</span><br><span class="line">                <span class="keyword">return</span> tx&gt;sx <span class="keyword">and</span> (tx-sx)%sy==<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tx&gt;ty:</span><br><span class="line">                tx-=ty</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ty-=tx</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(\max \left( {tx,ty} \right))$，空间复杂度为$o(1)$</p>
<h2>Transform to Chessboard</h2>
<p>原题地址 https://leetcode.com/problems/transform-to-chessboard/description/</p>
<blockquote>
<p>An N x N <code>board</code> contains only <code>0</code>s and <code>1</code>s. In each move, you can swap any <code>2</code> rows with each other, or any 2 columns with each other.</p>
</blockquote>
<blockquote>
<p>What is the minimum number of moves to transform the board into a &quot;chessboard&quot; - a board where no <code>0</code>s and no <code>1</code>s are 4-directionally adjacent? If the task is impossible, return -1.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">One potential sequence of moves is shown below, from left to right:</span><br><span class="line"></span><br><span class="line">0110     1010     1010</span><br><span class="line">0110 --&gt; 1010 --&gt; 0101</span><br><span class="line">1001     0101     1010</span><br><span class="line">1001     0101     0101</span><br><span class="line"></span><br><span class="line">The first move swaps the first and second column.</span><br><span class="line">The second move swaps the second and third row.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board = [[0, 1], [1, 0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">Also note that the board with 0 in the top left corner,</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">is also a valid chessboard.</span><br><span class="line"></span><br><span class="line">Input: board = [[1, 0], [1, 0]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">No matter what sequence of moves you make, you cannot end with a valid chessboard.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board</code> will have the same number of rows and columns, a number in the range <code>[2, 30]</code>.</li>
<li><code>board[i][j]</code> will be only <code>0</code>s or <code>1</code>s.</li>
</ol>
<p>直接参考<a href="https://leetcode.com/problems/transform-to-chessboard/discuss/114843/Key-Observation-on-property-of-ChessBoard" target="_blank" rel="noopener">这个讨论</a>提出的关键点，注意一下奇偶。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movesToChessboard</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(board)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>]^board[<span class="number">0</span>][i])^(board[j][<span class="number">0</span>]^board[j][i]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum(board[<span class="number">0</span>])&lt;n/<span class="number">2</span> <span class="keyword">or</span> sum(board[<span class="number">0</span>])&gt;n/<span class="number">2</span>+n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n/<span class="number">2</span>&lt;=sum(board[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n))&lt;=n/<span class="number">2</span>+n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        c=sum(board[<span class="number">0</span>][i]==i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">        r=sum(board[i][<span class="number">0</span>]==i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> c%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                c=n-c</span><br><span class="line">            <span class="keyword">if</span> r%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                r=n-r</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c=min(n-c,c)</span><br><span class="line">            r=min(n-r,r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (r+c)/<span class="number">2</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-71/" data-id="cjm54ylgt0012fkw30je7ot1e" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-70" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-70/">LeetCode Weekly Contest 70</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-70/" class="article-date"><time datetime="2018-02-04T13:06:59.544Z" itemprop="datePublished">2018-02-04</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>又是新的一周，希望各位安好。最近生病，写的可能有点慢，之前欠的债也要慢慢补上，各位见谅。直接看题。</p>
<p>https://leetcode.com/contest/weekly-contest-70/</p>
<p>&lt;!-- more --&gt;</p>
<h2>K-th Symbol in Grammar</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-70/problems/k-th-symbol-in-grammar/</p>
<blockquote>
<p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code> with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p>
</blockquote>
<blockquote>
<p>Given row <code>N</code> and index <code>K</code>, return the K-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N = 4, K = 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li>
<li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li>
</ol>
<p>上来直接难度分类为<code>Medium</code>有点吓人，但实际这题没有<code>Medium</code>的难度。你可以把这种数据结构理解成类似二叉树的东西，每一行都是一层第<code>N</code>层有<code>2**(N-1)</code>个结点。求深度为<code>N</code>的树第<code>K</code>个叶结点上的元素？很直接的就想到递归了：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthGrammar</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span> <span class="keyword">and</span> K==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> K&gt;<span class="number">2</span>**(N<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>-self.kthGrammar(N<span class="number">-1</span>,K<span class="number">-2</span>**(N<span class="number">-2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.kthGrammar(N<span class="number">-1</span>,K)</span><br></pre></td></tr></table></figure></p>
<p>递归的深度为$o(N)$，所以这个方法明显是关于$N$线性时间复杂度的。</p>
<h2>Swap Adjacent in LR String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-70/problems/swap-adjacent-in-lr-string/</p>
<blockquote>
<p>In a string composed of <code>'L'</code>, <code>'R'</code>, and <code>'X'</code> characters, like <code>&quot;RXXLRXRXL&quot;</code>, a move consists of either replacing one occurrence of <code>&quot;XL&quot;</code> with <code>&quot;LX&quot;</code>, or replacing one occurrence of <code>&quot;RX&quot;</code> with &quot;<code>XR&quot;</code>. Given the starting string <code>start</code> and the ending string <code>end</code>, return True if and only if there exists a sequence of moves to transform one string to the other.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">We can transform start to end following these steps:</span><br><span class="line">RXXLRXRXL -&gt;</span><br><span class="line">XRXLRXRXL -&gt;</span><br><span class="line">XRLXRXRXL -&gt;</span><br><span class="line">XRLXXRRXL -&gt;</span><br><span class="line">XRLXXRRLX</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>.</li>
<li>Both <code>start</code> and <code>end</code> will only consist of characters in <code>{'L', 'R', 'X'}</code>.</li>
</ol>
<p>对于<code>start</code>中的<code>L</code>可以通过<code>XL</code>$\to$<code>LX</code>操作进行左移，<code>R</code>可以通过<code>RX</code>$\to$<code>XR</code>操作进行右移，前提是<code>L</code>的左边和<code>R</code>的右边都全是<code>X</code>，<code>L</code>和<code>R</code>的相对次序不能改变。所以可以提取<code>start</code>和<code>end</code>中的所有<code>L</code>和<code>R</code>，保证相对次序上的<code>L</code>和<code>R</code>数量一致，<code>start</code>中的<code>L</code>相对<code>end</code>中的<code>L</code>可以相对左移一些，同理，<code>start</code>中的<code>R</code>相对<code>end</code>中的<code>R</code>可以相对右移一些。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s_lr=[(i,c) <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(start) <span class="keyword">if</span> c!=<span class="string">'X'</span>]</span><br><span class="line">        e_lr=[(i,c) <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(end) <span class="keyword">if</span> c!=<span class="string">'X'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(s_lr)!=len(e_lr):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> ((s_i,s_c),(e_i,e_c)) <span class="keyword">in</span> zip(s_lr,e_lr):</span><br><span class="line">            <span class="keyword">if</span> s_c!=e_c:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s_c==<span class="string">'L'</span> <span class="keyword">and</span> s_i&lt;e_i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s_c==<span class="string">'R'</span> <span class="keyword">and</span> s_i&gt;e_i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度都为$o(N)$，当然相同的思路<a href="https://discuss.leetcode.com/topic/119538/python-simple-solution-3-lines-o-n" target="_blank" rel="noopener">这位</a>写的比我好的多，建议直接看这位的解法。</p>
<h2>Swim in Rising Water</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-70/problems/swim-in-rising-water/</p>
<blockquote>
<p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i,j)</code>.</p>
</blockquote>
<blockquote>
<p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>
</blockquote>
<blockquote>
<p>You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,2],[1,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">At time 0, you are in grid location (0, 0).</span><br><span class="line">You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.</span><br><span class="line"></span><br><span class="line">You cannot reach point (1, 1) until time 3.</span><br><span class="line">When the depth of water is 3, we can swim anywhere inside the grid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class="line">Output: 16</span><br><span class="line">Explanation:</span><br><span class="line"> 0  1  2  3  4</span><br><span class="line">24 23 22 21  5</span><br><span class="line">12 13 14 15 16</span><br><span class="line">11 17 18 19 20</span><br><span class="line">10  9  8  7  6</span><br><span class="line"></span><br><span class="line">The final route is marked in bold.</span><br><span class="line">We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= N &lt;= 50</code>.</li>
<li><code>grid[i][j]</code> is a permutation of <code>[0, ..., N*N - 1]</code>.</li>
</ol>
<p>读题觉得有点被水淹没不知所措的感觉，差不多说的是在<code>t</code>时刻能经过的位置只有值小于等于<code>t</code>的位置。需要做的是找到<code>(0,0)-&gt;(N-1,N-1)</code>途经结点最大值最小的路径。直觉上可以采用类似于Dijkstra的贪心特性的寻路算法，一步步根据前驱结点找下一个代价最小的结点，直到触及<code>(N-1,N-1)</code>为止：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(grid)</span><br><span class="line">        seen=&#123;(<span class="number">0</span>,<span class="number">0</span>)&#125;</span><br><span class="line">        h=[(grid[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            d,r,c=heapq.heappop(h)</span><br><span class="line">            res=max(res,d)</span><br><span class="line">            <span class="keyword">if</span> r==c==N<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=r+dx&lt;N <span class="keyword">and</span> <span class="number">0</span>&lt;=c+dy&lt;N <span class="keyword">and</span> (r+dx,c+dy) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    heapq.heappush(h,(grid[r+dx][c+dy],r+dx,c+dy))</span><br><span class="line">                    seen.add((r+dx,c+dy))</span><br></pre></td></tr></table></figure></p>
<p>在最坏的情况需要遍历所有结点，再加上堆排序，时间复杂度为$o(N^2 \log N)$，空间复杂度为$o(N^2)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-70/" data-id="cjm54ylgm000zfkw3cdtyg0b7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-69" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-69/">LeetCode Weekly Contest 69</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-69/" class="article-date"><time datetime="2018-01-28T12:28:32.280Z" itemprop="datePublished">2018-01-28</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新的一周又开始了，祝大家愉快。上周因为我个人原因坑没填完，这周的题写完我一起补上，谢谢体谅。</p>
<p>https://leetcode.com/contest/weekly-contest-69/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Jewels and Stones</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-69/problems/jewels-and-stones/</p>
<blockquote>
<p>You're given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.  Each character in <code>S</code> is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p>
</blockquote>
<blockquote>
<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.
The characters in <code>J</code> are distinct.</li>
</ol>
<p>没什么好说的，题目很直接，我也就瞎姬儿写了一个通过了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numJewelsInStones</span><span class="params">(self, J, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type J: str</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len([<span class="number">1</span> <span class="keyword">for</span> s <span class="keyword">in</span> S <span class="keyword">if</span> s <span class="keyword">in</span> J])</span><br></pre></td></tr></table></figure></p>
<h2>Global and Local Inversions</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-69/problems/global-and-local-inversions/</p>
<blockquote>
<p>We have some permutation <code>A</code> of <code>[0, 1, ..., N - 1]</code>, where <code>N</code> is the length of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>The number of (global) inversions is the number of <code>i &lt; j</code> with <code>0 &lt;= i &lt; j &lt; N</code> and <code>A[i] &gt; A[j]</code>.</p>
</blockquote>
<blockquote>
<p>The number of local inversions is the number of <code>i</code> with <code>0 &lt;= i &lt; N</code> and <code>A[i] &gt; A[i+1]</code>.</p>
</blockquote>
<blockquote>
<p>Return true if and only if the number of global inversions is equal to the number of local inversions.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,0,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is 1 global inversion, and 1 local inversion.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,0]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are 2 global inversions, and 1 local inversion.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>A will be a permutation of <code>[0, 1, ..., A.length - 1]</code>.</li>
<li>A will have length in range <code>[1, 5000]</code>.</li>
<li>The time limit for this problem has been reduced.</li>
</ol>
<p>注意<code>A</code>是一个<code>[0,n]</code>的排列，所以判断<code>A</code>中的元素能否与其他元素构成一个inversion只要看下标<code>i</code>和元素值<code>num</code>是否相等，而local inversion只要看<code>num</code>和<code>i</code>的绝对差值是否为1，所以可以写成：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIdealPermutation</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> (i,num) <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> abs(i-num)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>只需要线性的时间和常数的空间，容易通过。</p>
<h2>Sliding Puzzle</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-69/problems/sliding-puzzle/</p>
<blockquote>
<p>On a 2x3 <code>board</code>, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.</p>
</blockquote>
<blockquote>
<p>A move consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>
</blockquote>
<blockquote>
<p>The state of the board is solved if and only if the <code>board</code> is <code>[[1,2,3],[4,5,0]]</code>.</p>
</blockquote>
<blockquote>
<p>Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[1,2,3],[4,0,5]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Swap the 0 and the 5 in one move.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[1,2,3],[5,4,0]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: No number of moves will make the board solved.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[4,1,2],[5,0,3]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 5 is the smallest number of moves that solves the board.</span><br><span class="line">An example path:</span><br><span class="line">After move 0: [[4,1,2],[5,0,3]]</span><br><span class="line">After move 1: [[4,1,2],[0,5,3]]</span><br><span class="line">After move 2: [[0,1,2],[4,5,3]]</span><br><span class="line">After move 3: [[1,0,2],[4,5,3]]</span><br><span class="line">After move 4: [[1,2,0],[4,5,3]]</span><br><span class="line">After move 5: [[1,2,3],[4,5,0]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[3,2,4],[1,5,0]]</span><br><span class="line">Output: 14</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board</code> will be a 2 x 3 array as described above.</li>
<li><code>board[i][j]</code> will be a permutation of <code>[0, 1, 2, 3, 4, 5]</code></li>
</ol>
<p>一开始我是想试试和<a href="https://discuss.leetcode.com/topic/118671/simple-python-solution-using-a-search" target="_blank" rel="noopener">这位</a>一样用A*搜索，也算学习一个新的启发式方法，关于这个方法的简单介绍和直观演示可以见<a href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html" target="_blank" rel="noopener">Introduction to A*</a>，简单来说相比经典Dijkstra算法，每轮寻找最小距离结点时，会在原有的到源点距离的基础上增加一个heuristic score值，在这里这个值是用每个被编号的Puzzle块的最终位置和当前位置的坐标差之和。但是这里计算heuristic score过于麻烦，这个值的引入也没给原有算法的性能带来显著的性能提升，所以我还是选择就用经典Dijkstra算法做了：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slidingPuzzle</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        goal=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>]]</span><br><span class="line">        seen=[board]</span><br><span class="line">        h=[(<span class="number">0</span>,board)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_neighbors</span><span class="params">(d,b)</span>:</span></span><br><span class="line">            r,c=(<span class="number">0</span>,b[<span class="number">0</span>].index(<span class="number">0</span>)) <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> b[<span class="number">0</span>] <span class="keyword">else</span> (<span class="number">1</span>,b[<span class="number">1</span>].index(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;= r+dx &lt;<span class="number">2</span> <span class="keyword">and</span> <span class="number">0</span>&lt;=c+dy&lt;<span class="number">3</span>:</span><br><span class="line">                    temp=copy.deepcopy(b)</span><br><span class="line">                    temp[r+dx][c+dy],temp[r][c]=temp[r][c],temp[r+dx][c+dy]</span><br><span class="line">                    <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        seen.append(temp)</span><br><span class="line">                        heapq.heappush(h,(d+<span class="number">1</span>,temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            d,b=heapq.heappop(h)</span><br><span class="line">            <span class="keyword">if</span> b==goal:</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line">            get_neighbors(d,b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>时空复杂度都与结点数相关，最坏情况为Puzzle块数n的排列数即$o(n!)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-69/" data-id="cjm54ylfm000qfkw317zcy0y7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-68" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-68/">LeetCode Weekly Contest 68</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-68/" class="article-date"><time datetime="2018-01-22T11:08:35.018Z" itemprop="datePublished">2018-01-22</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这周的题解写的有些晚，直接原因已经在微博解释过了，我周末偷懒不想刷题溜去看电影了，回来也把时间花在写影评上了。至于为什么不想刷题而逃去看电影，因为这周发生了太多事，我不可挽回的失去了很多，经历了朋友的背叛和自我的情绪失控，总之可以说是挣扎着撑过来了。我现在真的成为了一无所有的失败人士，连在浅色床单上哭泣的资格也没有。</p>
<p>不过那都是过去的事了，我会一直向前走下去的，成为一边哭泣一边追求着的人。我就算为了纸片人都要继续读书，写代码，赚钱啊。在这里求助万能的读者，我需要入手褪黑素和维生素B维持一下状态，有没有具体的安全有效的推荐产品，最好能直接在能刷医保卡的药店买到。我准备写完这篇文章以后去趟药店。</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/code_for_koishi.png" alt="为恋恋而码！"></p>
<p>&lt;!-- more --&gt;</p>
<h2>Toeplitz Matrix</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-68/problems/toeplitz-matrix/</p>
<blockquote>
<p>A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.</p>
</blockquote>
<blockquote>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is Toeplitz.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">1234</span><br><span class="line">5123</span><br><span class="line">9512</span><br><span class="line"></span><br><span class="line">In the above grid, the diagonals are &quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;, and in each diagonal all elements are the same, so the answer is True.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,2],[2,2]]</span><br><span class="line">Output: False</span><br><span class="line">Explanation:</span><br><span class="line">The diagonal &quot;[1, 2]&quot; has different elements.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>matrix</code> will be a 2D array of integers.</li>
<li><code>matrix</code> will have a number of rows and columns in range <code>[1, 20]</code>.</li>
<li><code>matrix[i][j]</code>will be integers in range <code>[0, 99]</code>.</li>
</ol>
<p>我首先疑惑的是没有条件限定<code>M=N</code>，难道不是方阵才有对角线吗？那么对于<code>M!=N</code>的情况，可以用Custom Testcase试一试，会发现对角线指的还是那个斜率的线，就像打阴影线一样，只是如果不是方阵有时不能通到“角”而已。这样的一条“对角线”上的所有元素的坐标<code>(i,j)</code>有<code>i-j</code>为一个固定的常数的性质，而所有“对角线”的<code>i-j</code>对应<code>[-(n-1),m-1]</code>，一个简单的想法就是按照<code>i-j</code>进行遍历找出每条对角线上的元素再对比值是否相同：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n=len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(-n+<span class="number">1</span>,m):</span><br><span class="line">            temp=<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> i-j==s:</span><br><span class="line">                        <span class="keyword">if</span> temp&lt;<span class="number">0</span>:</span><br><span class="line">                            temp=matrix[i][j]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> temp!=matrix[i][j]:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>这样$o((M+N)MN)$的时间复杂度是反人类直觉的，依靠纯人肉判断只要读一遍矩阵就可以判断出来矩阵是否符合要求，因此理想的算法也是只要遍历一遍所有元素即可，那么可以用<code>dict</code>存放每个对角线<code>i-j</code>上的元素然后在遍历时检查是否符合：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isToeplitzMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n=len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        v=dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i-j <span class="keyword">not</span> <span class="keyword">in</span> v:</span><br><span class="line">                    v[i-j]=matrix[i][j]</span><br><span class="line">                <span class="keyword">elif</span> v[i-j]!=matrix[i][j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以把时间复杂度缩减到$o(MN)$了，当然还有更好的方法，比如检查<code>matrix[i][j]</code>和<code>matrix[i+1][j+1]</code>是否相等。</p>
<h2>Reorganize String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-68/problems/reorganize-string/</p>
<blockquote>
<p>Given a string <code>S</code>, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p>
</blockquote>
<blockquote>
<p>If possible, output any possible result.  If not possible, return the empty string.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;aab&quot;</span><br><span class="line">Output: &quot;aba&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;aaab&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
<ol>
<li><code>S</code> will consist of lowercase letters and have length in range <code>[1, 500]</code>.</li>
</ol>
</blockquote>
<p>既然说了只要输出一种可行的重排列，那么不妨直接把字符用<code>Counter</code>统计一下，然后直接把出现频率比较高的字符互相&quot;穿插&quot;即可，只有一种情况即频率最高的字符出现的字符之间即使全部穿插剩下的全部字符也够时，返回空串。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorganizeString</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        counter=Counter(S)</span><br><span class="line">        c=counter.most_common()</span><br><span class="line">        max_fre=c[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> max_fre&gt;len(S)-max_fre+<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">while</span> counter:</span><br><span class="line">            out=counter.most_common(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> out:</span><br><span class="line">                res+=out[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">                counter[out[<span class="number">0</span>][<span class="number">0</span>]]-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(out)&gt;<span class="number">1</span>:</span><br><span class="line">                res+=out[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">                counter[out[<span class="number">1</span>][<span class="number">0</span>]]-=<span class="number">1</span></span><br><span class="line">            counter+=Counter()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这个写法是有问题的：对于频次相同的字符，自减更新之后可能会改变顺序，导致相同的字符在两个循环中连续出现，比如<code>&quot;woow&quot;</code>作为输入时无法得到正确的结果。这题的测试用例比较弱所以没出现这样的问题就AC了。</p>
<p>也有比较有意思的方法比如<a href="https://discuss.leetcode.com/topic/117933/4-lines-python" target="_blank" rel="noopener">4 lines Python</a>分奇偶重新放入高低频率字符。</p>
<h2>Max Chunks To Make Sorted</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-68/problems/max-chunks-to-make-sorted/</p>
<blockquote>
<p>Given an array <code>arr</code> that is a permutation of <code>[0, 1, ..., arr.length - 1]</code>, we split the array into some number of &quot;chunks&quot; (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.</p>
</blockquote>
<blockquote>
<p>What is the most number of chunks we could have made?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [4,3,2,1,0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Splitting into two or more chunks will not return the required result.</span><br><span class="line">For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&apos;t sorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,0,2,3,4]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">We can split into two chunks, such as [1, 0], [2, 3, 4].</span><br><span class="line">However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>arr</code> will have length in range <code>[1, 10]</code>.</li>
<li><code>arr[i]</code> will be a permutation of <code>[0, 1, ..., arr.length - 1]</code>.</li>
</ol>
<p>这题有些类似于<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-67/#Partition-Labels">Partition-Labels</a>，这是利用了排列本身的性质，让前<code>n</code>小的数放在<code>[0,n-1]</code>的位置，让这个<code>n</code>尽可能的小。那很自然想到线性遍历去找前<code>i</code>个数最大值恰好为<code>i</code>的几个关键点。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSorted</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,max_num=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i,num) <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">            max_num=max(max_num,num)</span><br><span class="line">            <span class="keyword">if</span> max_num==i:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>
<h2>Max Chunks To Make Sorted II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-68/problems/max-chunks-to-make-sorted-ii/</p>
<blockquote>
<p>This question is the same as &quot;Max Chunks to Make Sorted&quot; except the integers of the given array are not necessarily distinct, the input array could be up to length <code>2000</code>, and the elements could be up to <code>10**8</code>.</p>
</blockquote>
<blockquote>
<hr>
</blockquote>
<blockquote>
<p>Given an array arr of integers (<strong>not necessarily distinct</strong>), we split the array into some number of &quot;chunks&quot; (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.</p>
</blockquote>
<blockquote>
<p>What is the most number of chunks we could have made?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [5,4,3,2,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Splitting into two or more chunks will not return the required result.</span><br><span class="line">For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn&apos;t sorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [2,1,3,4,4]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">We can split into two chunks, such as [2, 1], [3, 4, 4].</span><br><span class="line">However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>arr</code> will have length in range <code>[1, 2000]</code>.</li>
<li><code>arr[i]</code> will be an integer in range <code>[0, 10**8]</code>.</li>
</ol>
<p>和上一问不同的是把排列改成了有重复的无规律正整数组，不过没关系，先做一下排序转换成排列还是可以继续套用上面的方法：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSorted</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p=sorted(range(<span class="number">0</span>,len(arr)),key=<span class="keyword">lambda</span>(i):(arr[i],i))</span><br><span class="line">        res,max_num=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i,num) <span class="keyword">in</span> enumerate(p):</span><br><span class="line">            max_num=max(max_num,num)</span><br><span class="line">            <span class="keyword">if</span> i==max_num:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(n)$</p>
<h2>Basic Calculator IV</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-68/problems/basic-calculator-iv/</p>
<p>这题之前估计也写过不少版本的小计算器，主要难点也不在算法而在细心和耐心，时间关系我自己就不写了，可以参考<a href="https://discuss.leetcode.com/topic/117974/easy-p" target="_blank" rel="noopener">这位</a>的解法，用正则表达式和<code>eval</code>函数省去了很多工作。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-68/" data-id="cjm54ylia001ifkw3avx6alkq" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-67" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-67/">LeetCode Weekly Contest 67</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-67/" class="article-date"><time datetime="2018-01-14T12:02:47.061Z" itemprop="datePublished">2018-01-14</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>有点懒得交代这周周赛的情况了，划水借口快被我用烂了，那以后干脆就不说这一长串的废话了，只交代这周的其他情况。首先我的kindle报废了，想要攒钱买个kpw，不过也不算什么当务之急，所以只希望大家在微博看到转发抽奖抽kindle的时候顺便带上一下我<a href="http://weibo.com/LxySeptember" target="_blank" rel="noopener">@我是欣宜我正常吗</a>；接下来，我最近因为心情不太好，每天处理完必要的事，新书新文献根本就看不进去，太前沿的东西看着也觉得脑壳疼，每天就漫无目的翻着<a href="https://book.douban.com/subject/20472991/" target="_blank" rel="noopener">Mathematics for Computer Science</a>之类的旧书打发时间磨到“应该去睡觉的时间”就算把一天熬过去了。</p>
<p>&lt;!-- more --&gt;</p>
<p>综上所述，我认为我需要得到帮助，这样说我确实觉得有点羞耻，但这也是事实，我正在走出很重要的一步，对我来说非常困难，很大概率会失败的一步。我很抱歉，我所面临的压力还是源自我自己抉择上的错误，我也没有办法给大家带来什么价值作为回报，但我还是不知羞耻地发出了这样的“求助”，这就是我现在的心情，有没有人看得到有没有人能回应我反而没这么在乎。</p>
<p>https://leetcode.com/contest/weekly-contest-67/</p>
<h2>Prime Number of Set Bits in Binary Representation</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-67/problems/prime-number-of-set-bits-in-binary-representation/</p>
<blockquote>
<p>Given two integers <code>L</code> and <code>R</code>, find the count of numbers in the range <code>[L, R]</code> (inclusive) having a prime number of set bits in their binary representation.</p>
</blockquote>
<blockquote>
<p>(Recall that the number of set bits an integer has is the number of <code>1</code>s present when written in binary. For example, <code>21</code> written in binary is <code>10101</code> which has 3 set bits. Also, 1 is not a prime.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: L = 6, R = 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">6 -&gt; 110 (2 set bits, 2 is prime)</span><br><span class="line">7 -&gt; 111 (3 set bits, 3 is prime)</span><br><span class="line">9 -&gt; 1001 (2 set bits , 2 is prime)</span><br><span class="line">10-&gt;1010 (2 set bits , 2 is prime)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: L = 10, R = 15</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">10 -&gt; 1010 (2 set bits, 2 is prime)</span><br><span class="line">11 -&gt; 1011 (3 set bits, 3 is prime)</span><br><span class="line">12 -&gt; 1100 (2 set bits, 2 is prime)</span><br><span class="line">13 -&gt; 1101 (3 set bits, 3 is prime)</span><br><span class="line">14 -&gt; 1110 (3 set bits, 3 is prime)</span><br><span class="line">15 -&gt; 1111 (4 set bits, 4 is not prime)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>L, R</code> will be integers <code>L &lt;= R</code> in the range <code>[1, 10^6]</code>.</li>
<li><code>R - L</code> will be at most 10000.</li>
</ol>
<p>我就是按照题意暴力无脑码了，遍历<code>[L,R]</code>把每个数转换成二进制，再数这个二进制数里面有几个<code>1</code>，这个数字再检测一下是不是质数。当然考虑到这些数字里面可能存在多个相同或相近的<code>Set Bits</code>(即1的个数)，可以先开一个字典存放某个数是否为质数（<code>cache</code>的功能）</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimeSetBits</span><span class="params">(self, L, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">or</span> x==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,int(math.sqrt(x))+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> x % j ==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        c=<span class="number">0</span></span><br><span class="line">        d=dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(L,R+<span class="number">1</span>):</span><br><span class="line">            ones=bin(i).count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">if</span> ones <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">if</span> d[ones]:</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[ones]=is_prime(ones)</span><br><span class="line">                <span class="keyword">if</span> d[ones]:</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></p>
<p>直观来看，在最坏的情形下，空间代价为$o(L-R)$，时间代价为$o((L - R)\sqrt R )$，当我写完这个已经AC的提交再去看<a href="https://leetcode.com/articles/prime-number-of-set-bits-in-binary-representation/" target="_blank" rel="noopener">官方题解</a>的思路，发现因为<code>2^20</code>&gt;<code>10^6</code>，也就是说这题涉及的质数只有<code>2, 3, 5, 7, 11, 13, 17, 19</code>，这要检查每个数的<code>1</code>的个数是否是上面的数之一就可以了，所以在他的题解里给出了非常简洁高效的方法
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimeSetBits</span><span class="params">(self, L, R)</span>:</span></span><br><span class="line">        primes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> sum(bin(x).count(<span class="string">'1'</span>) <span class="keyword">in</span> primes</span><br><span class="line">                   <span class="keyword">for</span> x <span class="keyword">in</span> xrange(L, R+<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>我应该为我迟钝的数感感到羞愧吧。不过我现在不会这么想了，实际上我的方法最终<code>d</code>的长度也不会超过20，根本不会达到那个“最坏情况”。总是想着一下子想到最佳解，拿来当成终身目标是可以的，天天拿这种想法和自己过不去就不应该了，最重要的还是客服拖延症和各种不良情绪，先把事情完成，优化可以慢慢做慢慢学。</p>
<h2>Partition Labels</h2>
<p>原题地址： https://leetcode.com/contest/weekly-contest-67/problems/partition-labels/</p>
<blockquote>
<p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> will have length in range <code>[1, 500]</code>.</li>
<li><code>S</code> will consist of lowercase letters (<code>'a'</code>to <code>'z'</code>) only.</li>
</ol>
<p>我的想法很直觉，记录每个字符第一次出现的坐标和最后一次出现的坐标，构成“区间”，再用上周区间合并的方法找出最终能合并为哪几个区间。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start=[<span class="number">-1</span>]*<span class="number">26</span></span><br><span class="line">        end=[<span class="number">-1</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            <span class="keyword">if</span> start[ord(c)-ord(<span class="string">'a'</span>)]&lt;<span class="number">0</span>:</span><br><span class="line">                start[ord(c)-ord(<span class="string">'a'</span>)]=i</span><br><span class="line">                end[ord(c)-ord(<span class="string">'a'</span>)]=i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end[ord(c)-ord(<span class="string">'a'</span>)]=i</span><br><span class="line"></span><br><span class="line">        intervals=[(start[i],end[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>)]</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> (s,e):s)</span><br><span class="line">        merged=[]</span><br><span class="line">        temp=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (s,e) <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> s&gt;=<span class="number">0</span> <span class="keyword">and</span> s&lt;=temp[<span class="number">1</span>]&lt;e:</span><br><span class="line">                temp[<span class="number">1</span>]=e</span><br><span class="line">            <span class="keyword">elif</span> s&gt;=<span class="number">0</span> <span class="keyword">and</span> s&gt;temp[<span class="number">1</span>]:</span><br><span class="line">                merged.append(temp)</span><br><span class="line">                temp=[s,e]</span><br><span class="line">        merged.append(temp)</span><br><span class="line">        <span class="keyword">return</span> [e-s+<span class="number">1</span> <span class="keyword">for</span> (s,e) <span class="keyword">in</span> merged]</span><br></pre></td></tr></table></figure></p>
<p>字母表长度为$A$，<code>S</code>长度为$n$，时间复杂度为$o(n)+o(A \log A)$，空间复杂度$o(A)$，考虑到这里$A$仅为26，所以$A$相关部分可以直接忽略当作常数处理。<a href="https://leetcode.com/problems/partition-labels/solution/" target="_blank" rel="noopener">官方题解</a>用的方法类似，当然写的比我好的多，有兴趣可以去看一下。</p>
<h2>Largest Plus Sign</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-67/problems/largest-plus-sign/</p>
<blockquote>
<p>In a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>. What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p>
</blockquote>
<blockquote>
<p>An &quot;axis-aligned plus sign of <code>1</code>s of order k&quot; has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code> going up, down, left, and right, and made of <code>1</code>s. This is demonstrated in the diagrams below. Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p>
</blockquote>
<blockquote>
<p><strong>Examples of Axis-Aligned Plus Signs of Order k</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Order 1:</span><br><span class="line">000</span><br><span class="line">010</span><br><span class="line">000</span><br><span class="line"></span><br><span class="line">Order 2:</span><br><span class="line">00000</span><br><span class="line">00100</span><br><span class="line">01110</span><br><span class="line">00100</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Order 3:</span><br><span class="line">0000000</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0111110</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0000000</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, mines = [[4, 2]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11111</span><br><span class="line">11011</span><br><span class="line">In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, mines = []</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">There is no plus sign of order 2, but there is of order 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, mines = [[0, 0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">There is no plus sign, so return 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>N</code> will be an integer in the range <code>[1, 500]</code>.</li>
<li><code>mines</code> will have length at most <code>5000</code>.</li>
<li><code>mines[i]</code> will be length 2 and consist of integers in the range <code>[0, N-1]</code>.</li>
<li><em>(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)</em></li>
</ol>
<p>和<a href="https://leetcode.com/problems/largest-plus-sign/solution/" target="_blank" rel="noopener">官方题解</a>的想法一样使用动态规划。对于每一行或者每一列，从四个arm的方向上数，到坐标<code>(i,j)</code>为止最多可以形成多长的arm，取四个方向上arm长度的最小值计入<code>dp[i][j]</code>，最后取整个<code>dp</code>数组中的最大值。思路不复杂，但写起来很容易就会TLE，关键是需要把<code>mines</code>从<code>list</code>转换为用hash表实现的<code>set</code>方便检索。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(self, N, mines)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type mines: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        zeros=set([tuple(m) <span class="keyword">for</span> m <span class="keyword">in</span> mines])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">                count=<span class="number">0</span> <span class="keyword">if</span> (i,j) <span class="keyword">in</span> zeros <span class="keyword">else</span> count+<span class="number">1</span></span><br><span class="line">                dp[i][j]=count</span><br><span class="line"></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                count=<span class="number">0</span> <span class="keyword">if</span> (i,j) <span class="keyword">in</span> zeros <span class="keyword">else</span> count+<span class="number">1</span></span><br><span class="line">                dp[i][j]=min(dp[i][j],count)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">                count=<span class="number">0</span> <span class="keyword">if</span> (i,j) <span class="keyword">in</span> zeros <span class="keyword">else</span> count+<span class="number">1</span></span><br><span class="line">                dp[i][j]=min(dp[i][j],count)</span><br><span class="line"></span><br><span class="line">            count=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                count=<span class="number">0</span> <span class="keyword">if</span> (i,j) <span class="keyword">in</span> zeros <span class="keyword">else</span> count+<span class="number">1</span></span><br><span class="line">                dp[i][j]=min(dp[i][j],count)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max([max(r) <span class="keyword">for</span> r <span class="keyword">in</span> dp])</span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度都为$o(N^2)$</p>
<h2>Couples Holding Hands</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-67/problems/couples-holding-hands/</p>
<blockquote>
<p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing <strong>any</strong> two people, then they stand up and switch seats.</p>
</blockquote>
<blockquote>
<p>The people and seats are represented by an integer from <code>0</code> to <code>2N-1</code>, the couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2N-2, 2N-1)</code>.</p>
</blockquote>
<blockquote>
<p>The couples' initial seating is given by <code>row[i]</code> being the value of the person who is initially sitting in the i-th seat.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: row = [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: row = [3, 2, 0, 1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: All couples are already seated side by side.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>len(row)</code> is even and in the range of <code>[4, 60]</code>.</li>
<li><code>row</code> is guaranteed to be a permutation of <code>0...len(row)-1</code>.</li>
</ol>
<p>又是继承了周赛惯例的谜之难度分级，虽然标记为<code>hard</code>但相比前面的题目无论是思路本身还是数据规模都没有特别大的难点。直接的策略是处理每一对座位时，先固定<code>2i</code>位置上的人，再把<code>2i+1</code>位置上的人换成其partner。对于<code>2n</code>对乱序的人，最多只需要交换<code>n-1</code>次。证明非常直觉化，归纳推导即可，这里我就不给出了，直接看我的提交：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwapsCouples</span><span class="params">(self, row)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type row: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(row),<span class="number">2</span>):</span><br><span class="line">            p=row[i]+<span class="number">1</span> <span class="keyword">if</span> row[i]%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> row[i]<span class="number">-1</span></span><br><span class="line">            j=row.index(p)</span><br><span class="line">            <span class="keyword">if</span> j-i&gt;<span class="number">1</span>:</span><br><span class="line">                row[i+<span class="number">1</span>],row[j]=row[j],row[i+<span class="number">1</span>]</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这里的时间复杂度为$o(n^2)$，只是我的写法偷懒的问题，完全可以再反向开一个索引表而不是用<code>index</code>寻址，使得时间复杂度降低到$o(n)$，当然作为trade off的是空间复杂度上升到了$o(n)$。另外，我这次不太推荐<a href="https://leetcode.com/problems/couples-holding-hands/solution/" target="_blank" rel="noopener">官方题解</a>把问题转换为无向图的做法，这种思维本身很好，但针对这个问题却明显绕了弯路。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-67/" data-id="cjm54ylep000efkw3ejh3nb8o" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="active"><span class="page-number">4</span></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-next" rel="next" href="/page/5/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p> <p>随着一次次的失败，一无所有的作者我已经别无所求了，只想安静的生活下去，不想再被打扰。谢谢大家的关心和照顾，可惜我已经无力回报，非常对不起。有事请联系<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">43</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
        </li>
      
        <li>
          <a href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
