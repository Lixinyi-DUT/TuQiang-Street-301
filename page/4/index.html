<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/4/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-continuations-for-nondeterministic-evaluator" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/continuations-for-nondeterministic-evaluator/">用continuation实现非确定计算</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/continuations-for-nondeterministic-evaluator/" class="article-date"><time datetime="2018-11-05T11:03:34.150Z" itemprop="datePublished">2018-11-05</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>刚拿到<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a> 的时候我扫了一眼没看见全书有提到过<code>call/cc</code>，所以天真的以为continuation相关的内容不会出现，就暂时放心的把书扔在了一边等以后有空慢慢看，毕竟continuation真是让我头疼不已的内容。现在发现在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html#%25_sec_4.3.3" target="_blank" rel="noopener">4.3.3  Implementing the Amb Evaluator</a> 实现非确定求值器（nondeterministic evaluator）时，continuation作为参数过程，成功时可以推进进一步求值，失败时可以回滚到上一个选择分支。所以到这个时候了continuation还是绕不开的话题，没办法也只能硬着头皮强行理解了，再加上整个<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html#%25_sec_4.3" target="_blank" rel="noopener">4.3  Variations on a Scheme -- Nondeterministic Computing</a> 的内容编排顺序也很容易让人（其实只有我）困惑，所以写这篇笔记按照自己的理解写一下如何实现Scheme的非确定求值系统。</p>
<p>&lt;!-- more --&gt;</p>
<p>有能力的人我建议还是先看原书，虽然个人感觉原书内容排的极其不友好，但硬啃下来还是没有问题的，只是文字材料太多很容易精力分散不知所云，而且代码内容距离比较远，不能通过实例体会到文字叙述的重点，所以如果看书最好先从代码密集的地方开始看实现，看不懂的地方再看上下文的文字解释，差不多感觉有点意思了再去看长篇的文字描述。另外，这小节的内容与<a href="http://notebook.xyli.me/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>那篇相反，一开始太专注于描绘底层实现，会让人产生为什么底层要怎么写的疑问，实际上都是为了top-level的特性有意写成这些奇怪的形式的，先去了解Evaluating <code>amb</code> expressions和top-level的Driver loop部分会好很多。如果还是觉得看书很辛苦，可以试试来读我这篇消化后的笔记，或许可以有所帮助。</p>
<h2><code>amb</code>表达式和非确定返回值</h2>
<p>在确定计算（deterministic computing）中，当输入一定时，输出的结果也是确定的。在纯函数式语言（不允许变量的变值操作）中体现为用相同的参数调用同一个函数，一定会返回相同的结果。这个返回结果不一定是标量的（scalar）值，可以是一个tuple，可以是一个list，可以是规模很大的矩阵，甚至可以是长度无限的流……当然也可以是这些复杂数据结构之间的多层复合，但我们仍然视之为单个的确定值。与此相反，如果每次返回的结果即使是并不复杂的小规模的数据，但相同的调用返回不同的结果，就是非确定的计算。</p>
<p>一个不怎么函数式的例子就是随机数生成函数<code>rand</code>，每次使用<code>(rand)</code>都会返回一个不同的随机数。当然，众所周知，这只是伪随机数生成函数<code>rand-update</code>的包装&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，隐藏了用于生成下一个随机数的种子参数。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> random-init <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">rand-update</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">remainder</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">23</span> x) <span class="number">19</span>) <span class="number">101</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> rand (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">x</span> random-init))</span><br><span class="line">                (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                  (<span class="name"><span class="builtin-name">set!</span></span> x (<span class="name">rand-update</span> x))</span><br><span class="line">                  x)))</span><br></pre></td></tr></table></figure></p>
<p>这里实现非确定性的方法是通过每次计算后再更新<code>rand</code>的局部变量<code>x</code>的赋值，即通过调用函数的副作用（side effect）来改变每一次的返回结果。</p>
<p>非确定的计算可以用于得到满足一组约束的任一可行结果。当然在计算资源充足的前提下，计算出所有可行结果把它们复合成一个数据对象（如list）返回，显然是一种更充分的做法，但很多情况下我们未必需要得到所有可行的结果（比如伪随机数的生成），很可能每次只需要一个结果；而且可行结果可能有无数个，或许可以把它们作为流（stream）返回，每次取用只计算一个需要的结果，后面可以看到，在确定求值的解释器上实现非确定求值器确实也使用了类似延迟计算的思想，但表现为每次只返回一个干净的结果。</p>
<p><code>amb</code>是实现非确定求值需要用到的重要的特殊表达式，名字来源于ambiguously
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">amb</span> &lt;e1&gt; &lt;e2&gt; ... &lt;en&gt;)</span><br></pre></td></tr></table></figure></p>
<p>表示可以取任<code>&lt;e1&gt;</code>到<code>&lt;en&gt;</code>的任一表达式作为返回值。比如
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">list</span></span> (<span class="name">amb</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">amb</span> <span class="symbol">'a</span> <span class="symbol">'b</span>))</span><br></pre></td></tr></table></figure></p>
<p>可以产生6种<strong>可能</strong>的返回结果<code>(1 a)	(1 b)	(2 a)	(2 b)	(3 a)	(3 b)</code>，每次调用返回的只能是6个结果之一。当<code>amb</code>只有一个参数时，只有一种确定的返回结果；当<code>amb</code>没有参数时，即调用<code>(amb)</code>时，我们的程序“走投无路”，不得不中止返回。因此我们可以把约束<code>p</code>写为这样的形式：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">require</span></span> p)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">not</span></span> p) (<span class="name">amb</span>)))</span><br></pre></td></tr></table></figure></p>
<p>在其他程序中就可以指令式的使用<code>(require p)</code>检查当前情况是否满足约束，如果不满足就直接跳回。从一个list中取任一元素的过程<code>an-element-of</code>可以写成这样
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">an-element-of</span> items)</span><br><span class="line">  (<span class="name"><span class="builtin-name">require</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">null?</span></span> items)))</span><br><span class="line">  (<span class="name">amb</span> (<span class="name"><span class="builtin-name">car</span></span> items) (<span class="name">an-element-of</span> (<span class="name"><span class="builtin-name">cdr</span></span> items))))</span><br></pre></td></tr></table></figure></p>
<p>初见这个写法的时候可能有人会和我一样困惑，如果<code>amb</code>是等概率随机选择那么<code>items</code>靠前的元素被选到的概率岂不是远大于后面的？按照应用序（applicative order）模型计算函数调用，会先计算函数的所有参数再把它们代入函数体求值，那么接下来会不断的计算最后一行的第二个参数，直至不满足<code>require</code>导致求值失败为止，但<code>amb</code>本身却一次也没被计算，这样不是没有达到预期效果吗？</p>
<p>首先解释第二个问题，<code>amb</code>表达式不是普通过程（ordinary procedure），不遵循一般函数的求值规则，它和<code>if</code>表达式，<code>cons</code>表达式等都是一种特殊形式（special form），不需要等所有参数都完成求值后才传入进行求值，这一点可以在后文解释器对<code>amb</code>语句的分析和求值中看到具体是如何实现的，现在只需要知道，它每次只计算<strong>被选中</strong>的参数的值。</p>
<p>回到第一个问题，等于触及本质的提问，<code>amb</code>到底是怎么做的？</p>
<p>我们可以把确定程序（实质就是某个函数的调用）想象成一个顺序执行的路径，哪怕存在<code>if</code>或<code>cond</code>的分支，因为某次调用的参数的固定的，所以接下来进行哪个分支也是确定的，而<code>amb</code>语句则被视为开始不同分支的选择结点，每个参数都会延伸出一条独立的路径。当遇到没有参数的<code>(amb)</code>或者其他错误时表示“此路不通”。<code>amb</code>执行的其实是我们熟悉的深度优先搜索（depth-first search, DFS），并当遇到失败时回溯（backtrack）到最近的选择结点选择另一条路径，直至找到第一个成功的结果返回。至于选择是依靠什么做出的，可以在后面的实现中看到，就是简单的按照参数的顺序依次去尝试，这也是BFS通常的做法，这样的做法确实会倾向于先返回参数顺序靠前的可行结果，需要下一个可行结果的时候也可以通过调用<code>try-again</code>得到，概率上的“公平”对于这个问题又有什么现实意义呢？</p>
<p>一个用于找和为质数的整数对的例子：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">(<span class="name">prime-sum-pair</span> '(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span>) '(<span class="number">20</span> <span class="number">35</span> <span class="number">110</span>))</span><br><span class="line"><span class="comment">;;; Starting a new problem</span></span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">3</span> <span class="number">20</span>)</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">try-again</span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">3</span> <span class="number">110</span>)</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">try-again</span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">8</span> <span class="number">35</span>)</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">try-again</span><br><span class="line"><span class="comment">;;; There are no more values of</span></span><br><span class="line">(<span class="name">prime-sum-pair</span> (<span class="name"><span class="builtin-name">quote</span></span> (<span class="name">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span>)) (<span class="name"><span class="builtin-name">quote</span></span> (<span class="name">20</span> <span class="number">35</span> <span class="number">110</span>)))</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">(<span class="name">prime-sum-pair</span> '(<span class="number">19</span> <span class="number">27</span> <span class="number">30</span>) '(<span class="number">11</span> <span class="number">36</span> <span class="number">58</span>))</span><br><span class="line"><span class="comment">;;; Starting a new problem</span></span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">30</span> <span class="number">11</span>)</span><br></pre></td></tr></table></figure></p>
<h2>语法分析</h2>
<p>非确定求值器是在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%25_sec_4.1.7" target="_blank" rel="noopener">4.1.7  Separating Syntactic Analysis from Execution</a>实现的，预先完成语法分析再代入环境执行计算的求值器的基础上改造完成的，因为两种求值器的框架十分相似。</p>
<p>为了提高求值的效率，对表达式的求值可以被分为用<code>analyze</code>分析表达式，返回一个只有环境作为参数的过程。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">eval</span></span> exp env)</span><br><span class="line">  ((<span class="name">analyze</span> exp) env))</span><br></pre></td></tr></table></figure></p>
<p><code>analyze</code>是结构与<code>eval</code>相似的dispatch函数，对不同表达式分析出不同的结果，实现细节可以直接去看源码，这里仅观察对于lambda表达式的分析</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-lambda</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">vars</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>))</span><br><span class="line">        (<span class="name">bproc</span> (<span class="name">analyze-sequence</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env) (<span class="name">make-procedure</span> vars bproc env))))</span><br></pre></td></tr></table></figure></p>
<p>如果这个lambda表达式被绑定到了某个函数名，以函数名反复多次调用这个函数时，lambda表达式的函数体<code>bproc</code>只需要被分析一次，可以极大提高求值效率。</p>
<p>在非确定求值器中，也是这样先对表达式进行语法，再把环境<code>env</code>作为参数之一传入分析结果得到最终结果，不同的是增加了另外两个参数，也就是两个续延（continuation）过程，成功续延（success continuation）<code>succeed</code>表示如果对这个表达式求值成功，接下来应该做什么，失败续延（failure continuation）<code>fail</code>表示如果当对这个表达式的求值陷入死路或者其他失败情况（如再次调用<code>try-again</code>）时需要被调用的过程。总之，求值写为</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ambeval</span> exp env succeed fail)</span><br><span class="line">  ((<span class="name">analyze</span> exp) env succeed fail))</span><br></pre></td></tr></table></figure></p>
<h3>续延的结构</h3>
<p>上文提到的success continuation更接近于我们在<code>call/cc</code>接触到的current continuation，不过这话说的很没意义，这里实现的continuation无论哪种和实践中的<code>call/cc</code>使用起来差别都不小。</p>
<p>success continuation负责接收表达式的求值结果并开始进一步的计算（这一点可以在后文对简单表达式的分析中看到典型的例子），除了这个值，还需要另一个failure continuation过程作为参数，来处理接下来在success continuation中如果遇到求值失败的情况。</p>
<p>而failure continuation是一个没有参数的过程，当对当前分支的求值失败时会被调用，从当前对这个错误的分支跳出，从而开始对另一个分支的求值。</p>
<p>所以对一个表达式的语法分析结果是这样的一个lambda表达式：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">  <span class="comment">;; succeed is (lambda (value fail) ...)</span></span><br><span class="line">  <span class="comment">;; fail is (lambda () ...)</span></span><br><span class="line">  ...)</span><br></pre></td></tr></table></figure></p>
<p>当对某个表达式求值时，如果用如下的实参</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">ambeval</span> &lt;exp&gt;</span><br><span class="line">         the-global-environment</span><br><span class="line">         (<span class="name"><span class="builtin-name">lambda</span></span> (value fail) value)</span><br><span class="line">         (<span class="name"><span class="builtin-name">lambda</span></span> () <span class="symbol">'failed</span>))</span><br></pre></td></tr></table></figure></p>
<p>如果计算<code>&lt;exp&gt;</code>顺利得到了结果，将会执行success continuation，直接返回求值结果；如果求值失败，将执行failure continuation返回<code>'failed</code>。</p>
<p>在这个非确定求值器的设计中，success continuation并不怎么需要费心去构造，在driver-loop中已经规定过对一个表达式最终求值成功只需要返回求值结果并开始下一轮输入，所以在大部分场景中<code>succeed</code>只是用来调用或者传递，少数需要重新构造的难点也不在逻辑本身。</p>
<p>比较麻烦的是failure continuation，首先要注意在每个新的success continuation的构造中都会使用一个新的failure continuation作为形参；其次是它的构造和调用场景的限制。</p>
<p>它的构造由只由以下操作完成：</p>
<ul>
<li><code>amb</code>表达式： 具体来说是在对<code>amb</code>表达式的分析和求值时，会构造新的failure continuation，这个failure continuation的内容是再去尝试当前<code>amb</code>中的其他选择。</li>
<li>top-level的<code>driver loop</code>：声明了如果对输入表达式的求值失败，即没有剩下的可行解，应该做什么，failure continuation的内容可以是打印提示信息然后再开始一个loop</li>
<li>赋值： 当选择了一个错误的分支，并进行了这个分支内对变量的变值操作时，如果想放弃对这个分支的继续计算，跳到其他分支，那么必须消除赋值等副作用。</li>
</ul>
<p>它的调用在以下情况发生：</p>
<ul>
<li>执行<code>(amb)</code>时：除了像<code>require</code>那样特意为了失败而失败以外，还有可能只是因为耗尽了<code>amb</code>表达式中所有的选择</li>
<li>用户在top-level输入了try-again迫使程序返回下一个可行结果，那么必须使用failure continuation跳到最近选择点的另一个分支。</li>
</ul>
<h2>实现细节</h2>
<p>接下来从driver-loop和对<code>amb</code>表达式的分析开始，来看我们的分析器和求值器怎样处理各种语句。</p>
<h3><code>amb</code>表达式</h3>
<p>首先来看对<code>amb</code>表达式的分析</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">amb?</span> exp) (<span class="name">tagged-list?</span> exp <span class="symbol">'amb</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">amb-choices</span> exp) (<span class="name"><span class="builtin-name">cdr</span></span> exp))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-amb</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">cprocs</span> (<span class="name"><span class="builtin-name">map</span></span> analyze (<span class="name">amb-choices</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try-next</span> choices)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> choices)</span><br><span class="line">            (<span class="name">fail</span>)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">car</span></span> choices) env</span><br><span class="line">                           succeed</span><br><span class="line">                           (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                             (<span class="name">try-next</span> (<span class="name"><span class="builtin-name">cdr</span></span> choices))))))</span><br><span class="line">      (<span class="name">try-next</span> cprocs))))</span><br></pre></td></tr></table></figure></p>
<p>当没有选择（<code>(amb)</code>语句或者已经耗尽了所有选项）时，直接执行<code>fail</code>，否则执行当前第一个选择<code>(car choices)</code>，并把尝试剩下的选择<code>(try-next (cdr choices)</code>作为当前这项选择失败后需要进入的failure continuation。这就是非确定选择实现的核心部分，由分析<code>amb</code>语句构造出来的failure continuation会一直<strong>传递</strong>下去，直至当前选择遭遇失败时才会执行它跳到最近选择点的下一个选择。</p>
<p>简单总结一下，当还有可选项时，执行可选项并把尝试剩下的选项作为failure continuation，当没有可选项时直接调用这个语句本身的failure continuation即跳回上一个选择点。这种做法是符合DFS的逻辑的。</p>
<h3>Driver loop</h3>
<p>driver-loop直接接受用户的输入并输出求值结果，维持着一个循环接受新的表达式或者<code>try-again</code>命令。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> input-prompt <span class="string">";;; Amb-Eval input:"</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> output-prompt <span class="string">";;; Amb-Eval value:"</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">driver-loop</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">internal-loop</span> try-again)</span><br><span class="line">    (<span class="name">prompt-for-input</span> input-prompt)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">input</span> (<span class="name"><span class="builtin-name">read</span></span>)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> input <span class="symbol">'try-again</span>)</span><br><span class="line">          (<span class="name">try-again</span>)</span><br><span class="line">          (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">            (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">            (<span class="name"><span class="builtin-name">display</span></span> <span class="string">";;; Starting a new problem "</span>)</span><br><span class="line">            (<span class="name">ambeval</span> input</span><br><span class="line">                     the-global-environment</span><br><span class="line">                     <span class="comment">;; ambeval success</span></span><br><span class="line">                     (<span class="name"><span class="builtin-name">lambda</span></span> (val next-alternative)</span><br><span class="line">                       (<span class="name">announce-output</span> output-prompt)</span><br><span class="line">                       (<span class="name">user-print</span> val)</span><br><span class="line">                       (<span class="name">internal-loop</span> next-alternative))</span><br><span class="line">                     <span class="comment">;; ambeval failure</span></span><br><span class="line">                     (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                       (<span class="name">announce-output</span></span><br><span class="line">                        <span class="string">";;; There are no more values of"</span>)</span><br><span class="line">                       (<span class="name">user-print</span> input)</span><br><span class="line">                       (<span class="name">driver-loop</span>)))))))</span><br><span class="line">  (<span class="name">internal-loop</span></span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">     (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">     (<span class="name"><span class="builtin-name">display</span></span> <span class="string">";;; There is no current problem"</span>)</span><br><span class="line">     (<span class="name">driver-loop</span>))))</span><br></pre></td></tr></table></figure></p>
<p>这里的内部过程<code>internal-loop</code>会接受一个参数过程，作为收到<code>try-again</code>命令时需要执行的内容。在internal-loop初始化时，这个参数过程被设置成了提示&quot;;;; There is no current problem&quot;并再次发起循环；当计算新的表达式时，整个<code>ambeval</code>的success continuation被初始化为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (val next-alternative)</span><br><span class="line">  (<span class="name">announce-output</span> output-prompt)</span><br><span class="line">  (<span class="name">user-print</span> val)</span><br><span class="line">  (<span class="name">internal-loop</span> next-alternative))</span><br></pre></td></tr></table></figure></p>
<p>全局的计算得到结果以后，把值作为<code>val</code>参数传递给这个success continuation，继而打印显示给用户；而<code>next-alternative</code>参数对照上文一般的<a href="#%E7%BB%AD%E5%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84">success continuation结构</a>应该是另一个用于处理后续求值失败的failure continuation，到达调用这个全局success continuation时，除了已经计算出的表达式结果，还有从最近的选择点构造出的failure continuation（内容是尝试剩下的选择）一直传递下直到被当成<code>next-alternative</code>传入，那么当打印完求值结果后，还会把<code>next-alternative</code>作为参数再调用一次<code>internal-loop</code>，当用户输入<code>try-again</code>时便可以直接调用<code>next-alternative</code>过程，即由上次求值附带的failure continuation进入最近选择点的另一个分支开始寻找另一个可行的求值结果，另外，即使是调用的<code>next-alternative</code>的success continuation也还是这个全局的success continuation，只是再调用时参数发生了变化，所以返回另一个结果后又开始开始一轮循环，这是很微妙的设计。</p>
<p>以上全是我已经假设了最后的failure continuation是由最近的<code>amb</code>选择点构造的情况，现实情况会更复杂一些，比如一直没有遇到<code>amb</code>语句，那么就会使用最初传入的failure continuation，提示&quot;;;; There are no more values of&quot;并重置循环。</p>
<p>更多情况需要参见求值器对语言中其他常见表达式的处理。</p>
<h3>简单表达式</h3>
<p>对简单表达式的求值在执行过程只需要把求值结果和failure continuation都传递给success continuation执行即可，相比普通的求值器，只需要增加continuation的维护。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-self-evaluating</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">    (<span class="name">succeed</span> exp fail)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-quoted</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">qval</span> (<span class="name">text-of-quotation</span> exp)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">succeed</span> qval fail))))</span><br></pre></td></tr></table></figure></p>
<p>self-evaluating对象（如数值常量）和quotation的求值结果与<code>env</code>无关，也不会发生求值失败，直接计算出交给<code>succeed</code>进行后续操作即可。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-variable</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">    (<span class="name">succeed</span> (<span class="name">lookup-variable-value</span> exp env)</span><br><span class="line">             fail)))</span><br></pre></td></tr></table></figure></p>
<p>变量绑定的值需要在<code>env</code>查找，如果无法找到也是因为用户的程序编写问题而不是因为非确定计算的问题，因此可以直接把结果和<code>fail</code>传入<code>succeed</code>继续求值。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-lambda</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">vars</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>))</span><br><span class="line">        (<span class="name">bproc</span> (<span class="name">analyze-sequence</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">succeed</span> (<span class="name">make-procedure</span> vars bproc env)</span><br><span class="line">               fail))))</span><br></pre></td></tr></table></figure></p>
<p>对lambda表达式的求值结果也是一个封装了形参，函数体和定义环境的过程对象，直接传入<code>succeed</code>。</p>
<h3>条件和顺序语句</h3>
<p>现在开始接触到一些有执行顺序的语句，这时，仅当对表达式的某一部分求值成功后，才可以开始下一部分的求值。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-if</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">pproc</span> (<span class="name">analyze</span> (<span class="name">if-predicate</span> exp)))</span><br><span class="line">        (<span class="name">cproc</span> (<span class="name">analyze</span> (<span class="name">if-consequent</span> exp)))</span><br><span class="line">        (<span class="name">aproc</span> (<span class="name">analyze</span> (<span class="name">if-alternative</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">pproc</span> env</span><br><span class="line">             <span class="comment">;; success continuation for evaluating the predicate</span></span><br><span class="line">             <span class="comment">;; to obtain pred-value</span></span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (pred-value fail2)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">true?</span> pred-value)</span><br><span class="line">                   (<span class="name">cproc</span> env succeed fail2)</span><br><span class="line">                   (<span class="name">aproc</span> env succeed fail2)))</span><br><span class="line">             <span class="comment">;; failure continuation for evaluating the predicate</span></span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure></p>
<p>if条件语句需要先执行它的predicate部分的求值，如果求值成功才可以根据predicate的值决定执行接下来哪个语句。因此整个表达式的分析结果是这样的函数，执行predicate的分析结果<code>pproc</code>，即对predicate求值，构造了一个新的success continuation，它的意思是：如果predicate求值成功，接下来根据它的值选择执行<code>cproc</code>或<code>aproc</code>，求值成功后再进入原来的<code>succeed</code>。</p>
<p>顺序语句，即<code>cond</code>或lambda表达式内可能出现多个连续语句，或者<code>begin</code>表达式，执行其中的每个表达式，但只返回最后一个表达式的求值结果作为最终结果。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-sequence</span> exps)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sequentially</span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">a</span> env</span><br><span class="line">         <span class="comment">;; success continuation for calling a</span></span><br><span class="line">         (<span class="name"><span class="builtin-name">lambda</span></span> (a-value fail2)</span><br><span class="line">           (<span class="name">b</span> env succeed fail2))</span><br><span class="line">         <span class="comment">;; failure continuation for calling a</span></span><br><span class="line">         fail)))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">loop</span> first-proc rest-procs)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> rest-procs)</span><br><span class="line">        first-proc</span><br><span class="line">        (<span class="name">loop</span> (<span class="name">sequentially</span> first-proc (<span class="name"><span class="builtin-name">car</span></span> rest-procs))</span><br><span class="line">              (<span class="name"><span class="builtin-name">cdr</span></span> rest-procs))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">procs</span> (<span class="name"><span class="builtin-name">map</span></span> analyze exps)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> procs)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Empty sequence -- ANALYZE"</span>))</span><br><span class="line">    (<span class="name">loop</span> (<span class="name"><span class="builtin-name">car</span></span> procs) (<span class="name"><span class="builtin-name">cdr</span></span> procs))))</span><br></pre></td></tr></table></figure></p>
<p>这里的内部过程<code>(sequentially a b)</code>很好的解释了顺序语句的执行，和if语句类似，先对分析结果<code>a</code>进行求值，构造新的success continuation表示如果成功继续对<code>b</code>求值。</p>
<h3>定义和赋值</h3>
<p>定义时需要先计算变量被定义的表达式，那就同样要考虑如果这个表达式求值不成功应该怎么办。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-definition</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">definition-variable</span> exp))</span><br><span class="line">        (<span class="name">vproc</span> (<span class="name">analyze</span> (<span class="name">definition-value</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">vproc</span> env                        </span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (val fail2)</span><br><span class="line">               (<span class="name">define-variable!</span> var val env)</span><br><span class="line">               (<span class="name">succeed</span> <span class="symbol">'ok</span> fail2))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure></p>
<p>这也是与上面的做法类似的过程，先对被表达式求值，构造新的success continuation调用它的分析结果，使成功的求值结果再进入success continuation完成绑定并把绑定操作的结果<code>'ok</code>传入原来的<code>succeed</code>继续接下来的操作。</p>
<p>这里不用担心如果完成定义后陷入思路重新开始时是否需要撤回定义，为了方便，我们假设这些内部定义语句是转化成let表达式的scan out操作完成的（可以见前篇<a href="http://notebook.xyli.me/SICP/local-bindings-and-internal-definitions/">局部绑定和内部定义</a>）。</p>
<p>但赋值操作就必须考虑在失败后消除它的副作用。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-assignment</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">assignment-variable</span> exp))</span><br><span class="line">        (<span class="name">vproc</span> (<span class="name">analyze</span> (<span class="name">assignment-value</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">vproc</span> env</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (val fail2)        <span class="comment">; *1*</span></span><br><span class="line">               (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">old-value</span></span><br><span class="line">                      (<span class="name">lookup-variable-value</span> var env)))</span><br><span class="line">                 (<span class="name">set-variable-value!</span> var val env)</span><br><span class="line">                 (<span class="name">succeed</span> <span class="symbol">'ok</span></span><br><span class="line">                          (<span class="name"><span class="builtin-name">lambda</span></span> ()    <span class="comment">; *2*</span></span><br><span class="line">                            (<span class="name">set-variable-value!</span> var</span><br><span class="line">                                                 old-value</span><br><span class="line">                                                 env)</span><br><span class="line">                            (<span class="name">fail2</span>)))))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure></p>
<p>首先还是像定义语句那样，对被绑定的表达式求值，如果求值成功，进入新的success continuation（即代码中<code>*1*</code>开始的位置），在这里先保存变量原来的值<code>old-value</code>，再对变量进行变值操作，赋值操作的结果<code>'ok</code>传递给<code>succeed</code>进行后续计算，注意<code>succeed</code>的第二个实参也是重新构造的failure continuation（<code>*2*</code>开始的位置），在赋值操作完成之后的后续计算中，如果遇到了求值失败会调用这个failure continuation，在执行原计划的<code>(fail2)</code>之前会先把变量恢复成改变之前的值。</p>
<h3>过程调用</h3>
<p>函数调用更为复杂一点。首先需要考虑函数被调用时还需要对所有实参求值，对每个实参求值时都可能遭遇求值失败，导致中断，因此不能用原来的<code>map</code>直接算出实参列表，需要写一个新的<code>get-args</code>对实参的分析结果列表<code>aprocs</code>进行<strong>依次</strong>求值：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-args</span> aprocs env succeed fail)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> aprocs)</span><br><span class="line">      (<span class="name">succeed</span> '() fail)</span><br><span class="line">      ((<span class="name"><span class="builtin-name">car</span></span> aprocs) env</span><br><span class="line">                    <span class="comment">;; success continuation for this aproc</span></span><br><span class="line">                    (<span class="name"><span class="builtin-name">lambda</span></span> (arg fail2)</span><br><span class="line">                      (<span class="name">get-args</span> (<span class="name"><span class="builtin-name">cdr</span></span> aprocs)</span><br><span class="line">                                env</span><br><span class="line">                                <span class="comment">;; success continuation for recursive</span></span><br><span class="line">                                <span class="comment">;; call to get-args</span></span><br><span class="line">                                (<span class="name"><span class="builtin-name">lambda</span></span> (args fail3)</span><br><span class="line">                                  (<span class="name">succeed</span> (<span class="name"><span class="builtin-name">cons</span></span> arg args)</span><br><span class="line">                                           fail3))</span><br><span class="line">                                fail2))</span><br><span class="line">                    fail)))</span><br></pre></td></tr></table></figure></p>
<p>有些像顺序语句的求值，但不同的是需要返回列表中所有实参的求值结果。在对第一个参数的分析结果求值成功后，这个值<code>arg</code>会进入line 6开始的success continuation，对剩下的参数分析结果用<code>get-args</code>递归求值得到参数列表<code>args</code>，完成后进入下一个从line 11开始的success continuation，再把它们<code>cons</code>起来返回给最终的<code>succeed</code>。除了维护continuation有些麻烦，把<code>aprocs</code>一层层<code>cdr</code>下来求值再通过构造新的<code>succeed</code>把结果一层层<code>cons</code>起来，这种做法和<code>map</code>的递归逻辑别无二致。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-application</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">fproc</span> (<span class="name">analyze</span> (<span class="name">operator</span> exp)))</span><br><span class="line">        (<span class="name">aprocs</span> (<span class="name"><span class="builtin-name">map</span></span> analyze (<span class="name">operands</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">fproc</span> env</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (proc fail2)</span><br><span class="line">               (<span class="name">get-args</span> aprocs</span><br><span class="line">                         env</span><br><span class="line">                         (<span class="name"><span class="builtin-name">lambda</span></span> (args fail3)</span><br><span class="line">                           (<span class="name">execute-application</span></span><br><span class="line">                            proc args succeed fail3))</span><br><span class="line">                         fail2))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure></p>
<p>对调用语句分析也是需要小心的按照顺序来，先对函数名（操作符）的分析结果<code>fproc</code>执行求值，成功后再开始用<code>get-args</code>对实参列表求值，最后用<code>execute-application</code>去计算调用结果。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">execute-application</span> proc args succeed fail)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">primitive-procedure?</span> proc)</span><br><span class="line">         (<span class="name">succeed</span> (<span class="name">apply-primitive-procedure</span> proc args)</span><br><span class="line">                  fail))</span><br><span class="line">        ((<span class="name">compound-procedure?</span> proc)</span><br><span class="line">         ((<span class="name">procedure-body</span> proc)</span><br><span class="line">          (<span class="name">extend-environment</span> (<span class="name">procedure-parameters</span> proc)</span><br><span class="line">                              args</span><br><span class="line">                              (<span class="name">procedure-environment</span> proc))</span><br><span class="line">          succeed</span><br><span class="line">          fail))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">         (<span class="name">error</span></span><br><span class="line">          <span class="string">"Unknown procedure type -- EXECUTE-APPLICATION"</span></span><br><span class="line">          proc))))</span><br></pre></td></tr></table></figure></p>
<p><code>execute-application</code>的定义和在普通求值器中除了管理continuation以外没有什么大的区别，调用是一步操作，因此没有前文那样反复构造新的success continuation的需求。对于primitive来说，不存在调用过程本身引起的求值失败，直接把调用结果作为参数传递给<code>succeed</code>就可以了；对于用户自己编写的复合过程，在当前两个continuation和添加实参绑定的定义环境下对函数体的分析结果进行调用计算，求值完成后，无论成功或失败，对于的continuation会作为实参被传入函数体的分析结果，用以执行下一步操作。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;使用种子$x$生成伪随机的一种常见做法是： 挑选合适的大整数$a$,$b$,$N$，返回$ax+b \bmod N$，我所给出的实现里面三个整数的挑选实际上都并不是很合适，仅为了演示，这里不再详细讨论怎样去生成统计性质良好的随机序列。&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/continuations-for-nondeterministic-evaluator/" data-id="cjuh9jx8g004sfww3ayri2200" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/continuation/">continuation</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-109" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-109/">LeetCode Weekly Contest 109</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-109/" class="article-date"><time datetime="2018-11-04T11:14:08.268Z" itemprop="datePublished">2018-11-04</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-109</p>
<p>&lt;!-- more --&gt;</p>
<h2>Number of Recent Calls</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-109/problems/number-of-recent-calls/</p>
<blockquote>
<p>Write a class <code>RecentCounter</code> to count recent requests.</p>
</blockquote>
<blockquote>
<p>It has only one method: <code>ping(int t)</code>, where t represents some time in milliseconds.</p>
</blockquote>
<blockquote>
<p>Return the number of <code>ping</code>s that have been made from 3000 milliseconds ago until now.</p>
</blockquote>
<blockquote>
<p>Any ping with time in <code>[t - 3000, t]</code> will count, including the current ping.</p>
</blockquote>
<blockquote>
<p>It is guaranteed that every call to <code>ping</code> uses a strictly larger value of t than before.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs = [[],[1],[100],[3001],[3002]]</span><br><span class="line">Output: [null,1,2,3,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Each test case will have at most <code>10000</code> calls to <code>ping</code>.</li>
<li>Each test case will call <code>ping</code> with strictly increasing values of <code>t</code>.</li>
<li>Each call to ping will have <code>1 &lt;= t &lt;= 10^9</code>.</li>
</ol>
<p>维护一个栈，每当有新的<code>ping</code>请求时把请求时间压入，当栈顶元素表示的时间在3000ms前时弹出，返回栈的大小。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pings = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.pings.append(t)</span><br><span class="line">        <span class="keyword">while</span> self.pings[<span class="number">0</span>] &lt; t - <span class="number">3000</span>:</span><br><span class="line">            self.pings.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(self.pings)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RecentCounter()</span></span><br><span class="line"><span class="comment"># param_1 = obj.ping(t)</span></span><br></pre></td></tr></table></figure></p>
<h2>Knight Dialer</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-109/problems/knight-dialer/</p>
<blockquote>
<p>A chess knight can move as indicated in the chess diagram below:
<img src="https://assets.leetcode.com/uploads/2018/10/12/knight.png" alt="">
<img src="https://assets.leetcode.com/uploads/2018/10/30/keypad.png" alt="">
This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes <code>N-1</code> hops.  Each hop must be from one key to another numbered key.</p>
</blockquote>
<blockquote>
<p>Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing <code>N</code> digits total.</p>
</blockquote>
<blockquote>
<p>How many distinct numbers can you dial in this manner?</p>
</blockquote>
<blockquote>
<p>Since the answer may be large, <strong>output the answer modulo <code>10^9 + 7</code></strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 20</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 5000</code></li>
</ol>
<p>我不懂这个chess的规则，感觉knight的走法规则有点像象棋的马，可以到正负[1,2]或[2,1]距离内的位置。对于到keypad就是位置1可以跳到位置6或8，反之也可以1也可以从6或8跳过来，因此第<code>N</code>跳时落在1的数字，第<code>N-1</code>跳时一定在6或8，因此可以写成比较典型的动态规划<code>dp[N][1]=dp[N-1][6]+dp[N-1][8]</code>，以此类推……比较麻烦的是对于每个位置还需要看图依次找可以从哪里跳过来，手写情况很烦。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">knightDialer</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre = [<span class="number">1</span>] * <span class="number">10</span></span><br><span class="line">        cur = [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            cur[<span class="number">0</span>] = pre[<span class="number">4</span>] + pre[<span class="number">6</span>]</span><br><span class="line">            cur[<span class="number">1</span>] = pre[<span class="number">6</span>] + pre[<span class="number">8</span>]</span><br><span class="line">            cur[<span class="number">2</span>] = pre[<span class="number">7</span>] + pre[<span class="number">9</span>]</span><br><span class="line">            cur[<span class="number">3</span>] = pre[<span class="number">4</span>] + pre[<span class="number">8</span>]</span><br><span class="line">            cur[<span class="number">4</span>] = pre[<span class="number">0</span>] + pre[<span class="number">3</span>] + pre[<span class="number">9</span>]</span><br><span class="line">            cur[<span class="number">5</span>] = <span class="number">0</span></span><br><span class="line">            cur[<span class="number">6</span>] = pre[<span class="number">0</span>] + pre[<span class="number">1</span>] + pre[<span class="number">7</span>]</span><br><span class="line">            cur[<span class="number">7</span>] = pre[<span class="number">2</span>] + pre[<span class="number">6</span>]</span><br><span class="line">            cur[<span class="number">8</span>] = pre[<span class="number">1</span>] + pre[<span class="number">3</span>]</span><br><span class="line">            cur[<span class="number">9</span>] = pre[<span class="number">2</span>] + pre[<span class="number">4</span>]</span><br><span class="line">            pre = list(cur)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(pre) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<p>也可以写成矩阵形式计算乘积，用快速幂运算等方法提高效率。</p>
<h2>Shortest Bridge</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-109/problems/shortest-bridge/</p>
<blockquote>
<p>n a given 2D binary array <code>A</code>, there are two islands.  (An island is a 4-directionally connected group of <code>1</code>s not connected to any other 1s.)</p>
</blockquote>
<blockquote>
<p>Now, we may change <code>0</code>s to <code>1</code>s so as to connect the two islands together to form 1 island.</p>
</blockquote>
<blockquote>
<p>Return the smallest number of <code>0</code>s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[1,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,0],[0,0,0],[0,0,1]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = A[0].length &lt;= 100</code></li>
<li><code>A[i][j] == 0</code> or <code>A[i][j] == 1</code></li>
</ol>
<p>如果两个岛之间造桥，端点一定分别在两个岛的边缘。寻找边缘首先用BFS进行union find，邻接点里面有<code>0</code>的结点（本身为<code>1</code>）是该岛的边缘点，再计算不同岛边缘位置之间最短的Manhattan距离，减去1即为需要改变的0的数量。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestBridge</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        margin = [set(), set()]</span><br><span class="line">        n = len(A)</span><br><span class="line">        color = <span class="number">0</span></span><br><span class="line">        seen = set()</span><br><span class="line">        res = <span class="number">2</span> * n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(x, y, color)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= x + dx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y + dy &lt; n:</span><br><span class="line">                    <span class="keyword">if</span> A[x + dx][y + dy] == <span class="number">0</span>:</span><br><span class="line">                        seen.add((x + dx, y + dy))</span><br><span class="line">                        margin[color].add((x, y))</span><br><span class="line">                    <span class="keyword">elif</span> (x + dx, y + dy) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        seen.add((x + dx, y + dy))</span><br><span class="line">                        bfs(x + dx, y + dy, color)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                    bfs(i, j, color)</span><br><span class="line">                    color += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x1, y1 <span class="keyword">in</span> margin[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">for</span> x2, y2 <span class="keyword">in</span> margin[<span class="number">1</span>]:</span><br><span class="line">                res = min(res, abs(x1 - x2) + abs(y1 - y2) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Stamping The Sequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-109/problems/stamping-the-sequence/</p>
<blockquote>
<p>You want to form a <code>target</code> string of <strong>lowercase letters</strong>.</p>
</blockquote>
<blockquote>
<p>At the beginning, your sequence is <code>target.length</code> <code>'?'</code> marks.  You also have a <code>stamp</code> of lowercase letters.</p>
</blockquote>
<blockquote>
<p>On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp.  You can make up to <code>10 * target.length</code> turns.</p>
</blockquote>
<blockquote>
<p>For example, if the initial sequence is &quot;?????&quot;, and your stamp is <code>&quot;abc&quot;</code>,  then you may make &quot;abc??&quot;, &quot;?abc?&quot;, &quot;??abc&quot; in the first turn.  (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)</p>
</blockquote>
<blockquote>
<p>If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn.  If the sequence is not possible to stamp, return an empty array.</p>
</blockquote>
<blockquote>
<p>For example, if the sequence is &quot;ababc&quot;, and the stamp is <code>&quot;abc&quot;</code>, then we could return the answer <code>[0, 2]</code>, corresponding to the moves &quot;?????&quot; -&gt; &quot;abc??&quot; -&gt; &quot;ababc&quot;.</p>
</blockquote>
<blockquote>
<p>Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within <code>10 * target.length</code> moves.  Any answers specifying more than this number of moves will not be accepted.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stamp = &quot;abc&quot;, target = &quot;ababc&quot;</span><br><span class="line">Output: [0,2]</span><br><span class="line">([1,0,2] would also be accepted as an answer, as well as some other answers.)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stamp = <span class="string">"abca"</span>, target = <span class="string">"aabcaca"</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</code></li>
<li><code>stamp</code> and <code>target</code> only contain lowercase letters.</li>
</ol>
<p>不妨反向考虑：越晚的覆盖保留在target上的越优先，最后一次覆盖必然包含全部<code>stamp</code>的内容，至于那些位置覆盖前是什么就不重要了，可以用<code>*</code>代表，再之前一次的覆盖，除了<code>*</code>的内容以外其他外置又必须与<code>stamp</code>完全匹配……</p>
<p>比如Example2的<code>aabcaca</code>，最后一次匹配是从第1位开始的<code>abca</code>，把它用<code>*</code>代替为<code>a****ca</code>，接下来<code>*</code>可以与任何字符匹配，那么从第0位开始<code>abca</code>与<code>a***</code>匹配，再往前操作，现在目标串为<code>*****ca</code>，从第3位开始又可以匹配一个<code>abca</code>，最终成为<code>*******</code>。</p>
<p>那么需要做的就是当目标串不为全<code>*</code>时，对与<code>stamp</code>长度不全为<code>*</code>的子串用<code>stamp</code>试图匹配，其中<code>*</code>可以匹配任意字符，其他情况则必须字符依次相同。当匹配成功时，把当前子串置为全<code>*</code>，无法找到匹配子串则返回空集。当目标串成为全<code>*</code>时，倒序输出所有成功匹配子串开始的坐标。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movesToStamp</span><span class="params">(self, stamp, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type stamp: str</span></span><br><span class="line"><span class="string">        :type target: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(pos, t)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(pos, pos + len(stamp)):</span><br><span class="line">                <span class="keyword">if</span> stamp[i - pos] != t[i] <span class="keyword">and</span> t[i] != <span class="string">'*'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">            t = t[:pos] + <span class="string">'*'</span> * len(stamp) + t[pos + len(stamp):]</span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">        completed = <span class="string">'*'</span> * len(target)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> target != completed:</span><br><span class="line">            flag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target) - len(stamp) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> target[i:i + len(stamp)] != <span class="string">'*'</span> * len(stamp):</span><br><span class="line">                    temp = remove(i, target)</span><br><span class="line">                    <span class="keyword">if</span> temp:</span><br><span class="line">                        res.append(i)</span><br><span class="line">                        target = temp</span><br><span class="line">                        flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-109/" data-id="cjuh9jwtm000vfww3jpbq9m1s" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-108" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-108/">LeetCode Weekly Contest 108</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-108/" class="article-date"><time datetime="2018-10-28T10:46:18.005Z" itemprop="datePublished">2018-10-28</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-108</p>
<p>&lt;!-- more --&gt;</p>
<h2>Unique Email Addresses</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-108/problems/unique-email-addresses/</p>
<blockquote>
<p>Every email consists of a local name and a domain name, separated by the @ sign.</p>
</blockquote>
<blockquote>
<p>For example, in <code>alice@leetcode.com</code>, <code>alice</code>is the local name, and <code>leetcode.com</code> is the domain name.</p>
</blockquote>
<blockquote>
<p>Besides lowercase letters, these emails may contain <code>'.'</code>s or <code>'+'</code>s.</p>
</blockquote>
<blockquote>
<p>If you add periods (<code>'.'</code>) between some characters in the <strong>local name</strong> part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, <code>&quot;alice.z@leetcode.com&quot;</code> and <code>&quot;alicez@leetcode.com&quot;</code> forward to the same email address.  (Note that this rule does not apply for domain names.)</p>
</blockquote>
<blockquote>
<p>If you add a plus (<code>'+'</code>) in the <strong>local name</strong>, everything after the first plus sign will be <strong>ignored</strong>. This allows certain emails to be filtered, for example <code>m.y+name@email.com</code> will be forwarded to <code>my@email.com</code>.  (Again, this rule does not apply for domain names.)</p>
</blockquote>
<blockquote>
<p>It is possible to use both of these rules at the same time.</p>
</blockquote>
<blockquote>
<p>Given a list of <code>emails</code>, we send one email to each address in the list.  How many different addresses actually receive mails?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= emails[i].length &lt;= 100</code></li>
<li><code>1 &lt;= emails.length &lt;= 100</code></li>
<li>Each <code>emails[i]</code> contains exactly one <code>'@'</code> character.</li>
</ol>
<p>按照规则去掉所有邮箱地址local name的<code>'.'</code>和<code>'+'</code>后面的内容，然后统计有多少不同的地址</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numUniqueEmails</span><span class="params">(self, emails)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type emails: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        email_list = set()</span><br><span class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> emails:</span><br><span class="line">            line = email.split(<span class="string">'@'</span>)</span><br><span class="line">            local, domain = str(line[<span class="number">0</span>]), line[<span class="number">1</span>]</span><br><span class="line">            local = local.translate(string.maketrans(<span class="string">''</span>, <span class="string">''</span>), <span class="string">'.'</span>)</span><br><span class="line">            local = local.split(<span class="string">'+'</span>)[<span class="number">0</span>]</span><br><span class="line">            email_list.add(local + <span class="string">'@'</span> + domain)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(email_list)</span><br></pre></td></tr></table></figure></p>
<h2>Binary Subarrays With Sum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-108/problems/binary-subarrays-with-sum/</p>
<blockquote>
<p>In an array <code>A</code> of <code>0</code>s and <code>1</code>s, how many <strong>non-empty</strong> subarrays have sum <code>S</code>?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,0,1,0,1], S = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The 4 subarrays are bolded below:</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A.length &lt;= 30000</code></li>
<li><code>0 &lt;= S &lt;= A.length</code></li>
<li><code>A[i]</code> is either <code>0</code> or <code>1</code>.</li>
</ol>
<p>这个blog暂时不支持代码块内字符的加粗，所有这里没有体现，example 1的4个子数组分别为<code>[1,0,1],[1,0,1,0],[0,1,0,1],[1,0,1]</code>，都是<strong>连续</strong>的。</p>
<p>如果某个子数组满足和为<code>S</code>，加上数组左边任意长度的连续0或数组右边任意长度的连续0，和仍然为<code>S</code>。因此可以用<code>ones</code>按顺序统计所有<code>1</code>出现的位置，从<code>ones[i]</code>到<code>ones[i+S-1]</code>位置作为子数组下标时满足和为<code>S</code>，<code>ones[i-1]</code>与<code>ones[i]</code>之间的<code>0</code>可以从右到左放入<code>ones[i]-ones[i-1]</code>种连续子数组，同理<code>ones[i+S-1]</code>与<code>ones[i+S]</code>之间可以放入<code>ones[i+S]-ones[i+S-1]</code>种。</p>
<p>当<code>S==0</code>时这样的计数不可行，会导致重复计数。此时只需要把所有全为0的连续子数组找到就可以了，假设两个<code>1</code>之间的一共有<code>n</code>个<code>0</code>，那么相当于从<code>0-n</code>这<code>n+1</code>个数中选出两个不同的数作为切片的两端，一共有<code>(n+1)*n/2</code>种选法。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarraysWithSum</span><span class="params">(self, A, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ones = [<span class="number">-1</span>] + [i <span class="keyword">for</span> (i, b) <span class="keyword">in</span> enumerate(A) <span class="keyword">if</span> b] + [len(A)]</span><br><span class="line">        <span class="keyword">if</span> len(ones) - <span class="number">2</span> &lt; S:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> sum([(ones[i] - ones[i - <span class="number">1</span>]) * ((ones[i] - ones[i - <span class="number">1</span>]) - <span class="number">1</span>) / <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ones))])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(ones) - S):</span><br><span class="line">            res += (ones[i] - ones[i - <span class="number">1</span>]) * (ones[i + S] - ones[i + S - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Falling Path Sum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-108/problems/minimum-falling-path-sum/</p>
<blockquote>
<p>Given a <strong>square</strong> array of integers <code>A</code>, we want the <strong>minimum</strong> sum of a <em>falling path</em> through <code>A</code>.</p>
</blockquote>
<blockquote>
<p>A falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation:</span><br><span class="line">The possible falling paths are:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<ul>
<li><code>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</code></li>
</ul>
</blockquote>
<ul>
<li><code>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</code></li>
<li><code>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</code>
The falling path with the smallest sum is <code>[1,4,7]</code>, so the answer is <code>12</code>.</li>
</ul>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length == A[0].length &lt;= 100</code></li>
<li><code>-100 &lt;= A[i][j] &lt;= 100</code></li>
</ol>
<p>直接用动态规划做就够了。<code>dp[i][j]</code>表示到<code>A[i][j]</code>位置为终点的falling path的最小和，那么显然有<code>dp[i][j]=min(dp[i][j-1],dp[i][j],dp[i][j+1])+A[i][j]</code>，<code>dp</code>首行按照<code>A</code>的首行初始化。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = list(A)</span><br><span class="line">        n = len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dp[i][j] += min(dp[i - <span class="number">1</span>][max(<span class="number">0</span>, j - <span class="number">1</span>):min(n, j + <span class="number">2</span>)])</span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2>Beautiful Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-108/problems/beautiful-array/</p>
<blockquote>
<p>For some fixed <code>N</code>, an array <code>A</code> is beautiful if it is a permutation of the integers <code>1, 2, ..., N</code>, such that:</p>
</blockquote>
<blockquote>
<p>For every <code>i &lt; j</code>, there is no k with <code>i &lt; k &lt; j</code> such that <code>A[k] * 2 = A[i] + A[j]</code>.</p>
</blockquote>
<blockquote>
<p>Given N, return any beautiful array A.  (It is guaranteed that one exists.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [3,1,2,5,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ol>
<p>如果一个数组满足beautiful array的性质，那么对数组中所有元素作线性的变换（同乘或者同加一个常数）时，依然会满足beautiful array的性质。当<code>A[i]</code>为偶数而<code>A[j]</code>为奇数时，中间不存在元素等于<code>(A[i] + A[j])/2</code>，因此也不用检查奇数与偶数之间的元素是否会破坏性质。那么只需要把两个beautiful array分别变换为全为奇数和全为偶数的数组连接起来就可以得到beautiful array，为了保证新的数组是一个permutation，需要较长的那个数组变换为奇数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">beautifulArray</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        evens = self.beautifulArray(N / <span class="number">2</span>)</span><br><span class="line">        odds = self.beautifulArray(N - N / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> [i * <span class="number">2</span> - <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> odds] + [i * <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> evens]</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度<code>o(nlogn)</code>，也可以通过其他分治的写法降低到<code>o(n)</code></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-108/" data-id="cjuh9jwth000rfww3k2kqh8tb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-local-bindings-and-internal-definitions" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/local-bindings-and-internal-definitions/">局部绑定和内部定义</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/local-bindings-and-internal-definitions/" class="article-date"><time datetime="2018-10-26T10:48:03.097Z" itemprop="datePublished">2018-10-26</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在我曾经写的<a href="http://notebook.xyli.me/SICP/SICP-with-DrRacket/#Internal-Definitions">SICP从DrRacket钻了出来</a>一文中我提到过不同的Scheme解释器实现对内部定义（internal definition）的处理不同，所以当需要定义一个中间变量时，需要格外小心地使用块结构（block structure，即在<code>define</code>中嵌套<code>define</code>）以及与之作用类似的<code>let</code>系列表达式。</p>
<p>这篇笔记沿用<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%25_sec_4.1" target="_blank" rel="noopener">SICP 4.1 The Metacircular Evaluator </a>的背景演示这些结构和语法实际上是如何被解释器理解的。</p>
<p>&lt;!-- more --&gt;</p>
<h2>lambda表达式</h2>
<p>众所周知，lambda表达式用于定义一个可以当场被调用的匿名函数。由lambda引导的整个表达式
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (&lt;parameters&gt;) &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>可以被看成一个被称为函数/过程的数据对象，形式参数为<code>&lt;parameters&gt;</code>，函数体<code>&lt;body&gt;</code>的内容并不在此时被求值，这就是延迟求值（delay evaluation）的基础。用<code>&lt;args&gt;</code>调用这个函数可以得到结果
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (&lt;parameters&gt;) &lt;body&gt;) &lt;args&gt;)</span><br></pre></td></tr></table></figure></p>
<p>当编写一个<code>(eval exp env)</code>函数来对这些过程求值时，可以考虑表达为一个形如<code>'(lambda (&lt;parameters&gt;).&lt;body&gt;)</code>的list结构，刚好与$\lambda$-calculus的表示法
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;function&gt; := λ &lt;name&gt;.&lt;expression&gt;</span><br></pre></td></tr></table></figure></p>
<p>一致，于是构造和选择的操作可以写为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-lambda</span> parameters body)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'lambda</span> (<span class="name"><span class="builtin-name">cons</span></span> parameters body)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lambda?</span> <span class="name"><span class="builtin-name">exp</span></span>) (<span class="name">tagged-list?</span> exp <span class="symbol">'lambda</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>) (<span class="name"><span class="builtin-name">cadr</span></span> exp))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>) (<span class="name">cddr</span> exp))</span><br></pre></td></tr></table></figure></p>
<p>对lambda表达式的求值（结果为一个函数对象）在<code>eval</code>中体现为这个<code>cond</code>分支
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">lambda?</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line"> (<span class="name">make-procedure</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">                 (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">                 env))</span><br></pre></td></tr></table></figure></p>
<p>暂时先不用去看<code>make-procedure</code>源码具体做了什么，只要知道它把函数被定义时的环境<code>env</code>也放进了函数对象中，待调用时会在被调用环境中计算实参的值绑定到函数的形参上，再把这些绑定连同原有的<code>env</code>一起用来计算函数体得到函数调用的结果。这就是词法作用域（lexical scope）的特性之一，函数内的变量（除形参）对应的值由函数被定义时的环境决定。</p>
<p>当然，更常见的定义函数，也就是过程的标准定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> &lt;parameter1&gt; ... &lt;parametern&gt;)</span><br><span class="line">  &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>实际上是
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> f</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (&lt;parameter1&gt; ... &lt;parametern&gt;)</span><br><span class="line">    &lt;body&gt;))</span><br></pre></td></tr></table></figure></p>
<p>的语法糖，变量<code>f</code>指向是一个lambda表达式，所以也可以说<code>f</code>就是这个匿名函数的函数名。把函数对象绑定到<code>f</code>可以让定义和调用很好的分离开来，在定义完成后，随时还可以再通过<code>f</code>去使用这个lambda表达式对应的函数。对刚才那个<code>define</code>过程的求值中，会把<code>f</code>和函数对象的绑定添加到当前环境。</p>
<h2>let</h2>
<p><code>let</code>表达式提供了一种本地绑定的方法
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">&lt;var1&gt;</span> &lt;exp1&gt;) ... (<span class="name">&lt;varn&gt;</span> &lt;expn&gt;))</span><br><span class="line">  &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>在<code>&lt;body&gt;</code>中可以直接使用<code>&lt;var1&gt;...&lt;varn&gt;</code>代表<code>&lt;exp1&gt;...&lt;expn&gt;</code>，这样的局部变量定义的写法实际上是
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (&lt;var1&gt; ... &lt;varn&gt;)</span><br><span class="line">   &lt;body&gt;)</span><br><span class="line"> &lt;exp1&gt;</span><br><span class="line"> ...</span><br><span class="line"> &lt;expn&gt;)</span><br></pre></td></tr></table></figure></p>
<p>的语法糖。形参就是典型的局部变量，也无怪<code>let</code>定义局部变量还是把看似单独定义的变量当成某个过程的形参，而它们应当指向的值作为实参传入进行计算。</p>
<p>语法糖的实现可以通过把<code>let</code>直接转换为一个lambda表达式+调用的<code>let-&gt;combination</code>函数：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let?</span> exp) (<span class="name">tagged-list?</span> exp <span class="symbol">'let</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let-vars</span> exp) (<span class="name"><span class="builtin-name">map</span></span> car (<span class="name"><span class="builtin-name">cadr</span></span> exp)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let-vals</span> exp) (<span class="name"><span class="builtin-name">map</span></span> cadr (<span class="name"><span class="builtin-name">cadr</span></span> exp)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let-body</span> exp) (<span class="name">cddr</span> exp))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let-&gt;combination</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-lambda</span> (<span class="name">let-vars</span> exp) (<span class="name">let-body</span> exp))</span><br><span class="line">        (<span class="name">let-vals</span> exp)))</span><br></pre></td></tr></table></figure></p>
<p>再在<code>(eval exp env)</code>中添加一个<code>cond</code>分支：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">let?</span> expr) (<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">let-&gt;combination</span> expr) env))</span><br></pre></td></tr></table></figure></p>
<p>接下来要做的又要回归到对lambda表达式的处理：对lambda表达式的<code>eval</code>求值返回的是封装了形参列表<code>lambda-parameters</code>，函数体<code>lambda-body</code>和定义时环境<code>env</code>的过程对象<code>procedure</code>。当用实参列表<code>arguments</code>来调用这个过程时，发生了如下的操作：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">apply</span></span> procedure arguments)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">primitive-procedure?</span> procedure)</span><br><span class="line">         (<span class="name">apply-primitive-procedure</span> procedure arguments))</span><br><span class="line">        ((<span class="name">compound-procedure?</span> procedure)</span><br><span class="line">         (<span class="name">eval-sequence</span></span><br><span class="line">           (<span class="name">procedure-body</span> procedure)</span><br><span class="line">           (<span class="name">extend-environment</span></span><br><span class="line">             (<span class="name">procedure-parameters</span> procedure)</span><br><span class="line">             arguments</span><br><span class="line">             (<span class="name">procedure-environment</span> procedure))))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">         (<span class="name">error</span></span><br><span class="line">          <span class="string">"Unknown procedure type -- APPLY"</span> procedure))))</span><br></pre></td></tr></table></figure></p>
<p>这是你自己写的lambda表达式所以肯定不会通过预言<code>primitive-procedure?</code>，只需要看<code>(compound-procedure? procedure)</code>分支的做法：<code>(eval-sequence exps env)</code>是在<code>env</code>环境下对一系列语句<code>exps</code>进行求值的过程；<code>(extend-environment &lt;variables&gt; &lt;values&gt; &lt;base-env&gt;)</code>表示把变量列表<code>&lt;variables&gt;</code>和值列表<code>&lt;values&gt;</code>绑定作为一个新的frame被包含在<code>&lt;base-env&gt;</code>形参一个新的环境。</p>
<p>当然<code>extend-environment</code>具体是怎么添加绑定的暂时不重要。虽然按照指令式编程的直觉，<code>let</code>语句如果引导了多个局部变量的绑定，它们的绑定<em>应该</em>是依次被添加到小环境中去的，比如
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">x</span> <span class="number">5</span>)</span><br><span class="line">      (<span class="name">y</span> (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> x y))</span><br></pre></td></tr></table></figure></p>
<p>是可以得到结果11的。但实际不是这样的，根据上文的分析，它被视为一个以<code>(x y)</code>为形参列表，函数体为<code>(+ x y)</code>的lambda表达式，以<code>5</code>和<code>(+ x 1)</code>作为实参去调用的结果。在Applicative order的<code>eval</code>系统中，复合表达式作为实参时，需要在被传入前就在调用环境中完成求值。这体现在<code>eval</code>的<code>cond</code>关于应用的分支
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">application?</span> exp)</span><br><span class="line"> (<span class="name"><span class="builtin-name">apply</span></span> (<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">operator</span> exp) env)</span><br><span class="line">        (<span class="name">list-of-values</span> (<span class="name">operands</span> exp) env)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">list-of-values</span> exps env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">no-operands?</span> exps)</span><br><span class="line">      '()</span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">eval</span></span> (<span class="name">first-operand</span> exps) env)</span><br><span class="line">            (<span class="name">list-of-values</span> (<span class="name">rest-operands</span> exps) env))))</span><br><span class="line"><span class="comment">; similar to (map (lambda (exp) (eval exp env)) exps)</span></span><br></pre></td></tr></table></figure></p>
<p>显然在当前计算实参<code>(+ x 1)</code>的值时，当前环境中没有任何关于变量<code>x</code>的信息。所以在<code>let</code>内部使用平级的局部变量去定义自己或另一个是不被允许的，在同一个<code>let</code>中，所有变量指向的表达式都必须与<code>let</code>规定的变量名无关。</p>
<h2>let*</h2>
<p><code>let*</code>是<code>let</code>表达式的一个变体
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">&lt;var1&gt;</span> &lt;exp1&gt;) ... (<span class="name">&lt;varn&gt;</span> &lt;expn&gt;))</span><br><span class="line">  &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>可以从左到右<strong>依次</strong>实现<code>var1-exp1</code>到<code>varn-expn</code>的绑定，使得当<code>i&lt;j</code>时，在<code>varj</code>指向的<code>expj</code>用到变量<code>vari</code>成为可能，更符合指令式编程的思维习惯。它的实现也并不复杂，只是转换成了多层<code>let</code>的嵌套
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">&lt;var1&gt;</span> &lt;exp1&gt;))</span><br><span class="line">  ...</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">&lt;varn&gt;</span> &lt;expn&gt;))</span><br><span class="line">    &lt;body&gt;))</span><br></pre></td></tr></table></figure></p>
<p>给出一个参考实现的版本
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let-args</span> exp) (<span class="name"><span class="builtin-name">cadr</span></span> exp))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let-body</span> exp) (<span class="name">cddr</span> exp))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-let</span> args body) (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'let</span> (<span class="name"><span class="builtin-name">cons</span></span> args body)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">let*-&gt;nested-lets</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">reduce-let*</span> args body)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> args)</span><br><span class="line">        (<span class="name">sequence-&gt;exp</span> body)</span><br><span class="line">        (<span class="name">make-let</span> (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">car</span></span> args))</span><br><span class="line">                  (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">reduce-let*</span> (<span class="name"><span class="builtin-name">cdr</span></span> args) body)))))</span><br><span class="line">  (<span class="name">reduce-let*</span> (<span class="name">let-args</span> exp) (<span class="name">let-body</span> exp)))</span><br></pre></td></tr></table></figure></p>
<p>这里为了去除冗余的<code>()</code>而使用<code>(sequence-&gt;exp body)</code>代替<code>body</code>。在通过<code>let*?</code>检查后通过<code>let*-&gt;nested-lets</code>可以转化为之前已经规定了求值方法的<code>let</code>，就可以直接用<code>(eval (let*-&gt;nested-lets exp) env)</code>完成求值了。</p>
<h2>internal define</h2>
<p>在<code>define</code>或其他语句内使用<code>define</code>就形成了一个block structure，体现为形如这样的“缩进”，内部<code>define</code>绑定的作用域范围无法突破外层的<code>define</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> ...</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> ...)</span><br><span class="line">  ...)</span><br></pre></td></tr></table></figure></p>
<p>想要观察内部<code>define</code>的行为，为了理解还是需要先去观察top-level的普通<code>define</code>的行为。</p>
<p>对<code>define</code>的<code>eval</code>通过<code>(define-variable! var val env)</code>在当前环境<code>env</code>的第一个frame添加变量<code>var</code>与值<code>val</code>的绑定。我们知道对lambda表达式的求值不会立即直接去计算它的函数体，而是和环境<code>env</code>一起打包成一个过程对象，对函数<code>f</code>定义语句的处理是让变量名<code>f</code>指向这个过程对象，再修改<code>env</code>使其包含这个绑定，以后再调用<code>f</code>时，函数体内部如果也用到了这个函数名<code>f</code>会在被封装到过程对象的<code>env</code>中找到<code>f</code>的定义。这就是函数递归实现的基础。</p>
<p>但当需要被指向的值不是像lambda表达式那样的延迟对象时，会在当前未添加绑定的<code>env</code>对<code>val</code>进行立即求值（eager evaluation），如果<code>val</code>中出现需要被定义的变量名<code>var</code>那么是无法找到<code>var</code>的定义的。所以如果对这样的变量进行递归定义，会出现unbound identifier error提示。</p>
<p>继续回到内部的<code>define</code>，众所周知，和<code>let</code>以及<code>let*</code>不同，内部的<code>define</code>也是可以实现函数的递归定义的。</p>
<p>IEEE Scheme标准对于内部<code>define</code>的作用域应该如何被解释没有给出特别严格的规定，所以各个解释器的做法不相同。毕竟IEEE Scheme标准只允许常量和lambda表达式作为内部<code>define</code>的值&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，内部<code>define</code>在其他表达式之前出现，所以具体哪个变量按照什么顺序在何时实现绑定，没有太大区别。但实践中大家似乎并不愿意遵守这个标准，因此制造出很多混乱。</p>
<p>如果在内部定义了这两个函数
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">even?</span></span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">        true</span><br><span class="line">        (<span class="name"><span class="builtin-name">odd?</span></span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">odd?</span></span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">        false</span><br><span class="line">        (<span class="name"><span class="builtin-name">even?</span></span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br><span class="line">  &lt;rest of body of f&gt;)</span><br></pre></td></tr></table></figure></p>
<p>这个互递归结构让很多人设想解释器应该<strong>同时</strong>完成<code>even?</code>和<code>odd?</code>的绑定，幸运的是两个变量都指向了lambda表达式，因此用普通的<code>define</code>就可以实现互递归，不需要实现真正意义上的同时。如GNU/MIT Scheme在内很多版本的解释器也是把它当成类似于top-level的<code>define</code>，从扫描到这个<code>define</code>语句开始把绑定放入当前环境。</p>
<p>但也有人追求这个真正意义上的同时，于是他们设计解释器的做法是：把一个代码块内所有内部定义的局部变量名都先扫描出来，用一个特定的标签进行初始化，放入当前环境。接下来再逐次对这些变量名按照指定表达式进行赋值，如此一来，这些表达式内如果包含其他局部变量，也不会被提示unbound identifier，但却有可能被警告 cannot use before initialization，因为表达式中的其他局部变量可能还没有指向可以用于计算的值。</p>
<p>也就是把
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">&lt;vars&gt;</span></span><br><span class="line">  (define u &lt;e1&gt;)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> v &lt;e2&gt;)</span><br><span class="line">  &lt;e3&gt;)</span><br></pre></td></tr></table></figure></p>
<p>处理成
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">&lt;vars&gt;</span></span><br><span class="line">  (let ((u '*unassigned*)</span><br><span class="line">        (<span class="name">v</span> <span class="symbol">'*unassigned*</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> u &lt;e1&gt;)</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> v &lt;e2&gt;)</span><br><span class="line">    &lt;e3&gt;))</span><br></pre></td></tr></table></figure></p>
<p>具体源码我就不写了，能猜出需要借助一个函数先去扫描代码找出所有的中间定义变量，在<code>make-procedure</code>中把函数体解析成如上形式。另外还需要注意在<code>env</code>寻值时遇到返回结果为<code>'*unassigned*</code>时应该发起一个未初始化的异常。</p>
<p>Racket就是使用了类似的“同时”机制，所以我在<a href="http://notebook.xyli.me/SICP/SICP-with-DrRacket/#Internal-Definitions">3.5.4 Streams and Delayed Evaluation </a> 中遇到的那个互相递归的内部变量定义即使在其中一个参数上加了<code>delay</code>也无法解决。现在再来想，让两个变量都定义为无参的lambda过程，也就是写为thunk就可以继续用了
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">solve</span> f y0 dt)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">y</span>) (<span class="name">integral</span> (<span class="name"><span class="builtin-name">delay</span></span> (<span class="name">dy</span>)) y0 dt))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dy</span>) (<span class="name">stream-map</span> f (<span class="name">y</span>)))</span><br><span class="line">  (<span class="name">y</span>))</span><br></pre></td></tr></table></figure></p>
<p>当然这种“同时”带来的弊端就是不能像<code>let*</code>那样让后面的变量绑定关于前面变量的表达式。比如这种写法就是不允许的
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> a <span class="number">1</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> b (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">1</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> x b))</span><br></pre></td></tr></table></figure></p>
<h2>letrec</h2>
<p><code>letrec</code>也是<code>let</code>的一个变体，使用的就是上文提到的内部<code>define</code>的“同时”绑定机制，即表达式
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">letrec</span></span> ((<span class="name">&lt;var1&gt;</span> &lt;exp1&gt;) ... (<span class="name">&lt;varn&gt;</span> &lt;expn&gt;))</span><br><span class="line">  &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<p>被视为
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">&lt;var1&gt;</span> <span class="symbol">'*unassigned*</span>)</span><br><span class="line">      ...</span><br><span class="line">      (<span class="name">&lt;varn&gt;</span> <span class="symbol">'*unassigned*</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">set!</span></span> &lt;var1&gt; &lt;exp1&gt;)</span><br><span class="line">  ...</span><br><span class="line">  (<span class="name"><span class="builtin-name">set!</span></span> &lt;varn&gt; &lt;expn&gt;)</span><br><span class="line">  &lt;body&gt;))</span><br></pre></td></tr></table></figure></p>
<p>处理，每个变量的作用域都是一致的，可以用来定义内部递归/互递归函数，这是<code>let*</code>做不到的，但同时注意，<code>let*</code>能实现的顺序绑定沿用<code>letrec</code>也同样无法完成&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。</p>
<h2>Y operator</h2>
<p>完全不用这一类局部绑定和内部定义也是可以实现局部变量的定义的，毕竟<code>let</code>展开还是lambda表达式，甚至可以完成递归定义的局部函数。比如计算10!
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (n)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (fact)</span><br><span class="line">      (<span class="name">fact</span> fact n))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (ft k)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> k <span class="number">1</span>)</span><br><span class="line">          <span class="number">1</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">*</span></span> k (<span class="name">ft</span> ft (<span class="name"><span class="builtin-name">-</span></span> k <span class="number">1</span>)))))))</span><br><span class="line"> <span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<p>定义一个<code>(f x)</code>判断<code>x</code>是否为偶数：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x)</span><br><span class="line">  ((<span class="name"><span class="builtin-name">lambda</span></span> (even? odd?) (<span class="name"><span class="builtin-name">even?</span></span> even? odd? x))</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (ev? od? n)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) true (<span class="name">od?</span> ev? od? (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (ev? od? n)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>) false (<span class="name">ev?</span> ev? od? (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure></p>
<p>不过Y operator这种东西还是看看就行了，没事就别给自己找麻烦了。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/Coding-style.html&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://docs.racket-lang.org/reference/let.html&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/local-bindings-and-internal-definitions/" data-id="cjuh9jxa8005gfww30j8pur8m" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DrRacket/">DrRacket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-107" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-107/">LeetCode Weekly Contest 107</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-107/" class="article-date"><time datetime="2018-10-21T14:01:39.524Z" itemprop="datePublished">2018-10-21</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-107</p>
<p>&lt;!-- more --&gt;</p>
<h2>Long Pressed Name</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-107/problems/long-pressed-name/</p>
<blockquote>
<p>Your friend is typing his <code>name</code> into a keyboard.  Sometimes, when typing a character <code>c</code>, the key might get long pressed, and the character will be typed 1 or more times.</p>
</blockquote>
<blockquote>
<p>You examine the <code>typed</code> characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;a&apos; and &apos;e&apos; in &apos;alex&apos; were long pressed.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &apos;e&apos; must have been pressed twice, but it wasn&apos;t in the typed output.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;leelee&quot;, typed = &quot;lleeelee&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;laiden&quot;, typed = &quot;laiden&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It&apos;s not necessary to long press any character.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>name.length &lt;= 1000</code></li>
<li><code>typed.length &lt;= 1000</code></li>
<li>The characters of <code>name</code> and <code>typed</code> are lowercase letters.</li>
</ol>
<p>两个字符串同时线性遍历，注意结尾处的判定。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLongPressedName</span><span class="params">(self, name, typed)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type name: str</span></span><br><span class="line"><span class="string">        :type typed: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        p1 = p2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2 &lt; len(typed) <span class="keyword">and</span> p1 &lt; len(name):</span><br><span class="line">            <span class="keyword">if</span> name[p1] != typed[p2]:</span><br><span class="line">                <span class="keyword">if</span> p2 &gt; <span class="number">0</span> <span class="keyword">and</span> typed[p2] == typed[p2 - <span class="number">1</span>]:</span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2 &lt; len(typed):</span><br><span class="line">            <span class="keyword">if</span> typed[p2] != name[<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p1 == len(name)</span><br></pre></td></tr></table></figure></p>
<h2>Flip String to Monotone Increasing</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-107/problems/flip-string-to-monotone-increasing/</p>
<blockquote>
<p>A string of <code>'0'</code>s and <code>'1'</code>s is monotone increasing if it consists of some number of <code>'0'</code>s (possibly 0), followed by some number of <code>'1'</code>s (also possibly 0.)</p>
</blockquote>
<blockquote>
<p>We are given a string <code>S</code> of <code>'0'</code>s and <code>'1'</code>s, and we may flip any <code>'0'</code> to a <code>'1'</code> or a <code>'1'</code> to a <code>'0'</code>.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of flips to make S monotone increasing.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;00110&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We flip the last digit to get 00111.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;010110&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We flip to get 011111, or alternatively 000111.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;00011000&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We flip to get 00000000.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S</code> only consists of <code>'0'</code> and <code>'1'</code> characters.</li>
</ol>
<p><code>dp[i]</code>表示前<code>i</code>个字符全为<code>'0'</code>则<code>S</code>需要翻转多少个字符，即<code>S[i]</code>前（不包括<code>S[i]</code>）全为<code>'0'</code>而<code>S[i]</code>和之后的字符都为<code>'1'</code>，那么相比<code>dp[i+1]</code>，如果<code>S[i]</code>原本是<code>'0'</code>,那么在<code>dp[i]</code>需要被翻转而在<code>dp[i+1]</code>不需要，所以有<code>dp[i+1]=dp[i]-1</code>，如果<code>S[i]</code>原本是<code>'1'</code>则反之，<code>dp[i+1]=dp[i]+1</code>，最后找到<code>dp</code>的最小值返回。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [S.count(<span class="string">'0'</span>)] + [<span class="number">0</span>] * len(S)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i] == <span class="string">'0'</span>:</span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(dp)</span><br></pre></td></tr></table></figure></p>
<h2>Three Equal Parts</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-107/problems/three-equal-parts/</p>
<blockquote>
<p>Given an array <code>A</code> of <code>0</code>s and <code>1</code>s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.</p>
</blockquote>
<blockquote>
<p>If it is possible, return any <code>[i, j]</code> with <code>i+1 &lt; j</code>, such that:</p>
</blockquote>
<ul>
<li><code>A[0], A[1], ..., A[i]</code> is the first part;</li>
<li><code>A[i+1], A[i+2], ..., A[j-1]</code> is the second part, and</li>
<li><code>A[j], A[j+1], ..., A[A.length - 1]</code> is the third part.</li>
<li>All three parts have equal binary value.</li>
</ul>
<blockquote>
<p>If it is not possible, return <code>[-1, -1]</code>.</p>
</blockquote>
<blockquote>
<p>Note that the entire part is used when considering what binary value it represents.  For example, <code>[1,1,0]</code> represents <code>6</code> in decimal, not <code>3</code>.  Also, leading zeros are allowed, so <code>[0,1,1]</code>and <code>[1,1]</code> represent the same value.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,0,1]</span><br><span class="line">Output: [0,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1]</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 30000</code></li>
<li><code>A[i] == 0 or A[i] == 1</code></li>
</ol>
<p>先用<code>ones</code>统计<code>A</code>的每个<code>1</code>出现的位置，以及一共有<code>cnt</code>个<code>1</code>。当<code>cnt</code>不能被3整除时，显然无法划分出3个相等的二进制数。</p>
<p>当<code>cnt</code>能被3整除时，每个二进制数都有<code>k=cnt/3</code>个<code>1</code>，如果这三个二进制数相等，那么对应顺序的<code>1</code>之间间隔也必须一致，即<code>ones[i+1]-ones[i]</code>，<code>ones[k+i+1]-ones[k+i]</code>和<code>ones[2*k+i+1]-ones[2*k+i]</code>都相等。</p>
<p>最后，因为最后一个部分尾部的<code>0</code>必须作为有效数值记录，划分时需要前两个部分也至少有<code>len(A)-1-ones[cnt]</code>个<code>0</code>。</p>
<p>以及需要注意返回结果的<code>i</code>是第一个部分结尾的位置，而<code>j</code>是第三个部分开始的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeEqualParts</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ones = &#123;&#125;</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> c == <span class="number">1</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                ones[cnt] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ones:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, len(A) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cnt % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        k = cnt / <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k):</span><br><span class="line">            <span class="keyword">if</span> ones[i + <span class="number">1</span>] - ones[i] == ones[i + k + <span class="number">1</span>] - ones[i + k] == ones[i + <span class="number">2</span> * k + <span class="number">1</span>] - ones[i + <span class="number">2</span> * k]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(A) - ones[cnt] &gt; ones[<span class="number">2</span> * k + <span class="number">1</span>] - ones[<span class="number">2</span> * k] <span class="keyword">or</span> len(A) - ones[cnt] &gt; ones[k + <span class="number">1</span>] - ones[k]:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ones[k] + (len(A) - <span class="number">1</span> - ones[cnt]), ones[<span class="number">2</span> * k] + (len(A) - ones[cnt])]</span><br></pre></td></tr></table></figure></p>
<h2>Minimize Malware Spread II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-107/problems/minimize-malware-spread-ii/</p>
<blockquote>
<p>This problem is the same as Minimize Malware Spread, with the differences bolded.)</p>
</blockquote>
<blockquote>
<p>In a network of nodes, each node <code>i</code> is directly connected to another node <code>j</code> if and only if <code>graph[i][j] = 1</code>.</p>
</blockquote>
<blockquote>
<p>Some nodes <code>initial</code> are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.</p>
</blockquote>
<blockquote>
<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network, after the spread of malware stops.</p>
</blockquote>
<blockquote>
<p>We will remove one node from the initial list, <strong>completely removing it and any connections from this node to any other node.</strong>  Return the node that if removed, would minimize <code>M(initial)</code>.  If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with the smallest index.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt; graph.length = graph[0].length &lt;= 300</code></li>
<li><code>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</code></li>
<li><code>graph[i][i] = 1</code></li>
<li><code>1 &lt;= initial.length &lt; graph.length</code></li>
<li><code>0 &lt;= initial[i] &lt; graph.length</code></li>
</ol>
<p>这题和<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-106/#Minimize-Malware-Spread">Minimize Malware Spread</a>很相似，除了去除初始点是直接物理的把它和它的连接都切断了。我直接按照原题第一种方法改了一下，还是计算每个结点能独立感染的其他结点，不同在于因为去除时会断开所有连接，所以在BFS时访问到<code>initial</code>的任何结点都假设它已经和整个网络断开所以直接不访问了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMalwareSpread</span><span class="params">(self, graph, initial)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :type initial: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        spread = dict()</span><br><span class="line">        source = dict()</span><br><span class="line">        n = len(graph)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> initial:</span><br><span class="line">            spread[s] = <span class="number">0</span></span><br><span class="line">            seen = set(initial)</span><br><span class="line">            q = [s]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        seen.add(j)</span><br><span class="line">                        q.append(j)</span><br><span class="line">                        <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> source:</span><br><span class="line">                            source[j] = s</span><br><span class="line">                            spread[s] += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">elif</span> source[j] &gt;= <span class="number">0</span>:</span><br><span class="line">                            spread[source[j]] -= <span class="number">1</span></span><br><span class="line">                            source[j] = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(initial, key=<span class="keyword">lambda</span> i: (spread[i], -i))</span><br></pre></td></tr></table></figure></p>
<p>请原谅我这几天抑郁非常难受，已经在自杀边缘试探了，因为过于焦虑已经很难安安静静坐下来想解法了，每天和自己负面的情绪抗争真的太辛苦了，所以我也没法再补上更好的解法，就当我先欠着吧，等哪天精神安定下来再想。真的太痛苦了。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-107/" data-id="cjuh9jwsy000qfww35zl426rc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-106" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-106/">LeetCode Weekly Contest 106</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-106/" class="article-date"><time datetime="2018-10-14T11:49:32.833Z" itemprop="datePublished">2018-10-14</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-106</p>
<p>&lt;!-- more --&gt;</p>
<h2>Sort Array By Parity II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-106/problems/sort-array-by-parity-ii/</p>
<blockquote>
<p>Given an array <code>A</code> of non-negative integers, half of the integers in A are odd, and half of the integers are even.</p>
</blockquote>
<blockquote>
<p>Sort the array so that whenever <code>A[i]</code> is odd, <code>i</code> is odd; and whenever <code>A[i]</code> is even, <code>i</code> is even.</p>
</blockquote>
<blockquote>
<p>You may return any answer array that satisfies this condition.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,5,7]</span><br><span class="line">Output: [4,5,2,7]</span><br><span class="line">Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= A.length &lt;= 20000</code></li>
<li><code>A.length % 2 == 0</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<p>没什么可多说的，把<code>A</code>的所有奇数和偶数提取出来，再重新交替合并。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParityII</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        odds = [i <span class="keyword">for</span> i <span class="keyword">in</span> A <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>]</span><br><span class="line">        evens = [i <span class="keyword">for</span> i <span class="keyword">in</span> A <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">        A[::<span class="number">2</span>] = evens</span><br><span class="line">        A[<span class="number">1</span>::<span class="number">2</span>] = odds</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Add to Make Parentheses Valid</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-106/problems/minimum-add-to-make-parentheses-valid/</p>
<blockquote>
<p>Given a string <code>S</code> of <code>'('</code> and <code>')'</code> parentheses, we add the minimum number of parentheses ( <code>'('</code> or <code>')'</code>, and in any positions ) so that the resulting parentheses string is valid.</p>
</blockquote>
<blockquote>
<p>Formally, a parentheses string is valid if and only if:</p>
</blockquote>
<ul>
<li>It is the empty string, or</li>
<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li>
<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li>
</ul>
<blockquote>
<p>Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;())&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(((&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()))((&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S.length &lt;= 1000</code></li>
<li><code>S</code> only consists of <code>'('</code> and <code>')'</code> characters.</li>
</ol>
<p>用<code>left</code>表示到目前为止有多少未被配对的<code>'('</code>，<code>right</code>表示未配对的<code>')'</code>，扫描到<code>'('</code>时<code>left</code>计数增加，扫描到<code>')'</code>时如果<code>left</code>不为0则抵消掉一个未配对的<code>'('</code>，否则增加<code>right</code>的计数，最后<code>left+right</code>是未被配对的括号总数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left + right</span><br></pre></td></tr></table></figure></p>
<h2>3Sum With Multiplicity</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-106/problems/3sum-with-multiplicity/</p>
<blockquote>
<p>Given an integer array <code>A</code>, and an integer <code>target</code>, return the number of tuples <code>i, j, k</code>  such that <code>i &lt; j &lt; k</code> and <code>A[i] + A[j] + A[k] == target</code>.</p>
</blockquote>
<blockquote>
<p><strong>As the answer can be very large, return it modulo <code>10^9 + 7</code></strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8</span><br><span class="line">Output: 20</span><br><span class="line">Explanation:</span><br><span class="line">Enumerating by the values (A[i], A[j], A[k]):</span><br><span class="line">(1, 2, 5) occurs 8 times;</span><br><span class="line">(1, 3, 4) occurs 8 times;</span><br><span class="line">(2, 2, 4) occurs 2 times;</span><br><span class="line">(2, 3, 3) occurs 2 times.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1,2,2,2,2], target = 5</span><br><span class="line">Output: 12</span><br><span class="line">Explanation:</span><br><span class="line">A[i] = 1, A[j] = A[k] = 2 occurs 12 times:</span><br><span class="line">We choose one 1 from [1,1] in 2 ways,</span><br><span class="line">and two 2s from [2,2,2,2] in 6 ways.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 3000</code></li>
<li><code>0 &lt;= A[i] &lt;= 100</code></li>
<li><code>0 &lt;= target &lt;= 300</code></li>
</ol>
<p>把<code>A</code>的重复元素去除（转换为<code>set</code>）就可以当成普通的3sum问题去做了，这个问题不一样的地方在 <strong>Example 2</strong> 也已经暗示了重复元素会存在多种取法，首先同一个元素<code>a</code>如果出现大于等于3次且3个<code>a</code>相加正好等于<code>target</code>那么取法就有<code>count(a)*(count(a)-1)*(count(a)-2)/3!</code>种。</p>
<p>对于两个不同的数<code>a&lt;b</code>如果有</p>
<ul>
<li><code>a+a+b==target</code>:<code>a</code>有<code>count(a)*(count(a)-1)/2</code>种取法，<code>b</code>有<code>count(b)</code>种</li>
<li><code>a+b+b==target</code>:<code>a</code>有<code>count(a)</code>种，<code>b</code>有<code>count(b)*(count(b)-1)/2</code>种</li>
<li><code>a+b+c==target</code>且<code>a&lt;b&lt;c</code>：共有<code>count(a)*count(b)*count(c)</code>种，严格规定<code>a&lt;b&lt;c</code>是为了防止重复计算这种情况</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumMulti</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = collections.Counter(A)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        A = set(A)</span><br><span class="line">        L = sorted(list(set(A)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(L)):</span><br><span class="line">            a = L[i]</span><br><span class="line">            <span class="keyword">if</span> a * <span class="number">3</span> == target <span class="keyword">and</span> cnt[a] &gt;= <span class="number">3</span>:</span><br><span class="line">                res += (cnt[a] * (cnt[a] - <span class="number">1</span>) * (cnt[a] - <span class="number">2</span>)) / <span class="number">6</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(L)):</span><br><span class="line">                b = L[j]</span><br><span class="line">                <span class="keyword">if</span> target - a - b == a <span class="keyword">and</span> cnt[a] &gt;= <span class="number">2</span>:</span><br><span class="line">                    res += cnt[a] * (cnt[a] - <span class="number">1</span>) * cnt[b] / <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> target - a - b == b <span class="keyword">and</span> cnt[b] &gt;= <span class="number">2</span>:</span><br><span class="line">                    res += cnt[b] * (cnt[b] - <span class="number">1</span>) * cnt[a] / <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> target - a - b <span class="keyword">in</span> A <span class="keyword">and</span> target - a - b &gt; b:</span><br><span class="line">                    res += cnt[a] * cnt[b] * cnt[target - a - b]</span><br><span class="line">            res %= <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimize Malware Spread</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-106/problems/minimize-malware-spread/</p>
<blockquote>
<p>n a network of nodes, each node <code>i</code> is directly connected to another node <code>j</code> if and only if <code>graph[i][j] = 1</code>.</p>
</blockquote>
<blockquote>
<p>Some nodes <code>initial</code> are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.</p>
</blockquote>
<blockquote>
<p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network, after the spread of malware stops.</p>
</blockquote>
<blockquote>
<p>We will remove one node from the initial list.  Return the node that if removed, would minimize <code>M(initial)</code>.  If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with the smallest index.</p>
</blockquote>
<blockquote>
<p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it may still be infected later as a result of the malware spread.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt; graph.length = graph[0].length &lt;= 300</code></li>
<li><code>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</code></li>
<li><code>graph[i][i] = 1</code></li>
<li><code>1 &lt;= initial.length &lt; graph.length</code></li>
<li><code>0 &lt;= initial[i] &lt; graph.length</code></li>
</ol>
<p>说的比较绕，实际意思是问如果<code>initial</code>的哪个结点一开始没有被感染最后影响最小？我的想法也比较简单，找<code>initial</code>的每个结点能<strong>独立</strong>感染的其他结点数量，看哪一个最多。做法简单来说就是对每个<code>initial</code>结点<code>s</code>遍历找包含它在内的最大连通分支，再减去<code>initial-s</code>的连通分支覆盖的结点。具体做法是对每个<code>s</code>进行BFS，如果第一次感染到当前结点则记录当前结点<code>j</code>的感染源<code>source[j]</code>为<code>s</code>并计入感染范围<code>spread[s]</code>，当其他<code>s</code>的感染过程也经过这个结点时再根据<code>source[j]</code>为之前的<code>s</code>删除感染<code>j</code>的记录。最后找到<code>spread[s]</code>长度最大且<code>s</code>最小的<code>s</code>。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMalwareSpread</span><span class="params">(self, graph, initial)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :type initial: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        spread = dict()</span><br><span class="line">        infected = set()</span><br><span class="line">        source = dict()</span><br><span class="line">        n = len(graph)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> initial:</span><br><span class="line">            spread[s] = set()</span><br><span class="line">            q = [s]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> infected:</span><br><span class="line">                    infected.add(i)</span><br><span class="line">                    spread[s].add(i)</span><br><span class="line">                    source[i] = s</span><br><span class="line">                <span class="keyword">elif</span> source[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                    spread[source[i]].remove(i)</span><br><span class="line">                    source[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> graph[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> q:</span><br><span class="line">                        q.append(j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(initial, key=<span class="keyword">lambda</span> i: (len(spread[i]), -i))</span><br></pre></td></tr></table></figure></p>
<p>这是当时赶时间没过脑子写的。</p>
<p>不过一个连通分支只要有1个结点被感染就会全部被感染，所以只要union find找出所有连通分支，再看<code>initial</code>中不同结点所在的连通分支是否有重复的，如果有结点对应的连通分支和其他都不同，就返回对应的连通分支规模最大的结点即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMalwareSpread</span><span class="params">(self, graph, initial)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :type initial: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        color = dict()</span><br><span class="line">        seen = set()</span><br><span class="line">        amount = dict()</span><br><span class="line">        component = collections.defaultdict(list)</span><br><span class="line">        res = []</span><br><span class="line">        n = len(graph)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(i)</span><br><span class="line">                amount[i] = <span class="number">0</span></span><br><span class="line">                q = [i]</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> q:</span><br><span class="line">                    color[j] = i</span><br><span class="line">                    amount[i] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                        <span class="keyword">if</span> j != k <span class="keyword">and</span> graph[j][k] == <span class="number">1</span> <span class="keyword">and</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                            seen.add(k)</span><br><span class="line">                            q.append(k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> initial:</span><br><span class="line">            component[color[i]].append(i)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> component:</span><br><span class="line">            <span class="keyword">if</span> len(component[c]) == <span class="number">1</span>:</span><br><span class="line">                res.append((amount[c], -component[c][<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">            <span class="keyword">return</span> -max(res)[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(initial)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-106/" data-id="cjuh9jwsq000nfww3lvmodjcy" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-105" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-105/">LeetCode Weekly Contest 105</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-105/" class="article-date"><time datetime="2018-10-07T12:22:31.726Z" itemprop="datePublished">2018-10-07</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>有个不情之请，希望看到这里的，有余力的朋友监督我早睡早起！帮助我战胜失眠！</p>
<p>https://leetcode.com/contest/weekly-contest-105</p>
<p>&lt;!-- more --&gt;</p>
<h2>Reverse Only Letters</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-105/problems/reverse-only-letters/</p>
<blockquote>
<p>Given a string <code>S</code>, return the &quot;reversed&quot; string where all characters that are not a letter stay in the same place, and all letters reverse their positions.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ab-cd&quot;</span><br><span class="line">Output: &quot;dc-ba&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a-bC-dEf-ghIj&quot;</span><br><span class="line">Output: &quot;j-Ih-gfE-dCba&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Test1ng-Leet=code-Q!&quot;</span><br><span class="line">Output: &quot;Qedo1ct-eeLg=ntse-T!&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S.length &lt;= 100</code></li>
<li><code>33 &lt;= S[i].ASCIIcode &lt;= 122</code></li>
<li><code>S</code> doesn't contain <code>\</code> or <code>&quot;</code></li>
</ol>
<p>从<code>S</code>两端向中间扫描，如果指针<code>s</code>和<code>e</code>都遇到字母则交换，任何一个指针遇到其他字符则忽略它继续前进。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseOnlyLetters</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        S = list(S)</span><br><span class="line">        s, e = <span class="number">0</span>, len(S) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> s &lt; e:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> S[s].isalpha():</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> S[e].isalpha():</span><br><span class="line">                e -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                S[s], S[e] = S[e], S[s]</span><br><span class="line">                s += <span class="number">1</span></span><br><span class="line">                e -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(S)</span><br></pre></td></tr></table></figure></p>
<h2>Maximum Sum Circular Subarray</h2>
<blockquote>
<p>Given a <strong>circular array</strong> C of integers represented by <code>A</code>, find the maximum possible sum of a non-empty subarray of <strong>C</strong>.</p>
</blockquote>
<blockquote>
<p>Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, <code>C[i] = A[i]</code> when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code> when <code>i &gt;= 0</code>.)</p>
</blockquote>
<blockquote>
<p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray<code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length = k2 % A.length</code>.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>-30000 &lt;= A[i] &lt;= 30000</code></li>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
</ol>
<p>最后得到的子数组可能在<code>A</code>的中间，也可能分布在<code>A</code>的两端，那么有两种情况</p>
<ol>
<li>找到<code>A</code>的最大和子数组并直接返回这个和</li>
<li>找到<code>A</code>的最小和子数组，剩下的元素就是<code>C</code>的最大和子数组，返回<code>sum(A)</code>与最小和的差值</li>
</ol>
<p>而寻找最大（小）和子数组可以用常见的$o(n)$复杂度的<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm" target="_blank" rel="noopener">Kadane算法</a>，返回上面两种结果中的较大值。</p>
<p>需要注意子数组至少需要一个元素，当所有元素都小于等于0时，最小和就是<code>sum(A)</code>，第二种情况计算得到的最大和子数组不包含任何元素，这是不符合题意需要另外处理的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubarraySumCircular</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> max(A) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> max(A)</span><br><span class="line">        max_ending_here = max_so_far = A[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">            max_ending_here = max(max_ending_here + i, i)</span><br><span class="line">            max_so_far = max(max_so_far, max_ending_here)</span><br><span class="line"></span><br><span class="line">        min_ending_here = min_so_far = A[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A[<span class="number">1</span>:]:</span><br><span class="line">            min_ending_here = min(min_ending_here + i, i)</span><br><span class="line">            min_so_far = min(min_so_far, min_ending_here)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(max_so_far, sum(A) - min_so_far)</span><br></pre></td></tr></table></figure></p>
<h2>Complete Binary Tree Inserter</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-105/problems/complete-binary-tree-inserter/</p>
<blockquote>
<p>A <em>complete</em> binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>
</blockquote>
<blockquote>
<p>Write a data structure <code>CBTInserter</code> that is initialized with a complete binary tree and supports the following operations:</p>
</blockquote>
<ul>
<li><code>CBTInserter(TreeNode root)</code> initializes the data structure on a given tree with head node <code>root</code>;</li>
<li><code>CBTInserter.insert(int v)</code> will insert a <code>TreeNode</code> into the tree with value <code>node.val = v</code> so that the tree remains complete, <strong>and returns the value of the parent of the inserted <code>TreeNode</code></strong>;</li>
<li><code>CBTInserter.get_root()</code> will return the head node of the tree.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]</span><br><span class="line">Output: [null,1,[1,2]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]</span><br><span class="line">Output: [null,3,4,[1,2,3,4,5,6,7,8]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The initial given tree is complete and contains between <code>1</code> and <code>1000</code> nodes.</li>
<li><code>CBTInserter.insert</code> is called at most <code>10000</code> times per test case.</li>
<li>Every value of a given or inserted node is between <code>0</code> and <code>5000</code>.</li>
</ol>
<p>普通的数据结构题，没有什么需要特别思考的算法部分。在初始化时先对完全二叉树做一次BFS，把子结点未满的结点放到一个队列<code>insert_queue</code>中，当需要调用<code>insert</code>方法时，被插入结点的父结点即为队首的结点，如果它已经有了左结点则插入到右结点并弹出队列，如果没有则插到左结点，再将新插入的结点放入<code>insert_queue</code>的队尾。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.r = root</span><br><span class="line">        self.insert_queue = []</span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.insert_queue.append(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.insert_queue.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type v: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.insert_queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            node.right = TreeNode(v)</span><br><span class="line">            self.insert_queue.pop(<span class="number">0</span>)</span><br><span class="line">            self.insert_queue.append(node.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.left = TreeNode(v)</span><br><span class="line">            self.insert_queue.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.r</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CBTInserter(root)</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(v)</span></span><br><span class="line"><span class="comment"># param_2 = obj.get_root()</span></span><br></pre></td></tr></table></figure></p>
<h2>Number of Music Playlists</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-105/problems/number-of-music-playlists/</p>
<blockquote>
<p>Your music player contains <code>N</code> different songs and she wants to listen to <code>L</code> (not necessarily different) songs during your trip.  You create a playlist so that:</p>
</blockquote>
<ul>
<li>Every song is played at least once</li>
<li>A song can only be played again only if <code>K</code> other songs have been played</li>
</ul>
<blockquote>
<p>Return the number of possible playlists.  <strong>As the answer can be very large, return it modulo <code>10^9 + 7</code></strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, L = 3, K = 1</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, L = 3, K = 0</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, L = 3, K = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= K &lt; N &lt;= L &lt;= 100</code></li>
</ol>
<p>试着去分解这个计数问题。</p>
<p>首先，最后长度为<code>L</code>的playlist至多包含<code>N</code>首不同的歌，至少包含<code>K+1</code>首不同的歌。假设一共包含$i$首不同的歌，而且我们已知这$i$首歌分别是什么，那么可能的playlist可以这样计算：第一首歌有$i$种取法，第二首不能和第一首相同，有$i-1$种取法……第$K$首不能与前面的$K-1$首相同因此有$i-(K-1)$种取法，而到第$K+1$首至最后一首，都是需要保证和前面$K$首不同，都是只有$i-K$种取法，因此对于某个元素数为$i$的歌曲集合$S$组成的playlist共有$${A_S} = \frac{i!}{(i - K)!}{(i - K)^{(L - K)}},\quad \left| S \right| = i$$每个长度为$i$的子集$S$的计数相同，可以直接使用<a href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle" target="_blank" rel="noopener">容斥原理</a>的特殊形式，把需要解决的计数问题即这些集合之间的并集计数表达为
$$\begin{align}
&amp; \sum\limits_{i = K + 1}^N {( - 1)}^{N-i}{N \choose i}{A_{\left| S \right| = i}} \\
= &amp;\sum\limits_{i = K + 1}^N {( - 1)}^{N-i}\frac{N!}{(N - K)!(i - K)!}{(i - K)}^{(L - K)}
\end{align} $$</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMusicPlaylists</span><span class="params">(self, N, L, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        f = [<span class="number">1</span>] + range(<span class="number">1</span>, N + <span class="number">1</span>)  <span class="comment"># factorial number</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            f[i + <span class="number">1</span>] *= f[i]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N, K, <span class="number">-1</span>):</span><br><span class="line">            res += sign * (f[N] / (f[N - i] * f[i - K])) * (i - K)**(L - K)</span><br><span class="line">            res %= <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">            sign *= <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-105/" data-id="cjuh9jwsg000kfww3bu9gcesg" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-stream-count-and-generating-function" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/stream-count-and-generating-function/">流，计数与生成函数</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/stream-count-and-generating-function/" class="article-date"><time datetime="2018-10-06T14:03:16.198Z" itemprop="datePublished">2018-10-06</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在很久以前阅读<a href="http://www.boazbarak.org/cs121/LehmanLeighton.pdf" target="_blank" rel="noopener">旧版 <em>Mathematics for Computer Science</em></a> 时我就感叹过生成函数（generating function）是全书最精彩的部分之一，这个漂亮的结构有很多非常有趣的用法。近日在看<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a> 时也被迫复习了Racket/Scheme语言所定义的流（stream）结构，偶然想到二者之间似乎存在着十分微妙的联系。所以我在此随手写一篇抄书性质的小结，不作严谨的定义和推导，仅浅谈我对它们的新理解和应用。</p>
<p>&lt;!-- more --&gt;</p>
<h2>生成函数的定义</h2>
<p>生成函数是离散数学中最神奇且实用的工具之一，它把关于序列（sequence）的问题转换成了关于代数的问题。</p>
<p>简单来说，我们可以构造这样一个关于变量$x$的函数
$$F\left( x \right) = {f_0} + {f_1}x + {f_2}{x^2} +  \cdots $$ 来表示一个无穷级数（infinite series）,每个$x^n$前的系数$f_n$按顺序作为序列的每一项，即用生成函数（generating function）$F\left( x \right) $来表示/定义的序列是$${f_0},{f_1},{f_2},\ldots,f_n,\ldots$$这种表示法可以在很多问题的解决上给出启发，比如一个由1组成的序列$1,1,...$可以写成这样的生成函数
$$G\left( x \right)=1+x+x^2+\cdots+x^n+\cdots$$用常见的perturbation method来消去等式右边关于$x$的项&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;$$
\begin{alignat}{2}
G\left( x \right) &amp;=1&amp;+x+x^2+\cdots+x^n+\cdots \\
-xG\left( x \right) &amp;=&amp;-x-x^2-\cdots-x^n-\cdots \\
G\left( x \right) -xG\left( x \right) &amp;=1 \
\end{alignat}$$就可以得到一个关于级数的重要结论，也是几何级数的计算公式$$\sum\limits_{n = 0}^\infty{x^n} = G\left( x \right) = \frac{1}{1 - x}$$当然，这只是生成函数应用的冰山一角，接下来会随着编程工具的引入发掘更多，包括很多脱离辅助变量$x$的例子。</p>
<h2>流的表示</h2>
<p>Scheme的函数即lambda表达式的语法糖，封装一个无参函数，把需要求值的部分写在函数体中可以实现延迟求值（delayed evaluation）。流结构正是利用了该特性，用于表示一个特殊的pair或者说list，只有第一个元素的值是已经求值完成的，后面的元素只有<strong>当取用时</strong>才会安排求值过程。构造一个stream所用的特殊过程<code>cons-stream</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons-stream</span> &lt;a&gt; &lt;b&gt;)</span><br></pre></td></tr></table></figure></p>
<p>可以被理解为等同于这样的一个过程（当然<code>cons-stream</code>的特殊性在于它不会在传入参数前就对第二个参数进行求值）
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">cons</span></span> &lt;a&gt; (<span class="name"><span class="builtin-name">delay</span></span> &lt;b&gt;))</span><br></pre></td></tr></table></figure></p>
<p>一个stream通常由第一个已经求值完成的元素<code>&lt;a&gt;</code>和剩下还没有进行求值而被放置的另一个stream也就是上面的形参<code>&lt;b&gt;</code>组成，看上去像是一个天然的递归结构。可以和一般的pair一样定义一些选择器（selector）：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">stream-car</span> stream) (<span class="name"><span class="builtin-name">car</span></span> stream))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">stream-cdr</span> stream) (<span class="name"><span class="builtin-name">force</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> stream)))</span><br></pre></td></tr></table></figure></p>
<p><code>delay</code>表示推迟对对象的求值，而<code>force</code>表示强制立刻对该对象进行求值，它们实际上的实现也是那么回事，<code>(delay &lt;exp&gt;)</code>给<code>&lt;exp&gt;</code>套上一层lambda表达式<code>(lambda () &lt;exp&gt;)</code>，<code>force</code>则调用这个lambda表达式得到<code>&lt;exp&gt;</code>的求值结果。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">force</span></span> delayed-object)</span><br><span class="line">  (<span class="name">delayed-object</span>))</span><br></pre></td></tr></table></figure></p>
<p>当然，除此之外对于<code>delay</code>还有一个重要的<strong>优化</strong>，因为这些表达式可能会被调用多次进行多次求值，所以很有必要在被调用前检查它是否在之前的调用中已经被计算过了，如果是，可以直接返回之前的计算结果而不用再次计算。所以实际上会用<code>memo-proc</code>封装一个过程<code>proc</code>，调用<code>proc</code>返回它的结果，并把结果放入本地cache，以备不时之需。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">memo-proc</span> proc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">already-run?</span> false) (<span class="name">result</span> false))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">not</span></span> already-run?)</span><br><span class="line">          (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name"><span class="builtin-name">set!</span></span> result (<span class="name">proc</span>))</span><br><span class="line">                 (<span class="name"><span class="builtin-name">set!</span></span> already-run? true)</span><br><span class="line">                 result)</span><br><span class="line">          result))))</span><br></pre></td></tr></table></figure></p>
<p>那么<code>(delay &lt;exp&gt;)</code>实际上是
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">memo-proc</span> (<span class="name"><span class="builtin-name">lambda</span></span> () &lt;exp&gt;))</span><br></pre></td></tr></table></figure></p>
<p>的语法糖。</p>
<p>接下来我们用上面流工具来隐式定义（implicitly define）上面那个全为1的序列
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> ones (<span class="name">cons-stream</span> <span class="number">1</span> ones))</span><br></pre></td></tr></table></figure></p>
<p>这个长度无限的流<code>ones</code>也可以用来表示前文提到的生成函数$G(x)$</p>
<p>同样可以做一些显式的定义，如正整数序列可以定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">integers-starting-from</span> n)</span><br><span class="line">  (<span class="name">cons-stream</span> n (<span class="name">integers-starting-from</span> (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h3>习语</h3>
<p>为了方便使用和构造更多的流，我们需要仿照着针对普通list的几个常用函数，给我们的stream定义一些习语（idiom）。</p>
<p><code>stream-map</code>对流<code>s</code>的每个元素应用一次<code>proc</code>并将结果组成新的流返回
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">stream-map</span> proc s)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">stream-null?</span> s)</span><br><span class="line">      the-empty-stream</span><br><span class="line">      (<span class="name">cons-stream</span> (<span class="name">proc</span> (<span class="name">stream-car</span> s))</span><br><span class="line">                   (<span class="name">stream-map</span> proc (<span class="name">stream-cdr</span> s)))))</span><br></pre></td></tr></table></figure></p>
<p>Scheme的内置习语<code>map</code>是一个更复杂的过程，可以使用多个长度相同的list作为参数，参数<code>proc</code>取每个<code>list</code> <strong>相同位置</strong> 的元素作为<code>proc</code>的所有参数进行计算，计算结果放入返回list的对应位置。对于流操作，这样的过程仿写为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">stream-map</span> proc . argstreams)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">stream-null?</span> (<span class="name"><span class="builtin-name">car</span></span> argstreams))</span><br><span class="line">      the-empty-stream</span><br><span class="line">      (<span class="name">cons-stream</span></span><br><span class="line">       (<span class="name"><span class="builtin-name">apply</span></span> proc (<span class="name"><span class="builtin-name">map</span></span> car argstreams))</span><br><span class="line">       (<span class="name"><span class="builtin-name">apply</span></span> stream-map</span><br><span class="line">              (<span class="name"><span class="builtin-name">cons</span></span> proc (<span class="name"><span class="builtin-name">map</span></span> stream-cdr argstreams))))))</span><br></pre></td></tr></table></figure></p>
<p>应用<code>stream-map</code>可以定义两个流对应位置的元素相加产生新的流的过程<code>add-streams</code>，这个操作也等同于把两个生成函数直接相加。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-streams</span> s1 s2) (<span class="name">stream-map</span> + s1 s2))</span><br></pre></td></tr></table></figure></p>
<p>把<code>stream</code>的每个元素乘以一个常数<code>factor</code>的放缩操作<code>scale-stream</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">scale-stream</span> stream factor)</span><br><span class="line">  (<span class="name">stream-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">*</span></span> x factor)) stream))</span><br></pre></td></tr></table></figure></p>
<p>最后，可能需要用以显示前<code>n</code>个元素的打印过程
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">display-stream</span> s n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">display</span></span> (<span class="name">stream-car</span> s))</span><br><span class="line">  (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</span><br><span class="line">      <span class="symbol">'done</span></span><br><span class="line">      (<span class="name">display-stream</span> (<span class="name">stream-cdr</span> s) (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>))))</span><br></pre></td></tr></table></figure></p>
<h2>用生成函数表示计数问题</h2>
<blockquote>
<p>德川和我修院来到一家高级雪食餐厅，喝完迎宾酒后主菜还没有做完，于是侍者主动提出可以先上$n$块曲奇，但只有巧克力味和原味两种口味，我修院认为原味非常新鲜非常美味，而德川更喜欢巧克力口味，于是开始为了这$n$块曲奇应该如何点而争执起来，请一共有多少种可能的点法？</p>
</blockquote>
<p>这个计数问题很熟悉，如果$n=1$只有两种可能性，$n=2$时有三种可能，$n$块曲奇中巧克力味的数量为$[0,n]$，剩下的都是原味，所以共有$n+1$种取法。</p>
<p>现在可以构造一个生成函数$Cookie(x)$来表示这样的计数问题，$x^n$项前的系数为两种口味从取出$n$块曲奇的取法总数。$$Cookie(x) = 1+2x+3x^2+\cdots + (n+1)x^n+\cdots$$</p>
<blockquote>
<p>塘埔冰室的烧仙草可以加入不同类别不同数量的配料，但不同的配料在数量上有一些限制：珍珠只能加3的整数倍颗，葡萄干只能加奇数粒……</p>
</blockquote>
<p>如果以一个生成函数$f(x)$表示$n$颗珍珠怎么取，实际上只有0和1两种系数，当$n$为3的倍数时$x^n$的系数为1，否则为0$$f(x)=1+x^3+x^6+\cdots+x^{3n}+\cdots$$同理，葡萄干的生成函数为$$g(x)=x+x^3+x^5+\cdots+x^{2n+1}+\cdots$$</p>
<blockquote>
<p>现在有一位蜘蛛侠来到了冰室点了一杯烧仙草，并准备加入数量为$n$的配料，请问他一共有多少种方案？</p>
</blockquote>
<p>这个问题先放一下，虽然我猜很多人看到这已经算出答案了或者知道做法了，但为了更完整的解法，还是需要再引入一些工具。</p>
<h2>Maclaurin级数</h2>
<p>为了把更多关于$x$的函数转换成与生成函数形式相似的，关于$x$的多项式函数，需要借助Taylor级数在$x=0$处的展开，即Maclaurin级数：$$f(x) = f(0) + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}{x^2} +  \cdots  + \frac{f^{(n)}(0)}{n!}{x^n} +  \cdots$$等式右边这样多项式的写法对于求导或积分非常有利，以积分为例，如果有一个形如这样的生成函数或Maclaurin级数$$
f(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n+\cdots$$两边对$x$积分得到$$\int{f(x)dx} = C + {a_0}x + \frac{1}{2}{a_1}{x^2} + \frac{1}{3}{a_2}{x^3} +  \cdots  + \frac{1}{n + 1}{a_n}{x^{n + 1}} +  \cdots$$常数$C$需要根据具体情况确定。现在试着计算出从$x$项开始的系数序列，假设$f(x)$的各项系数按顺序用<code>stream</code>表示，那么<code>integrate-series</code>函数返回这个生成函数的积分除了常数项以外的所有部分
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">mul-streams</span> s1 s2) (<span class="name">stream-map</span> * s1 s2))</span><br><span class="line"><span class="comment">;inner product of sequence s1 and s2</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">integrate-series</span> stream)</span><br><span class="line">  (<span class="name">mul-streams</span> (<span class="name">stream-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (n) (<span class="name"><span class="builtin-name">/</span></span> <span class="number">1</span> n))</span><br><span class="line">                           integers)</span><br><span class="line">               stream))</span><br></pre></td></tr></table></figure></p>
<p>接下来我们可以隐式的定义和计算出更多函数的Maclaurin级数，比如众所周知有$$
\begin{align}
\sin x &amp; = C_1 + \int {\cos x dx} \\
\cos x &amp; = C_2 -\int {\sin x dx}
\end{align}$$当$x=0$时，$C_1=\sin x=0$而$C_2=\cos x=1$，这两个函数的第一项可以确定了，那么剩下的只需要再这样隐式的定义即可
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> sine-series</span><br><span class="line">  (<span class="name">cons-stream</span> <span class="number">0</span></span><br><span class="line">               (<span class="name">integrate-series</span> cosine-series)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> cosine-series</span><br><span class="line">  (<span class="name">cons-stream</span> <span class="number">1</span></span><br><span class="line">               (<span class="name">scale-stream</span></span><br><span class="line">                (<span class="name">integrate-series</span> sine-series)</span><br><span class="line">                <span class="number">-1</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">display-stream</span> sine-series <span class="number">10</span>)</span><br><span class="line"><span class="comment">;0 1 0 -1/6 0 1/120 0 -1/5040 0 1/362880 0</span></span><br><span class="line"></span><br><span class="line">(<span class="name">display-stream</span> cosine-series <span class="number">10</span>)</span><br><span class="line"><span class="comment">;1 0 -1/2 0 1/24 0 -1/720 0 1/40320 0 -1/3628800</span></span><br></pre></td></tr></table></figure></p>
<p>上面是一个很典型的互递归（mutual recursion）定义，<code>sine-series</code>和<code>cons-stream</code>的定义中都带有另一个。虽然函数（过程）的定义中这样互递归的场景很多，但对于非过程的变量这样做需要十分谨慎，因为变量的求值一般是遵循及时求值（eager evaluation）的，好在这里的<code>cons-stream</code>保证了对第二个参数的延迟求值。</p>
<h2>卷积与逆运算</h2>
<blockquote>
<p>铃木，木村和三浦三位同学在空手部社团活动结束后来到一家新开的拉面店为社团$n$位同学预定$n$份拉面，已知每种拉面的选择都遵循相应的生成函数……</p>
</blockquote>
<p>假设a拉面的点对应的生成函数为$$A(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n+\cdots$$也就是说点$n$份时共有$a_n$种取法，同时b拉面生成函数$$B(x)=b_0+b_1x+b_2x^2+\cdots+b_nx^n+\cdots$$相应的，$n$份b拉面有$b_n$种取法。</p>
<p>现在需要从a和b两种拉面中选出$n$份，那么可以是0份a+$n$份b，1份a+$n-1$份b，2份a+$n-2$份b，……，$n-1$份a+1份b，$n$份a+0份b，所以取法共有$$\sum\limits_{i = 0}^n {a_i b_{n - i}}  = {a_0}{b_n} + {a_1}{b_{n - 1}} +  \cdots  + {a_{n - 1}}{b_1} + {a_n}{b_0}$$这个数就是生成函数$f(x) = A(x) \cdot B(x)$的$x^n$项前系数。$f(x)$的各项系数组成的序列也被称为序列$(a_0,a_1,a_2,\cdots)$和$(b_0,b_1,b_2,\cdots)$的卷积（convolution）序列，在信号处理和控制论中可以看到卷积序列的很多应用，这里就不展开详谈了。卷积序列的计算可以直接用上面那个求和公式计算每一项，也可以为了编写程序方便而把它看成</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">$1$</th>
<th style="text-align:center">$x$</th>
<th style="text-align:center">$x^2$</th>
<th style="text-align:center">$x^3$</th>
<th style="text-align:center">$\cdots$</th>
<th style="text-align:center">$x^n$</th>
<th style="text-align:center">$\cdots$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$a_0 B(x)$</td>
<td style="text-align:center">$a_0 b_0$</td>
<td style="text-align:center">$a_0 b_1$</td>
<td style="text-align:center">$a_0 b_2$</td>
<td style="text-align:center">$a_0 b_3$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$a_0 b_n$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$a_1 x B(x)$</td>
<td style="text-align:center"></td>
<td style="text-align:center">$a_1 b_0$</td>
<td style="text-align:center">$a_1 b_1$</td>
<td style="text-align:center">$a_1 b_2$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$a_1 b_{n-1}$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$a_2 x^2 B(x)$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$a_2 b_0$</td>
<td style="text-align:center">$a_2 b_1$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$a_2 b_{n-2}$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$a_3 x^3 B(x)$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$a_3 b_0$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$a_3 b_{n-3}$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$a_n x^n B(x)$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$a_n b_0$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
<tr>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$\cdots$</td>
</tr>
</tbody>
</table>
<p>这样只需要将$A(x)$的每项系数乘以$B(x)$并按顺序错位相加就可以得到$A(x) \cdot B(x)$的结果，借助<code>inter-conv-series</code>把每行第一个元素设置为0并与上一行相加，就可以定义计算<code>s1</code>和<code>s2</code>序列的卷积函数<code>convolute-series</code>了
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inter-conv-series</span> s1 s2) <span class="comment">;helper function, return the result with 0 as first item</span></span><br><span class="line">  (<span class="name">cons-stream</span> <span class="number">0</span></span><br><span class="line">               (<span class="name">add-streams</span></span><br><span class="line">                (<span class="name">scale-stream</span> s2 (<span class="name">stream-car</span> s1))</span><br><span class="line">                (<span class="name">inter-conv-series</span> (<span class="name">stream-cdr</span> s1) s2))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">convolute-series</span> s1 s2)</span><br><span class="line">  (<span class="name">stream-cdr</span> (<span class="name">inter-conv-series</span> s1 s2)))</span><br></pre></td></tr></table></figure></p>
<p>计算<code>(convolute-series ones ones)</code>可以发现结果等于<code>integers</code>，这也是符合上面对于计数问题的解释的：从没有数量限制的$A$和$B$中一共取$n$个，取法共有$n+1$种。当然，反过来说，也可以用类似于前文对几何级数所做的错位相减计算出<code>integers</code>所代表的生成函数$$f(x) = \sum\limits_{n = 0}^\infty{(n + 1)x^n}  = \frac{1}{(1 - x)^2}$$这也正好是两个<code>ones</code>所代表的生成函数的乘积。</p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-check-circle&quot;&gt;&lt;/i&gt; 卷积规则（Convolution Rule）</h4>
<p>令$A(x)$表示从集合$\cal A$中选取项的生成函数，$B(x)$表示从与$\cal A$ <strong>不相交</strong> 的集合$\cal B$中选取项的生成函数，那么从$\cal A \cup \cal B$中选取项的生成函数为$A(x) \cdot B(x)$</p>
</div></p>
<p>根据结合律，这个规则也可以推广到多个<strong>两两不相交</strong>的集合。</p>
<p>&lt;a name=&quot;mur&quot;&gt;&lt;/a&gt;
假设拉面一共有$k$种口味可选，需要从中点$n$份，一共有多少种选法？这个问题用普通的计数问题视角可以转化成另一个与之双射的问题：长度为$n$的序列中需要插入$k-1$个间隔，第$i$个间隔和第$i+1$个间隔间的全部元素都是第$i$种口味的拉面，也就是说需要在$n+(k-1)$长度的序列中选择$(k-1)$个元素作为间隔，剩下的元素自然的可以标记为确定口味的拉面，那么显然总共可以有$$n+(k-1) \choose k-1$$种选取的方法。</p>
<p>接下来再试着用生成函数的思路看待这个问题：每种口味的拉面对应的生成函数都可以用<code>ones</code>序列表示，即$1/(1+x)$，那么从$k$种拉面中选取项的生成函数等于它们的乘积即$$f(x)=\frac{1}{(1-x)^k}$$为了找到$x^n$项前系数，需要用<a href="#Maclaurin%E7%BA%A7%E6%95%B0">Maclaurin级数</a>展开，那么首先要计算出$f(x)$的$n$阶导函数，$(1-x)^{-k}$性质很好，可以重复多次求导，一阶导数为$k(1-x)^{-k-1}$，二阶导数为$k(k+1)(1-x)^{-k-2}$，……，$n$阶导数为$$k(k+1)(k+2)\cdots (k+n-1)(1-x)^{-k-n}$$也就是$$f^{(n)}(x)=\frac{(n+k-1)!}{(k-1)!}\cdot \frac{1}{(1-x)^{k+n}}$$根据Maclaurin级数展开式，$x^n$项的系数为$f^{(n)}(0)/n!$，那么取$x=0$计算$f^{(n)}(x)/n!$得到$$\frac{(n+k-1)!}{(k-1)!n!}$$就是我们刚才用普通的计数法算得的结果。</p>
<h3>烧仙草问题</h3>
<p>把之前的问题完整的延伸开来</p>
<blockquote>
<p>蜘蛛侠来到塘埔冰室购买一杯烧仙草，冰室主人梁启超允许他加入数量为$n$的配料，已知配料的选择必须遵循以下原则：</p>
</blockquote>
<ul>
<li>珍珠的数量为3的倍数</li>
<li>葡萄干的数量必须为奇数</li>
<li>最多能放2粒花生米</li>
<li>最多能拿一个和别人不一样的勺子（勺子包含在配料内）</li>
</ul>
<blockquote>
<p>那么蜘蛛侠可以选择多少种不同的搭配方案？</p>
</blockquote>
<p>珍珠的生成函数为$$A(x)=1+x^3+x^6+\cdots+x^{3n}+\cdots=\frac{1}{1-x^3}$$葡萄干的生成函数为$$B(x)=x+x^3+x^5+\cdots+x^{2n+1}+\cdots=\frac{x}{1-x^2}$$花生米的生成函数$$C(x)=1+x+x^2=\frac{1-x^3}{1-x}$$和别人不一样的勺子的生成函数$$D(x)=1+x$$那么计算它们组合出的计数就可以按照卷积规则直接相乘得$$
\begin{align}
A(x)B(x)C(x)D(x) &amp; =\frac{1}{1-x^3}\cdot \frac{x}{1-x^2} \cdot \frac{1-x^3}{1-x} \cdot (1+x) \\
&amp; = \frac{x}{(1-x)^2} \\
&amp; = x(1+2x+3x^2+\cdots+(n+1)x^n+\cdots) \\
&amp; = x+2x^2+3x^3+\cdots+nx^n+\cdots
\end{align}$$ $x^n$前的系数为$n$，也就是说蜘蛛侠一共有$n$种方案去搭配出数量为$n$的配料。</p>
<h3>逆运算</h3>
<p>在上面烧仙草的例子中可以看到最后得到生成函数的代数形式有时是可以互相约分消去的，比如<code>ones</code>写为$1/(1-x)$意味着它在形式上与$1-x$互为倒数。上面用<code>add-streams</code>定义的加法$\oplus$和用<code>convolute-series</code>定义的乘法$\otimes$满足交换环（commutative ring）的性质，令$S$表示生成函数$f(x)$对应的序列，如果有一个生成$g(x)$使得$f(x)\cdot g(x)=1$，那么$g(x)$对应的生成序列$R$满足$$S\otimes R=(1,0,0,0,\cdots)=I$$其中$I$为初始项为1其他项为0的单位元，那么可以说$R$是$S$的乘法逆元。当且仅当$S$的初始项不为0时，$S$存在相应的乘法逆元$S^{-1}$，直接计算$S^{-1}$可能会有些困难，但可以通过关系隐式定义，假设$S$的初始项为$S_0$，初始项后面的部分为$S_R$(除了初始项为0，其他部分与$S$一致)，那么有$$\begin{align}
S \otimes S^{-1} &amp; = I \\
(S_0 \oplus S_R) \otimes S^{-1} &amp; =I \\
S_0 \cdot S^{-1} &amp;=I \oplus (-1) \cdot S_R \otimes S^{-1} \\
S^{-1} &amp; =I/{S_0}\oplus (-1/{S_0}) \cdot S_R \otimes S^{-1}
\end{align}$$根据上面的表达式可以直接隐式的递归定义逆运算为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inv-series</span> s)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">s0</span> (<span class="name">stream-car</span> s)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> s0 <span class="number">0</span>)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"divided by zero"</span>)</span><br><span class="line">        (<span class="name">cons-stream</span> (<span class="name"><span class="builtin-name">/</span></span> <span class="number">1</span> s0)</span><br><span class="line">                     (<span class="name">scale-stream</span></span><br><span class="line">                        (<span class="name">convolute-series</span> (<span class="name">stream-cdr</span> s) (<span class="name">inv-series</span> s))</span><br><span class="line">                        (<span class="name"><span class="builtin-name">/</span></span> <span class="number">-1</span> s0))))))</span><br></pre></td></tr></table></figure></p>
<p>可以看到调用<code>(inv-series ones)</code>得到的结果是流<code>(1 -1 0 0 0 0 ...)</code>也就是$1-x$，符合上面的结果。</p>
<p>有了上面的工具，可以定义序列之间的除法操作，$S_1/{S_2}$即$S_1 \otimes  {S_2}^{-1}$，$\sin x$和$\cos x$的商$\tan x$可以直接这样计算，把两个函数对应的Maclaurin级数序列相除就得到了$\tan x$的Maclaurin级数序列：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">div-series</span> s1 s2)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">stream-car</span> s2) <span class="number">0</span>)</span><br><span class="line">      (<span class="name">error</span> <span class="string">"divided by zero"</span>)</span><br><span class="line">      (<span class="name">convolute-series</span> s1 (<span class="name">inv-series</span> s2))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> tangent-series</span><br><span class="line">  (<span class="name">div-series</span> sine-series cosine-series))</span><br><span class="line"></span><br><span class="line">(<span class="name">display-stream</span> tangent-series <span class="number">10</span>)</span><br><span class="line"><span class="comment">;0 1 0 1/3 0 2/15 0 17/315 0 62/2835 0</span></span><br></pre></td></tr></table></figure></p>
<h2>部分分式*</h2>
<p>多个生成函数相乘得到的结果，有时并不像<a href="#%E7%83%A7%E4%BB%99%E8%8D%89%E9%97%AE%E9%A2%98">烧仙草问题</a>那样在形式上工整熟悉容易展开，也可能同时不像<a href="#mur">拉面问题/曲奇问题</a>那样性质良好适合重复求高阶导数算Maclaurin级数。最后需要面对的可能是一些更一般的形式，虽说借助上面定制的编程工具<code>convolute-series</code>直接硬算卷积也没什么可麻烦的，不过技不压身，完全可以多学习一些算术技巧去解决它们。</p>
<p>令$p(x)$为最高次数小于$n$的多项式，$\alpha_1,\cdots,\alpha_n$是$n$个<strong>不同</strong>的<strong>非零</strong>常数，那么必然存在常数$c_1,\cdots，c_n$使得$$\frac{p(x)}{(1 - \alpha _1x)(1 - {\alpha _2}x) \cdots (1 - {\alpha _n}x)} = \frac{c_1}{(1 - \alpha _1 x)} + \frac{c_2}{(1 - \alpha _2 x)}  +  \cdots  + \frac{c_n}{(1 - \alpha _n x)} $$
部分分式方法（partial fraction method）利用这个等式关系把多项式的商转化成和的形式。举个例子，假设我们得到的某个结果为$$R(x)=\frac{x}{1-x-x^2}$$现在要把它转化为普通的生成函数那样幂级数的形式，首先把分母因式分解，利用一元二次方程求根公式得到$1-x-x^2=0$的两个根为$$r_1 = \frac{ - 1 - \sqrt 5 }{2}, \quad r_2 = \frac{ - 1 + \sqrt 5 }{2}$$分母写成$$1-x-x^2=-(x - {r_1})(x - {r_2}) = -{r_1}{r_2}(1 - x/{r_1})(1 - x/{r_2})$$其中$r_1r_2=-1$那么$$R(x)=\frac{x}{(1 - \alpha _1x)(1 - {\alpha _2}x)}$$其中$$\begin{align}
\alpha_1&amp;=1/{r_2}=\frac{1 + \sqrt 5}{2} \\
\alpha_2&amp;=1/{r_1}=\frac{1 - \sqrt 5}{2}
\end{align}$$需要找到$c_1$和$c_2$满足$$\frac{x}{(1 - \alpha _1x)(1 - {\alpha _2}x)} = \frac{c_1}{(1 - \alpha _1 x)} + \frac{c_2}{(1 - \alpha _2 x)} $$两边同乘左边的分母$$x= c_1 (1 - {\alpha _2}x) +c_2 (1 - {\alpha _1}x) $$可以把$x$的系数整理出来联立方程组求解，也可以直接令$x=1/{\alpha_2}$代入得到$$c_2=\frac{1/{\alpha_2}}{1-{\alpha_1}/{\alpha_2}}=\frac{1}{\alpha_2-\alpha_1}=-\frac{1}{\sqrt 5}$$同理，令$x=1/{\alpha_1}$得到$$c_1=\frac{1}{\sqrt 5}$$分母上的因式可以写为$$
\begin{align}
\frac{1}{(1 - \alpha _1 x)} &amp; =1+\alpha _1 x+{\alpha _1}^2 x^2 +\cdots+{\alpha _1}^n x^n+ \cdots \\
\frac{1}{(1 - \alpha _2 x)} &amp; =1+\alpha _2 x+{\alpha _2}^2 x^2 +\cdots+{\alpha _2}^n x^n+ \cdots
\end{align}$$
因此最后的结果是$$
\begin{align}
\frac{c_1}{(1 - \alpha _1 x)} + \frac{c_2}{(1 - \alpha _2 x)} &amp; =\frac{1}{\sqrt 5}(\frac{1}{(1 - \alpha _1 x)}-\frac{1}{(1 - \alpha _2 x)}) \\
&amp;=\frac{1}{\sqrt 5}((c_1-c_2)+(c_1 \alpha_1-c_2 \alpha_2)x + \cdots+ (c_1 {\alpha_1}^n-c_2 {\alpha_2}^n)x^n+\cdots)
\end{align}$$最后，$R(x)$的$x^n$项前系数为$$\frac{c_1 {\alpha_1}^n-c_2 {\alpha_2}^n}{\sqrt 5}=\frac{1}{\sqrt 5}((\frac{1 + \sqrt 5}{2})^n-(\frac{1 - \sqrt 5}{2})^n)$$</p>
<h3>重复根</h3>
<p>上面是一种比较一般的形式，有时会遇到更特化的形式：分母在因式分解后存在重复的分式。也就是分母存在重复根，那么展开为分式的和的形式时可以存在这样的项：$$\frac{c}{(1 - \alpha x)^k}$$其中$\alpha$为$k$个重复根$r$的倒数，计算这个式子的展开形式并不困难，在<a href="#mur">拉面问题</a>中已经看到了$1/(1-x)^k$展开后$x^n$项前系数为$${n+k-1} \choose {k-1}$$再用$\alpha x$代替$x$并在整个式子前面乘以系数$c$，就可以得到整个分式展开后$x^n$前系数为$$c{\alpha}^n {n+k-1 \choose k-1}$$再加上其他分式展开后的系数就是最终的计算结果了。</p>
<h2>线性递推*</h2>
<p>在解线性递推（linear recurrence）问题时，我们常常会找连续几项的关系，并用对应的$x^n$代表它们，然后形成一个特征方程求解。这样的方法从生成函数的角度也是可以找到依据的。以求解Fibonacci序列的通项为例，令$F(x)$表示它的生成函数，即$f_n$为第$n$项的值：$$F\left( x \right) = {f_0} + {f_1}x + {f_2}{x^2} +  \cdots+{f_n}{x^n}+\cdots $$ 用$x$乘$F(x)$可以使所有系数“后移”一位，用$x^2$乘$F(x)$可以使之“后移”两位，Fibonacci数有$f_n=f_{n-1}+f_{n-2}$的关系，因此有&lt;a name=&quot;fib&quot;&gt;&lt;/a&gt;$$
\begin{alignat}{3}
F\left( x \right) &amp;= {f_0} +  &amp; {f_1} x + &amp; {f_2} {x^2} +  \cdots+{f_n}{x^n}+\cdots\\
xF\left( x \right) &amp;=  &amp;{f_0} x + &amp;{f_1} {x^2} +  \cdots+f_{n-1} {x^n}+\cdots\\
x^2 F\left( x \right) &amp;= &amp; &amp; {f_0}{x^2} +  \cdots+f_{n-2} {x^n}+\cdots \\
(1-x-x^2)F\left( x \right) &amp;= f_0+ &amp; (f_1-f_0)x &amp;
\end{alignat}$$假设Fibonacci序列的初始项$f_0=0,f_1=1$那么有$$F(x)=\frac{x}{1-x-x^2}$$接下来的具体求解过程已经在演示<a href="#%E9%83%A8%E5%88%86%E5%88%86%E5%BC%8F">部分分式</a>方法时写过一遍了，这里不再赘述。解出Fibonacci的通项公式为$$f_n=\frac{1}{\sqrt 5}((\frac{1 + \sqrt 5}{2})^n-(\frac{1 - \sqrt 5}{2})^n)$$与Binet公式一致。</p>
<blockquote>
<p>顺带一提，根据<a href="#fib">上面的公式</a>演示的递推关系，即第二行与第三行的和从第二项开始与Fibonacci序列一致，可以隐式的定义出一个表示Fibonacci数的<code>stream</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> fibs</span><br><span class="line">  (<span class="name">cons-stream</span> <span class="number">0</span></span><br><span class="line">               (<span class="name">cons-stream</span> <span class="number">1</span></span><br><span class="line">                            (<span class="name">add-streams</span> (<span class="name">stream-cdr</span> fibs)</span><br><span class="line">                                         fibs))))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>本来根据$f_n=f_{n-1}+f_{n-2}$的关系对应的特征方程应该是$x^2-x-1=0$，但$F(x)$的分母上却是$1-x-x^2$，两处的$x$呈现互为倒数的关系，在部分分式方法中求分母上$x$前系数也是有$\alpha=1/r$的关系。</p>
<p>一个更一般的线性递推式关系表现为$$f(n)=c_1f(n-1)+c_2f(n-2)+\cdots+c_df(n-d)+h(n)$$其中$d$表示递推的次数，$c_i$为常数，$h(n)$表示非齐次项。</p>
<p>从生成函数的角度来看，要使得这些$f(n),f(n-1),\cdots,f(n-d)$像刚才那样“对齐”到同一个位置，需要在生成函数前乘$x^i$并乘以系数$c_i$使之符合递推关系，假设它的生成函数为$G(x)$,那么$$(1-c_1x-c_2x^2-\cdots-c_dx^d)G(x)$$可以消去生成函数中与在$x^d$和之后的项的系数中与$f$相关的内容，高次部分只剩下$h(n)x^n$，那么当$h(n)$的生成函数也可以被表示为多项式的商的形式时，这个线性递推问题可以用类似前面的部分分式法把它分解为多个生成函数的线性组合。</p>
<p>当然，解线性递推问题已经有了像特征方程那样成熟的工具，直接使用就可以了。从生成函数视角开始一步步求解只是为了方便理解为什么可以那样做。</p>
<h2>小结</h2>
<p>通过生成函数，我们在离散的序列问题与连续的代数问题之间建立了联系。$x^n$乃至$x$本身在函数中都只起了占位作用，在不理解由序列构造的生成函数本身的物理意义的前提下，在构造出的幂级数往往并不收敛的情况下，用代数的方法求解忽略限制求解计数问题。<code>stream</code>数据结构是生成函数和它们对应的无限长度的序列的良好容器，可以应用于表达幂级数，通过编写相关计算函数工具，也给形式并不特殊的生成函数问题提供了求解的可能性。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;假设 $x \ne 1$，$x$取值并不重要所以这里和以后涉及这个断点时也不再强调这个不等式约束。&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/stream-count-and-generating-function/" data-id="cjuh9jxbh005vfww3mw45ygm9" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组合数学/">组合数学</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-104" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-104/">LeetCode Weekly Contest 104</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-104/" class="article-date"><time datetime="2018-09-30T10:43:17.409Z" itemprop="datePublished">2018-09-30</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-104</p>
<p>&lt;!-- more --&gt;</p>
<h2>X of a Kind in a Deck of Cards</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-104/problems/x-of-a-kind-in-a-deck-of-cards/</p>
<blockquote>
<p>In a deck of cards, each card has an integer written on it.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if you can choose <code>X &gt;= 2</code> such that it is possible to split the entire deck into 1 or more groups of cards, where:</p>
</blockquote>
<ul>
<li>Each group has exactly <code>X</code> cards.</li>
<li>All the cards in each group have the same integer.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,4,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,2,2,2,3,3]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: No possible partition.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: No possible partition.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2,2,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1],[2,2],[2,2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= deck.length &lt;= 10000</code></li>
<li><code>0 &lt;= deck[i] &lt; 10000</code></li>
</ol>
<p><code>X</code>是所有元素出现次数的最小公倍数，只要最小公倍数<code>&gt;=2</code>就可以了
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasGroupsSizeX</span><span class="params">(self, deck)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type deck: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c = collections.Counter(deck)</span><br><span class="line">        <span class="keyword">return</span> reduce(fractions.gcd, c.values()) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2>Partition Array into Disjoint Intervals</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-104/problems/partition-array-into-disjoint-intervals/</p>
<blockquote>
<p>Given an array <code>A</code>, partition it into two (contiguous) subarrays <code>left</code> and <code>right</code> so that:</p>
</blockquote>
<ul>
<li>Every element in <code>left</code> is less than or equal to every element in <code>right</code>.</li>
<li><code>left</code> and <code>right</code> are non-empty.</li>
<li><code>left</code> has the smallest possible size.</li>
</ul>
<blockquote>
<p>Return the <strong>length</strong> of <code>left</code> after such a partitioning.  It is guaranteed that such a partitioning exists.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,0,3,8,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: left = [5,0,3], right = [8,6]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,6,12]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: left = [1,1,1,0], right = [6,12]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= A.length &lt;= 30000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
<li>It is guaranteed there is at least one way to partition <code>A</code> as described.</li>
</ol>
<p>要求长度为<code>n</code>的<code>left</code>包含的所有元素正好是<code>A</code>中最小的<code>n</code>个元素。暂时先不管每个元素具体值是多少，先转化为它们在<code>A</code>中所有元素值大小的升序排序序号，那么要找的<code>left</code>就是就是一个最小的<code>n</code>长度的<code>0</code>至<code>n-1</code>的permutation：从最左的元素开始找，如果当前<code>n</code>长度的子数组内有大于<code>n-1</code>的元素<code>m</code>，则跳的位置<code>m</code>，在<code>m</code>长度的子数组中重复上述操作，直到<code>left</code>的最大元素恰好等于它的长度：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionDisjoint</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rank = sorted(range(len(A)), key=<span class="keyword">lambda</span> i: (A[i], i))</span><br><span class="line">        max_rank, end = rank[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> max_rank &gt; end:</span><br><span class="line">            end = max_rank</span><br><span class="line">            max_rank = max(rank[:end + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> end + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2>Word Subsets</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-104/problems/word-subsets/</p>
<blockquote>
<p>We are given two arrays <code>A</code> and <code>B</code> of words.  Each word is a string of lowercase letters.</p>
</blockquote>
<blockquote>
<p>Now, say that word <code>b</code> is a subset of word <code>a</code> if every letter in <code>b</code> occurs in <code>a</code>, <strong>including multiplicity</strong>.  For example, <code>&quot;wrr&quot;</code> is a subset of <code>&quot;warrior&quot;</code>, but is not a subset of <code>&quot;world&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Now say a word <code>a</code> from <code>A</code> is <em>universal</em> if for every <code>b</code> in <code>B</code>, <code>b</code> is a subset of a.</p>
</blockquote>
<blockquote>
<p>Return a list of all universal words in <code>A</code>.  You can return the words in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;l&quot;,&quot;e&quot;]</span><br><span class="line">Output: [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;oo&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;google&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;lo&quot;,&quot;eo&quot;]</span><br><span class="line">Output: [&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;ec&quot;,&quot;oc&quot;,&quot;ceo&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length, B.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i].length, B[i].length &lt;= 10</code></li>
<li><code>A[i]</code> and <code>B[i]</code> consist only of lowercase letters.</li>
<li>All words in <code>A[i]</code> are unique: there isn't <code>i != j</code> with <code>A[i] == A[j]</code>.</li>
</ol>
<p>先计算满足<code>B</code>中所有<code>b</code>都是子集则需要<code>a</code>至少出现哪些字母，出现多少次，直接用<code>Counter()</code>的合并运算求<code>b</code>出现字符的最大值。</p>
<p>接下来对每个<code>a</code>观察需要出现的字符出现次数是否满足最小要求，如果满足添加到返回结果中</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordSubsets</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :type B: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = Counter()</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> B:</span><br><span class="line">            d |= Counter(b)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">            f = <span class="keyword">True</span></span><br><span class="line">            letters = Counter(a)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> letters <span class="keyword">or</span> letters[c] &lt; d[c]:</span><br><span class="line">                    f = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> f:</span><br><span class="line">                res.append(a)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Cat and Mouse</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-104/problems/cat-and-mouse/</p>
<blockquote>
<p>A game on an <strong>undirected</strong> graph is played by two players, Mouse and Cat, who alternate turns.</p>
</blockquote>
<blockquote>
<p>The graph is given as follows: <code>graph[a]</code> is a list of all nodes <code>b</code> such that <code>ab</code> is an edge of the graph.</p>
</blockquote>
<blockquote>
<p>Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.</p>
</blockquote>
<blockquote>
<p>During each player's turn, they <strong>must</strong> travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node <code>1</code>, it <strong>must</strong> travel to any node in <code>graph[1]</code>.</p>
</blockquote>
<blockquote>
<p>Additionally, it is not allowed for the Cat to travel to the Hole (node 0.)</p>
</blockquote>
<blockquote>
<p>Then, the game can end in 3 ways:</p>
</blockquote>
<ul>
<li>If ever the Cat occupies the same node as the Mouse, the Cat wins.</li>
<li>If ever the Mouse reaches the Hole, the Mouse wins.</li>
<li>If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.</li>
</ul>
<blockquote>
<p>Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">4---3---1</span><br><span class="line">|   |</span><br><span class="line">2---5</span><br><span class="line"> \ /</span><br><span class="line">  0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= graph.length &lt;= 50</code></li>
<li>It is guaranteed that <code>graph[1]</code> is non-empty.</li>
<li>It is guaranteed that <code>graph[2]</code> contains a non-zero element.</li>
</ol>
<p>一时想不到什么好的算法直接根据<code>graph</code>预测结局，只能用比较直接的方法去模拟这个游戏过程。</p>
<p>既然提到了both players play optimally，那么就需要动态规划，在每个回合都需要DFS去考虑如果我这么操作了，对方会接下来会怎么操作。我们用<code>dp[mouse_cur][cat_cur][player]</code>来表示老鼠在<code>mouse_cur</code>位置，猫在<code>cat_cur</code>位置时，且当前轮到<code>player</code>（0表示老鼠，1表示猫）移动的回合时，最好的游戏结果是什么。</p>
<p>首先我们知道</p>
<ul>
<li>当<code>mouse_cur=0</code>时的游戏结果一定为<code>1</code></li>
<li>当<code>mouse_cur=cat_cur</code>时游戏结果一定为<code>2</code></li>
</ul>
<p>因为不允许猫移动到位置0，所以可以规定当猫到位置0时返回的结果是对猫最不利的<code>1</code>，如此一来，在当猫面临选择时，为了最优的结果一定为避开移动到这个位置。</p>
<p><code>mouse_move(mouse_cur,cat_cur)</code>用于计算<code>dp[mouse_cur][cat_cur][0]</code>：这时是老鼠的回合，如果下一步可以直接到达位置0就可以直接获胜，返回<code>1</code>。否则先将<code>dp[mouse_cur][cat_cur][0]</code>设置为<code>0</code>，然后DFS，选择任意一个结点<code>nei</code>并用<code>cat_move(nei,cat_cur)</code>计算下一回合猫使自己的结局最优时的游戏结果，然后选择出这些游戏结果中最利于自己的，如果有<code>1</code>直接就用<code>1</code>，没有<code>1</code>时尽量找到存在的平局<code>0</code>作为最佳选择，最差的结果就是只存在<code>2</code>了。</p>
<p>开始遍历前先把当前结果临时的设置为<code>0</code>是为了防止在搜索时回溯到当前位置，在寻求当前结果时如果又回到了这个位置，那确实是没有未被访问的邻结点了，这时玩家们还没分出胜负，也满足draw的条件，应该返回<code>0</code></p>
<p><code>cat_move(mouse_cur,cat_cur)</code>用于计算<code>dp[mouse_cur][cat_cur][1]</code>，与<code>mouse_move</code>相似，只是用于寻找怎么走是对猫最有利的结果，尽量找到<code>2</code>，退则求<code>0</code>，实在走投无路时只能返回<code>1</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">catMouseGame</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        dp = [[[<span class="number">-1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mouse_move</span><span class="params">(mouse_cur, cat_cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> mouse_cur == cat_cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mouse_cur == <span class="number">0</span> <span class="keyword">or</span> cat_cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[mouse_cur][cat_cur][<span class="number">0</span>] != <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[mouse_cur][cat_cur][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            dp[mouse_cur][cat_cur][<span class="number">0</span>] = <span class="number">0</span> <span class="comment">#going back to current node will draw</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> graph[mouse_cur]: <span class="comment"># one step to node 0</span></span><br><span class="line">                dp[mouse_cur][cat_cur][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            can_draw = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[mouse_cur]:</span><br><span class="line">                next_turn = cat_move(nei, cat_cur)</span><br><span class="line">                <span class="keyword">if</span> next_turn == <span class="number">1</span>:</span><br><span class="line">                    dp[mouse_cur][cat_cur][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> next_turn == <span class="number">0</span>:</span><br><span class="line">                    can_draw = <span class="keyword">True</span></span><br><span class="line">            dp[mouse_cur][cat_cur][<span class="number">0</span>] = <span class="number">0</span> <span class="keyword">if</span> can_draw <span class="keyword">else</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> dp[mouse_cur][cat_cur][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cat_move</span><span class="params">(mouse_cur, cat_cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> mouse_cur == cat_cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mouse_cur == <span class="number">0</span> <span class="keyword">or</span> cat_cur == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[mouse_cur][cat_cur][<span class="number">1</span>] != <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[mouse_cur][cat_cur][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            dp[mouse_cur][cat_cur][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mouse_cur <span class="keyword">in</span> graph[cat_cur]: <span class="comment"># one step to catch the morse</span></span><br><span class="line">                dp[mouse_cur][cat_cur][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            can_draw = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[cat_cur]:</span><br><span class="line">                next_turn = mouse_move(mouse_cur, nei)</span><br><span class="line">                <span class="keyword">if</span> next_turn == <span class="number">2</span>:</span><br><span class="line">                    dp[mouse_cur][cat_cur][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">                <span class="keyword">elif</span> next_turn == <span class="number">0</span>:</span><br><span class="line">                    can_draw = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">            dp[mouse_cur][cat_cur][<span class="number">1</span>] = <span class="number">0</span> <span class="keyword">if</span> can_draw <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> dp[mouse_cur][cat_cur][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mouse_move(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>回合制游戏让两玩家交替执行，所以<code>mouse_move</code>和<code>cat_move</code>也始终在互相调用，算是不多见的mutual recursion的实例之一了，分别找着想象着怎么走能使得对方的最优结果最差，有点像minimax算法。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-104/" data-id="cjuh9jws2000gfww3kxxami3s" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-103" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-103/">LeetCode Weekly Contest 103</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-103/" class="article-date"><time datetime="2018-09-23T11:08:44.525Z" itemprop="datePublished">2018-09-23</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-103</p>
<p>&lt;!-- more --&gt;</p>
<h2>Smallest Range I</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-103/problems/smallest-range-i/</p>
<blockquote>
<p>Given an array <code>A</code> of integers, for each integer <code>A[i]</code> we may choose any x with <code>-K &lt;= x &lt;= K</code>, and add <code>x</code> to <code>A[i]</code>.</p>
</blockquote>
<blockquote>
<p>After this process, we have some array <code>B</code>.</p>
</blockquote>
<blockquote>
<p>Return the smallest possible difference between the maximum value of B and the minimum value of <code>B</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1], K = 0</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,10], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: B = [2,8]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,6], K = 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [3,3,3] or B = [4,4,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
</ol>
<p>通过给最小值加上小于等于<code>K</code>的数，和最大值减去小于等于<code>K</code>的数，尽可能减小<code>A</code>的最大值和最小值之间的差距
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestRangeI</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> max(max(A) - min(A) - <span class="number">2</span> * K, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h2>Snakes and Ladders</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-103/problems/snakes-and-ladders/</p>
<blockquote>
<p>On an N x N <code>board</code>, the numbers from <code>1</code> to <code>N*N</code>are written <em>boustrophedonically</em> <strong>starting from the bottom left of the board</strong>, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:</p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">36 35 34 33 32 31</span><br><span class="line">25 26 27 28 29 30</span><br><span class="line">24 23 22 21 20 19</span><br><span class="line">13 14 15 16 17 18</span><br><span class="line">12 11 10 09 08 07</span><br><span class="line">01 02 03 04 05 06</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt=""></p>
</blockquote>
<blockquote>
<p>You start on square <code>1</code> of the board (which is always in the last row and first column).  Each move, starting from square <code>x</code>, consists of the following:</p>
</blockquote>
<blockquote>
<p>You choose a destination square <code>S</code> with number <code>x+1</code>, <code>x+2</code>, <code>x+3</code>, <code>x+4</code>, <code>x+5</code>, or <code>x+6</code>, provided this number is <code>&lt;= N*N</code>.</p>
</blockquote>
<ul>
<li>If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to <code>S</code>.</li>
<li>A board square on row r and column c has a &quot;snake or ladder&quot; if <code>board[r][c] != -1</code>.  The destination of that snake or ladder is <code>board[r][c]</code>.</li>
</ul>
<blockquote>
<p>Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> continue moving.</p>
</blockquote>
<blockquote>
<p>Return the least number of moves required to reach square N*N.  If it is not possible, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,35,-1,-1,13,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,15,-1,-1,-1,-1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">At the beginning, you start at square 1 [at row 5, column 0].</span><br><span class="line">You decide to move to square 2, and must take the ladder to square 15.</span><br><span class="line">You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.</span><br><span class="line">You then decide to move to square 14, and must take the ladder to square 35.</span><br><span class="line">You then decide to move to square 36, ending the game.</span><br><span class="line">It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= board.length = board[0].length &lt;= 20</code></li>
<li><code>board[i][j]</code> is between <code>1</code> and <code>N*N</code> or is equal to <code>-1</code>.</li>
<li>The board square with number <code>1</code> has no snake or ladder.</li>
<li>The board square with number <code>N*N</code> has no snake or ladder.</li>
</ol>
<p>题目说的比较麻烦，简单来说这个snake or ladder可以看成某种重定向，snake表示可以从这里直接跳跃到这一行的另一列，ladder表示可以从这里直接跳跃到另一行的某个位置。位置的序号<code>square</code>遵循boustrophedonically从左下开始每行填充完成至上一行。</p>
<p>每到一个位置可以任意选择前进6步以内的其他位置，如果其他位置上有snake or ladder可以直接跳到目标位置，最后走到<code>N*N</code>结束。无视这个风骚的boustrophedonical位序规则，有点像飞行棋。</p>
<p>possible的情况很好做，impossible的情况可能一时不容易想到，没有任何一个snake or ladder可以直接到达终点，终点六步内都是指向更前方的snake or ladder。</p>
<p>解这种问题常用的BFS这里也当然可以用，impossible的情况以及重复访问问题可以通过增加hash表<code>seen</code>记录，因为<code>move</code>的计数是每访问一次增加1，所以BFS就足够找到最短路径了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(board)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">            r, c = (x - <span class="number">1</span>) / n, (x - <span class="number">1</span>) % n</span><br><span class="line">            <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> board[n - <span class="number">1</span> - r][c]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> board[n - <span class="number">1</span> - r][n - <span class="number">1</span> - c]</span><br><span class="line"></span><br><span class="line">        q = [(<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">        seen = &#123;(<span class="number">1</span>, <span class="number">0</span>)&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> s, move <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(s + <span class="number">1</span>, min(n * n, s + <span class="number">6</span>) + <span class="number">1</span>):</span><br><span class="line">                l = square(i)</span><br><span class="line">                next_s = l <span class="keyword">if</span> l &gt; <span class="number">0</span> <span class="keyword">else</span> i</span><br><span class="line">                <span class="keyword">if</span> next_s <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    <span class="keyword">if</span> next_s == n * n:</span><br><span class="line">                        <span class="keyword">return</span> move + <span class="number">1</span></span><br><span class="line">                    seen.add(next_s)</span><br><span class="line">                    q.append((next_s, move + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2>Smallest Range II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-103/problems/smallest-range-ii/</p>
<blockquote>
<p>Given an array <code>A</code> of integers, for each integer A[i] we need to choose <strong>either <code>x = -K</code>or <code>x = K</code></strong>, and add <code>x</code> to <code>A[i]</code> (only once).</p>
</blockquote>
<blockquote>
<p>After this process, we have some array <code>B</code>.</p>
</blockquote>
<blockquote>
<p>Return the smallest possible difference between the maximum value of B and the minimum value of <code>B</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1], K = 0</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,10], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: B = [2,8]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,6], K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: B = [4,6,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
</ol>
<p>相比<a href="#Smallest-Range-I">上一题</a>，这里要求<code>A</code>的元素只能加上<code>-K</code>或者<code>K</code>，不能用中间的值来调整差距。不过这题的测试数据规模确实不大，我直接暴力穷举没用什么算法就过去了。</p>
<p>先将<code>A</code>按照升序排序，直觉的找到某个中间坐标<code>i</code>，令<code>i</code>及其左边的元素都加上<code>K</code>，右边的元素都减去<code>K</code>，最大值只能是<code>A[-1]-K</code>或者<code>A[i]+K</code>，最小值只能是<code>A[i+1]-K</code>或者<code>A[0]+K</code>。除此之外，还需要计算一种情况即所有元素同时加上<code>K</code>或者减去<code>K</code>，那么差值还是<code>A[-1]-A[0]</code>。排序需要$o(n\log n)$的开销，之后的穷举遍历需要$o(n)$，也没那么不可接受。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestRangeII</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        A.sort()</span><br><span class="line">        res = A[<span class="number">-1</span>] - A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) - <span class="number">1</span>):</span><br><span class="line">            res = min(res, max(A[<span class="number">-1</span>] - K, A[i] + K) -</span><br><span class="line">                      min(A[i + <span class="number">1</span>] - K, A[<span class="number">0</span>] + K))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Online Election</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-103/problems/online-election/</p>
<blockquote>
<p>In an election, the <code>i</code>-th vote was cast for <code>persons[i]</code> at time <code>times[i]</code>.</p>
</blockquote>
<blockquote>
<p>Now, we would like to implement the following query function: <code>TopVotedCandidate.q(int t)</code> will return the number of the person that was leading the election at time <code>t</code>.</p>
</blockquote>
<blockquote>
<p>Votes cast at time <code>t</code> will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span><br><span class="line">Output: [null,0,1,1,0,0,1]</span><br><span class="line">Explanation:</span><br><span class="line">At time 3, the votes are [0], and 0 is leading.</span><br><span class="line">At time 12, the votes are [0,1,1], and 1 is leading.</span><br><span class="line">At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)</span><br><span class="line">This continues for 3 more queries at time 15, 24, and 8.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= persons.length = times.length &lt;= 5000</code></li>
<li><code>0 &lt;= persons[i] &lt;= persons.length</code></li>
<li>times is a strictly increasing array with all elements in <code>[0, 10^9]</code>.</li>
<li><code>TopVotedCandidate.q</code> is called at most <code>10000</code> times per test case.</li>
<li><code>TopVotedCandidate.q(int t)</code> is always called with <code>t &gt;= times[0]</code>.</li>
</ol>
<p><code>TopVotedCandidate</code>只需要构造一次就可以存储所有投票数据，开销来自反复调用<code>q</code>查询。因此考虑尽可能在一次构造就计算好所有被查询的数值，查询时只需要取用。</p>
<p>简单的思路是把每个关键点时间（即投票发生时间）的领先候选人都记录下来，查询<code>t</code>时间时只要用二分查找找到它在关键时间序列<code>times</code>中对应的位置，直接返回结果。反正我们没文化的人就是这么简单粗暴。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, persons, times)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type persons: List[int]</span></span><br><span class="line"><span class="string">        :type times: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.times = times</span><br><span class="line">        self.top = []</span><br><span class="line">        d = dict()</span><br><span class="line">        max_vote = persons[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> persons:</span><br><span class="line">            d[p] = d.get(p, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d[max_vote] &lt;= d[p]:</span><br><span class="line">                max_vote = p</span><br><span class="line">            self.top.append(max_vote)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">q</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = bisect.bisect(self.times, t)</span><br><span class="line">        <span class="keyword">return</span> self.top[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your TopVotedCandidate object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = TopVotedCandidate(persons, times)</span></span><br><span class="line"><span class="comment"># param_1 = obj.q(t)</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-103/" data-id="cjuh9jwro000efww3zc7fty2g" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="active"><span class="page-number">4</span></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/5/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
