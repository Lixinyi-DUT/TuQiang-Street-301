<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/6/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-96" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-96/">LeetCode Weekly Contest 96</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-96/" class="article-date"><time datetime="2018-08-05T13:38:39.578Z" itemprop="datePublished">2018-08-05</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>由于失眠过度熬夜，一不小心睡过了没去现场周赛，只能在这里补做题解了。已经尝试过褪黑素了，现在好像对我完全没作用了，没办法了，求治失眠。</p>
<p>https://leetcode.com/contest/weekly-contest-96</p>
<p>&lt;!-- more --&gt;</p>
<h2>Projection Area of 3D Shapes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/projection-area-of-3d-shapes/</p>
<blockquote>
<p>On a <code>N * N</code> grid, we place some <code>1 * 1 * 1</code> cubes that are axis-aligned with the x, y, and z axes.</p>
</blockquote>
<blockquote>
<p>Each value <code>v = grid[i][j]</code> represents a tower of v cubes placed on top of grid cell <code>(i, j)</code>.</p>
</blockquote>
<blockquote>
<p>Now we view the projection of these cubes onto the xy, yz, and zx planes.</p>
</blockquote>
<blockquote>
<p>A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.</p>
</blockquote>
<blockquote>
<p>Here, we are viewing the &quot;shadow&quot; when looking at the cubes from the top, the front, and the side.</p>
</blockquote>
<blockquote>
<p>Return the total area of all three projections.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation:</span><br><span class="line">Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 14</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ul>
<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ul>
<p>不多说</p>
<ul>
<li>在xy平面的投影是所有非零<code>v</code>的个数</li>
<li>在xz平面的投影是每一个<code>x</code>值对应的最大<code>v</code>的和</li>
<li>在yz平面的投影是每一个<code>y</code>值对应的最大<code>v</code>的和</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">projectionArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(grid)</span><br><span class="line">        xy,xz,yz=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            xy+=sum(v&gt;<span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> grid[i])</span><br><span class="line">            xz+=max(v <span class="keyword">for</span> v <span class="keyword">in</span> grid[i])</span><br><span class="line">            yz+=max(grid[j][i] <span class="keyword">for</span> j <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xy+xz+yz</span><br></pre></td></tr></table></figure></p>
<h2>Boats to Save People</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/boats-to-save-people/</p>
<blockquote>
<p>The i-th person has weight <code>people[i]</code>, and each boat can carry a maximum weight of <code>limit</code>.</p>
</blockquote>
<blockquote>
<p>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [1,2], limit = 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,2,2,1], limit = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,5,3,4], limit = 5</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ul>
<li><code>1 &lt;= people.length &lt;= 50000</code></li>
<li><code>1 &lt;= people[i] &lt;= limit &lt;= 30000</code></li>
</ul>
<p>符合直觉的做法：先将<code>people</code>排序，试图组合最大的和最小的，如果超过<code>limit</code>则弹出当前最大的单独安排一条船，如果组合成功则弹出二者安排一条船，重复以上程序直至无法找出这样的组合。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span><span class="params">(self, people, limit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type people: List[int]</span></span><br><span class="line"><span class="string">        :type limit: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        people.sort()</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(people)&gt;<span class="number">1</span> <span class="keyword">and</span> people[<span class="number">0</span>]*<span class="number">2</span>&lt;=limit:</span><br><span class="line">            <span class="keyword">if</span> people[<span class="number">-1</span>]+people[<span class="number">0</span>]&lt;=limit:</span><br><span class="line">                people.pop(<span class="number">0</span>)</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">            people.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res+len(people)</span><br></pre></td></tr></table></figure></p>
<h2>Decoded String at Index</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/decoded-string-at-index/</p>
<blockquote>
<p>An encoded string <code>S</code> is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:</p>
</blockquote>
<blockquote>
<p>If the character read is a letter, that letter is written onto the tape.
If the character read is a digit (say <code>d</code>), the entire current tape is repeatedly written <code>d-1</code> more times in total.
Now for some encoded string <code>S</code>, and an index <code>K</code>, find and return the <code>K</code>-th letter (1 indexed) in the decoded string.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;leet2code3&quot;, K = 10</span><br><span class="line">Output: &quot;o&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.</span><br><span class="line">The 10th letter in the string is &quot;o&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ha22&quot;, K = 5</span><br><span class="line">Output: &quot;h&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The decoded string is &quot;hahahaha&quot;.  The 5th letter is &quot;h&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a2345678999999999999999&quot;, K = 1</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The decoded string is &quot;a&quot; repeated 8301530446056247680 times.  The 1st letter is &quot;a&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= S.length &lt;= 100</code></li>
<li><code>S</code> will only contain lowercase letters and digits <code>2</code> through <code>9</code>.</li>
<li><code>S</code> starts with a letter.</li>
<li><code>1 &lt;= K &lt;= 10^9</code></li>
<li>The decoded string is guaranteed to have less than <code>2^63</code> letters.</li>
</ol>
<p>按照规则还原原始字符串会有TLE的风险。那么可以遍历字符串，如果<code>K</code>恰好在某个重复的子串，则递归计算被重复的子串中<code>K</code>对应的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeAtIndex</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> ord(<span class="string">'a'</span>) &lt;= ord(c) &lt;= ord(<span class="string">'z'</span>):</span><br><span class="line">                n+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n==K: <span class="keyword">return</span> c</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> n &lt; K &lt;= int(c)*n:</span><br><span class="line">                    <span class="keyword">return</span> self.decodeAtIndex(S,(K<span class="number">-1</span>)%n+<span class="number">1</span>)</span><br><span class="line">                n*=int(c)</span><br></pre></td></tr></table></figure></p>
<h2>Reachable Nodes In Subdivided Graph</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/reachable-nodes-in-subdivided-graph/</p>
<blockquote>
<p>Starting with an <strong>undirected</strong> graph (the &quot;original graph&quot;) with nodes from <code>0</code> to <code>N-1</code>, subdivisions are made to some of the edges.</p>
</blockquote>
<blockquote>
<p>The graph is given as follows: <code>edges[k]</code> is a list of integer pairs <code>(i, j, n)</code> such that <code>(i, j)</code> is an edge of the original graph,</p>
</blockquote>
<blockquote>
<p>and <code>n</code> is the total number of <strong>new</strong> nodes on that edge.</p>
</blockquote>
<blockquote>
<p>Then, the edge <code>(i, j)</code> is deleted from the original graph, <code>n</code> new nodes <code>(x_1, x_2, ..., x_n)</code>are added to the original graph,</p>
</blockquote>
<blockquote>
<p>and <code>n+1</code> new edges <code>(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)</code> are added to the original graph.</p>
</blockquote>
<blockquote>
<p>Now, you start at node <code>0</code> from the original graph, and in each move, you travel along one edge.</p>
</blockquote>
<blockquote>
<p>Return how many nodes you can reach in at most <code>M</code> moves.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3</span><br><span class="line">Output: 13</span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are reachable in the final graph after M = 6 moves are indicated below.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= edges.length &lt;= 10000</code></li>
<li><code>0 &lt;= edges[i][0] &lt; edges[i][1] &lt; N</code></li>
<li>There does not exist any <code>i != j</code> for which <code>edges[i][0] == edges[j][0]</code> and <code>edges[i][1] == edges[j][1]</code>.</li>
<li>The original graph has no parallel edges.</li>
<li><code>0 &lt;= edges[i][2] &lt;= 10000</code></li>
<li><code>0 &lt;= M &lt;= 10^9</code></li>
<li><code>1 &lt;= N &lt;= 3000</code></li>
</ol>
<p>一个可以接受的思路：从起始结点开始BFS，访问到结点<code>i</code>时，<code>seen[i]</code>记录到达<code>i</code>后最多可以剩下多少次<code>move</code>，如果足够到达下一个结点<code>j</code>则把<code>j</code>和<code>seen[j]</code>也放入队列，重复直至队列为空。最后遍历到的原结点（图中大的结点）数为<code>len(seen)</code>，边上新增结点（图中小的结点）数则计算每条边<code>(i,j,n)</code>的<code>min(seen[i]+seen[j],n)</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachableNodes</span><span class="params">(self, edges, M, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :type M: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        e=collections.defaultdict(dict)</span><br><span class="line">        <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges:</span><br><span class="line">            e[i][j]=e[j][i]=n</span><br><span class="line"></span><br><span class="line">        seen=&#123;<span class="number">0</span>:M&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,M)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,move <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> e[i]:</span><br><span class="line">                left=move<span class="number">-1</span>-e[i][j]</span><br><span class="line">                <span class="keyword">if</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> (j <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">or</span> seen[j]&lt;left):</span><br><span class="line">                    seen[j]=left</span><br><span class="line">                    q.append((j,left))</span><br><span class="line"></span><br><span class="line">        res=len(seen)+sum(min(seen.get(i,<span class="number">0</span>)+seen.get(j,<span class="number">0</span>),n) <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>当然为了避免重复刷新<code>seen[i]</code>的值以及多余的遍历，可以用Dijkstra算法找到到结点的最短路径然后更新<code>seen[i]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachableNodes</span><span class="params">(self, edges, M, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :type M: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        e=collections.defaultdict(dict)</span><br><span class="line">        <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges:</span><br><span class="line">            e[i][j]=e[j][i]=n</span><br><span class="line"></span><br><span class="line">        seen=&#123;&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cost,i=heapq.heappop(q)</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen[i]=M-cost</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> e[i]:</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> cost+e[i][j]+<span class="number">1</span>&lt;=M:</span><br><span class="line">                    heapq.heappush(q,(cost+e[i][j]+<span class="number">1</span>,j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(seen)+sum(min(seen.get(i,<span class="number">0</span>)+seen.get(j,<span class="number">0</span>),n) <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-96/" data-id="cjuh9jx75004cfww37e46z10p" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-95" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-95/">LeetCode Weekly Contest 95</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-95/" class="article-date"><time datetime="2018-07-29T08:46:31.908Z" itemprop="datePublished">2018-07-29</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-95/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Middle of the Linked List</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-95/problems/middle-of-the-linked-list/</p>
<blockquote>
<p>Given a non-empty, singly linked list with head node <code>head</code>, return a middle node of linked list.</p>
</blockquote>
<blockquote>
<p>If there are two middle nodes, return the second middle node.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&apos;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given list will be between <code>1</code> and <code>100</code>.</li>
</ol>
<p>用一快一慢两个指针遍历链表，快的走两步慢的走一步，快的完成遍历后慢的就在链表的中间了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        fast,slow=head,head</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast=fast.next</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>: slow=slow.next</span><br><span class="line">            n+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></p>
<h2>Stone Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-95/problems/stone-game/</p>
<blockquote>
<p>Alex and Lee play a game with piles of stones.  There are an even number of piles <strong>arranged in a row</strong>, and each pile has a positive integer number of stones <code>piles[i]</code>.</p>
</blockquote>
<blockquote>
<p>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.</p>
</blockquote>
<blockquote>
<p>Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.</p>
</blockquote>
<blockquote>
<p>Assuming Alex and Lee play optimally, return <code>True</code> if and only if Alex wins the game.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">Alex starts first, and can only take the first 5 or the last 5.</span><br><span class="line">Say he takes the first 5, so that the row becomes [3, 4, 5].</span><br><span class="line">If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.</span><br><span class="line">If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.</span><br><span class="line">This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= piles.length &lt;= 500</code></li>
<li><code>piles.length</code> is even.</li>
<li><code>1 &lt;= piles[i] &lt;= 500</code></li>
<li><code>sum(piles)</code> is odd.</li>
</ol>
<p>注意这题有pile的长度为偶数的限定，那么Alex可以从头（偶数项）或者尾（奇数项）开始取走所有的奇数项或所有的偶数项，而总数又是奇数，奇数项和与偶数项和存在一个较大值，那么存在一个必胜的策略：Alex只要选择每轮都选择奇数项或者偶数项使得Lee被迫选剩下的，必然可以达到较大的和。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Nth Magical Number</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-95/problems/nth-magical-number/</p>
<blockquote>
<p>A positive integer is magical if it is divisible by either A or B.</p>
</blockquote>
<blockquote>
<p>Return the N-th magical number.  Since the answer may be very large, return it <strong>modulo</strong> <code>10^9 + 7</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, A = 2, B = 3</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, A = 2, B = 3</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, A = 2, B = 4</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, A = 6, B = 4</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
<li><code>2 &lt;= A &lt;= 40000</code></li>
<li><code>2 &lt;= B &lt;= 40000</code></li>
</ol>
<p>每增加一个<code>lcm(A,B)</code>就会增加<code>lcm(A,B)/A+lcm(A,B)/B-1</code>个magical number，那么先对<code>N</code>除<code>lcm(A,B)/A+lcm(A,B)/B-1</code>，得到的商乘以<code>lcm(A,B)</code>，再按照余数一个个去找到剩下的余数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthMagicalNumber</span><span class="params">(self, N, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type A: int</span></span><br><span class="line"><span class="string">        :type B: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        g=fractions.gcd(A,B)</span><br><span class="line">        m=A/g+B/g<span class="number">-1</span></span><br><span class="line">        r=N%m</span><br><span class="line">        res=((N/m)*A*B/g)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">        m_a,m_b,cur=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (m_a+<span class="number">1</span>)*A&gt;(m_b+<span class="number">1</span>)*B:</span><br><span class="line">                m_b+=<span class="number">1</span></span><br><span class="line">                cur=m_b*B</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m_a+=<span class="number">1</span></span><br><span class="line">                cur=m_a*A</span><br><span class="line">            r-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (res+cur)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<h2>Profitable Schemes</h2>
<blockquote>
<p>There are G people in a gang, and a list of various crimes they could commit.</p>
</blockquote>
<blockquote>
<p>The <code>i</code>-th crime generates a <code>profit[i]</code> and requires <code>group[i]</code> gang members to participate.</p>
</blockquote>
<blockquote>
<p>If a gang member participates in one crime, that member can't participate in another crime.</p>
</blockquote>
<blockquote>
<p>Let's call a profitable scheme any subset of these crimes that generates at least <code>P</code> profit, and the total number of gang members participating in that subset of crimes is at most G.</p>
</blockquote>
<blockquote>
<p>How many schemes can be chosen?  Since the answer may be very large, <strong>return it modulo</strong> <code>10^9 + 7</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: G = 5, P = 3, group = [2,2], profit = [2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.</span><br><span class="line">In total, there are 2 schemes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">To make a profit of at least 5, the gang could commit any crimes, as long as they commit one.</span><br><span class="line">There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= G &lt;= 100</code></li>
<li><code>0 &lt;= P &lt;= 100</code></li>
<li><code>1 &lt;= group[i] &lt;= 100</code></li>
<li><code>0 &lt;= profit[i] &lt;= 100</code></li>
<li><code>1 &lt;= group.length = profit.length &lt;= 100</code></li>
</ol>
<p>也是背包问题的变种，这里也用动态规划。<code>dp[i][j]</code>表示利润为<code>i</code>人员数为<code>j</code>的方案总数（除了<code>i=P</code>时表示利润<code>&gt;=P</code>），遍历犯罪列表，对于每次取到的利润为<code>p</code>人员数为<code>g</code>的犯罪，更新整个<code>dp</code>：</p>
<ol>
<li>如果<code>i+p&lt;P</code>，则<code>dp[i+p][j+g]+=dp[i][j]</code></li>
<li>如果<code>i+p&gt;=P</code>，则<code>dp[P][j+g]+=dp[i][j]</code></li>
</ol>
<p>当然注意第二维（人员数）不要超过<code>G</code>。这里用的还是类似于<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-93/#Minimum-Number-of-Refueling-Stops">Minimum Number of Refueling Stops</a>用到的自底而上的遍历<code>dp</code>，原理也相同。初始条件为<code>dp[0][0]=1</code>这样保证初次遍历的时候只有<code>dp[min(p,P)][g]</code>可以得到更新为<code>1</code>，之后加入的犯罪也只会以这二者为起点。最后返回<code>i=P</code>的所有<code>dp</code>的和作为结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span><span class="params">(self, G, P, group, profit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type G: int</span></span><br><span class="line"><span class="string">        :type P: int</span></span><br><span class="line"><span class="string">        :type group: List[int]</span></span><br><span class="line"><span class="string">        :type profit: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(G+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(P+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> g,p <span class="keyword">in</span> zip(group,profit):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(P,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(G-g,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    dp[min(i+p,P)][j+g]+=dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(dp[P])%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-95/" data-id="cjuh9jx6s0048fww35xd8f3ba" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-94" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-94/">LeetCode Weekly Contest 94</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-94/" class="article-date"><time datetime="2018-07-22T05:51:23.969Z" itemprop="datePublished">2018-07-22</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-94/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Leaf-Similar Trees</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/leaf-similar-trees/</p>
<blockquote>
<p>Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a <em>leaf value</em> sequence.
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="">
For example, in the given tree above, the leaf value sequence is <code>(6, 7, 4, 9, 8)</code>.</p>
</blockquote>
<blockquote>
<p>Two binary trees are considered leaf-similar if their leaf value sequence is the same.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the two given trees with head nodes <code>root1</code> and <code>root2</code> are leaf-similar.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Both of the given trees will have between <code>1</code> and <code>100</code> nodes.</li>
</ol>
<p>遍历（保证遍历顺序是左支在右支之前就可以了）树得到叶结点指序列，比较两个序列是否相等。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leafSimilar</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">leaf_sequence</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> root.left) <span class="keyword">and</span> (<span class="keyword">not</span> root.right):</span><br><span class="line">                 <span class="keyword">return</span> [root.val]</span><br><span class="line">            <span class="keyword">return</span> leaf_sequence(root.left)+leaf_sequence(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leaf_sequence(root1)==leaf_sequence(root2)</span><br></pre></td></tr></table></figure></p>
<h2>Walking Robot Simulation</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/walking-robot-simulation/</p>
<blockquote>
<p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:</p>
</blockquote>
<ul>
<li><code>-2</code>: turn left 90 degrees</li>
<li><code>-1</code>: turn right 90 degrees</li>
<li><code>1 &lt;= x &lt;= 9</code>: move forward x units
Some of the grid squares are obstacles.</li>
</ul>
<blockquote>
<p>The i-th obstacle is at grid point <code>(obstacles[i][0], obstacles[i][1])</code></p>
</blockquote>
<blockquote>
<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>
</blockquote>
<blockquote>
<p>Return the <strong>square</strong> of the maximum Euclidean distance that the robot will be from the origin.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,3], obstacles = []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: robot will go to (3, 4)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= commands.length &lt;= 10000</code></li>
<li><code>0 &lt;= obstacles.length &lt;= 10000</code></li>
<li><code>-30000 &lt;= obstacle[i][0] &lt;= 30000</code></li>
<li><code>-30000 &lt;= obstacle[i][1] &lt;= 30000</code></li>
<li>The answer is guaranteed to be less than <code>2 ^ 31</code>.</li>
</ol>
<p>顺时针排一下四个方向，左转就是前一个方向，右转则是后一个。要求返回的是移动过程中离原点最大距离的平方（我看例子给的结果实际上并不是Euclidean距离的平方，实际上就是距离的平方），而不是最终点与原点之间距离的平方。另外注意一下可能会多次在<code>obstacles</code>中寻值，可以转换成<code>set</code>或者<code>dict</code>之类的hash表避免过大的时间开销。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands, obstacles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type commands: List[int]</span></span><br><span class="line"><span class="string">        :type obstacles: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        direction=[(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>)]</span><br><span class="line">        ob=set([(x,y) <span class="keyword">for</span> [x,y] <span class="keyword">in</span> obstacles])</span><br><span class="line">        d=<span class="number">0</span></span><br><span class="line">        pos=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        dist=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> c==<span class="number">-2</span>:</span><br><span class="line">                d=(d+<span class="number">3</span>)%<span class="number">4</span></span><br><span class="line">            <span class="keyword">elif</span> c==<span class="number">-1</span>:</span><br><span class="line">                d=(d+<span class="number">1</span>)%<span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(c):</span><br><span class="line">                    pos[<span class="number">0</span>]+=direction[d][<span class="number">0</span>]</span><br><span class="line">                    pos[<span class="number">1</span>]+=direction[d][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> (pos[<span class="number">0</span>],pos[<span class="number">1</span>]) <span class="keyword">in</span> ob:</span><br><span class="line">                        pos[<span class="number">0</span>]-=direction[d][<span class="number">0</span>]</span><br><span class="line">                        pos[<span class="number">1</span>]-=direction[d][<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                dist=max(dist,pos[<span class="number">0</span>]*pos[<span class="number">0</span>]+pos[<span class="number">1</span>]*pos[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure></p>
<h2>Koko Eating Bananas</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/koko-eating-bananas/</p>
<blockquote>
<p>Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.</p>
</blockquote>
<blockquote>
<p>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.</p>
</blockquote>
<blockquote>
<p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.</p>
</blockquote>
<blockquote>
<p>Return the minimum integer K such that she can eat all the bananas within H hours.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [3,6,7,11], H = 8</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 5</span><br><span class="line">Output: 30</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 6</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= piles.length &lt;= 10^4</code></li>
<li><code>piles.length &lt;= H &lt;= 10^9</code></li>
<li><code>1 &lt;= piles[i] &lt;= 10^9</code></li>
</ol>
<p>找到满足<code>sum(ceil(piles[i]/K))&lt;=H</code>的最小<code>K</code>，显然这个至少要从<code>ceil(sum(piles)/H)</code>开始找这个<code>K</code>值，不过比较奇怪的是contest现场时我没多想直接从这里一个个向后找整数竟然也能AC</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k=int(math.ceil(<span class="number">1.0</span>*sum(piles)/H))</span><br><span class="line">        <span class="keyword">while</span> sum([math.ceil(<span class="number">1.0</span>*i/k) <span class="keyword">for</span> i <span class="keyword">in</span> piles])&gt;H:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure></p>
<p>看其他人的做法是在<code>[ceil(sum(piles)/H),max(piles)]</code>范围内用<code>bisect</code>二分搜索找到使得<code>sum(ceil(piles[i]/K))&lt;=H</code>的位置，这样会高效的多。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r=(sum(piles)+H<span class="number">-1</span>)/H,max(piles)</span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            m=(l+r)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> sum((p+m<span class="number">-1</span>)/m <span class="keyword">for</span> p <span class="keyword">in</span> piles) &gt; H:</span><br><span class="line">                l=m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r=m</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure></p>
<p>但不知道为什么看提交的runtime反而明显被拖慢了，大概test cases实在选的太糟糕了，它们的结果都是接近起点的值。</p>
<h2>Length of Longest Fibonacci Subsequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-94/problems/length-of-longest-fibonacci-subsequence/</p>
<blockquote>
<p>A sequence <code>X_1, X_2, ..., X_n</code> is <em>fibonacci-like</em> if:</p>
</blockquote>
<ul>
<li><code>n &gt;= 3</code></li>
<li><code>X_i + X_{i+1} = X_{i+2}</code> for all <code>i + 2 &lt;= n</code>
Given a <strong>strictly increasing</strong> array <code>A</code> of positive integers forming a sequence, find the <strong>length</strong> of the longest fibonacci-like subsequence of <code>A</code>.  If one does not exist, return 0.</li>
</ul>
<blockquote>
<p>(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from <code>A</code>, without changing the order of the remaining elements.  For example, <code>[3, 5, 8]</code> is a subsequence of <code>[3, 4, 5, 6, 7, 8]</code>.)
s
<strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7,8]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The longest subsequence that is fibonacci-like: [1,2,3,5,8].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,7,11,12,14,18]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The longest subsequence that is fibonacci-like:</span><br><span class="line">[1,11,12], [3,11,14] or [7,11,18].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[0] &lt; A[1] &lt; ... &lt; A[A.length - 1] &lt;= 10^9</code></li>
<li><em>(The time limit has been reduced by 50% for submissions in Java, C, and C++.)</em></li>
</ol>
<p>我用的方法比较直接，找到任意满足<code>A[i]+A[j]</code>也在<code>A</code>的初始对<code>(A[i],A[j])</code>然后找出这个对开始能构造出的最长的序列，找到所有对分别对应的最长序列的长度即为结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums=set(A)</span><br><span class="line">        maxnum=A[<span class="number">-1</span>]</span><br><span class="line">        maxlen=<span class="number">0</span></span><br><span class="line">        q=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j]&gt;maxnum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j] <span class="keyword">in</span> nums:</span><br><span class="line">                    q.append((A[j],A[i]+A[j]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x,y) <span class="keyword">in</span> q:</span><br><span class="line">            l=<span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> x+y <span class="keyword">in</span> nums:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure></p>
<p>当然这肯定不是最好的方法，这些序列肯定会有部分重叠，因此考虑动态规划或许是<a href="https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/discuss/152476/Java-DP-with-explanation-O(n2)-time-O(n2)space" target="_blank" rel="noopener">更好的解法</a></p>
<p>我也试着写了一个不重复计算子序列的方法，但运行时间上没有太大的提升</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums=set(A)</span><br><span class="line">        maxnum=A[<span class="number">-1</span>]</span><br><span class="line">        d=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j]&gt;maxnum:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> A[i]+A[j] <span class="keyword">in</span> nums:</span><br><span class="line">                    d[(A[i],A[j])]=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> d: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x,y) <span class="keyword">in</span> sorted(d.keys(),reverse=<span class="keyword">True</span>):</span><br><span class="line">            <span class="keyword">if</span> (y,x+y) <span class="keyword">in</span> d:</span><br><span class="line">                d[(x,y)]=<span class="number">1</span>+d[(y,x+y)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(d.values())</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-94/" data-id="cjuh9jx6x004afww32d8vrbrw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-93" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-93/">LeetCode Weekly Contest 93</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-93/" class="article-date"><time datetime="2018-07-15T06:29:48.592Z" itemprop="datePublished">2018-07-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>转型LeetCode养老玩家，这几周都是周赛现场只做三题就不想继续水题直接去做饭了，年龄大了以后专注力陡降。不过放心，题解还是会把四题都写完的。</p>
<p>https://leetcode.com/contest/weekly-contest-93</p>
<p>&lt;!-- more --&gt;</p>
<h2>Binary Gap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/binary-gap/</p>
<blockquote>
<p>Given a positive integer <code>N</code>, find and return the longest distance between two consecutive 1's in the binary representation of <code>N</code>.</p>
</blockquote>
<blockquote>
<p>If there aren't two consecutive 1's, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: 22</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">22 in binary is 0b10110.</span><br><span class="line">In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.</span><br><span class="line">The first consecutive pair of 1&apos;s have distance 2.</span><br><span class="line">The second consecutive pair of 1&apos;s have distance 1.</span><br><span class="line">The answer is the largest of these two distances, which is 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">5 in binary is 0b101.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">6 in binary is 0b110.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">8 in binary is 0b1000.</span><br><span class="line">There aren&apos;t any consecutive pairs of 1&apos;s in the binary representation of 8, so we return 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>找到二进制串中每个<code>1</code>的位置，计算相邻<code>1</code>之间的间隔找到最大值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryGap</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s=bin(N)[<span class="number">2</span>:]</span><br><span class="line">        ones=[i <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(s) <span class="keyword">if</span> c==<span class="string">'1'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(ones)&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max([ones[i]-ones[i<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(ones))])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2>Reordered Power of 2</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/reordered-power-of-2/</p>
<blockquote>
<p>Starting with a positive integer <code>N</code>, we reorder the digits in any order (including the original order) such that the leading digit is not zero.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if we can do this in a way such that the resulting number is a power of 2.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 24</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 46</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>假设<code>N</code>是一个<code>n</code>位数，找到所有<code>n</code>位数（<code>10^(n-1)</code>-<code>10^n-1</code>）中最小的2的幂<code>2^x</code>和最大的2的幂<code>2^y</code>，对<code>[x,y]</code>中每个数算2的幂，并取出所有位的数字对比是否有和<code>N</code>的所有位一致的</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderedPowerOf2</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        digits=list(str(N))</span><br><span class="line">        digits.sort()</span><br><span class="line">        n=len(digits)</span><br><span class="line">        max_num=<span class="number">10</span>**n<span class="number">-1</span></span><br><span class="line">        min_num=<span class="number">10</span>**(n<span class="number">-1</span>)</span><br><span class="line">        lower_exponent=len(bin(min_num)[<span class="number">2</span>:])<span class="number">-1</span></span><br><span class="line">        upper_exponent=len(bin(max_num)[<span class="number">2</span>:])<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lower_exponent,upper_exponent+<span class="number">1</span>):</span><br><span class="line">            target=sorted(list(str(<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">            <span class="keyword">if</span> target==digits:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2>Advantage Shuffle</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/advantage-shuffle/</p>
<blockquote>
<p>Given two arrays <code>A</code> and <code>B</code> of equal size, the advantage of <code>A</code> with respect to <code>B</code> is the number of indices i for which <code>A[i] &gt; B[i]</code>.</p>
</blockquote>
<blockquote>
<p>Return <strong>any</strong> permutation of <code>A</code> that maximizes its advantage with respect to <code>B</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,11,15], B = [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [12,24,8,32], B = [13,25,32,11]</span><br><span class="line">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = B.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= B[i] &lt;= 10^9</code></li>
</ol>
<p>有点像田忌赛马，安排一下让优胜的回合最多。对<code>A</code>和<code>B</code>都先升序排序，依次对每个<code>B[i]</code>都找到最小的<code>A[j]</code>使得<code>A[j]&gt;B[i]</code>然后把<code>A[j]</code>放在<code>B[i]</code>对应的原位置，这样安排上了以后，当<code>A</code>的元素都开始小于等于<code>B[i]</code>时，对于<code>B[i:]</code>的所有元素对应位置任意放置<code>A</code>中还没有被安排的元素，整个过程就被安排的明明白白了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">advantageCount</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(A)</span><br><span class="line">        A.sort()</span><br><span class="line">        res=[<span class="number">-1</span>]*N</span><br><span class="line">        posB=sorted(range(N),key=<span class="keyword">lambda</span> i:B[i])</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> posB:</span><br><span class="line">            <span class="keyword">while</span> j&lt;len(A) <span class="keyword">and</span> B[i]&gt;=A[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j&gt;=len(A): <span class="keyword">break</span></span><br><span class="line">            res[i]=A.pop(j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> res[i]&lt;<span class="number">0</span>:</span><br><span class="line">                res[i]=A.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Number of Refueling Stops</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-93/problems/minimum-number-of-refueling-stops/</p>
<blockquote>
<p>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.</p>
</blockquote>
<blockquote>
<p>Along the way, there are gas stations.  Each <code>station[i]</code> represents a gas station that is <code>station[i][0]</code> miles east of the starting position, and has s<code>tation[i][1]</code> liters of gas.</p>
</blockquote>
<blockquote>
<p>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.</p>
</blockquote>
<blockquote>
<p>When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p>
</blockquote>
<blockquote>
<p>What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.</p>
</blockquote>
<blockquote>
<p>Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 1, startFuel = 1, stations = []</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can reach the target without refueling.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 100, startFuel = 1, stations = [[10,100]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: We can&apos;t reach the target (or even the first gas station).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">We start with 10 liters of fuel.</span><br><span class="line">We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.</span><br><span class="line">Then, we drive from position 10 to position 60 (expending 50 liters of fuel),</span><br><span class="line">and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.</span><br><span class="line">We made 2 refueling stops along the way, so we return 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= target, startFuel, stations[i][1] &lt;= 10^9</code></li>
<li><code>0 &lt;= stations.length &lt;= 500</code></li>
<li><code>0 &lt; stations[0][0] &lt; stations[1][0] &lt; ... &lt; stations[stations.length-1][0] &lt; target</code></li>
</ol>
<p>这个问题类似于背包问题，可以用动态规划求解。</p>
<p>用<code>dp[n]</code>表示在<code>n</code>个站加油后能达到的最大距离。到达第<code>i</code>站时，如果有<code>j&lt;=i</code>且<code>dp[j]&gt;=stations[i][0]</code>，那么经过<code>j+1</code>次加油后可能的最大行驶距离可能就是在第<code>i</code>站之前经过<code>j</code>次加油并在此进行加油的距离，即<code>dp[j+1]=max(d[j+1],d[j]+stations[i][1])</code>，注意从最大的<code>j</code>开始更新<code>d[j+1]</code>的值以防因为到达<code>i</code>使得<code>d[j]</code>发生更新从而使得<code>d[j+1]</code>计算了两次在第<code>i</code>站的加油。最后找到使得<code>d[j]&gt;=target</code>的最小<code>j</code>值作为返回结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minRefuelStops</span><span class="params">(self, target, startFuel, stations)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type startFuel: int</span></span><br><span class="line"><span class="string">        :type stations: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(stations)</span><br><span class="line">        dp=[<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=startFuel</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j]&gt;=stations[i][<span class="number">0</span>]:</span><br><span class="line">                    dp[j+<span class="number">1</span>]=max(dp[j+<span class="number">1</span>],dp[j]+stations[i][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,dist <span class="keyword">in</span> enumerate(dp):</span><br><span class="line">            <span class="keyword">if</span> dist&gt;=target: <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-93/" data-id="cjuh9jx6o0046fww3h3gtfdsw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-92" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-92/">LeetCode Weekly Contest 92</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-92/" class="article-date"><time datetime="2018-07-08T07:05:33.249Z" itemprop="datePublished">2018-07-08</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>俗话说码如其人，我突然发现我长得丑还隐藏着巨大的优势，不用花太多时间把代码特意写的优雅，能用就行，反正别人看见我长那么丑，代码也写的那么丑就没什么好奇怪的了（比如最后一题，真的懒得想优雅的解法了，能过就行）。相反美人们写的东西就要承载更多期待了。不多说了，辛苦你们阅读我丑陋的解法了：</p>
<p>https://leetcode.com/contest/weekly-contest-92</p>
<p>&lt;!-- more --&gt;</p>
<h2>Transpose Matrix</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/transpose-matrix/</p>
<blockquote>
<p>Given a matrix <code>A</code>, return the transpose of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>The transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6]]</span><br><span class="line">Output: [[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[0].length &lt;= 1000</code></li>
</ol>
<p>把每列元素重新组成行就是转置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transpose</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> [[A[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[<span class="number">0</span>]))]</span><br></pre></td></tr></table></figure></p>
<h2>Smallest Subtree with all the Deepest Nodes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/smallest-subtree-with-all-the-deepest-nodes/</p>
<blockquote>
<p>Given a binary tree rooted at <code>root</code>, the depth of each node is the shortest distance to the root.</p>
</blockquote>
<blockquote>
<p>A node is deepest if it has the largest depth possible.</p>
</blockquote>
<blockquote>
<p>Return the node with the largest depth such that it contains all the deepest nodes in it's subtree.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line">Output: [2,7,4]</span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">We return the node with value 2, colored in yellow in the diagram.</span><br><span class="line">The nodes colored in blue are the deepest nodes of the tree.</span><br><span class="line">The input &quot;[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]&quot; is a serialization of the given tree.</span><br><span class="line">The output &quot;[2, 7, 4]&quot; is a serialization of the subtree rooted at the node with value 2.</span><br><span class="line">Both the input and output have TreeNode type.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the tree will be between <code>1</code> and <code>500</code>.</li>
</ol>
<p>这样的最小子树满足两个条件</p>
<ol>
<li>它的左右子树的高度相同</li>
<li>它的高度与它父结点所表示的树只相差1</li>
</ol>
<p>可以先遍历一次整个树算出每个子树的高度，再进行BFS找到第一个同时满足这两个条件的子树。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        height=&#123;<span class="keyword">None</span>:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            height[r]=<span class="number">1</span>+max(depth(r.left),depth(r.right))</span><br><span class="line">            <span class="keyword">return</span> height[r]</span><br><span class="line"></span><br><span class="line">        q=[root]</span><br><span class="line">        d=depth(root)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> height[r.left]==height[r.right]:</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            <span class="keyword">if</span> r.left <span class="keyword">and</span> height[r.left]==height[r]<span class="number">-1</span>: q.append(r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right <span class="keyword">and</span> height[r.right]==height[r]<span class="number">-1</span>: q.append(r.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2>Prime Palindrome</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/prime-palindrome/</p>
<blockquote>
<p>Find the smallest prime palindrome greater than or equal to <code>N</code>.</p>
</blockquote>
<blockquote>
<p>Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1.</p>
</blockquote>
<blockquote>
<p>For example, 2,3,5,7,11 and 13 are primes.</p>
</blockquote>
<blockquote>
<p>Recall that a number is a palindrome if it reads the same from left to right as it does from right to left.</p>
</blockquote>
<blockquote>
<p>For example, 12321 is a palindrome.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 11</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 13</span><br><span class="line">Output: 101</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^8</code></li>
<li>The answer is guaranteed to exist and be less than <code>2 * 10^8</code>.</li>
</ol>
<p>我的做法比较朴素，先找到大于等于<code>N</code>的第一个palindrome，检查是否是质数，如果不是则找到大于这个palindrome的下一个palindrome</p>
<p>找到大于等于某个<code>n</code>的palindrome方法如下：</p>
<ol>
<li>对于低位（对称的右半部分），如果该位值大于对称位的值，则向前进位，该位置为0</li>
<li>把低位置为和对称位相等的值</li>
</ol>
<p>注意下边界情况比如<code>N=1</code>时应该返回2</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primePalindrome</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">            i=<span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> i*i&lt;=n:</span><br><span class="line">                <span class="keyword">if</span> n%i==<span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">palind</span><span class="params">(n)</span>:</span></span><br><span class="line">            x=str(n)</span><br><span class="line">            l=len(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l/<span class="number">2</span>)):</span><br><span class="line">                <span class="keyword">if</span> int(x[<span class="number">-1</span>-i])&gt;int(x[i]):</span><br><span class="line">                    <span class="keyword">return</span> palind(n+(<span class="number">10</span>-int(x[<span class="number">-1</span>-i]))*(<span class="number">10</span>**i))</span><br><span class="line">            x=list(x)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(l/<span class="number">2</span>)):</span><br><span class="line">                x[<span class="number">-1</span>-i]=x[i]</span><br><span class="line">            <span class="keyword">return</span> int(<span class="string">''</span>.join(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        t=palind(N)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_prime(t):</span><br><span class="line">            t=palind(t+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure></p>
<h2>Shortest Path to Get All Keys</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-92/problems/shortest-path-to-get-all-keys/</p>
<blockquote>
<p>We are given a 2-dimensional <code>grid</code>. <code>&quot;.&quot;</code> is an empty cell, <code>&quot;#&quot;</code> is a wall, <code>&quot;@&quot;</code> is the starting point, (<code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, ...) are keys, and (<code>&quot;A&quot;</code>, <code>&quot;B&quot;</code>, ...) are locks.</p>
</blockquote>
<blockquote>
<p>We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.</p>
</blockquote>
<blockquote>
<p>For some 1 &lt;= K &lt;= 6, there is exactly one lowercase and one uppercase letter of the first <code>K</code> letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.</p>
</blockquote>
<blockquote>
<p>Return the lowest number of moves to acquire all keys.  If it's impossible, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;@.a.#&quot;,&quot;###.#&quot;,&quot;b.A.B&quot;]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;@..aA&quot;,&quot;..B#.&quot;,&quot;....b&quot;]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length &lt;= 30</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 30</code></li>
<li><code>grid[i][j]</code> contains only <code>'.'</code>, <code>'#'</code>, <code>'@'</code>, <code>'a'-'f'</code> and <code>'A'-'F'</code>
The number of keys is in <code>[1, 6]</code>.  Each key has a different letter and opens exactly one lock.</li>
</ol>
<p>有点像<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-87/##-Shortest-Path-Visiting-All-Nodes">Shortest Path Visiting All Nodes</a>引入一个<code>K</code>位二进制数<code>state</code>表示<code>K</code>个钥匙的访问状态，因为是简单的网格图，用BFS第一次在状态<code>state</code>下访问到坐标<code>(x,y)</code>时的所经历的路径长度就是<code>(x,y,state)</code>的最小值，因此只要对四个方向不断进行BFS，捡到钥匙的时候更新<code>state</code>，遇到锁时检查<code>state</code>能否满足开锁条件继续遍历，第一次把状态更新到获得所有钥匙时的路径长度即为最短路径长度。当然在BFS之前需要先扫描一下整个网格找到起点位置和钥匙数量。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathAllKeys</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n,m=len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        start=(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        keys=<span class="number">0</span></span><br><span class="line">        visited=set()</span><br><span class="line">        d=[(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">'@'</span>:</span><br><span class="line">                    visited.add((i,j,<span class="number">0</span>))</span><br><span class="line">                    start=(i,j)</span><br><span class="line">                <span class="keyword">elif</span> <span class="string">'A'</span>&lt;=grid[i][j]&lt;=<span class="string">'F'</span>:</span><br><span class="line">                    keys+=<span class="number">1</span>        </span><br><span class="line">        complete=(<span class="number">1</span>&lt;&lt;keys)<span class="number">-1</span></span><br><span class="line">        q=[(start,<span class="number">0</span>,<span class="number">0</span>)] <span class="comment">#((x,y),steps,state)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ((i,j),s,state) <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> d:</span><br><span class="line">                x,y=i+dx,j+dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;m:</span><br><span class="line">                    temp_state=state</span><br><span class="line">                    <span class="keyword">if</span> grid[x][y]==<span class="string">'#'</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="string">'a'</span>&lt;=grid[x][y]&lt;=<span class="string">'f'</span>:</span><br><span class="line">                        temp_state=state|(<span class="number">1</span>&lt;&lt;ord(grid[x][y])-ord(<span class="string">'a'</span>))</span><br><span class="line">                        <span class="keyword">if</span> temp_state==complete:</span><br><span class="line">                            <span class="keyword">return</span> s+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="string">'A'</span>&lt;=grid[x][y]&lt;=<span class="string">'F'</span>:</span><br><span class="line">                        <span class="keyword">if</span> state &amp; (<span class="number">1</span>&lt;&lt;ord(grid[x][y])-ord(<span class="string">'A'</span>)) ==<span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (x,y,temp_state) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((x,y,temp_state))</span><br><span class="line">                        q.append(((x,y),s+<span class="number">1</span>,temp_state))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-92/" data-id="cjuh9jx6i0044fww338c4giuz" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-91" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-91/">LeetCode Weekly Contest 91</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-91/" class="article-date"><time datetime="2018-07-01T03:45:38.636Z" itemprop="datePublished">2018-07-01</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-91</p>
<p>&lt;!-- more --&gt;</p>
<h2>Lemonade Change</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/lemonade-change/</p>
<blockquote>
<p>At a lemonade stand, each lemonade costs <code>$5</code>.</p>
</blockquote>
<blockquote>
<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by <code>bills</code>).</p>
</blockquote>
<blockquote>
<p>Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>
</blockquote>
<blockquote>
<p>Note that you don't have any change in hand at first.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if you can provide every customer with correct change.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,10,20]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">From the first 3 customers, we collect three $5 bills in order.</span><br><span class="line">From the fourth customer, we collect a $10 bill and give back a $5.</span><br><span class="line">From the fifth customer, we give a $10 bill and a $5 bill.</span><br><span class="line">Since all customers got correct change, we output true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,10]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10,10,20]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">From the first two customers in order, we collect two $5 bills.</span><br><span class="line">For the next two customers in order, we collect a $10 bill and give back a $5 bill.</span><br><span class="line">For the last customer, we can&apos;t give change of $15 back because we only have two $10 bills.</span><br><span class="line">Since not every customer received correct change, the answer is false.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= bills.length &lt;= 10000</code></li>
<li><code>bills[i]</code> will be either <code>5</code>, <code>10</code>, or <code>20</code>.</li>
</ol>
<p>收到<code>10</code>时检查之前有没有收到至少一个<code>5</code>并找出，收到<code>20</code>时检查之前有没有收到<code>[10,5]</code>(优先)或者<code>[5,5,5]</code>并找出。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span><span class="params">(self, bills)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        income=[]</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="keyword">if</span> b==<span class="number">5</span>:</span><br><span class="line">                income.append(b)</span><br><span class="line">            <span class="keyword">elif</span> b==<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                    income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                    income.append(b)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                    income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">10</span> <span class="keyword">in</span> income:</span><br><span class="line">                        income.pop(income.index(<span class="number">10</span>))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                            income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> income:</span><br><span class="line">                                income.pop(income.index(<span class="number">5</span>))</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>All Nodes Distance K in Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/all-nodes-distance-k-in-binary-tree/</p>
<blockquote>
<p>We are given a binary tree (with root node <code>root</code>), a <code>target</code> node, and an integer value K.</p>
</blockquote>
<blockquote>
<p>Return a list of the values of all nodes that have a distance <code>K</code> from the <code>target</code> node.  The answer can be returned in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span><br><span class="line">Output: [7,4,1]</span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class="line">have values 7, 4, and 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note that the inputs &quot;root&quot; and &quot;target&quot; are actually TreeNodes.</span><br><span class="line">The descriptions of the inputs above are just serializations of these objects.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The given tree is non-empty and has at most <code>K</code> nodes.</li>
<li>Each node in the tree has unique values <code>0 &lt;= node.val &lt;= 500</code>.</li>
<li>The <code>target</code> node is a node in the tree.</li>
<li><code>0 &lt;= K &lt;= 1000.</code></li>
</ol>
<p>先进行一次后序遍历，找到根结点与<code>target</code>的距离，同时从根到<code>target</code>的路径上每一个结点到<code>target</code>的距离，再从根结点进行一次先序遍历，计算每个在后序遍历中没有被计算到<code>target</code>的距离，找到满足<code>=K</code>的所有结点。注意当<code>K=0</code>时直接返回<code>target.val</code>即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root, target, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> K==<span class="number">0</span>: <span class="keyword">return</span> [target.val]</span><br><span class="line">        d=&#123;target:<span class="number">0</span>&#125;</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> r==target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            dist_left,dist_right=post_order(r.left),post_order(r.right)</span><br><span class="line">            <span class="keyword">if</span> dist_left&gt;=<span class="number">0</span> <span class="keyword">or</span> dist_right&gt;=<span class="number">0</span>:</span><br><span class="line">                d[r]=max(dist_left,dist_right)+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[r]==K: res.append(r.val)</span><br><span class="line">                <span class="keyword">return</span> d[r]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                <span class="keyword">if</span> r.left <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[r.left]=d[r]+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[r.left]==K: res.append(r.left.val)</span><br><span class="line">                pre_order(r.left)</span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                <span class="keyword">if</span> r.right <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[r.right]=d[r]+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[r.right]==K: res.append(r.right.val)</span><br><span class="line">                pre_order(r.right)</span><br><span class="line"></span><br><span class="line">        post_order(root)</span><br><span class="line">        pre_order(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Score After Flipping Matrix</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/score-after-flipping-matrix/</p>
<blockquote>
<p>We have a two dimensional matrix <code>A</code> where each value is <code>0</code> or <code>1</code>.</p>
</blockquote>
<blockquote>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all <code>0</code>s to <code>1</code>s, and all <code>1</code>s to <code>0</code>s.</p>
</blockquote>
<blockquote>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
</blockquote>
<blockquote>
<p>Return the highest possible score.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br><span class="line">Explanation:</span><br><span class="line">Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20</code></li>
<li><code>1 &lt;= A[0].length &lt;= 20</code></li>
<li><code>A[i][j]</code> is <code>0</code> or <code>1</code>.</li>
</ol>
<p>直接的做法：先通过行变换把每行的最高位翻转成1，再通过列变换使得每列的1最多（如果该列的1不足半数则翻转）</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixScore</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n,m=len(A),len(A[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>]==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">if</span> sum([A[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)])&lt;n/<span class="number">2.0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum([int(<span class="string">''</span>.join([str(c) <span class="keyword">for</span> c <span class="keyword">in</span> r]),<span class="number">2</span>) <span class="keyword">for</span> r <span class="keyword">in</span> A])</span><br></pre></td></tr></table></figure></p>
<h2>Shortest Subarray with Sum at Least K</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-91/problems/shortest-subarray-with-sum-at-least-k/</p>
<blockquote>
<p>Return the <strong>length</strong> of the shortest, non-empty, contiguous subarray of <code>A</code> with sum at least <code>K</code>.</p>
</blockquote>
<blockquote>
<p>If there is no non-empty subarray with sum at least <code>K</code>, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1], K = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], K = 4</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,-1,2], K = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5</code></li>
<li><code>1 &lt;= K &lt;= 10 ^ 9</code></li>
</ol>
<p>因为有连续限定，直接莽上去也是可以解决的（但几乎一定TLE），受到<a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C++JavaPython-O(N)-Using-Deque" target="_blank" rel="noopener">这个解法</a>的启发，可以先计算<code>A</code>的前<code>n</code>个元素的和记为<code>S[n+1]</code>，这样<code>sum(A[j:i])</code>可以用<code>S[i]-S[j]</code>表示。对于每个<code>j&lt;i</code>，检查是否有<code>S[i]-S[j]&lt;=K</code>，如果满足，对于<code>j</code>来说满足要求且从<code>j</code>开始的最小子数组就是<code>A[j:i]</code>，之后不用继续检查大于<code>i</code>的终点。如果<code>j&lt;i</code>且有<code>S[i]&lt;=S[j]</code>，那么如果有一个<code>k</code>使得<code>S[k]-S[j]&gt;=K</code>必然有<code>S[k]-S[i]&gt;=K</code>，所以从<code>i</code>开始能找到更短的满足要求的子数组，同样的，接下来不用考虑以<code>j</code>为起点的子数组。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSubarray</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(A)</span><br><span class="line">        S=[<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        res=N+<span class="number">1</span></span><br><span class="line">        d=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            S[i+<span class="number">1</span>]=S[i]+A[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">and</span> S[i]-S[d[<span class="number">0</span>]]&gt;=K:</span><br><span class="line">                res=min(res,i-d.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">while</span> d <span class="keyword">and</span> S[i]&lt;=S[d[<span class="number">-1</span>]]:</span><br><span class="line">                d.pop()</span><br><span class="line">            d.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res&lt;N+<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度也为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-91/" data-id="cjuh9jx6f0042fww3bthmfa3r" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-90" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-90/">LeetCode Weekly Contest 90</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-90/" class="article-date"><time datetime="2018-06-24T03:04:18.514Z" itemprop="datePublished">2018-06-24</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-90</p>
<p>&lt;!-- more --&gt;</p>
<h2>Buddy Strings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/buddy-strings/</p>
<blockquote>
<p>Given two strings <code>A</code> and <code>B</code> of lowercase letters, return <code>true</code> if and only if we can swap two letters in A so that the result equals B.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aa&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aaaaaaabc&quot;, B = &quot;aaaaaaacb&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= B.length &lt;= 20000</code></li>
<li>A and B consist only of lowercase letters.</li>
</ol>
<p>时间来不及所以就写的比较丑陋，检查是否只有两个位置不同，是否可以交换。如果全相同，是否存在重复字符。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A)!=len(B):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        diff=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i]!=B[i]:</span><br><span class="line">                diff.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> diff:</span><br><span class="line">            <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> A[:i]+A[i+<span class="number">1</span>:]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(diff)!=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A[diff[<span class="number">0</span>]]==B[diff[<span class="number">1</span>]] <span class="keyword">and</span> B[diff[<span class="number">0</span>]]==A[diff[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure></p>
<h2>Score of Parentheses</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/score-of-parentheses/</p>
<blockquote>
<p>Given a balanced parentheses string <code>S</code>, compute the score of the string based on the following rule:</p>
</blockquote>
<ul>
<li><code>()</code> has score 1</li>
<li><code>AB</code> has score <code>A + B</code>, where A and B are balanced parentheses strings.</li>
<li><code>(A)</code> has score <code>2 * A</code>, where A is a balanced parentheses string.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(())&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()(()))&quot;</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> is a balanced parentheses string, containing only <code>(</code> and <code>)</code>.</li>
<li><code>2 &lt;= S.length &lt;= 50</code></li>
</ol>
<p>只有括号一种运算符，那么可以只用一个栈存操作数，每对一对括号完成求值就把值放入前一个操作数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        operand=[<span class="number">0</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">eval_par</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i]==<span class="string">'('</span>:</span><br><span class="line">                operand.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x=operand.pop()</span><br><span class="line">                <span class="keyword">if</span> len(operand)&gt;<span class="number">1</span>:</span><br><span class="line">                    operand[<span class="number">-1</span>]+=<span class="number">2</span>*eval_par(x)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    operand[<span class="number">-1</span>]+=eval_par(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> eval_par(operand[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<h2>Mirror Reflection</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/mirror-reflection/</p>
<blockquote>
<p>There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered <code>0</code>, <code>1</code>, and <code>2</code>.</p>
</blockquote>
<blockquote>
<p>The square room has walls of length <code>p</code>, and a laser ray from the southwest corner first meets the east wall at a distance <code>q</code> from the <code>0</code>th receptor.</p>
</blockquote>
<blockquote>
<p>Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: p = 2, q = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png" alt=""></p>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= p &lt;= 1000</code></li>
<li><code>0 &lt;= q &lt;= p</code></li>
</ol>
<p>直接算每个入射点和反射点的坐标也可以AC</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :type q: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">next_point</span><span class="params">(<span class="params">(x1,y1)</span>,<span class="params">(x2,y2)</span>,d)</span>:</span></span><br><span class="line">            dx,dy=(x2-x1)*d[<span class="number">0</span>],(y2-y1)*d[<span class="number">1</span>]</span><br><span class="line">            ks=[-x2/dx,(p-x2)/dx,-y2/dy,(p-y2)/dy]</span><br><span class="line">            i=min(range(<span class="number">4</span>),key=<span class="keyword">lambda</span> x: ks[x] <span class="keyword">if</span> ks[x]&gt;<span class="number">0</span> <span class="keyword">else</span> float(<span class="string">'inf'</span>))</span><br><span class="line">            k=ks[i]</span><br><span class="line">            temp=[(<span class="number">0</span>,y2+k*dy),(p,y2+k*dy),(x2+k*dx,<span class="number">0</span>),(x2+k*dx,p)]</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> temp[i],(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> temp[i],(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_receptors</span><span class="params">(<span class="params">(x,y)</span>)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> (i,(x0,y0)) <span class="keyword">in</span> enumerate([(p,<span class="number">0</span>),(p,p),(<span class="number">0</span>,p)]):</span><br><span class="line">                <span class="keyword">if</span> abs(x-x0)&lt;<span class="number">0.001</span> <span class="keyword">and</span> abs(y-y0)&lt;<span class="number">0.001</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        p1,p2,d=(<span class="number">0</span>,<span class="number">0</span>),(p,q),(<span class="number">-1.0</span>,<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> in_receptors(p2)&lt;<span class="number">0</span>:</span><br><span class="line">            next_p2,next_d=next_point(p1,p2,d)</span><br><span class="line">            p1,p2,d=p2,next_p2,next_d</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> in_receptors(p2)</span><br></pre></td></tr></table></figure></p>
<p>该轨迹每在水平方向运动<code>p</code>距离，会在竖直方向移动<code>q</code>距离，当两个方向经过的距离同时为<code>p</code>的整数倍时，遇到接收器。y方向第一次到达的<code>p</code>的整数倍是<code>lcm(p,q)</code>，在<code>y</code>方向上经过了<code>lcm(p,q)/p</code>个<code>p</code>，在x方向上经过了<code>lcm(p,q)/q</code>个<code>p</code>，每经历2个<code>p</code>则在坐标上往复一次，很容易找出这些数模2对应的接收器编号。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :type q: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        g=fractions.gcd(p,q)</span><br><span class="line">        <span class="comment"># the ray travels the distance p*q/g on y-axis direction and p*p/g on x-axis direction</span></span><br><span class="line">        <span class="keyword">if</span> q/g%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> p/g%<span class="number">2</span>==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> q/g%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> p/g%<span class="number">2</span>==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> q/g%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> p/g%<span class="number">2</span>==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2>Minimum Cost to Hire K Workers</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-90/problems/minimum-cost-to-hire-k-workers/</p>
<blockquote>
<p>There are <code>N</code> workers.  The <code>i</code>-th worker has a <code>quality[i]</code> and a minimum wage expectation <code>wage[i]</code>.</p>
</blockquote>
<blockquote>
<p>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:</p>
</blockquote>
<ol>
<li>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.</li>
<li>Every worker in the paid group must be paid at least their minimum wage expectation.
Return the least amount of money needed to form a paid group satisfying the above conditions.</li>
</ol>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: quality = [10,20,5], wage = [70,50,30], K = 2</span><br><span class="line">Output: 105.00000</span><br><span class="line">Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3</span><br><span class="line">Output: 30.66667</span><br><span class="line">Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= N &lt;= 10000</code>, where <code>N = quality.length = wage.length</code></li>
<li><code>1 &lt;= quality[i] &lt;= 10000</code></li>
<li><code>1 &lt;= wage[i] &lt;= 10000</code></li>
<li>Answers within <code>10^-5</code> of the correct answer will be considered correct.</li>
</ol>
<p>先按照<code>ratio[i]=wage[i]/quality[i]</code>进行排序，当<code>ratio[j]&lt;=ratio[i]</code>时，按照<code>ratio[i]</code>给第<code>j</code>个工人支付的报酬<code>ratio[i]*quality[j]&gt;=wage[i]</code>满足要求，因此对于每个<code>ratio[i]</code>只要找到<code>K</code>个满足<code>ratio[j]&lt;=ratio[i]</code>的最小的<code>quality[j]</code>的和再乘以<code>ratio[i]</code>就是支付的总额。</p>
<p>具体做法是在按照<code>ratio</code>给<code>quality</code>升序排序后，对于每个<code>i&gt;=K-1</code>，计算<code>ratio[i]*sum(nsmallest(K,quality[:i+1]))</code>取最小值。为了提高效率，可以维护一个大小为<code>K</code>的最大堆，遍历到<code>quality[i]</code>时如果比堆顶大则弹出堆顶压入<code>quality[i]</code>，再计算这<code>K</code>个<code>quality</code>的和与<code>ratio[i]</code>的乘积并与当前最小的支付组比较。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostToHireWorkers</span><span class="params">(self, quality, wage, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type quality: List[int]</span></span><br><span class="line"><span class="string">        :type wage: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rq=sorted([(<span class="number">1.0</span>*wage[i]/quality[i],quality[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(quality))])</span><br><span class="line">        q=[-qual <span class="keyword">for</span> ratio,qual <span class="keyword">in</span> rq[:K]]</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        q_sum=-sum(q)</span><br><span class="line">        res=rq[K<span class="number">-1</span>][<span class="number">0</span>]*q_sum</span><br><span class="line">        <span class="keyword">for</span> r,qual <span class="keyword">in</span> rq[K:]:</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">and</span> qual&lt;-q[<span class="number">0</span>]:</span><br><span class="line">                q_sum+=(qual+q[<span class="number">0</span>])</span><br><span class="line">                heapq.heapreplace(q,-qual)</span><br><span class="line">                res=min(res,r*q_sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-90/" data-id="cjuh9jx610040fww3haafb8ds" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-mathcs" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/MIT6-042/mathcs/">Math for CS 一周目阅读完成纪念！</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/MIT6-042/mathcs/" class="article-date"><time datetime="2018-06-18T16:00:00.000Z" itemprop="datePublished">2018-06-19</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MIT6-042/">MIT6.042</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>google books https://books.google.com/books?id=EdOQswEACAAJ</li>
<li>豆瓣读书主页 https://book.douban.com/subject/20472991/</li>
<li>2004版（339页）http://www.boazbarak.org/cs121/LehmanLeighton.pdf</li>
<li>2012版（800页） https://www.seas.harvard.edu/courses/cs20/MIT6_042Notes.pdf</li>
<li>2017版（1006页） https://courses.csail.mit.edu/6.042/spring17/mcs.pdf</li>
<li>2018版（1048页） https://courses.csail.mit.edu/6.042/spring18/mcs.pdf</li>
<li>MIT 6.042相关习题/材料 https://learning-modules.mit.edu/materials/index.html?uuid=/course/6/sp18/6.042#materials</li>
<li>MIT 6.042 2017 final https://courses.csail.mit.edu/6.042/spring17/finalS17.pdf</li>
</ul>
<hr>
<p>这本久负盛名的6.042同名教材Mathematics for Computer Science几乎每年随着MIT重新开设6.042更新一遍，从2004年单薄的339页到今年已经1000多页。第一次被介绍这本书是在Stanford的公开课<a href="https://www.coursera.org/learn/algorithm-design-analysis" target="_blank" rel="noopener">Algorithms: Design and Analysis</a>的延伸阅读材料里推荐了这本书2004版作为课程的数学基础参考，我也只通读了这一版的全部内容。</p>
<p>&lt;!-- more --&gt;</p>
<p>目前市面上没有正式出版过它的纸质书，它实质上只是MIT 6.042这门课的讲义集。相比附赠丰富习题集的2012以及后来版本，2004版339页的讲解内容显得清爽紧凑，但或许也因为只是电子版的讲义集，编写时间距今已久，其中存在不少可能会使人困扰的勘误。所以如果此时决定入手阅读这本书，可以从这一年最近的电子版开始，习题大部分也是值得一做的。比较遗憾的是，网上比较难找到这些习题的题解，我也在读完2004版开始<a href="http://notebook.xyli.me/MIT6-042/2017final/">尝试</a>着做了一下2017 final（欢迎和感谢有兴趣的朋友交流和指正），试图快速检验阅读成效和两版之间的区别，发现近年以来这本书也增加了很多有趣实用的概念和方法。</p>
<p>Mathematics for Computer Science这个标题试图涵盖的范围很大，让人无端联想到知乎式的提问</p>
<blockquote>
<p>我数学零基础，想当程序员，应该先从什么内容学起？</p>
</blockquote>
<p>在了解到这本书之前，被问到想学计算机应该学哪些数学，大概会很潦草模糊的回答就像大部分大学的CS本科生一样，学微积分，线性代数，离散数学，概率论……大概想学密码学还需要补一下数论等等建议。突然有了这么一本标题宏大的书似乎能一次性解决这个老生常谈的问题？不存在的，稍有常识的人都知道不可能有一本书能够一次打包计算机科学领域所需的全部数学工具，每当你想了解新理论和技术的基础，都几乎必须再去了解新的你所未曾了解过的数学知识。数学的应用和发展支持着计算机科学的常用常新，但反之计算机领域的新成果也一样深刻地影响着数学，用静态的眼光试图一劳永逸掌握计算机领域的所有数学不过是不切实际的幻想。那么为什么MIT还要开这门课呢？我们还有继续读这本书的必要吗？</p>
<p>当然有。MIT 6.042对于计算机基础薄弱的低年级本科生来说，是非常快速和实用的前导课程。这本书无法成为万用的灵丹妙药帮助任何人一步登天，但可以拉着初学者的手温柔平稳地把迷茫的他们送到美妙的计算机科学世界的门口。对于已经从事计算机工作或学习很久的读者来说，也同样可以通过它了解到自己可能忽视和遗忘的世界。应数风格的编书使得每个新概念都由一个具体的计算机问题引入，一步步手把手教你建模，用直观的方法解决和证明，然后引出更多在计算机领域相关的该概念应用。即使抛开这些工具的实用性，它们也本来就是很美好的东西，阅读这本书也可以仅凭直觉感受到这种让人拍案的精妙。</p>
<ul>
<li>Proofs 部分讲了逻辑规范表达，以及一般会用到的证明方法。不仅有归纳和反证等贯穿全书的证明工具，也有针对于可计算基础的递归定义的递归结构证明。这些都构成了good proof template的一部分。</li>
<li>Number Theory 部分以具体的Turing Code场景，展现了简洁的密码学发展史。</li>
<li>Communication Networks 部分介绍了图论的知识在现实的分组转发网络是如何运作的，以bufferfly模型为例引入分析整个网络的性能指标在不同的图结构下的差异。</li>
<li>Counting 部分介绍了复杂度理论常用的渐近工具的定义和用法，Generating Functions转换序列，以集合映射关系作为规范的计数基础，配合丰富的应用场景讲解计数方法，为后面的Probability部分打下坚实的铺垫。</li>
<li>Recurrences 部分为递归问题提供了强力的计算工具，解Linear Recurrences递推式同样给了很多动态规划问题另一种可能性。</li>
</ul>
<p>以上作为本科时学习过相关数学课程的我仍感到值得一读的地方，很多培养计划里面不会涉及这些内容或者只是草草带过。当然虽然名字叫Mathematics for Computer Science却完全没有涉及微积分或者线性代数任何相关基础知识，大概是默认这些内容需要另开课程详细讲解，其实对于其他出现在书中数学工具也是如此，它只能拉着你的手带你了解到有这些东西的存在，敲开它们的门还是需要你自己动手，主动去寻求更深入的用法。正如前文所说，不存在这样一劳永逸的包裹（正如<a href="https://book.douban.com/subject/4470166/" target="_blank" rel="noopener">Mathematics for Physics: A Guided Tour for Graduate Students</a>本质上也只是更深刻严谨的“标题党”，笑），想保持自己站在计算机科学技术的前沿，永远要不断去学习和开发新的数学工具，但这不影响这本书对于新手的巨大价值，以及系统和连贯讲解这些本质美丽自由之物的美感。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/MIT6-042/mathcs/" data-id="cjuh9jxac005jfww3j9rlu7os" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/书评/">书评</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-89" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-89/">LeetCode Weekly Contest 89</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-89/" class="article-date"><time datetime="2018-06-17T06:52:46.549Z" itemprop="datePublished">2018-06-17</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-89</p>
<p>&lt;!-- more --&gt;</p>
<h2>Peak Index in a Mountain Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/peak-index-in-a-mountain-array/</p>
<blockquote>
<p>Let's call an array <code>A</code> a mountain if the following properties hold:</p>
<ul>
<li><code>A.length &gt;= 3</code></li>
<li>There exists some <code>0 &lt; i &lt; A.length - 1</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
</blockquote>
<blockquote>
<p>Given an array that is definitely a mountain, return any <code>i</code> such that <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^6</code></li>
<li><code>A</code> is a mountain, as defined above.</li>
</ol>
<p>真没什么好说的，特别是还告诉你<code>A</code>肯定是个mountain</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i<span class="number">-1</span>]&lt;A[i] <span class="keyword">and</span> A[i]&gt;A[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<h2>Car Fleet</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/car-fleet/</p>
<blockquote>
<p><code>N</code> cars are going to the same destination along a one lane road.  The destination is <code>target</code> miles away.</p>
</blockquote>
<blockquote>
<p>Each car <code>i</code> has a constant speed <code>speed[i]</code> (in miles per hour), and initial position <code>position[i]</code> miles towards the target along the road.</p>
</blockquote>
<blockquote>
<p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p>
</blockquote>
<blockquote>
<p>The distance between these two cars is ignored - they are assumed to have the same position.</p>
</blockquote>
<blockquote>
<p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p>
</blockquote>
<blockquote>
<p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.</p>
</blockquote>
<blockquote>
<p>How many car fleets will arrive at the destination?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class="line">The car starting at 0 doesn&apos;t catch up to any other car, so it is a fleet by itself.</span><br><span class="line">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class="line">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= N &lt;= 10 ^ 4</code></li>
<li><code>0 &lt; target &lt;= 10 ^ 6</code></li>
<li><code>0 &lt; speed[i] &lt;= 10 ^ 6</code></li>
<li><code>0 &lt;= position[i] &lt; target</code></li>
<li>All initial positions are different.</li>
</ol>
<p>因为语言问题，一开始可能会疑惑成为车队后的速度到底是哪辆车原来的速度，其实是车队所有车速度的最小值。</p>
<p>先将车辆按照初始位置的降序排序，分别计算到达<code>target</code>所需的时间<code>time[i]</code>，如果该车辆到达终点的所需时间是当前最长，说明不会和前面任何车汇合，因此可以形成一个车队。反之如果时间小于前面任何一辆车，则会<s>追尾前面的一辆高级黑色车</s>有一个车队被赶上并汇合，不可能单独形成一个车队。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">carFleet</span><span class="params">(self, target, position, speed)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :type position: List[int]</span></span><br><span class="line"><span class="string">        :type speed: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur,res=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        time=[float(target-p)/s <span class="keyword">for</span> p,s <span class="keyword">in</span> sorted(zip(position,speed),reverse=<span class="keyword">True</span>)]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> time:</span><br><span class="line">            <span class="keyword">if</span> t&gt;cur:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">                cur=t</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$n\log(n)$，空间复杂度为$o(n)$</p>
<h2>Exam Room</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/exam-room/</p>
<blockquote>
<p>n an exam room, there are <code>N</code> seats in a single row, numbered <code>0, 1, 2, ..., N-1</code>.</p>
</blockquote>
<blockquote>
<p>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)</p>
</blockquote>
<blockquote>
<p>Return a class <code>ExamRoom(int N)</code> that exposes two functions: <code>ExamRoom.seat()</code> returning an <code>int</code> representing what seat the student sat in, and <code>ExamRoom.leave(int p)</code> representing that the student in seat number <code>p</code> now leaves the room.  It is guaranteed that any calls to <code>ExamRoom.leave(p)</code> have a student sitting in seat <code>p</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</span><br><span class="line">Output: [null,0,9,4,2,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">ExamRoom(10) -&gt; null</span><br><span class="line">seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.</span><br><span class="line">seat() -&gt; 9, the student sits at the last seat number 9.</span><br><span class="line">seat() -&gt; 4, the student sits at the last seat number 4.</span><br><span class="line">seat() -&gt; 2, the student sits at the last seat number 2.</span><br><span class="line">leave(4) -&gt; null</span><br><span class="line">seat() -&gt; 5, the student​​​​​​​ sits at the last seat number 5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
<li><code>ExamRoom.seat()</code> and <code>ExamRoom.leave()</code> will be called at most 10^4 times across all test cases.</li>
<li>Calls to <code>ExamRoom.leave(p)</code> are guaranteed to have a student currently sitting in seat number p.</li>
</ol>
<p>和上周的<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-88/#Maximize-Distance-to-Closest-Person">Maximize-Distance-to-Closest-Person</a>有点像，这里要求最近距离最大，那么就取两个被占座位中间的座位，为了以较小的成本维护有序<code>token</code>，需要在查找新座位时额外找到它在<code>token</code>的索引。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.N=N</span><br><span class="line">        self.token=[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_dist</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur,s,pos=self.token[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.token)<span class="number">-1</span>):</span><br><span class="line">            temp=int((self.token[i+<span class="number">1</span>]-self.token[i])/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> temp&gt;cur:</span><br><span class="line">                cur,s,pos=temp,self.token[i]+temp,i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.N<span class="number">-1</span>-self.token[<span class="number">-1</span>]&gt;cur:</span><br><span class="line">            s,pos=self.N<span class="number">-1</span>,len(self.token)</span><br><span class="line">        <span class="keyword">return</span> pos,s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.token:</span><br><span class="line">            self.token.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pos,s=self.max_dist()</span><br><span class="line">        self.token.insert(pos,s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leave</span><span class="params">(self, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.token.remove(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your ExamRoom object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = ExamRoom(N)</span></span><br><span class="line"><span class="comment"># param_1 = obj.seat()</span></span><br><span class="line"><span class="comment"># obj.leave(p)</span></span><br></pre></td></tr></table></figure></p>
<h2>K-Similar Strings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-89/problems/k-similar-strings/</p>
<blockquote>
<p>Strings <code>A</code> and <code>B</code> are <code>K</code>-similar (for some non-negative integer <code>K</code>) if we can swap the positions of two letters in <code>A</code> exactly <code>K</code> times so that the resulting string equals <code>B</code>.</p>
</blockquote>
<blockquote>
<p>Given two anagrams <code>A</code> and <code>B</code>, return the smallest <code>K</code> for which <code>A</code> and <code>B</code> are K-similar.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;abc&quot;, B = &quot;bca&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;abac&quot;, B = &quot;baca&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aabc&quot;, B = &quot;abca&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length == B.length &lt;= 20</code></li>
<li><code>A</code> and <code>B</code> contain only lowercase letters from the set <code>{'a', 'b', 'c', 'd', 'e', 'f'}</code></li>
</ol>
<p>第一反应就是BFS，有点像<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-64/#Open-the-Lock">Open the Lock</a>而且远远没有那么麻烦，生成新的结点时注意当<code>s[j]==b[j]</code>或者<code>s[j]!=b[i]</code>时，交换<code>i,j</code>所在位置的字符并不能使<code>s</code>和<code>B</code>“更加相似”。这个做法是符合直觉的，当你要面对这些交换工作时，也是想着如何从左到右，用后面的字符交换当前第一个不匹配的字符，直到把每个字符匹配正确。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSimilarity</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> A==B:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        seen=&#123;A&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,A)]</span><br><span class="line">        n=len(A)</span><br><span class="line">        <span class="keyword">for</span> step,s <span class="keyword">in</span> q:</span><br><span class="line">            i=<span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> s[i]==B[i]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> s[j]!=B[j] <span class="keyword">and</span> s[i]==B[j]:</span><br><span class="line">                    temp=s[:i]+s[j]+s[i+<span class="number">1</span>:j]+s[i]+s[j+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> temp==B:</span><br><span class="line">                        <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                            q.append((step+<span class="number">1</span>,temp))</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-89/" data-id="cjuh9jx5w003yfww3wpfcdje0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-2017final" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/MIT6-042/2017final/">试着做一下MIT 6.042的期末题</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/MIT6-042/2017final/" class="article-date"><time datetime="2018-06-15T06:29:01.762Z" itemprop="datePublished">2018-06-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MIT6-042/">MIT6.042</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>2017年的math for cs期末题，180分钟，原题挂在了 https://courses.csail.mit.edu/6.042/spring17/finalS17.pdf 但题解需要MIT注册学生的权限，我暂时也找不到。只能自己尝试着做一份题解，可能（几乎一定）存在错误，先预先感谢一下愿意指出和纠正交流者。</p>
<p>&lt;!-- more --&gt;</p>
<hr>
<h2>Problem 1 Simple Graphs &amp; Trees</h2>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$${41 \choose 2}$$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p><s>完全图中每个顶点都必然与其他所有顶点邻接，$K_{41}$只有1种结构</s>
<strong>2019/1/11更新</strong>：上面的解答是错误的，题目问的是$K_{41}$到$K_{41}$有多少种同构，即点集$V$到$V$有多少个双射可以保证变换后的图还是原来的$K_{41}$，因为是完全图， 所有双射都是可行的，一共$41!$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>$C_{41}$已经是规定了边集顺序的特定的环，而不是一般意义上的顶点数为41的环</p>
<blockquote>
<p>isomorphisms from $C_{41}$ to $C_{41}$</p>
</blockquote>
<p><s>这个说法有点奇怪，我暂且理解为问题中的$C_{41}$有多少isomorphisms</s></p>
<p><s>选择从环的一个顶点开始依次放置41个顶点，这里有$41!$种排列的方法，而起始顶点之间又是等效的，因此共有$41!/41=40!$种同构。</s></p>
<p><strong>2019/1/11更新</strong>：上面的理解和做法都是错误的，还是刚才的问题，有多少种$V$到$V$的双射可以保证从原来的$C_{41}$变换过来还是$C_{41}$，变换只有两种方向的旋转，因此答案是$2\times 41$种。</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>众所周知，有$\chi \left( {K_n} \right) = n$，所以$\chi \left( K_{41} \right) = 41$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; e</h4>
<p>同样，我们知道$\chi \left( C_{odd} \right) = 3$，所以$\chi \left( C_{41} \right) = 3$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; f</h4>
<p>41个结点的树的边数$\left| E \right| = \left| V \right| - 1 = 40$</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; g</h4>
<p>移除$C_{41}$的任意一条边都可以得到$C_{41}$的一个独特的生成树（实际上是路径），因此生成树的数量就是边数41</p>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; h</h4>
<p>$K_{41}$的任意两个顶点之间直接由边连通，找长度为10的路径数可以通过找11个顶点组成的不同序列数即${}^{41}{P_{11}}$，路径的起点与终点不作区分，因此为${}^{41}{P_{11}}/2=41!/(2 \cdot 30!)$</p>
</div></p>
<h2>Problem 2 Quantifiers</h2>
<p><s>就是problem 3.43 原题</s></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>i.o.的限制只要求使得$R(n)$为真的$n$有无限多个，可以是
${\bf{Q}}_1$: $\forall {n_0}$
${\bf{Q}}_2$: $\exists n \ge {n_0}$
如果这样的集合是有限的，那么该集合存在一个最大的$n_0$，对于$n_0+1$也存在一个$n \ge n_0+1&gt;n_0$使$R(n)$为真，这与$n_0$是该集合最大值矛盾，故该集合有限的假设不成立。使得$R(n)$成立的$n$构成无限集。</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>a.e.严格规定了使$R(n)$为假的$n$只能为有限个，可以是
${\bf{Q}}_3$: $\exists {n_0}$
${\bf{Q}}_4$: $\forall n \ge {n_0}$
仅当$n&lt;n_0$时$S(n)$可能为假，则这样$n$数量不可能超过$n_0$的最小值，使$S(n)$为假的$n$是有限的。</p>
</div></p>
<h2>Problem 3 Logical Injections</h2>
<p><s>problem 4.43 原题简化</s></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>找到使得$R$为单射关系的充分条件</p>
<ul>
<li>&lt;i class=&quot;fa fa-square-o&quot;&gt;&lt;/i&gt; (i) $R(x)$和$R(y)$都是集合，只要里面的元素不完全相同就可以取到$\ne$，二者仍然可能交集不为空，在交集中的点存在$\ge 2$条入边，不符合单射关系。</li>
<li>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; (ii) 不同的$x$和$y$无法通过$R$与同一个点连接，即陪域上不存在超过1的点，符合单射的定义。</li>
<li>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; (iii) 任意$x$指向的点只被$\le 1$个点指向，如果$x$出度不为0，则这个点就是$x$，如果$x$出度为0，则为空集。</li>
<li>&lt;i class=&quot;fa fa-square-o&quot;&gt;&lt;/i&gt; (iv) 任意$x$指向的点至少被$\ge 1$个点指向，这是不符合单射定义的。</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>$not(S ; inj ; [0,1]) \iff not([0,1] ; surj ; S) \iff A ; strict ;  B$
找一个严格小于$[0,1]$的无穷集就可以了，最简单的构造$pow([0,1])$</p>
</div></p>
<h2>Problem 4 Number Theory</h2>
<p><s>类似原题在problem 9.10</s></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>True</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>(ii)</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>False</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>$\gcd \left(a^2,b^2 \right) = \left( \gcd \left( a,b \right)\right)^2$
(iii)</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; e</h4>
<p>(iv)</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; f</h4>
<p>True</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; g</h4>
<p><s>Fermat小定理要求(i)+(vii)就够了，但只能选一项就选(viii)</s>
<strong>2019/1/11更新</strong>：Fermat小定理只需要(vii)就足够了，在(i)条件不成立时$a^b \bmod b=a \bmod b=0$也是满足等式的，所以不用满足(i)</p>
</div></p>
<h2>Problem 5 Counting</h2>
<p><s>原题 Problem 15.43</s>
<div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p><s>原结论见Problem 15.7</s>
(2)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>(1)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>(8)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>(7)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; e</h4>
<p>(8)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; f</h4>
<p>(1)</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; g</h4>
<p>(5)</p>
</div></p>
<h2>Problem 6 Structural Induction</h2>
<p>不太想写证明，特别是这种自娱自乐的recursive definitions的structural induction真没什么意思，随便写写吧，不用当真。</p>
<p>命题：对于任意Atrig $f(x)$，其导函数也是Atrig
<div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Base Case</h4>
<ul>
<li>当$f(x)=id(x)$时，导函数$f'(x)=1$是常函数，所以是Atrig</li>
<li>当$f(x)=c$为常函数时，导函数$f'(x)=0$是常函数，所以是Atrig</li>
<li>当$f(x)=\sin(x)$时，导函数$f'(x)=\cos(x)=\sin(x-\pi/2)$，$y=x$是Atrig，$y=\pi/2$也是Atrig，这两个函数的和$y=x-\pi/2$根据递归定义Atrig函数的和也是Atrig，那它与另一个Atrig函数$y=\sin(x)$的复合结构根据递归定义也是Atrig，即$f'$是Atrig</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Constructor case</h4>
<p>假设对于$f$和$g$，都有$f'$和$g'$也为Atrig成立</p>
<ul>
<li>$(f+g)'=f'+g'$，因为$f'$和$g'$都是Atrig，$(f+g)'$也是Atrig</li>
<li>$(f \cdot g)'=f \cdot g'+f' \cdot g$，$f$和$g'$都是Atrig，所以二者的乘积$f \cdot g'$也是Atrig，同理$f' \cdot g$也是，它们的和也是，所以$(f \cdot g)'$是Atrig</li>
<li>$\left( f \circ g \right)'= g' \cdot \left( {f' \circ g} \right)$，$f'$和$g$都是Atrig，所以$f' \circ g$也是Atrig，又因为$g'$是Atrig，所以它们的乘积即$\left( f \circ g \right)'$也是Atrig</li>
</ul>
</div></p>
<p>综上所述，该命题成立。</p>
<h2>Problem 7 Probable Satisfiability</h2>
<p><s>原题Promblem 19.22</s></p>
<p>不严格按照概率和期望的格式来写了</p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$1-1/2^3=7/8$</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>每个3-clause为真的期望为$7/8$，真3-clause数量的期望为$7/8 \times 7=49/8$</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>假设$G$是不可能为真的，即真3-clause数量$X$有$Pr(X=7)=0$
&lt;span&gt;$$\begin{align}
Ex\left( X \right) &amp; = \sum\limits_{i = 0}^6 {i \cdot \Pr \left( {X = i} \right)} \\
&amp; \le \sum\limits_{i = 0}^6 {6 \cdot \Pr \left( {X = i} \right)} \\
&amp; = 6
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;
与b的答案$Ex(X)&gt;6$矛盾，所以假设不成立，$G$是可以满足的。</p>
</div></p>
<h2>Problem 8 Connectivity, Induction</h2>
<p><s>Problem 12.64</s></p>
<p>我不太会写证明，也懒得再开TeX画图了，就简单说下思路，等有空了再补上严谨的证明和示意图。<s>（这句话的意思就是以后也不会写的啦）</s></p>
<p>题给的结论是完全符合直觉的：想象一个长度为$m$的路径上面所有结点都是hub，除了两个结点各可以连接4个computer，其他中间的hub都可以连接3个computer，这是图上所有hub能容纳的最大computer数量($n=8+3(m-2)$)，此时如果增加$[1,3]$个computer，只需要在路径中间添加一个hub</p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Base Case</h4>
<p>当$n \le 8$时：</p>
<ul>
<li>当$2 \le n \le 5$时： 以一个hub为中心连接所有computer的星状网络可以使结论成立</li>
<li>当$6 \le n \le 8$时: 两个直接相连的hub各自剩下的4个可以连接的位置最多容纳数为8，可以满足只用2个hub的要求</li>
</ul>
</div></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; Inductive Step</h4>
<p>假设对于$x&gt;1$和$0 \le y &lt;3$，$n=3x+2-y$，可以找到只用$x$个hub的组装方法，即长度为$x$的hub路径</p>
<ul>
<li>当$y=0$时，当增加一个computer时可以在路径中间增加一个hub并与其连接，此时共有$x+1$个hub，$\left\lceil {\left( {n+1 - 2} \right)/3} \right\rceil=\left\lceil {\left( {3x + 3} \right)/3} \right\rceil =x+1$</li>
<li>当$y&gt;0$时，路径上必然有一个hub的度&lt;5，再增加一个computer时，连接在这个$hub$上即可，还是只需要$x$个hub，$\left\lceil {\left( {n+1 - 2} \right)/3} \right\rceil=\left\lceil {\left( {3x + 3-y} \right)/3} \right\rceil =x$</li>
</ul>
</div>
综上所述，对于$n$个computer，只需要$\left\lceil {\left( {n - 2} \right)/3} \right\rceil$个hub即可组装cluster</p>
<h2>Problem 9 Conditional Probability</h2>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$\Pr(E|R)&gt;\Pr(E|B)$</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>$\Pr(R|E)&gt;\Pr(B|E)$</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>已知$Pr(A)=Pr(B)$
&lt;span&gt;$$\begin{align}
\Pr(E|R) &amp; &gt;\Pr(E|B) \\
\Pr(E|R) \cdot \Pr(R) / \Pr(E) &amp; &gt; \Pr(E|B) \cdot \Pr(B) / \Pr(E) \\
\Pr(R|E) &amp;&gt; \Pr(B|E)
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;</p>
</div></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>不能，当$\Pr(R)/\Pr(B) \le \Pr(E|B)/\Pr(E|R)$时不成立</p>
</div></p>
<h2>Problem 10 Expectation, Sums</h2>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>$Ex(X_i) = 5/4$
$Ex\left( {X_1} \ldots {X_k} \right) \cdot $ 1,000,000 = {\left( 5/4 \right)}^k \cdot $ 1,000,000$</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>&lt;span&gt;$$\begin{align}
&amp; \left( {1/10} \right) \cdot \left( Ex({X_1}) + Ex({X_1}{X_2}) +  \ldots  + Ex({X_1}{X_2} \ldots X_{10}) \right) \cdot {10^6}\\
= &amp; (1/10) \cdot \left( 5/4 \right) \cdot \left(\frac{1 - {\left( 5/4 \right)}^{10}}{1 - 5/4} \right) \cdot 10^6\\
\approx &amp; 4,156,613
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;</p>
</div></p>
<p><div class="bs-callout bs-callout-info"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<p>$Ex\left( 2^Y \right) \ne 2^{Ex\left( Y \right)}$</p>
</div></p>
<h2>Problem 11 Chebyshev Bound</h2>
<p><s>原题Problem 20.5</s></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; a</h4>
<p>collection-variance与Chebyshev边界的方差定义是一致的，用概率和统计转换一下可以推导。
$\Pr \left(\left|T - Ex(T) \right| \ge 10 \right) \le \frac{CVar(A)}{10^2} = 0.2$</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; b</h4>
<p>outcomes: all the body temperatures
每个outcome的概率相等，假设牛的数量为$n$，那么概率为$1/n$</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; c</h4>
<blockquote>
<p>Explain why for this probability space, the fraction of cows with any given cow property $P$ is the same as $\Pr[P]$.</p>
</blockquote>
<p>我没看懂这个问题的意思，是问为什么每头牛的体温的概率分布都一样吗？</p>
</div></p>
<p><div class="bs-callout bs-callout-primary"><h4>&lt;i class=&quot;fa fa-bookmark-o&quot;&gt;&lt;/i&gt; d</h4>
<p>令$A$为这群牛所有体温数的集合
&lt;span&gt;$$\begin{align}
CVar(A) &amp; =  \frac{\sum\nolimits_{t \in A} {\left( t - Ex\left( T \right)\right)}^2 }{n}  \\
&amp; = \sum\nolimits_{t \in A} {\Pr[T=t] \cdot ( t - Ex( T))^2} \\
&amp; = \sum\nolimits_{t \in A} {\Pr[(T-Ex(T))^2 = (t - Ex(T)))^2] \cdot ( t - Ex( T))^2} \\
&amp; = Ex[(T - Ex(T))^2] \\
&amp; = Var[T]
\end{align}$$&lt;/span&gt;&lt;!-- Has MathJax --&gt;</p>
</div></p>
<h2>Problem 12 Random Walk, Expectation</h2>
<p>似乎并不要求解出方程</p>
<p>$$a=p_{AC} + p_{AB} (1+b) + p_{AA} (1+a)$$ $$b=p_{BC} + p_{BB} (1+b) + p_{BA} (1+a)$$</p>
<h2>Problem 13 Sampling &amp; Confidence</h2>
<p>这一问也是不要求具体计算的，虽然二项分布算方差也没什么麻烦的。</p>
<p>$\epsilon$取0.006，找到令$f(0.006,n_0) \le 0.03$的最小$n_0$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/MIT6-042/2017final/" data-id="cjuh9jwp60001fww3qz8srwjm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/5/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li class="active"><span class="page-number">6</span></li><li><a class="page-number" href="/page/7/">7</a></li><li><a class="page-number" href="/page/8/">8</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/7/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
