<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/7/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-88" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-88/">LeetCode Weekly Contest 88</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-88/" class="article-date"><time datetime="2018-06-10T12:17:08.175Z" itemprop="datePublished">2018-06-10</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-88/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Shifting Letters</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/shifting-letters/</p>
<blockquote>
<p>We have a string S of lowercase letters, and an integer array shifts.</p>
</blockquote>
<blockquote>
<p>Call the shift of a letter, the next letter in the alphabet, (wrapping around so that <code>'z'</code> becomes <code>'a'</code>).</p>
</blockquote>
<blockquote>
<p>For example, <code>shift('a') = 'b'</code>, s<code>hift('t') = 'u'</code>, <code>and shift('z') = 'a'</code>.</p>
</blockquote>
<blockquote>
<p>Now for each <code>shifts[i] = x</code>, we want to shift the first <code>i+1</code> letters of <code>S</code>, <code>x</code> times.</p>
</blockquote>
<blockquote>
<p>Return the final string after all such shifts to <code>S</code> are applied.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abc&quot;, shifts = [3,5,9]</span><br><span class="line">Output: &quot;rpl&quot;</span><br><span class="line">Explanation:</span><br><span class="line">We start with &quot;abc&quot;.</span><br><span class="line">After shifting the first 1 letters of S by 3, we have &quot;dbc&quot;.</span><br><span class="line">After shifting the first 2 letters of S by 5, we have &quot;igc&quot;.</span><br><span class="line">After shifting the first 3 letters of S by 9, we have &quot;rpl&quot;, the answer.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length = shifts.length &lt;= 20000</code></li>
<li><code>0 &lt;= shifts[i] &lt;= 10 ^ 9</code></li>
</ol>
<p>难度被标记为<code>Medium</code>有些夸张，大概主要是要对<code>shifts</code>处理一下，每个元素还要加上后面所有元素的和。不过这题也是够直接和无聊的</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shiftingLetters</span><span class="params">(self, S, shifts)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type shifts: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        S=list(S)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(shifts)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            shifts[i]+=shifts[i+<span class="number">1</span>]%<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            S[i]=chr((ord(S[i])+shifts[i]-ord(<span class="string">'a'</span>))%<span class="number">26</span>+ord(<span class="string">'a'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(S)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$</p>
<h2>Maximize Distance to Closest Person</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/maximize-distance-to-closest-person/</p>
<blockquote>
<p>In a row of <code>seats</code>, <code>1</code> represents a person sitting in that seat, and <code>0</code> represents that the seat is empty.</p>
</blockquote>
<blockquote>
<p>There is at least one empty seat, and at least one person sitting.</p>
</blockquote>
<blockquote>
<p>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.</p>
</blockquote>
<blockquote>
<p>Return that maximum distance to closest person.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0,1,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.</span><br><span class="line">If Alex sits in any other open seat, the closest person has distance 1.</span><br><span class="line">Thus, the maximum distance to the closest person is 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">If Alex sits in the last seat, the closest person is 3 seats away.</span><br><span class="line">This is the maximum distance possible, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= seats.length &lt;= 20000</code></li>
<li><code>seats</code> contains only 0s or 1s, at least one <code>0</code>, and at least one <code>1</code>.</li>
</ol>
<p>比上一题还要简单一些，两个<code>1</code>中间的位置，<code>seats[0]</code>，<code>seats[-1]</code>都可能成为使最近人最远的选座，找到最大值即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(self, seats)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type seats: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seats)) <span class="keyword">if</span> seats[i]]</span><br><span class="line">        gap=[int((token[i]-token[i<span class="number">-1</span>])/<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(token))]</span><br><span class="line">        <span class="keyword">return</span> max(gap+[token[<span class="number">0</span>],len(seats)<span class="number">-1</span>-token[<span class="number">-1</span>]])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度为$o(n)$</p>
<h2>Loud and Rich</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/loud-and-rich/</p>
<blockquote>
<p>n a group of N people (labelled <code>0, 1, 2, ..., N-1</code>), each person has different amounts of money, and different levels of quietness.</p>
</blockquote>
<blockquote>
<p>For convenience, we'll call the person with label <code>x</code>, simply &quot;person <code>x</code>&quot;.</p>
</blockquote>
<blockquote>
<p>We'll say that <code>richer[i] = [x, y]</code> if person <code>x</code> definitely has more money than person <code>y</code>.  Note that <code>richer</code> may only be a subset of valid observations.</p>
</blockquote>
<blockquote>
<p>Also, we'll say <code>quiet[x] = q</code> if person x has quietness <code>q</code>.</p>
</blockquote>
<blockquote>
<p>Now, return <code>answer</code>, where <code>answer[x] = y</code> if <code>y</code> is the least quiet person (that is, the person y with the smallest value of <code>quiet[y]</code>), among all people who definitely have equal to or more money than person <code>x</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]</span><br><span class="line">Output: [5,5,2,5,4,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line">answer[0] = 5.</span><br><span class="line">Person 5 has more money than 3, which has more money than 1, which has more money than 0.</span><br><span class="line">The only person who is quieter (has lower quiet[x]) is person 7, but</span><br><span class="line">it isn&apos;t clear if they have more money than person 0.</span><br><span class="line"></span><br><span class="line">answer[7] = 7.</span><br><span class="line">Among all people that definitely have equal to or more money than person 7</span><br><span class="line">(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])</span><br><span class="line">is person 7.</span><br><span class="line"></span><br><span class="line">The other answers can be filled out with similar reasoning.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= quiet.length = N &lt;= 500</code></li>
<li><code>0 &lt;= quiet[i] &lt; N</code>, all <code>quiet[i]</code> are different.</li>
<li><code>0 &lt;= richer.length &lt;= N * (N-1) / 2</code></li>
<li><code>0 &lt;= richer[i][j] &lt; N</code></li>
<li><code>richer[i][0] != richer[i][1]</code></li>
<li><code>richer[i]</code>'s are all different.</li>
<li>The observations in <code>richer</code> are all logically consistent.</li>
</ol>
<p>这问题背景的描述实在过于意义不明，我没有仔细看题，也没详细的去测试test case，我所理解的<code>richer</code>在逻辑上的一致，是指以<code>richer</code>关系为有向边构造出来的图中不存在环，那么可能是全序的路径，可能是树，也可能是不联通的森林，无所谓了，总之对每个结点只要找到子树中<code>quiet</code>最小的元素再和该结点的<code>quiet</code>比较就可以得到<code>answer[i]</code>了，很朴素的分治递归问题。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(self, richer, quiet)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type richer: List[List[int]]</span></span><br><span class="line"><span class="string">        :type quiet: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(quiet)</span><br><span class="line">        g=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        res=[<span class="number">-1</span>]*N</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loudest</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> res[i]&gt;<span class="number">0</span>: <span class="keyword">return</span> res[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> g[i]:</span><br><span class="line">                res[i]=i</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[i]=min([loudest(j) <span class="keyword">for</span> j <span class="keyword">in</span> g[i]]+[i],key=<span class="keyword">lambda</span> x:quiet[x])</span><br><span class="line">                <span class="keyword">return</span> res[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> richer:</span><br><span class="line">            g[y].append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> res[i]&lt;<span class="number">0</span>:</span><br><span class="line">                loudest(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$，空间复杂度为$o(N^2)$</p>
<h2>Rectangle Area II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-88/problems/rectangle-area-ii/</p>
<blockquote>
<p>We are given a list of (axis-aligned) rectangles.  Each <code>rectangle[i] = [x1, y1, x2, y2]</code> , where <code>(x1, y1)</code> are the coordinates of the bottom-left corner, and <code>(x2, y2)</code> are the coordinates of the top-right corner of the <code>i</code>th rectangle.</p>
</blockquote>
<blockquote>
<p>Find the total area covered by all <code>rectangles</code> in the plane.  Since the answer may be too large, <strong>return it modulo 10^9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,2,2],[1,0,2,3],[1,0,3,1]]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: As illustrated in the picture.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1000000000,1000000000]]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The answer is 10^18 modulo (10^9 + 7), which is (10^9)^2 = (-7)^2 = 49.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= rectangles.length &lt;= 200</code></li>
<li><code>rectanges[i].length = 4</code></li>
<li><code>0 &lt;= rectangles[i][j] &lt;= 10^9</code></li>
<li>The total area covered by all rectangles will never exceed <code>2^63 - 1</code> and thus will fit in a 64-bit signed integer.</li>
</ol>
<p>根据所有矩形的水平边（即<code>y</code>值）对整个图像进行分片，计算每个分片中的<code>x</code>范围长度与分片高度的乘积，再累加所有分片的计算结果。可以先按照底边<code>y</code>值进行排序，把每个底边在<code>upper</code>以下的矩形放入分片，顶边在达到<code>upper</code>在计算完分片中覆盖面积后删除。注意结果需要模<code>10^9 + 7</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectangleArea</span><span class="params">(self, rectangles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rectangles: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge_x_range</span><span class="params">(rlist)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> rlist: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            rlist.sort()</span><br><span class="line">            start,end=rlist[<span class="number">0</span>][<span class="number">0</span>],rlist[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">            res=[]</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> rlist:</span><br><span class="line">                <span class="keyword">if</span> r[<span class="number">0</span>]&lt;=end:</span><br><span class="line">                    end=max(r[<span class="number">2</span>],end)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append((start,end))</span><br><span class="line">                    start,end=r[<span class="number">0</span>],r[<span class="number">2</span>]</span><br><span class="line">            res.append((start,end))</span><br><span class="line">            <span class="keyword">return</span> sum(j-i <span class="keyword">for</span> i,j <span class="keyword">in</span> res)</span><br><span class="line"></span><br><span class="line">        area=<span class="number">0</span></span><br><span class="line">        rectangles.sort(key=<span class="keyword">lambda</span> r:(r[<span class="number">1</span>],r[<span class="number">3</span>]))</span><br><span class="line">        y=sorted(set([r[<span class="number">1</span>] <span class="keyword">for</span> r <span class="keyword">in</span> rectangles]+[r[<span class="number">3</span>] <span class="keyword">for</span> r <span class="keyword">in</span> rectangles]))</span><br><span class="line">        temp=[]</span><br><span class="line">        upper=y.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> y:</span><br><span class="line">            lower,upper=upper,y.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> rectangles <span class="keyword">and</span> rectangles[<span class="number">0</span>][<span class="number">1</span>]&lt;upper:</span><br><span class="line">                temp.append(rectangles.pop(<span class="number">0</span>))</span><br><span class="line">            area+=(upper-lower)*merge_x_range(temp)</span><br><span class="line">            area%=(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">while</span> temp:</span><br><span class="line">                h=min(range(len(temp)),key=<span class="keyword">lambda</span> x:temp[x][<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">if</span> temp[h][<span class="number">3</span>]!=upper: <span class="keyword">break</span></span><br><span class="line">                temp.pop(h)</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度可以达到$o(N\log N)$，当然我这里在计算<code>x</code>范围的过程写的很不好，拖慢了速度。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-88/" data-id="cjuh9jx5n003wfww3veuoevc0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-87" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-87/">LeetCode Weekly Contest 87</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-87/" class="article-date"><time datetime="2018-06-03T07:55:34.617Z" itemprop="datePublished">2018-06-03</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-87</p>
<p>&lt;!-- more --&gt;</p>
<h2>Backspace String Compare</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/backspace-string-compare/</p>
<blockquote>
<p>Given two strings <code>S</code> and <code>T</code>, return if they are equal when both are typed into empty text editors. <code>#</code> means a backspace character.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>1 &lt;= T.length &lt;= 200</code></li>
<li><code>S</code> and <code>T</code> only contain lowercase letters and <code>'#'</code> characters.</li>
</ol>
<p>直接比较退格处理后的字符串，可能需要注意一下，当前面没有字符的时候退格符不进行任何操作。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">output_text</span><span class="params">(s)</span>:</span></span><br><span class="line">            res=<span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> c==<span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">if</span> res:</span><br><span class="line">                        res=res[:<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>: res+=c</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output_text(S)==output_text(T)</span><br></pre></td></tr></table></figure></p>
<h2>Longest Mountain in Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/longest-mountain-in-array/</p>
<blockquote>
<p>Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:</p>
</blockquote>
<ul>
<li><code>B.length &gt;= 3</code></li>
<li>There exists some<code>0 &lt; i &lt; B.length - 1</code> such that<code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code>
(Note that B could be any subarray of A, including the entire array A.)</li>
</ul>
<blockquote>
<p>Given an array <code>A</code> of integers, return the length of the longest mountain.</p>
</blockquote>
<blockquote>
<p>Return <code>0</code> if there is no mountain.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,4,7,3,2,5]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no mountain.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<p>直接按照题意，先找到上升开始的地方，再找到顶点，然后找到下坡的终点。很容易实现的线性扫描。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,cur,pos=<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_start</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> pos+<span class="number">2</span>&lt;len(A) <span class="keyword">and</span> A[pos]&gt;=A[pos+<span class="number">1</span>]:</span><br><span class="line">                pos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_end</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> pos+<span class="number">1</span>&lt;len(A) <span class="keyword">and</span> A[pos]&gt;A[pos+<span class="number">1</span>]:</span><br><span class="line">                pos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_peak</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> pos+<span class="number">2</span>&lt;len(A) <span class="keyword">and</span> A[pos]&lt;A[pos+<span class="number">1</span>]:</span><br><span class="line">                pos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">        i=find_start(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> i&lt;len(A)<span class="number">-2</span>:</span><br><span class="line">            p=find_peak(i)</span><br><span class="line">            <span class="keyword">if</span> p&lt;len(A)<span class="number">-1</span>:</span><br><span class="line">                e=find_end(p)</span><br><span class="line">                <span class="keyword">if</span> e&gt;p+<span class="number">1</span>: res=max(res,e-i)</span><br><span class="line">                p=e<span class="number">-1</span></span><br><span class="line">            i=find_start(p)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Hand of Straights</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/hand-of-straights/</p>
<blockquote>
<p>Alice has a <code>hand</code> of cards, given as an array of integers.</p>
</blockquote>
<blockquote>
<p>Now she wants to rearrange the cards into groups so that each group is size<code>W</code>, and consists of <code>W</code> consecutive cards.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if she can.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hand = [1,2,3,6,2,3,4,7,8], W = 3</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice&apos;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hand = [1,2,3,4,5], W = 4</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice&apos;s hand can&apos;t be rearranged into groups of 4.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= hand.length &lt;= 10000</code></li>
<li><code>0 &lt;= hand[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= W &lt;= hand.length</code></li>
</ol>
<p>既然每个数都必须在且仅在一个长度为<code>W</code>的序列，那么对升序排序后的数组，抽出最小的数开始寻找剩下的<code>W-1</code>个数在不在数组内，在则取出，不在则直接返回<code>False</code>。时间开销主要在寻址，因此可以考虑用基于hash表的效率实现来表达数组中的所有元素，比如<code>SortedDict</code>之类的，这里用的是<code>Counter</code>，在计数值减到0时直接删去该项，而用<code>+=Counter()</code>这样传统的计数器维护操作为极大增加时间成本。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNStraightHand</span><span class="params">(self, hand, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type hand: List[int]</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span>            </span><br><span class="line">        <span class="keyword">if</span> len(hand)%W != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        k=len(hand)/W</span><br><span class="line">        counter=collections.Counter(hand)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            cur=min(counter)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(W):</span><br><span class="line">                <span class="keyword">if</span> cur+j <span class="keyword">in</span> counter:</span><br><span class="line">                    counter[cur+j]-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> counter[cur+j]==<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">del</span> counter[cur+j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(\max (n,n\log(n)/W))$，空间复杂度为$o(n)$</p>
<h2>Shortest Path Visiting All Nodes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-87/problems/shortest-path-visiting-all-nodes/</p>
<blockquote>
<p>An undirected, connected graph of N nodes (labeled <code>0, 1, 2, ..., N-1</code>) is given as graph.</p>
</blockquote>
<blockquote>
<p><code>graph.length = N</code>, and <code>j != i</code> is in the list <code>graph[i]</code> exactly once, if and only if nodes <code>i</code> and <code>j</code> are connected.</p>
</blockquote>
<blockquote>
<p>Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[0],[0],[0]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible path is [1,0,2,0,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[0,2,4],[1,3,4],[2],[1,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: One possible path is [0,1,4,2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= graph.length &lt;= 12</code></li>
<li><code>0 &lt;= graph[i].length &lt; graph.length</code></li>
</ol>
<p>乍一看有点像TSP问题，但因为有单向，连通，无权的条件限制，实际上也没那么麻烦，动态规划处理即可。<code>dp[path][node]</code>表示到经过结点集<code>path</code>到当前结点<code>node</code>的最短路径长度，<code>path</code>可以由<code>2^N</code>个数表示是否经过各个结点。因为边无权重，BFS第一次访问到该结点的时候，必然是到该结点的最短路径。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathLength</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(graph)</span><br><span class="line">        M=<span class="number">1</span>&lt;&lt;N</span><br><span class="line">        dp=[[<span class="number">-1</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> range(M)]</span><br><span class="line">        q=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            dp[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">0</span></span><br><span class="line">            q.append((i,<span class="number">1</span>&lt;&lt;i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node,path=q.pop(<span class="number">0</span>)</span><br><span class="line">            step=dp[path][node]</span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[node]:</span><br><span class="line">                next_path=path|(<span class="number">1</span>&lt;&lt;nei)</span><br><span class="line">                <span class="keyword">if</span> dp[next_path][nei]&lt;<span class="number">0</span>:</span><br><span class="line">                    dp[next_path][nei]=step+<span class="number">1</span></span><br><span class="line">                    q.append((nei,next_path))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(E)$，空间复杂度为$o(N\times 2^N)$，$E$为边数。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-87/" data-id="cjuh9jx5f003ufww3fx8exfci" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-86" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-86/">LeetCode Weekly Contest 86</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-86/" class="article-date"><time datetime="2018-05-27T15:14:31.873Z" itemprop="datePublished">2018-05-27</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-86</p>
<p>&lt;!-- more --&gt;</p>
<h2>Magic Squares In Grid</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-86/problems/magic-squares-in-grid/</p>
<blockquote>
<p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers <strong>from 1 to 9</strong> such that each row, column, and both diagonals all have the same sum.</p>
</blockquote>
<blockquote>
<p>Given an <code>grid</code> of integers, how many 3 x 3 &quot;magic square&quot; subgrids are there?  (Each subgrid is contiguous).</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: [[4,3,8,4],</span><br><span class="line">        [9,5,1,9],</span><br><span class="line">        [2,7,6,2]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">The following subgrid is a 3 x 3 magic square:</span><br><span class="line">438</span><br><span class="line">951</span><br><span class="line">276</span><br><span class="line"></span><br><span class="line">while this one is not:</span><br><span class="line">384</span><br><span class="line">519</span><br><span class="line">762</span><br><span class="line"></span><br><span class="line">In total, there is only one magic square inside the given grid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>
</ol>
<p>数据规模不大，子阵的大小还固定，无脑直接写判定就行</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMagicSquaresInside</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_magic_square</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            nums=[grid[x][y] <span class="keyword">for</span> x <span class="keyword">in</span> range(i,i+<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(j,j+<span class="number">3</span>)]</span><br><span class="line">            <span class="keyword">if</span> len(set(nums))!=<span class="number">9</span> <span class="keyword">or</span> max(nums)&gt;<span class="number">9</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> sum(grid[i+k][j:j+<span class="number">3</span>])!=<span class="number">15</span> <span class="keyword">or</span> grid[i][j+k]+grid[i+<span class="number">1</span>][j+k]+grid[i+<span class="number">2</span>][j+k]!=<span class="number">15</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]+grid[i+<span class="number">2</span>][j+<span class="number">2</span>]!=<span class="number">15</span> <span class="keyword">or</span> grid[i][j+<span class="number">2</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]+grid[i+<span class="number">2</span>][j]!=<span class="number">15</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> is_magic_square(i,j):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Keys and Rooms</h2>
<blockquote>
<p>There are <code>N</code> rooms and you start in room <code>0</code>.  Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room.</p>
</blockquote>
<blockquote>
<p>Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>.  A key <code>rooms[i][j] = v</code>opens the room with number <code>v</code>.</p>
</blockquote>
<blockquote>
<p>Initially, all the rooms start locked (except for room <code>0</code>).</p>
</blockquote>
<blockquote>
<p>You can walk back and forth between rooms freely.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if you can enter every room.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&apos;t enter the room with number 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>The number of keys in all rooms combined is at most <code>3000</code>.</li>
</ol>
<p>很简单的图遍历问题，根据初始只能访问0结点的BFS，最后验证能否访问全图。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rooms: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        access=set(rooms[<span class="number">0</span>]+[<span class="number">0</span>])</span><br><span class="line">        current=rooms[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> len(access)&lt;len(rooms) <span class="keyword">and</span> current:</span><br><span class="line">            node=current.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> rooms[node]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> access:</span><br><span class="line">                    access.add(i)</span><br><span class="line">                    current.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(access)==len(rooms)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度都为$o(N)$</p>
<h2>Split Array into Fibonacci Sequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-86/problems/split-array-into-fibonacci-sequence/</p>
<blockquote>
<p>Given a string <code>S</code> of digits, such as <code>S = &quot;123456579&quot;</code>, we can split it into a Fibonacci-like sequence <code>[123, 456, 579]</code>.</p>
</blockquote>
<blockquote>
<p>Formally, a Fibonacci-like sequence is a list <code>F</code> of non-negative integers such that:</p>
</blockquote>
<ol>
<li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>, (that is, each integer fits a 32-bit signed integer type);</li>
<li><code>F.length &gt;= 3</code>;</li>
<li>and <code>F[i] + F[i+1] = F[i+2]</code> for all <code>0 &lt;= i &lt; F.length - 2</code>.</li>
</ol>
<blockquote>
<p>Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.</p>
</blockquote>
<blockquote>
<p>Return any Fibonacci-like sequence split from <code>S</code>, or return <code>[]</code> if it cannot be done.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;123456579&quot;</span><br><span class="line">Output: [123,456,579]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;11235813&quot;</span><br><span class="line">Output: [1,1,2,3,5,8,13]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;112358130&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The task is impossible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;0123&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: Leading zeroes are not allowed, so &quot;01&quot;, &quot;2&quot;, &quot;3&quot; is not valid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1101111&quot;</span><br><span class="line">Output: [110, 1, 111]</span><br><span class="line">Explanation: The output [11, 0, 11, 11] would also be accepted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>S contains only digits</code>.</li>
</ol>
<p>直接的想法是DFS/BFS+回溯，但其实没有必要，因为递推式固定，只要确定前两项，就可以直接线性扫描后面的字符串是否符合递推式从而判断这两项前否成为一个类Fibonacci序列的初始项。</p>
<p>而找这前两项的时候，有一些细碎的问题需要注意</p>
<ol>
<li>因为存在每项整数大小限制，所以该每个数字所占的位数不会超过10</li>
<li>第一项的长度不可能大于第三项，所以第一项终点最多到<code>len(S)/2</code></li>
<li>前两项需要当心前导0，当数字长度超过1时第一位不能为0</li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check_recurrent</span><span class="params">(base,start)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> start&lt;len(S):</span><br><span class="line">                next_num=base[<span class="number">-1</span>]+base[<span class="number">-2</span>]</span><br><span class="line">                offset=len(str(next_num))</span><br><span class="line">                <span class="keyword">if</span> next_num&lt;<span class="number">2</span>**<span class="number">31</span> <span class="keyword">and</span> start+offset&lt;=len(S) <span class="keyword">and</span> str(next_num)==S[start:start+offset]:</span><br><span class="line">                    base.append(next_num)</span><br><span class="line">                    start+=offset</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,min(<span class="number">11</span>,len(S)/<span class="number">2</span>+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> S[<span class="number">0</span>]==<span class="string">'0'</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,min(<span class="number">11</span>+i,len(S))):</span><br><span class="line">                <span class="keyword">if</span> j-i&gt;<span class="number">1</span> <span class="keyword">and</span> S[i]==<span class="string">'0'</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> int(S[:i])&lt;<span class="number">2</span>**<span class="number">31</span> <span class="keyword">and</span> int(S[i:j])&lt;<span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">                    third=int(S[:i])+int(S[i:j])</span><br><span class="line">                    <span class="keyword">if</span> third&lt;<span class="number">2</span>**<span class="number">31</span> <span class="keyword">and</span> j+len(str(third))&lt;=len(S) <span class="keyword">and</span> str(third)==S[j:j+len(str(third))]:</span><br><span class="line">                        res=check_recurrent([int(S[:i]),int(S[i:j]),third],j+len(str(third)))</span><br><span class="line">                        <span class="keyword">if</span> res:</span><br><span class="line">                            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></p>
<p>因为整数不超过10位的限制，所以双指针找前两项的循环次数不会超过<code>10^2</code>，可以看做常数，算法的开销在验证后续项是否符合递推式的<code>check_recurrent</code>过程上，复杂度为$o(N)$</p>
<h2>Guess the Word</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-86/problems/guess-the-word/</p>
<blockquote>
<p>his problem is an <strong>interactive problem</strong> new to the LeetCode platform.</p>
</blockquote>
<blockquote>
<p>We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as <strong>secret</strong>.</p>
</blockquote>
<blockquote>
<p>You may call <code>master.guess(word)</code> to guess a word.  The guessed word should have type <code>string</code> and must be from the original list with 6 lowercase letters.</p>
</blockquote>
<blockquote>
<p>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <strong>secret word</strong>.  Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.</p>
</blockquote>
<blockquote>
<p>For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to <code>master.guess</code> and at least one of these guesses was the <strong>secret</strong>, you pass the testcase.</p>
</blockquote>
<blockquote>
<p>Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from <code>'a'</code> to <code>'z'</code>, such that every word in the given word lists is unique.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: secret = &quot;acckzz&quot;, wordlist = [&quot;acckzz&quot;,&quot;ccbazz&quot;,&quot;eiowzz&quot;,&quot;abcczz&quot;]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">master.guess(&quot;aaaaaa&quot;) returns -1, because &quot;aaaaaa&quot; is not in wordlist.</span><br><span class="line">master.guess(&quot;acckzz&quot;) returns 6, because &quot;acckzz&quot; is secret and has all 6 matches.</span><br><span class="line">master.guess(&quot;ccbazz&quot;) returns 3, because &quot;ccbazz&quot; has 3 matches.</span><br><span class="line">master.guess(&quot;eiowzz&quot;) returns 2, because &quot;eiowzz&quot; has 2 matches.</span><br><span class="line">master.guess(&quot;abcczz&quot;) returns 4, because &quot;abcczz&quot; has 4 matches.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We made 5 calls to master.guess and one of them was the secret, so we pass the test case.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:  Any solutions that attempt to circumvent the judge will result in disqualification.</p>
</blockquote>
<p>新题型，不过没什么好慌的，无非是从长度为100的<code>wordlist</code>猜<code>secret</code>并且调用<code>master.guess(word)</code>次数<code>&lt;=10</code>的限制。注意：</p>
<ol>
<li><code>wordlist</code>的元素是随机生成的，且每个词都不同</li>
<li><code>secret</code>一定在<code>wordlist</code>中</li>
</ol>
<p>那么当得到上一次猜测<code>g</code>的返回值<code>n=master.guess(g)</code>，再次猜测的范围就可以缩小到<code>wordlist</code>中只有<code>n</code>个字符和<code>g</code>匹配的子集。这样一步步提高<code>n</code>的值，最后一定能找到<code>secret</code>。问题在于如何找第一个<code>g</code>，为了让最坏的情况，即<code>n=0</code>时下一轮猜测的范围也能减少到最小，每个<code>g</code>应该选择当前<code>wordlist</code>中匹配数为<code>0</code>的元素最少的元素。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment"># This is Master's API interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment">#class Master(object):</span></span><br><span class="line"><span class="comment">#    def guess(self, word):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        :type word: str</span></span><br><span class="line"><span class="comment">#        :rtype int</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type wordlist: List[Str]</span></span><br><span class="line"><span class="string">        :type master: Master</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match_count</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum(a[i]==b[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n&lt;<span class="number">6</span>:</span><br><span class="line">            match=collections.Counter(a <span class="keyword">for</span> (a,b) <span class="keyword">in</span> itertools.permutations(wordlist,<span class="number">2</span>) <span class="keyword">if</span> match_count(a,b)==<span class="number">0</span>)</span><br><span class="line">            g=min(wordlist,key=<span class="keyword">lambda</span> w:match[w])</span><br><span class="line">            n=master.guess(g)</span><br><span class="line">            wordlist=[w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> match_count(g,w)==n]</span><br></pre></td></tr></table></figure></p>
<p>令$n$为<code>wordlist</code>长度，时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-86/" data-id="cjuh9jx5a003sfww3mo9du2xz" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-85" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-85/">LeetCode Weekly Contest 85</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-85/" class="article-date"><time datetime="2018-05-20T13:21:27.819Z" itemprop="datePublished">2018-05-20</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-85</p>
<p>&lt;!-- more --&gt;</p>
<h2>Rectangle Overlap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/rectangle-overlap/</p>
<blockquote>
<p>A rectangle is represented as a list <code>[x1, y1, x2, y2]</code>, where <code>(x1, y1)</code> are the coordinates of its bottom-left corner, and <code>(x2, y2)</code> are the coordinates of its top-right corner.</p>
</blockquote>
<blockquote>
<p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p>
</blockquote>
<blockquote>
<p>Given two rectangles, return whether they overlap.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li>Both rectangles <code>rec1</code> and <code>rec2</code> are lists of 4 integers.</li>
<li>All coordinates in rectangles will be between <code>-10^9</code>and <code>10^9</code>.</li>
</ol>
<p>左下顶点和右上顶点给出的是整个矩形的x范围和y范围，比较两个矩阵的x范围和y范围是否都有重叠就可以判断两个矩形有无重叠。注意仅有顶点或边重叠时不算重叠。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(self, rec1, rec2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rec1: List[int]</span></span><br><span class="line"><span class="string">        :type rec2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r1x1,r1y1,r1x2,r1y2=rec1</span><br><span class="line">        r2x1,r2y1,r2x2,r2y2=rec2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (r2x1-r1x2)*(r2x2-r1x1)&lt;<span class="number">0</span> <span class="keyword">and</span> (r2y1-r1y2)*(r2y2-r1y1)&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2>Push Dominoes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/push-dominoes/</p>
<blockquote>
<p>There are <code>N</code> dominoes in a line, and we place each domino vertically upright.</p>
</blockquote>
<blockquote>
<p>In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png" alt=""></p>
</blockquote>
<blockquote>
<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left.</p>
</blockquote>
<blockquote>
<p>Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>
</blockquote>
<blockquote>
<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>
</blockquote>
<blockquote>
<p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p>
</blockquote>
<blockquote>
<p>Given a string &quot;S&quot; representing the initial state. <code>S[i] = 'L'</code>, if the <code>i</code>-th domino has been pushed to the left; <code>S[i] = 'R'</code>, if the i-th domino has been pushed to the right; <code>S[i] = '.'</code>, if the <code>i</code>-th domino has not been pushed.</p>
</blockquote>
<blockquote>
<p>Return a string representing the final state.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;.L.R...LR..L..&quot;</span><br><span class="line">Output: &quot;LL.RR.LLRRLL..&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;RR.L&quot;</span><br><span class="line">Output: &quot;RR.L&quot;</span><br><span class="line">Explanation: The first domino expends no additional force on the second domino.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= N &lt;= 10^5</code></li>
<li>String dominoes contains only <code>'L'</code>, <code>'R'</code> and <code>'.'</code></li>
</ol>
<p>对每一轮（秒）新产生的倾倒的多米诺，观察其倾倒方向的下一个多米诺：</p>
<ol>
<li>是否为已经在下一轮且反方向倾倒？如果是，则改为竖直且从下一轮中移除</li>
<li>是否未倾倒？如果是，则放入下一轮且改为该方向倾倒</li>
</ol>
<p>注意每轮需要处理的多米诺序号放入寻址比较方便的<code>set</code>，否则可能有TLE的危险。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushDominoes</span><span class="params">(self, dominoes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dominoes: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dominoes=list(dominoes)</span><br><span class="line">        now=set([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dominoes)) <span class="keyword">if</span> dominoes[i]!=<span class="string">'.'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            temp=set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> now:</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> dominoes[i]==<span class="string">'L'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">in</span> temp <span class="keyword">and</span> dominoes[i<span class="number">-1</span>]==<span class="string">'R'</span>:</span><br><span class="line">                        temp.remove(i<span class="number">-1</span>)</span><br><span class="line">                        dominoes[i<span class="number">-1</span>]=<span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">elif</span> dominoes[i<span class="number">-1</span>]==<span class="string">'.'</span>:</span><br><span class="line">                        temp.add(i<span class="number">-1</span>)</span><br><span class="line">                        dominoes[i<span class="number">-1</span>]=<span class="string">'L'</span></span><br><span class="line">                <span class="keyword">if</span> i&lt;len(dominoes)<span class="number">-1</span> <span class="keyword">and</span> dominoes[i]==<span class="string">'R'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i+<span class="number">1</span> <span class="keyword">in</span> temp <span class="keyword">and</span> dominoes[i+<span class="number">1</span>]==<span class="string">'L'</span>:</span><br><span class="line">                        temp.remove(i+<span class="number">1</span>)</span><br><span class="line">                        dominoes[i+<span class="number">1</span>]=<span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">elif</span> dominoes[i+<span class="number">1</span>]==<span class="string">'.'</span>:</span><br><span class="line">                        temp.add(i+<span class="number">1</span>)</span><br><span class="line">                        dominoes[i+<span class="number">1</span>]=<span class="string">'R'</span></span><br><span class="line">            now=temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(dominoes)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度也为$o(n)$</p>
<h2>New 21 Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/new-21-game/</p>
<blockquote>
<p>Alice plays the following game, loosely based on the card game &quot;21&quot;.</p>
</blockquote>
<blockquote>
<p>Alice starts with <code>0</code> points, and draws numbers while she has less than <code>K</code> points.  During each draw, she gains an integer number of points randomly from the range <code>[1, W]</code>, where <code>W</code> is an integer.  Each draw is independent and the outcomes have equal probabilities.</p>
</blockquote>
<blockquote>
<p>Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 10, K = 1, W = 10</span><br><span class="line">Output: 1.00000</span><br><span class="line">Explanation:  Alice gets a single card, then stops.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 6, K = 1, W = 10</span><br><span class="line">Output: 0.60000</span><br><span class="line">Explanation:  Alice gets a single card, then stops.</span><br><span class="line">In 6 out of W = 10 possibilities, she is at or below N = 6 points.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 21, K = 17, W = 10</span><br><span class="line">Output: 0.73278</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li>
<li><code>1 &lt;= W &lt;= 10000</code></li>
<li>Answers will be accepted as correct if they are within <code>10^-5</code> of the correct answer.</li>
<li>The judging time limit has been reduced for this question.</li>
</ol>
<p>获得<code>i</code>点数的方法无非就是从某个<code>[i-W,i-1]</code>开始抽中一个正好相加得到<code>i</code>的整数，也就是说获得过点数<code>i</code>的概率$p(i)$可以表示为：</p>
<p><span>$p\left( i \right) = \sum\limits_{j = i - W}^{i - 1} {p\left( j \right) \cdot \frac{1}{W}}  = \frac{\sum\limits_{j = i - W}^{i - 1} {p\left( j \right)}}{W}$</span><!-- Has MathJax --></p>
<p>也就是说$p(i)$等于之前最近的<code>w</code>个数的概率和的平均数，当然需要注意一下边界，最小从0开始计数，当点数已经达到<code>K</code>时就停止继续取数，所以求和上界也不可以超过<code>K</code>。最后返回<code>&gt;K</code>且<code>&lt;=N</code>部分的概率即可</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N, K, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N&gt;=K+W <span class="keyword">or</span> K==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp=[<span class="number">1.0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            start=max(i-W,<span class="number">0</span>)</span><br><span class="line">            end=min(i,K)</span><br><span class="line">            dp[i]=sum(dp[start:end])/W</span><br><span class="line">        <span class="keyword">return</span> sum(dp[K:])</span><br></pre></td></tr></table></figure></p>
<p>这种写法是有问题的，浪费时间在反复求和上，最终导致TLE，因为是连续数，所以可以像以前在<a href="https://leetcode.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">Maximum Average Subarray I</a>的做法，只计算当前临时和的变化。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N, K, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N&gt;=K+W <span class="keyword">or</span> K==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp=[<span class="number">1.0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        temp=dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            dp[i]=temp/W</span><br><span class="line">            <span class="keyword">if</span> i&lt;K:</span><br><span class="line">                temp+=dp[i]</span><br><span class="line">            <span class="keyword">if</span> i&gt;=W:</span><br><span class="line">                temp-=dp[i-W]</span><br><span class="line">        <span class="keyword">return</span> sum(dp[K:])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$，空间复杂度也为$o(N)$</p>
<h2>Similar String Groups</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/similar-string-groups/</p>
<blockquote>
<p>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>.</p>
</blockquote>
<blockquote>
<p>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to &quot;tars&quot;, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>
</blockquote>
<blockquote>
<p>We are given a list <code>A</code> of unique strings.  Every string in <code>A</code> is an anagram of every other string in <code>A</code>.  How many groups are there?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A.length &lt;= 2000</code></li>
<li><code>A[i].length &lt;= 1000</code></li>
<li><code>A.length * A[i].length &lt;= 20000</code></li>
<li>All words in <code>A</code> consist of lowercase letters only.</li>
<li>All words in <code>A</code> have the same length and are anagrams of each other.</li>
<li>The judging time limit has been increased for this question.</li>
</ol>
<p>基本参考[这个解法][1]。</p>
<p>这题的时间限制稍微宽松一点，所以暴力搜索也不是很糟糕。当<code>A</code>的元素不是特别多的时候，使用暴力搜索，将相似的词两两等价合并。注意<code>A</code>的单词都是anagram所以当<code>A</code>的元素比较多而单词长度不是特别大的时候，可以通过穷举构造相似集检验这些词是否在<code>A</code>中以避开对<code>A</code>的遍历</p>
<p>[1]: https://leetcode.com/problems/similar-string-groups/discuss/132345/Python-Union-Find-Solution-with-Tricky-min(O(MN2)-O(NM2))</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n,m=len(A),len(A[<span class="number">0</span>])</span><br><span class="line">        leader=&#123;i: i <span class="keyword">for</span> i <span class="keyword">in</span> A&#125;</span><br><span class="line">        self.groups=n</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">similar</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum(i!=j <span class="keyword">for</span> (i,j) <span class="keyword">in</span> zip(x,y))==<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">label</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> leader[x]!=x:</span><br><span class="line">                <span class="keyword">return</span> label(leader[x])</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            x,y=label(x),label(y)</span><br><span class="line">            <span class="keyword">if</span> x!=y:</span><br><span class="line">                leader[x]=y</span><br><span class="line">                self.groups-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;m:</span><br><span class="line">            <span class="keyword">for</span> (x,y) <span class="keyword">in</span> itertools.combinations(A,<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> similar(x,y):</span><br><span class="line">                    union(x,y)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">for</span> (i,j) <span class="keyword">in</span> itertools.combinations(range(m),<span class="number">2</span>):</span><br><span class="line">                    y=x[:i]+x[j]+x[i+<span class="number">1</span>:j]+x[i]+x[j+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> y <span class="keyword">in</span> leader:</span><br><span class="line">                        union(x,y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.groups</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$(mn\times min(m,n))$，空间复杂度为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-85/" data-id="cjuh9jx55003qfww3ytfhqymv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-84" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-84/">LeetCode Weekly Contest 84</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-84/" class="article-date"><time datetime="2018-05-13T07:31:11.615Z" itemprop="datePublished">2018-05-13</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-84</p>
<p>&lt;!-- more --&gt;</p>
<h2>Flipping an Image</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/flipping-an-image/</p>
<blockquote>
<p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.</p>
</blockquote>
<blockquote>
<p>To flip an image horizontally means that each row of the image is reversed.  For example, flipping <code>[1, 1, 0]</code> horizontally results in <code>[0, 1, 1]</code>.</p>
</blockquote>
<blockquote>
<p>To invert an image means that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>. For example, inverting <code>[0, 1, 1]</code> results in <code>[1, 0, 0]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">Output: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</span><br><span class="line">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].</span><br><span class="line">Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ol>
<p>随便写吧，<code>numpy</code>会更方便写，但也没必要</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[i])):</span><br><span class="line">                A[i][j]=<span class="number">1</span>-A[i][j]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[i])/<span class="number">2</span>):</span><br><span class="line">                A[i][j],A[i][-j<span class="number">-1</span>]=A[i][-j<span class="number">-1</span>],A[i][j]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p>
<h2>Find And Replace in String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/find-and-replace-in-string/</p>
<blockquote>
<p>To some string <code>S</code>, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
</blockquote>
<blockquote>
<p>Each replacement operation has <code>3</code> parameters: a starting index <code>i</code>, a source word x and a target word <code>y</code>.  The rule is that if <code>x</code> starts at position <code>i</code> in the <strong>original string</strong> <code>S</code>, then we will replace that occurrence of <code>x</code> with <code>y</code>.  If not, we do nothing.</p>
</blockquote>
<blockquote>
<p>For example, if we have <code>S = &quot;abcd&quot;</code> and we have some replacement operation <code>i = 2, x = &quot;cd&quot;, y = &quot;ffff&quot;</code>, then because <code>&quot;cd&quot;</code> starts at position <code>2</code> in the original string <code>S</code>, we will replace it with <code>&quot;ffff&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Using another example on <code>S = &quot;abcd&quot;</code>, if we have both the replacement operation <code>i = 0, x = &quot;ab&quot;, y = &quot;eee&quot;</code>, as well as another replacement operation <code>i = 2, x = &quot;ec&quot;, y = &quot;ffff&quot;</code>, this second operation does nothing because in the original string <code>S[2] = 'c'</code>, which doesn't match <code>x[0] = 'e'</code>.</p>
</blockquote>
<blockquote>
<p>All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, <code>S = &quot;abc&quot;, indexes = [0, 1], sources = [&quot;ab&quot;,&quot;bc&quot;]</code> is not a valid test case.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeebffff&quot;</span><br><span class="line">Explanation: &quot;a&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;cd&quot; starts at index 2 in S, so it&apos;s replaced by &quot;ffff&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeecd&quot;</span><br><span class="line">Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= indexes.length = sources.length = targets.length &lt;= 100</code></li>
<li><code>0 &lt; indexes[i] &lt; S.length &lt;= 1000</code></li>
<li>All characters in given inputs are lowercase letters.</li>
</ol>
<p>比上面那题甚至更简单，Py的<code>str</code>还是不可更改的变量，不用动原地代替的想法，所以索引上都没什么特别要留心的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span><span class="params">(self, S, indexes, sources, targets)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type indexes: List[int]</span></span><br><span class="line"><span class="string">        :type sources: List[str]</span></span><br><span class="line"><span class="string">        :type targets: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ptr=<span class="number">0</span></span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> ptr&lt;len(S):</span><br><span class="line">            res+=S[ptr]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(indexes)):</span><br><span class="line">                <span class="keyword">if</span> ptr==indexes[i] <span class="keyword">and</span> ptr+len(sources[i])&lt;=len(S) <span class="keyword">and</span> S[ptr:ptr+len(sources[i])]==sources[i]:</span><br><span class="line">                    res=res[:<span class="number">-1</span>]+targets[i]</span><br><span class="line">                    ptr+=len(sources[i])<span class="number">-1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ptr+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Image Overlap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/image-overlap/</p>
<blockquote>
<p>Two images <code>A</code> and <code>B</code> are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.)</p>
</blockquote>
<blockquote>
<p>We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images.</p>
</blockquote>
<blockquote>
<p>(Note also that a translation does <strong>not</strong> include any kind of rotation.)</p>
</blockquote>
<blockquote>
<p>What is the largest possible overlap?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [[1,1,0],</span><br><span class="line">            [0,1,0],</span><br><span class="line">            [0,1,0]]</span><br><span class="line">       B = [[0,0,0],</span><br><span class="line">            [0,1,1],</span><br><span class="line">            [0,0,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We slide A to right by 1 unit and down by 1 unit.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = A[0].length = B.length = B[0].length &lt;= 30</code></li>
<li><code>0 &lt;= A[i][j], B[i][j] &lt;= 1</code></li>
</ol>
<p>因为只有平移后<code>1</code>位置相同才可以被看作重叠，也只有重叠的<code>1</code>的数目需要返回。没有特别好的方法，还是暴力搜索，记录<code>A</code>和<code>B</code>中所有<code>1</code>的坐标，并记录每个<code>A</code>中的<code>1</code>和每个<code>B</code>中的<code>1</code>之间的距离，距离的最大频数即为结果。这里为了节约空间，把这个距离表示成了一个一维线性的数值：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestOverlap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :type B: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(A)</span><br><span class="line">        ones_in_A=[i/n*(n*<span class="number">2</span>)+i%n <span class="keyword">for</span> i <span class="keyword">in</span> range(n*n) <span class="keyword">if</span> A[i/n][i%n]==<span class="number">1</span>]</span><br><span class="line">        ones_in_B=[i/n*(n*<span class="number">2</span>)+i%n <span class="keyword">for</span> i <span class="keyword">in</span> range(n*n) <span class="keyword">if</span> B[i/n][i%n]==<span class="number">1</span>]</span><br><span class="line">        c=collections.Counter([i-j <span class="keyword">for</span> i <span class="keyword">in</span> ones_in_A <span class="keyword">for</span> j <span class="keyword">in</span> ones_in_B])</span><br><span class="line">        <span class="keyword">return</span> max(c.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^4)$，空间复杂度也为$o(n^4)$</p>
<h2>Sum of Distances in Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/sum-of-distances-in-tree/</p>
<blockquote>
<p>An undirected, connected tree with <code>N</code> nodes labelled <code>0...N-1</code> and <code>N-1</code> edges are given.</p>
</blockquote>
<blockquote>
<p>The <code>i</code>th edge connects nodes <code>edges[i][0]</code> and <code>edges[i][1]</code> together.</p>
</blockquote>
<blockquote>
<p>Return a list <code>ans</code>, where <code>ans[i]</code> is the sum of the distances between node i and all other nodes.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]</span><br><span class="line">Output: [8,12,6,10,10,10]</span><br><span class="line">Explanation:</span><br><span class="line">Here is a diagram of the given tree:</span><br><span class="line">  0</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /|\</span><br><span class="line">  3 4 5</span><br><span class="line">We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)</span><br><span class="line">equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: <code>1 &lt;= N &lt;= 10000</code></p>
</blockquote>
<p>直球去遍历算多源之间的路径长度和将面临$o(N^2)$的时间复杂度，但树是一种有良好性质的图，可以利用它的一些特性（连通且无回路，任一一个点可以作为根结点）简化计算，使得我们只要后序遍历和先序遍历一次就能得到结果。</p>
<p>我们用<code>subtree[i]</code>表示以<code>i</code>为根结点的子树的结点总数（包括<code>i</code>本身），用<code>s[i]</code>表示<code>i</code>到其他所有结点的距离的和。那么接下来可以做的工作是自底而上<strong>后序遍历</strong>一遍整根树，得到每个结点正确的<code>subtree[i]</code>值，即<code>subtree[i]=sum(subtree[j])+1</code>，<code>j</code>为<code>i</code>所有的子结点，再计算<code>i</code>来自及子树的距离和，相比<code>j</code>到其子树的所有距离和，显然需要对<code>j</code>子树的每个结点加上<code>i</code>到<code>j</code>距离（也就是1），所以有<code>s[i]=sum(s[j]+subtree[j])</code>。注意这时的<code>s[i]</code>仅包含来自子结点的距离和，不包含父结点部分，所以只有整个树的根结点<code>root</code>（可以假设这个根结点为<code>0</code>）的<code>subtree[root]</code>值是完整的。</p>
<p>接下来要得到该树除了根结点以外的结点的正确的<code>s[i]</code>值，只需要再进行一次自顶向下的<strong>先序遍历</strong>。对于结点<code>i</code>，“旋转”其与父结点<code>r</code>的边，使得<code>i</code>成为<code>r</code>的父结点，相比到<code>r</code>的距离和，计算到<code>i</code>的距离和时可以发现：以<code>r</code>为根且与<code>i</code>无关的部分即<code>N-subtree[i]</code>每个结点再加上<code>i-r</code>间距离（即<code>1</code>）就是到<code>i</code>的距离和，与<code>i</code>子树相关的部分则是到<code>r</code>的距离和再减去<code>1</code>构成。容易得到<code>s[i]=s[r]+(N-subtree[i])-subtree[i]</code>。完成这次自顶而下的遍历后返回<code>s</code>即最终结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfDistancesInTree</span><span class="params">(self, N, edges)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        subtree=[<span class="number">0</span>]*N</span><br><span class="line">        s=[<span class="number">0</span>]*N</span><br><span class="line">        adj=collections.defaultdict(set)</span><br><span class="line">        seen=set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> [i,j] <span class="keyword">in</span> edges:</span><br><span class="line">            adj[i].add(j)</span><br><span class="line">            adj[j].add(i)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            seen.add(root)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adj[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    post_dfs(i)</span><br><span class="line">                    subtree[root]+=subtree[i]</span><br><span class="line">                    s[root]+=s[i]+subtree[i]</span><br><span class="line">            subtree[root]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre_dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            seen.add(root)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adj[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    s[i]=s[root]+N<span class="number">-2</span>*subtree[i]</span><br><span class="line">                    pre_dfs(i)</span><br><span class="line"></span><br><span class="line">        post_dfs(<span class="number">0</span>)</span><br><span class="line">        seen=set()</span><br><span class="line">        pre_dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$，空间复杂度也为$o(N)$（这点注意是树结构，边也是$o(N)$，所以邻接表的空间代价只有$o(N)$）</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-84/" data-id="cjuh9jx51003ofww37swz3ozb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-83" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-83/">LeetCode Weekly Contest 83</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-83/" class="article-date"><time datetime="2018-05-06T08:12:30.273Z" itemprop="datePublished">2018-05-06</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-83</p>
<p>&lt;!-- more --&gt;</p>
<h2>Positions of Large Groups</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/positions-of-large-groups/</p>
<blockquote>
<p>In a string <code>S</code> of lowercase letters, these letters form consecutive groups of the same character.</p>
</blockquote>
<blockquote>
<p>For example, a string like <code>S = &quot;abbxxxxzyy&quot;</code> has the groups <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> and <code>&quot;yy&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group.</p>
</blockquote>
<blockquote>
<p>The final answer should be in lexicographic order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbxxxxzzy&quot;</span><br><span class="line">Output: [[3,6]]</span><br><span class="line">Explanation: &quot;xxxx&quot; is the single large group with starting  3 and ending positions 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">Output: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 1000</code></li>
</ol>
<p>老题了，这种线性扫描一遍找指定子串的问题不知道写过多少次了。可能唯一值得注意的就是最后一个子串的最后一个字符是不是<code>len(S)-1</code>。然后就随便写写吧。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        interval=[]</span><br><span class="line">        lo=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            <span class="keyword">if</span> c!=S[lo]:</span><br><span class="line">                <span class="keyword">if</span> i-lo<span class="number">-1</span>&gt;<span class="number">1</span>:</span><br><span class="line">                    interval.append([lo,i<span class="number">-1</span>])</span><br><span class="line">                lo=i</span><br><span class="line">        <span class="keyword">if</span> len(S)<span class="number">-1</span>-lo&gt;<span class="number">1</span>:</span><br><span class="line">            interval.append([lo,len(S)<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> interval</span><br></pre></td></tr></table></figure></p>
<p>线性扫描的时间和空间复杂度都为$o(n)$</p>
<h2>Masking Personal Information</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/masking-personal-information/</p>
<blockquote>
<p>We are given a personal information string <code>S</code>, which may represent either <strong>an email address</strong> or <strong>a phone number</strong>.</p>
</blockquote>
<blockquote>
<p>We would like to mask this personal information according to the following rules:</p>
</blockquote>
<blockquote>
<p><strong>1. Email address</strong>:</p>
</blockquote>
<blockquote>
<p>We define a <strong>name</strong> to be a string of <code>length ≥ 2</code> consisting of only lowercase letters <code>a-z</code> or uppercase letters <code>A-Z</code>.</p>
</blockquote>
<blockquote>
<p>An email address starts with a name, followed by the symbol <code>'@'</code>, followed by a name, followed by the dot <code>'.'</code> and followed by a name.</p>
</blockquote>
<blockquote>
<p>All email addresses are guaranteed to be valid and in the format of <code>&quot;name1@name2.name3&quot;</code>.</p>
</blockquote>
<blockquote>
<p>To mask an email, <strong>all names must be converted to lowercase</strong> and <strong>all letters between the first and last letter of the first name</strong> must be replaced by 5 asterisks <code>'*'</code>.</p>
</blockquote>
<blockquote>
<p><strong>2. Phone number</strong>:</p>
</blockquote>
<blockquote>
<p>A phone number is a string consisting of only the digits <code>0-9</code> or the characters from the set <code>{'+', '-', '(', ')', ' '}</code>. You may assume a phone number contains 10 to 13 digits.</p>
</blockquote>
<blockquote>
<p>The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.</p>
</blockquote>
<blockquote>
<p>The local number should be formatted and masked as <code>&quot;***-***-1111&quot;</code>, where 1 represents the exposed digits.</p>
</blockquote>
<blockquote>
<p>To mask a phone number with country code like <code>&quot;+111 111 111 1111&quot;</code>, we write it in the form <code>&quot;+***-***-***-1111&quot;</code>.  The <code>'+'</code> sign and the first <code>'-'</code> sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with <code>&quot;+**-&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Note that extraneous characters like <code>&quot;(&quot;, &quot;)&quot;, &quot; &quot;</code>, as well as extra dashes or plus signs not part of the above formatting scheme should be removed.</p>
</blockquote>
<blockquote>
<p>Return the correct &quot;mask&quot; of the information provided.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LeetCode@LeetCode.com&quot;</span><br><span class="line">Output: &quot;l*****e@leetcode.com&quot;</span><br><span class="line">Explanation: All names are converted to lowercase, and the letters between the</span><br><span class="line">             first and last letter of the first name is replaced by 5 asterisks.</span><br><span class="line">             Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB@qq.com&quot;</span><br><span class="line">Output: &quot;a*****b@qq.com&quot;</span><br><span class="line">Explanation: There must be 5 asterisks between the first and last letter</span><br><span class="line">             of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1(234)567-890&quot;</span><br><span class="line">Output: &quot;***-***-7890&quot;</span><br><span class="line">Explanation: 10 digits in the phone number, which means all digits make up the local number.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;86-(10)12345678&quot;</span><br><span class="line">Output: &quot;+**-***-***-5678&quot;</span><br><span class="line">Explanation: 12 digits, 2 digits for country code and 10 digits for local number.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>S.length &lt;= 40</code>.</li>
<li>Emails have length at least 8.</li>
<li>Phone numbers have length at least 10.</li>
</ol>
<p>不涉及任何算法，只是处理不规范（其实还算非常规范）数据形式的“脏”活。邮箱地址容易就不说了，电话号码注意主体只有10位，多下来的就是区号，至于原数据是怎么划分电话号码怎么用括号怎么用分隔符的关我什么事，把<code>S</code>的所有数字提取出来然后按照位数处理，保留最后四位就完成了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maskPII</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'@'</span> <span class="keyword">in</span> S:</span><br><span class="line">            parts=S.lower().split(<span class="string">'@'</span>)</span><br><span class="line">            <span class="keyword">return</span> parts[<span class="number">0</span>][<span class="number">0</span>]+<span class="string">'*****'</span>+parts[<span class="number">0</span>][<span class="number">-1</span>]+<span class="string">'@'</span>+parts[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums=filter(<span class="keyword">lambda</span> c:c.isdigit(),S)</span><br><span class="line">            <span class="keyword">if</span> len(nums)&gt;<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'+'</span>+<span class="string">'*'</span>*(len(nums)<span class="number">-10</span>)+<span class="string">'-***-***-'</span>+nums[<span class="number">-4</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'***-***-'</span>+nums[<span class="number">-4</span>:]</span><br></pre></td></tr></table></figure></p>
<h2>Consecutive Numbers Sum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/consecutive-numbers-sum/</p>
<blockquote>
<p>Given a positive integer <code>N</code>, how many ways can we write it as a sum of consecutive positive integers?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 = 5 = 2 + 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 15</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10 ^ 9</code>.</li>
</ol>
<p>假设<code>N</code>能写出<code>k</code>个连续正整数的和。那么这些正整数中最小的数为<code>N/k-(k-1)/2</code>，为了保证这个数为正整数，必然有:</p>
<ol>
<li><code>N/k-(k-1)/2&gt;0</code>即<code>k*(k-1)/2&lt;N</code></li>
<li>如果<code>k</code>是奇数，<code>N</code>必须能被<code>k</code>整除</li>
<li>如果<code>k</code>是偶数，<code>N/k</code>等于某个正整数+<code>1/2</code></li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k,res=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> k*(k<span class="number">-1</span>)/<span class="number">2</span>&lt;N:</span><br><span class="line">            <span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> N%k==k/<span class="number">2</span>) <span class="keyword">or</span> (k%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> N%k==<span class="number">0</span>):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(\sqrt{N})$</p>
<h2>Unique Letter String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/unique-letter-string/</p>
<blockquote>
<p>A character is unique in string <code>S</code> if it occurs exactly once in it.</p>
</blockquote>
<blockquote>
<p>For example, in string <code>S = &quot;LETTER&quot;</code>, the only unique characters are &quot;L&quot; and &quot;R&quot;.</p>
</blockquote>
<blockquote>
<p>Let's define <code>UNIQ(S)</code> as the number of unique characters in string S.</p>
</blockquote>
<blockquote>
<p>For example, <code>UNIQ(&quot;LETTER&quot;) = 2</code>.</p>
</blockquote>
<blockquote>
<p>Given a string <code>S</code> with only uppercases, calculate the sum of <code>UNIQ(substring)</code> over all non-empty substrings of <code>S</code>.</p>
</blockquote>
<blockquote>
<p>If there are two or more equal substrings at different positions in <code>S</code>, we consider them different.</p>
</blockquote>
<blockquote>
<p>Since the answer can be very large, retrun the answer modulo <code>10 ^ 9 + 7</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ABC&quot;</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.</span><br><span class="line">Evey substring is composed with only unique letters.</span><br><span class="line">Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ABA&quot;</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The same as example 1, except uni(&quot;ABA&quot;) = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= S.length &lt;= 10000</code>.</li>
</ol>
<p>正向去考虑可以分割出多少个子串，每个子串有多少只出现过一次的字符，因为生成子串本身已经是$o(n^2)$级的，再去计算每个子串的<code>UNIQ</code>值则会上升到$o(n^3)$的复杂度。这时不妨反过来考虑，<code>S</code>的每个字符<code>S[i]</code>会在哪些子串中成为unique字符。</p>
<p>假设某个字符最近出现的三个位置为<code>k&lt;j&lt;i</code>，<code>S[k]==S[j]==S[i]</code>，那么<code>S[j]</code>在符合这些条件的子串中可以成为unique字符：</p>
<ol>
<li>子串第一个字符位置在<code>[k+1,j]</code>，一共<code>j-k</code>种可能</li>
<li>子串最后一个字符位置在<code>[j,i-1]</code>，一共<code>i-j</code>种可能</li>
</ol>
<p>所以<code>S[j]</code>在<code>(j-k)*(i-j)</code>个子串中贡献了1个计数。</p>
<p>为了方便设定初始条件，可以假设每个字符都在<code>-1</code>和<code>len(S)</code>位置出现过，这样对于每个字符的第一次出现和最后一次出现也可以用上面的方法计算在多少个子串中成为了unique字符。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        pos=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            k,j=pos.get(c,(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line">            res+=(j-k)*(i-j)</span><br><span class="line">            pos[c]=(j,i)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> pos:</span><br><span class="line">            k,j=pos[c]</span><br><span class="line">            res+=(j-k)*(len(S)-j)</span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-83/" data-id="cjuh9jx4o003mfww3umnze0jk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-82" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-82/">LeetCode Weekly Contest 82</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-82/" class="article-date"><time datetime="2018-04-29T08:56:13.704Z" itemprop="datePublished">2018-04-29</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-82</p>
<p>&lt;!-- more --&gt;</p>
<h2>Goat Latin</h2>
<p>https://leetcode.com/contest/weekly-contest-82/problems/goat-latin/</p>
<blockquote>
<p>A sentence <code>S</code> is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>
</blockquote>
<blockquote>
<p>We would like to convert the sentence to &quot;Goat Latin&quot; (a made-up language similar to Pig Latin.)</p>
</blockquote>
<blockquote>
<p>The rules of Goat Latin are as follows:</p>
</blockquote>
<ul>
<li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.
For example, the word 'apple' becomes 'applema'.</li>
<li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add &quot;ma&quot;.
For example, the word <code>&quot;goat&quot;</code> becomes <code>&quot;oatgma&quot;</code>.</li>
<li>Add one letter <code>'a'</code> to the end of each word per its word index in the sentence, starting with 1.
For example, the first word gets <code>&quot;a&quot;</code> added to the end, the second word gets <code>&quot;aa&quot;</code> added to the end and so on.
Return the final sentence representing the conversion from <code>S</code> to Goat Latin.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;I speak Goat Latin&quot;</span><br><span class="line">Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Notes</strong>:</p>
<ol>
<li><code>S</code> contains only uppercase, lowercase and spaces. Exactly one space between each word.</li>
<li><code>1 &lt;= S.length &lt;= 100</code>.</li>
</ol>
<p>反正转换规则都给你写的很详细了，一个个分支照着做就行，注意元音大小写。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        vowel=[<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]</span><br><span class="line">        <span class="keyword">for</span> i,w <span class="keyword">in</span> enumerate(S.split()):</span><br><span class="line">            <span class="keyword">if</span> w[<span class="number">0</span>] <span class="keyword">in</span> vowel <span class="keyword">or</span> len(w)&lt;<span class="number">2</span>:</span><br><span class="line">                res.append(w+<span class="string">'ma'</span>+<span class="string">'a'</span>*(i+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(w[<span class="number">1</span>:]+w[<span class="number">0</span>]+<span class="string">'ma'</span>+<span class="string">'a'</span>*(i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure></p>
<h2>Friends Of Appropriate Ages</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-82/problems/friends-of-appropriate-ages/</p>
<blockquote>
<p>Some people will make friend requests. The list of their ages is given and <code>ages[i]</code> is the age of the ith person.</p>
</blockquote>
<blockquote>
<p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p>
</blockquote>
<blockquote>
<ul>
<li><code>age[B] &lt;= 0.5 * age[A] + 7</code></li>
<li><code>age[B] &gt; age[A]</code></li>
<li><code>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</code>
Otherwise, A will friend request B.</li>
</ul>
</blockquote>
<blockquote>
<p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p>
</blockquote>
<blockquote>
<p>How many total friend requests are made?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,16]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 2 people friend request each other.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,17,18]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [20,30,100,110,120]</span><br><span class="line">Output:</span><br><span class="line">Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= ages.length &lt;= 20000</code>.</li>
<li><code>1 &lt;= ages[i] &lt;= 120</code>.</li>
</ol>
<p>如果按照这些条件对遍历<code>ages</code>中的排列，因为<code>o(n^2)</code>的时间复杂度可能会TLE，所以可以先试着对<code>ages</code>进行排序，然后对上面那些条件取反，也就是说对于给定的A来说，能接受交友请求的B必须同时满足</p>
<ul>
<li><code>ages[B]&gt;0.5*ages[A]+7</code></li>
<li><code>ages[B]&lt;=ages[A]</code></li>
<li><code>ages[B]&gt;=100</code>或<code>ages[A]&lt;=100</code></li>
</ul>
<p>前两个条件可以通过二分查找轻松划定一个比较宽泛的坐标范围，最后一个条件不取反直接按照正向去分<code>ages[A]&gt;=100</code>是否成立再取B的上界。需要注意的主要有两个：</p>
<ol>
<li><code>ages</code>的元素值可能存在重复，当<code>ages[A]==ages[B]</code>时也是符合前两个条件的</li>
<li>所以找上界<code>&lt;=ages[A]</code>时，最后的值要减去<code>A</code>本身所占的一个值（自己不能向自己发起好友请求）</li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numFriendRequests</span><span class="params">(self, ages)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ages: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        ages.sort()</span><br><span class="line">        hundred=bisect.bisect(ages,<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ages)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            a=bisect.bisect(ages,ages[i],lo=i)</span><br><span class="line">            b=bisect.bisect(ages,<span class="number">0.5</span>*ages[i]+<span class="number">7</span>,hi=a)</span><br><span class="line">            <span class="keyword">if</span> ages[i]&gt;=<span class="number">100</span>:</span><br><span class="line">                res+=a-b<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res+=max(min(a<span class="number">-1</span>,hundred)-b,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(1)$</p>
<h2>Most Profit Assigning Work</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-82/problems/most-profit-assigning-work/</p>
<blockquote>
<p>We have jobs: <code>difficulty[i]</code> is the difficulty of the <code>i</code>th job, and <code>profit[i]</code> is the profit of the <code>i</code>th job.</p>
</blockquote>
<blockquote>
<p>Now we have some workers. <code>worker[i]</code> is the ability of the <code>i</code>th worker, which means that this worker can only complete a job with difficulty at most <code>worker[i]</code>.</p>
</blockquote>
<blockquote>
<p>Every worker can be assigned at most one job, but one job can be completed multiple times.</p>
</blockquote>
<blockquote>
<p>For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0.</p>
</blockquote>
<blockquote>
<p>What is the most profit we can make?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">Output: 100</span><br><span class="line">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= difficulty.length = profit.length &lt;= 10000</code></li>
<li><code>1 &lt;= worker.length &lt;= 10000</code></li>
<li><code>difficulty[i]</code>, <code>profit[i]</code>, <code>worker[i]</code>  are in range <code>[1, 10^5]</code></li>
</ol>
<p>既然没有任务必须完成的次数限制，那就尽量把员工都安排到他们能力范围内利润最大的任务。先把任务按照利润大小排序，再把员工按照能力高低排序，双指针找到当前员工能胜任的利润最大的任务。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitAssignment</span><span class="params">(self, difficulty, profit, worker)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type difficulty: List[int]</span></span><br><span class="line"><span class="string">        :type profit: List[int]</span></span><br><span class="line"><span class="string">        :type worker: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        jobs=sorted(zip(profit,difficulty),reverse=<span class="keyword">True</span>)</span><br><span class="line">        worker.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> worker:</span><br><span class="line">            <span class="keyword">while</span> i&lt;len(profit) <span class="keyword">and</span> w&lt;jobs[i][<span class="number">1</span>]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==len(profit):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res+=jobs[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度主要来自排序的<code>o(max(length) log(max(length)))</code>，空间复杂度为<code>o(len(difficulty))</code></p>
<h2>Making A Large Island</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-82/problems/making-a-large-island/</p>
<blockquote>
<p>In a 2D grid of 0s and 1s, we change at most one <code>0</code> to a <code>1</code>.</p>
</blockquote>
<blockquote>
<p>After, what is the size of the largest island? (An island is a 4-directionally connected group of <code>1</code>s).</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 0], [0, 1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 1], [1, 0]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 1], [1, 1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Can&apos;t change any 0 to 1, only one island with area = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code>.</li>
<li><code>0 &lt;= grid[i][j] &lt;= 1</code>.</li>
</ol>
<p>暂时没想到什么特别好的方法，用比较直接的策略：先DFS找出所有的连通分支（岛屿）并标记编号和面积大小，再遍历<code>0</code>坐标计算每个<code>0</code>翻转为<code>1</code>后使几个分支合并（总面积等于这些分支的大小再加上1），找到最大的合并后面积。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(grid)</span><br><span class="line">        area=&#123;<span class="number">0</span>:<span class="number">0</span>&#125;</span><br><span class="line">        seen=set()</span><br><span class="line">        zeros=set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(index,x,y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y]&gt;<span class="number">0</span>:</span><br><span class="line">                grid[x][y]=index</span><br><span class="line">                area[index]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=x+dx&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y+dy&lt;n <span class="keyword">and</span> (x+dx,y+dy) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        seen.add((x+dx,y+dy))</span><br><span class="line">                        dfs(index,x+dx,y+dy)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                zeros.add((x,y))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            island=set()</span><br><span class="line">            <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x+dx&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y+dy&lt;n:</span><br><span class="line">                    island.add(grid[x+dx][y+dy])</span><br><span class="line">            <span class="keyword">return</span> sum(area[i] <span class="keyword">for</span> i <span class="keyword">in</span> island)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        tag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (i,j) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add((i,j))</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j]&gt;<span class="number">0</span>:</span><br><span class="line">                        tag+=<span class="number">1</span></span><br><span class="line">                        area[tag]=<span class="number">0</span></span><br><span class="line">                        dfs(tag,i,j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        zeros.add((i,j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max([max(area.values())]+[connect(i,j) <span class="keyword">for</span> (i,j) <span class="keyword">in</span> zeros])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度与点集大小相关$o(n^2)$，空间复杂度也为$o(n^2)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-82/" data-id="cjuh9jx4l003kfww3qu12gbp1" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-81" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-81/">LeetCode Weekly Contest 81</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-81/" class="article-date"><time datetime="2018-04-22T14:11:52.857Z" itemprop="datePublished">2018-04-22</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-81</p>
<p>&lt;!-- more --&gt;</p>
<h2>Shortest Distance to a Character</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/shortest-distance-to-a-character/</p>
<blockquote>
<p>Given a string <code>S</code> and a character <code>C</code>, return an array of integers representing the shortest distance from the character <code>C</code> in the string.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;</span><br><span class="line">Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> string length is in <code>[1, 10000]</code>.</li>
<li><code>C</code> is a single character, and guaranteed to be in string <code>S</code>.
All letters in <code>S</code> and <code>C</code> are lowercase.</li>
</ol>
<p>找到所有<code>C</code>的索引，<code>S</code>的每个字符与所有<code>C</code>的索引值的绝对差取最小值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestToChar</span><span class="params">(self, S, C)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type C: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        targets=[i <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(S) <span class="keyword">if</span> c==C]</span><br><span class="line">        <span class="keyword">return</span> [min([abs(t-i) <span class="keyword">for</span> t <span class="keyword">in</span> targets]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S))]</span><br></pre></td></tr></table></figure></p>
<h2>Card Flipping Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/card-flipping-game/</p>
<blockquote>
<p>On a table are <code>N</code> cards, with a positive integer printed on the front and back of each card (possibly different).</p>
</blockquote>
<blockquote>
<p>We flip any number of cards, and after we choose one card.</p>
</blockquote>
<blockquote>
<p>If the number <code>X</code> on the back of the chosen card is not on the front of any card, then this number <code>X</code> is good.</p>
</blockquote>
<blockquote>
<p>What is the smallest number that is good?  If no number is good, output <code>0</code>.</p>
</blockquote>
<blockquote>
<p>Here, <code>fronts[i]</code> and <code>backs[i]</code> represent the number on the front and back of card <code>i</code>.</p>
</blockquote>
<blockquote>
<p>A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].</span><br><span class="line">We choose the second card, which has number 2 on the back, and it isn&apos;t on the front of any card, so 2 is good.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= fronts.length == backs.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= fronts[i] &lt;= 2000</code>.</li>
<li><code>1 &lt;= backs[i] &lt;= 2000</code>.</li>
</ol>
<p>除了正反两面一样的卡牌无法避免，其他数字都可以通过翻转操作使其只存在于<code>fronts</code>或<code>backs</code>中的一面，只要在这些数字中找到最小的数返回</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipgame</span><span class="params">(self, fronts, backs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type fronts: List[int]</span></span><br><span class="line"><span class="string">        :type backs: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        taboo=set(fronts[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(fronts)) <span class="keyword">if</span> fronts[i]==backs[i])</span><br><span class="line">        gn=set(fronts+backs)-taboo</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> gn:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min(gn)</span><br></pre></td></tr></table></figure></p>
<h2>Short Encoding of Words</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/short-encoding-of-words/</p>
<blockquote>
<p>Given a list of words, we may encode it by writing a reference string <code>S</code> and a list of indexes <code>A</code>.</p>
</blockquote>
<blockquote>
<p>For example, if the list of words is <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>, we can write it as <code>S = &quot;time#bell#&quot;</code> and <code>indexes = [0, 2, 5]</code>.</p>
</blockquote>
<blockquote>
<p>Then for each index, we will recover the word by reading from the reference string from that index until we reach a &quot;#&quot; character.</p>
</blockquote>
<blockquote>
<p>What is the length of the shortest reference string S possible that encodes the given words?</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: S = &quot;time#bell#&quot; and indexes = [0, 2, 5].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code>.</li>
<li><code>1 &lt;= words[i].length &lt;= 7</code>.</li>
<li>Each word has only lowercase letters.</li>
</ol>
<p>当一个词<code>a</code>的全部内容正好能与<code>b</code>的最后几个字母重合，那么在<code>S</code>中只要保留<code>b</code>串即可。那么在<code>words</code>去掉重复词后，对每个词<code>w</code>只要检查它的所有长度的后缀是否还在<code>words</code>中，如果在则移除，<code>words</code>剩下的词即<code>S</code>中所有的词，每个词后加上<code>#</code>标识即可组成<code>S</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumLengthEncoding</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s=set(words)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(w)):</span><br><span class="line">                <span class="keyword">if</span> w[i:] <span class="keyword">in</span> s:</span><br><span class="line">                    s.remove(w[i:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(len(w)+<span class="number">1</span> <span class="keyword">for</span> w <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure></p>
<h2>Binary Trees With Factors</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/binary-trees-with-factors/</p>
<blockquote>
<p>Given an array of unique integers, each integer is strictly greater than 1.</p>
</blockquote>
<blockquote>
<p>We make a binary tree using these integers and each number may be used for any number of times.</p>
</blockquote>
<blockquote>
<p>Each non-leaf node's value should be equal to the product of the values of it's children.</p>
</blockquote>
<blockquote>
<p>How many binary trees can we make?  Return the answer <strong>modulo 10 ** 9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can make these trees: [2], [4], [4, 2, 2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4, 5, 10]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code>.</li>
<li><code>2 &lt;= A[i] &lt;= 10 ^ 9</code>.</li>
</ol>
<p>这题其实不能达到最后一题应有的难度。设每个数字<code>n</code>应有的以其为根的树的数量为<code>tree[n]</code>，<code>n</code>有<code>(i,n/i),...(j,n/k)</code>等<strong>不同</strong>的因数对在<code>A</code>中，因为左右子树可以交换构造不同的树，所有<code>tree[n]=2*tree[i]*tree[n/i]+...+2*tree[j]*tree[n/j]+1</code>，最后的<code>1</code>是因为仅有根结点<code>n</code>也可以形成符合要求的树，如果<code>sqrt(n)</code>也在<code>A</code>中出现，那么只需要再加上<code>tree[sqrt(n)]*tree[sqrt(n)]</code>不必考虑子树的顺序。写的时候可能需要注意一下检查<code>n/i</code>是否在<code>A</code>中的寻址时间过长导致的TLE，可以把<code>A</code>先转换成hash表（<code>set</code>）来适当规避。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        nums=set(A)</span><br><span class="line">        factor=collections.defaultdict(list)</span><br><span class="line">        tree=[<span class="number">1</span>]*len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[j]*A[j]&lt;=A[i] <span class="keyword">and</span> A[i]%A[j]==<span class="number">0</span> <span class="keyword">and</span> A[i]/A[j] <span class="keyword">in</span> nums:</span><br><span class="line">                    factor[i].append((j,A.index(A[i]/A[j])))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(A))):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> factor:</span><br><span class="line">                <span class="keyword">for</span> (x,y) <span class="keyword">in</span> factor[i]:</span><br><span class="line">                    <span class="keyword">if</span> x==y:</span><br><span class="line">                        tree[i]+=tree[x]*tree[y]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tree[i]+=<span class="number">2</span>*tree[x]*tree[y]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(tree)%(<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(n^2)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-81/" data-id="cjuh9jx4i003ifww31uqdfkst" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-80" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-80/">LeetCode Weekly Contest 80</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-80/" class="article-date"><time datetime="2018-04-15T15:20:34.341Z" itemprop="datePublished">2018-04-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-80</p>
<p>&lt;!-- more --&gt;</p>
<h2>Most Common Word</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/most-common-word/</p>
<blockquote>
<p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.</p>
</blockquote>
<blockquote>
<p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class="line">banned = [&quot;hit&quot;]</span><br><span class="line">Output: &quot;ball&quot;</span><br><span class="line">Explanation:</span><br><span class="line">&quot;hit&quot; occurs 3 times, but it is a banned word.</span><br><span class="line">&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.</span><br><span class="line">Note that words in the paragraph are not case sensitive,</span><br><span class="line">that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;),</span><br><span class="line">and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= paragraph.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= banned.length &lt;= 100</code>.</li>
<li><code>1 &lt;= banned[i].length &lt;= 10</code>.</li>
<li>The answer is unique, and written in lowercase (even if its occurrences in <code>paragraph</code> may have uppercase symbols, and even if it is a proper noun.)</li>
<li><code>paragraph</code> only consists of letters, spaces, or the punctuation symbols <code>!?',;</code>.</li>
<li>Different words in <code>paragraph</code> are always separated by a space.</li>
<li>There are no hyphens or hyphenated words.</li>
<li>Words only consist of letters, never apostrophes or other punctuation symbols.</li>
</ol>
<p>把<code>paragraph</code>去掉标点，转换成小写，然后统计词频</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostCommonWord</span><span class="params">(self, paragraph, banned)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type paragraph: str</span></span><br><span class="line"><span class="string">        :type banned: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        punc=<span class="string">"!?',;."</span></span><br><span class="line">        paragraph = str(paragraph).translate(string.maketrans(<span class="string">""</span>,<span class="string">""</span>), punc)</span><br><span class="line">        <span class="keyword">for</span> word,fre <span class="keyword">in</span> collections.Counter(paragraph.lower().split(<span class="string">" "</span>)).most_common():</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> banned:</span><br><span class="line">                <span class="keyword">return</span> word</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度都为$o(n)$</p>
<h2>Linked List Components</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/linked-list-components/</p>
<blockquote>
<p>We are given <code>head</code>, the head node of a linked list containing <strong>unique integer values</strong>.</p>
</blockquote>
<blockquote>
<p>We are also given the list <code>G</code>, a subset of the values in the linked list.</p>
</blockquote>
<blockquote>
<p>Return the number of connected components in <code>G</code>, where two values are connected if they appear consecutively in the linked list.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3</span><br><span class="line">G = [0, 1, 3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">0 and 1 are connected, so [0, 1] and [3] are the two connected components.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class="line">G = [0, 3, 1, 4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>If N is the length of the linked list given by <code>head</code>, <code>1 &lt;= N &lt;= 10000</code>.</li>
<li>The value of each node in the linked list will be in the range <code>[0, N - 1]</code>.</li>
<li><code>1 &lt;= G.length &lt;= 10000</code>.</li>
<li><code>G</code> is a subset of all values in the linked list.</li>
</ol>
<p>遍历链表找哪些连续的部分都出现在了<code>G</code>中，当然<code>list</code>寻值可能会导致TLE，可以转换为hashset之类的数据类型</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numComponents</span><span class="params">(self, head, G)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type G: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        start=<span class="keyword">False</span></span><br><span class="line">        G=set(G)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val <span class="keyword">in</span> G:</span><br><span class="line">                start=<span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> start:</span><br><span class="line">                    start=<span class="keyword">False</span></span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">            head=head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start:</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，$n$为链表的长度</p>
<h2>Ambiguous Coordinates</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/ambiguous-coordinates/</p>
<blockquote>
<p>We had some 2-dimensional coordinates, like <code>&quot;(1, 3)&quot;</code> or <code>&quot;(2, 0.5)&quot;</code>.  Then, we removed all commas, decimal points, and spaces, and ended up with the string <code>S</code>.  Return a list of strings representing all possibilities for what our original coordinates could have been.</p>
</blockquote>
<blockquote>
<p>Our original representation never had extraneous zeroes, so we never started with numbers like &quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;, or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like &quot;.1&quot;.</p>
</blockquote>
<blockquote>
<p>The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(123)&quot;</span><br><span class="line">Output: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(00011)&quot;</span><br><span class="line">Output:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">0.0, 00, 0001 or 00.01 are not allowed.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(0123)&quot;</span><br><span class="line">Output: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(100)&quot;</span><br><span class="line">Output: [(10, 0)]</span><br><span class="line">Explanation:</span><br><span class="line">1.0 is not allowed.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>4 &lt;= S.length &lt;= 12</code>.</li>
<li><code>S[0]</code> = &quot;(&quot;, <code>S[S.length - 1]</code> = &quot;)&quot;, and the other elements in <code>S</code> are digits.</li>
</ol>
<p>需要考虑情况比较多的就是每个坐标里面该不该放小数点？该往哪放？以0开始的数字只可能把小数点放在第二位，以0结尾的数字则不能有小数点，首尾都是0无论怎么放小数点都会是无效数字，单个0本身可以作为一个坐标值。至于x与y的分割没什么限制，只是放小数点的时候需要格外小心。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ambiguousCoordinates</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">SplitDot</span><span class="params">(num)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> num==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'0'</span>]</span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">-1</span>]==<span class="string">'0'</span> <span class="keyword">and</span> num[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'0.'</span>+num[<span class="number">1</span>:]]</span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">-1</span>]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> [num]</span><br><span class="line">            temp=[num]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(num)):</span><br><span class="line">                temp.append(num[:i]+<span class="string">'.'</span>+num[i:])</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(S)<span class="number">-1</span>):</span><br><span class="line">            x=SplitDot(S[<span class="number">1</span>:i])</span><br><span class="line">            y=SplitDot(S[i:len(S)<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> y:</span><br><span class="line">                    res.append(<span class="string">'('</span>+a+<span class="string">', '</span>+b+<span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>最坏情况下的时间复杂度为$o(n^3)$</p>
<h2>Race Car</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/race-car/</p>
<blockquote>
<p>Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)</p>
</blockquote>
<blockquote>
<p>Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).</p>
</blockquote>
<blockquote>
<p>When you get an instruction &quot;A&quot;, your car does the following: <code>position += speed</code>, <code>speed *= 2.</code></p>
</blockquote>
<blockquote>
<p>When you get an instruction &quot;R&quot;, your car does the following: if your speed is positive then <code>speed = -1</code> , otherwise <code>speed = 1</code>.  (Your position stays the same.)</p>
</blockquote>
<blockquote>
<p>For example, after commands &quot;AAR&quot;, your car goes to positions <code>0-&gt;1-&gt;3-&gt;3</code>, and your speed goes to <code>1-&gt;2-&gt;4-&gt;-1</code>.</p>
</blockquote>
<blockquote>
<p>Now for some target position, say the length of the shortest sequence of instructions to get there.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">target = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The shortest instruction sequence is &quot;AA&quot;.</span><br><span class="line">Your position goes from 0-&gt;1-&gt;3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">target = 6</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The shortest instruction sequence is &quot;AAARA&quot;.</span><br><span class="line">Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= target &lt;= 10000</code>.</li>
</ol>
<p>解法还是参考<a href="https://leetcode.com/problems/race-car/discuss/123834/C++JavaPython-DP-solution-average-O(logN)" target="_blank" rel="noopener">DP solution, average O(logN)</a>介绍的动态规划方法，可能很容易想到对于<code>2 ^ (n - 1) -1&lt; target &lt; 2 ^ n-1</code>来说有两种策略</p>
<ol>
<li>先用<code>n</code>个<code>A</code>达到<code>2 ^ n-1</code>位置，然后用一个<code>R</code>，再加上<code>dp[2^n-1-target]</code>的指令</li>
<li>先用<code>n-1</code>个<code>A</code>达到<code>2^(n-1)-1</code>位置，然后用两个<code>R</code>完成速度重置，再加上<code>dp[target-2^(n-1)+1]</code></li>
</ol>
<p>注意情况2是可能存在问题的，在这种情况下，<code>RR</code>操作后从<code>2^(n-1)-1</code>到<code>target</code>的路径可能会存在<code>R</code>，而这个<code>R</code>事实上又可以和前面的<code>R</code>合并，因此是多余的。所以需要在第二个<code>R</code>前先用<code>m</code>个<code>A</code>使其回退，再用<code>R</code>恢复速度方向，从<code>2^(n-1)-2^m</code>位置开始，再加上<code>dp[target-2^(n-1)+2^m)]</code></p>
<p>这里代码还是直接放上原讨论中使用的bottom-up的递归，避免计算了一些不需要了解的情况，非常高效：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> self.dp = &#123;<span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">racecar</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">in</span> self.dp: <span class="keyword">return</span> self.dp[t]</span><br><span class="line">        n = t.bit_length()</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span>**n - <span class="number">1</span> == t: self.dp[t] = n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dp[t] = self.racecar(<span class="number">2</span>**n - <span class="number">1</span> - t) + n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">                self.dp[t] = min(self.dp[t], self.racecar(t - <span class="number">2</span>**(n - <span class="number">1</span>) + <span class="number">2</span>**m) + n + m + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.dp[t]</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-80/" data-id="cjuh9jx4d003gfww3vrty46fa" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-79" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-79/">LeetCode Weekly Contest 79</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-79/" class="article-date"><time datetime="2018-04-09T14:50:06.299Z" itemprop="datePublished">2018-04-09</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>因为最近时间线总是刷出如何看待2017 cs grad就业惨淡，如何看待秋季项目申请水涨船高这种信息，实在让我有点焦虑，所以可能以后社交网络会用的没有以前那么频繁了，不用报警我活的很好，谢谢大家的关心。对我来说刷题也算消遣，请千万不要被误导觉得专注刷题真的有什么用，保持手不生而已，主要还是要回去啃书和备考。</p>
<p>https://leetcode.com/contest/weekly-contest-79</p>
<p>&lt;!-- more --&gt;</p>
<h2>Largest Triangle Area</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/largest-triangle-area/</p>
<blockquote>
<p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The five points are show in the figure below. The red triangle is the largest.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= points.length &lt;= 50</code>.</li>
<li>No points will be duplicated.</li>
<li><code>-50 &lt;= points[i][j] &lt;= 50</code>.</li>
<li>Answers within <code>10^-6</code> of the true value will be accepted as correct.</li>
</ol>
<p>上来第一题，不要去考虑技巧，直接穷举找最大值就可以。顶点为<code>A(x1,y1)</code>，<code>B(x2,y2)</code>和<code>C(x3,y3)</code>的三角形面积为
<span>$S_{\Delta ABC} = \frac{1}{2} |{x_1}{y_2} + {x_2}{y_3} + {x_3}{y_1} - {x_1}{y_3} - {x_3}{y_2} - {x_2}{y_1}|$</span><!-- Has MathJax -->
用这个公式计算各个点组合的面积找到最大值
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestTriangleArea</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0.5</span>*abs(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2) <span class="keyword">for</span> ([x1,y1],[x2,y2],[x3,y3]) <span class="keyword">in</span> itertools.combinations(points,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>当然如果像我这么无聊还能把公式写成
<span>$$S_{\Delta ABC} =  \frac{1}{2} |\det \left( {\left[ {\begin{array}{*{20}{c}}
{x_1}&amp;{y_1}&amp;1\\
{x_2}&amp;{y_2}&amp;1\\
{x_3}&amp;{y_3}&amp;1
\end{array}} \right]} \right)|$$</span><!-- Has MathJax -->
当然这样算有TLE的风险就是了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> max(<span class="number">0.5</span>*abs(float(np.linalg.det(np.array([a+[<span class="number">1</span>],b+[<span class="number">1</span>],c+[<span class="number">1</span>]])))) <span class="keyword">for</span> (a,b,c) <span class="keyword">in</span> itertools.combinations(points,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^3)$，$n$为点集大小</p>
<h2>Binary Tree Pruning</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/binary-tree-pruning/</p>
<blockquote>
<p>We are given the head node <code>root</code> of a binary tree, where additionally every node's value is either a 0 or a 1.</p>
</blockquote>
<blockquote>
<p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p>
</blockquote>
<blockquote>
<p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,0,0,1]</span><br><span class="line">Output: [1,null,0,null,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.</span><br><span class="line">The diagram on the right represents the answer.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,0,0,0,1]</span><br><span class="line">Output: [1,null,1,null,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,0,1,0]</span><br><span class="line">Output: [1,1,0,1,1,null,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The binary tree will have at most <code>100 nodes</code>.</li>
<li>The value of each node will only be <code>0</code> or <code>1</code>.</li>
</ol>
<p>DFS从最低层开始删去每个值为<code>0</code>的叶结点</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pre,cur,d)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    dfs(cur,cur.left,<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    dfs(cur,cur.right,<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> cur.val==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> d&gt;<span class="number">0</span>:</span><br><span class="line">                        pre.right=<span class="keyword">None</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.left=<span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            dfs(root,root.left,<span class="number">-1</span>)</span><br><span class="line">            dfs(root,root.right,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2>Largest Sum of Averages</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/largest-sum-of-averages/</p>
<blockquote>
<p>We partition a row of numbers <code>A</code> into at most <code>K</code> adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
</blockquote>
<blockquote>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [9,1,2,3,9]</span><br><span class="line">K = 3</span><br><span class="line">Output: 20</span><br><span class="line">Explanation:</span><br><span class="line">The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.</span><br><span class="line">We could have also partitioned A into [9, 1], [2], [3, 9], for example.</span><br><span class="line">That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code>.</li>
<li><code>1 &lt;= A[i] &lt;= 10000</code>.</li>
<li><code>1 &lt;= K &lt;= A.length</code>.</li>
<li>Answers within <code>10^-6</code> of the correct answer will be accepted as correct.</li>
</ol>
<p>没多想，直接动态规划暴力解决，<code>dp[n][k]</code>存储到第<code>n</code>个元素为止至多划分<code>k+1</code>组平均数和的最大值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumOfAverages</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp=[[<span class="number">-1</span>]*K <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(A))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            dp[i][<span class="number">0</span>]=sum(A[:i+<span class="number">1</span>])/float(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,min(n+<span class="number">1</span>,K)):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k<span class="number">-1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                        dp[n][k]=max(dp[n][k],dp[i][k<span class="number">-1</span>]+sum(A[i+<span class="number">1</span>:n+<span class="number">1</span>])/float(n-i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2K)$，空间复杂度为$o(nK)$，其中$n$为数组<code>A</code>的长度。也可以用自底而上的方法递归使辅助空间减少到$o(n)$</p>
<h2>Bus Routes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/bus-routes/</p>
<blockquote>
<p>We have a list of bus routes. Each <code>routes[i]</code> is a bus route that the i-th bus repeats forever. For example if <code>routes[0] = [1, 5, 7]</code>, this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;... forever.</p>
</blockquote>
<blockquote>
<p>We start at bus stop <code>S</code> (initially not on a bus), and we want to go to bus stop <code>T</code>. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">routes = [[1, 2, 7], [3, 6, 7]]</span><br><span class="line">S = 1</span><br><span class="line">T = 6</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= routes.length &lt;= 500</code>.</li>
<li><code>1 &lt;= routes[i].length &lt;= 500</code>.</li>
<li><code>0 &lt;= routes[i][j] &lt; 10 ^ 6</code>.</li>
</ol>
<p>一开始我是看错了以为要找到的是最小站数，后来发现是最小换车次数，这样的话应该以公交车的路线为结点，而不是以公交站为结点。有共同站点的两条路线视为邻接结点，包含<code>S</code>的公交路线视为可以开始的源点集，用BFS找到可以到达包含<code>T</code>的公交路线目标点集中任意结点的最短路径。需要格外注意的是，当<code>S==T</code>时，不需要上车就可以到达，所以应该返回0</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination</span><span class="params">(self, routes, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type routes: List[List[int]]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :type T: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> S==T:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        start=set()</span><br><span class="line">        target=set()</span><br><span class="line">        graph=collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(routes)):</span><br><span class="line">            <span class="keyword">if</span> S <span class="keyword">in</span> routes[i]: start.add(i)</span><br><span class="line">            <span class="keyword">if</span> T <span class="keyword">in</span> routes[i]: target.add(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(routes)):</span><br><span class="line">                <span class="keyword">if</span> set(routes[i])&amp;set(routes[j]):</span><br><span class="line">                    graph[i].add(j)</span><br><span class="line">                    graph[j].add(i)</span><br><span class="line"></span><br><span class="line">        queue=[(i,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> start]</span><br><span class="line">        seen=set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node,dist <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> target:</span><br><span class="line">                <span class="keyword">return</span> dist</span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> nei <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nei)</span><br><span class="line">                    queue.append((nei,dist+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-79/" data-id="cjuh9jx49003efww3ypp3tmf3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/6/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li class="active"><span class="page-number">7</span></li><li><a class="page-number" href="/page/8/">8</a></li><li><a class="page-number" href="/page/9/">9</a></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/8/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
