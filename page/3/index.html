<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/3/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-86" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-86/">LeetCode Weekly Contest 86</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-86/" class="article-date"><time datetime="2018-05-27T15:14:31.873Z" itemprop="datePublished">2018-05-27</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-86</p>
<p>&lt;!-- more --&gt;</p>
<h2>Magic Squares In Grid</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-86/problems/magic-squares-in-grid/</p>
<blockquote>
<p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers <strong>from 1 to 9</strong> such that each row, column, and both diagonals all have the same sum.</p>
</blockquote>
<blockquote>
<p>Given an <code>grid</code> of integers, how many 3 x 3 &quot;magic square&quot; subgrids are there?  (Each subgrid is contiguous).</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: [[4,3,8,4],</span><br><span class="line">        [9,5,1,9],</span><br><span class="line">        [2,7,6,2]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">The following subgrid is a 3 x 3 magic square:</span><br><span class="line">438</span><br><span class="line">951</span><br><span class="line">276</span><br><span class="line"></span><br><span class="line">while this one is not:</span><br><span class="line">384</span><br><span class="line">519</span><br><span class="line">762</span><br><span class="line"></span><br><span class="line">In total, there is only one magic square inside the given grid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 15</code></li>
</ol>
<p>数据规模不大，子阵的大小还固定，无脑直接写判定就行</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMagicSquaresInside</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_magic_square</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            nums=[grid[x][y] <span class="keyword">for</span> x <span class="keyword">in</span> range(i,i+<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(j,j+<span class="number">3</span>)]</span><br><span class="line">            <span class="keyword">if</span> len(set(nums))!=<span class="number">9</span> <span class="keyword">or</span> max(nums)&gt;<span class="number">9</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> sum(grid[i+k][j:j+<span class="number">3</span>])!=<span class="number">15</span> <span class="keyword">or</span> grid[i][j+k]+grid[i+<span class="number">1</span>][j+k]+grid[i+<span class="number">2</span>][j+k]!=<span class="number">15</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]+grid[i+<span class="number">2</span>][j+<span class="number">2</span>]!=<span class="number">15</span> <span class="keyword">or</span> grid[i][j+<span class="number">2</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>]+grid[i+<span class="number">2</span>][j]!=<span class="number">15</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> is_magic_square(i,j):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Keys and Rooms</h2>
<blockquote>
<p>There are <code>N</code> rooms and you start in room <code>0</code>.  Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room.</p>
</blockquote>
<blockquote>
<p>Formally, each room <code>i</code> has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>.  A key <code>rooms[i][j] = v</code>opens the room with number <code>v</code>.</p>
</blockquote>
<blockquote>
<p>Initially, all the rooms start locked (except for room <code>0</code>).</p>
</blockquote>
<blockquote>
<p>You can walk back and forth between rooms freely.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if you can enter every room.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&apos;t enter the room with number 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>The number of keys in all rooms combined is at most <code>3000</code>.</li>
</ol>
<p>很简单的图遍历问题，根据初始只能访问0结点的BFS，最后验证能否访问全图。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRooms</span><span class="params">(self, rooms)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rooms: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        access=set(rooms[<span class="number">0</span>]+[<span class="number">0</span>])</span><br><span class="line">        current=rooms[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> len(access)&lt;len(rooms) <span class="keyword">and</span> current:</span><br><span class="line">            node=current.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> rooms[node]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> access:</span><br><span class="line">                    access.add(i)</span><br><span class="line">                    current.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(access)==len(rooms)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度都为$o(N)$</p>
<h2>Split Array into Fibonacci Sequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-86/problems/split-array-into-fibonacci-sequence/</p>
<blockquote>
<p>Given a string <code>S</code> of digits, such as <code>S = &quot;123456579&quot;</code>, we can split it into a Fibonacci-like sequence <code>[123, 456, 579]</code>.</p>
</blockquote>
<blockquote>
<p>Formally, a Fibonacci-like sequence is a list <code>F</code> of non-negative integers such that:</p>
</blockquote>
<ol>
<li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>, (that is, each integer fits a 32-bit signed integer type);</li>
<li><code>F.length &gt;= 3</code>;</li>
<li>and <code>F[i] + F[i+1] = F[i+2]</code> for all <code>0 &lt;= i &lt; F.length - 2</code>.</li>
</ol>
<blockquote>
<p>Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.</p>
</blockquote>
<blockquote>
<p>Return any Fibonacci-like sequence split from <code>S</code>, or return <code>[]</code> if it cannot be done.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;123456579&quot;</span><br><span class="line">Output: [123,456,579]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;11235813&quot;</span><br><span class="line">Output: [1,1,2,3,5,8,13]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;112358130&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The task is impossible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;0123&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: Leading zeroes are not allowed, so &quot;01&quot;, &quot;2&quot;, &quot;3&quot; is not valid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1101111&quot;</span><br><span class="line">Output: [110, 1, 111]</span><br><span class="line">Explanation: The output [11, 0, 11, 11] would also be accepted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>S contains only digits</code>.</li>
</ol>
<p>直接的想法是DFS/BFS+回溯，但其实没有必要，因为递推式固定，只要确定前两项，就可以直接线性扫描后面的字符串是否符合递推式从而判断这两项前否成为一个类Fibonacci序列的初始项。</p>
<p>而找这前两项的时候，有一些细碎的问题需要注意</p>
<ol>
<li>因为存在每项整数大小限制，所以该每个数字所占的位数不会超过10</li>
<li>第一项的长度不可能大于第三项，所以第一项终点最多到<code>len(S)/2</code></li>
<li>前两项需要当心前导0，当数字长度超过1时第一位不能为0</li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitIntoFibonacci</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check_recurrent</span><span class="params">(base,start)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> start&lt;len(S):</span><br><span class="line">                next_num=base[<span class="number">-1</span>]+base[<span class="number">-2</span>]</span><br><span class="line">                offset=len(str(next_num))</span><br><span class="line">                <span class="keyword">if</span> next_num&lt;<span class="number">2</span>**<span class="number">31</span> <span class="keyword">and</span> start+offset&lt;=len(S) <span class="keyword">and</span> str(next_num)==S[start:start+offset]:</span><br><span class="line">                    base.append(next_num)</span><br><span class="line">                    start+=offset</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> base</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,min(<span class="number">11</span>,len(S)/<span class="number">2</span>+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> S[<span class="number">0</span>]==<span class="string">'0'</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,min(<span class="number">11</span>+i,len(S))):</span><br><span class="line">                <span class="keyword">if</span> j-i&gt;<span class="number">1</span> <span class="keyword">and</span> S[i]==<span class="string">'0'</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> int(S[:i])&lt;<span class="number">2</span>**<span class="number">31</span> <span class="keyword">and</span> int(S[i:j])&lt;<span class="number">2</span>**<span class="number">31</span>:</span><br><span class="line">                    third=int(S[:i])+int(S[i:j])</span><br><span class="line">                    <span class="keyword">if</span> third&lt;<span class="number">2</span>**<span class="number">31</span> <span class="keyword">and</span> j+len(str(third))&lt;=len(S) <span class="keyword">and</span> str(third)==S[j:j+len(str(third))]:</span><br><span class="line">                        res=check_recurrent([int(S[:i]),int(S[i:j]),third],j+len(str(third)))</span><br><span class="line">                        <span class="keyword">if</span> res:</span><br><span class="line">                            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></p>
<p>因为整数不超过10位的限制，所以双指针找前两项的循环次数不会超过<code>10^2</code>，可以看做常数，算法的开销在验证后续项是否符合递推式的<code>check_recurrent</code>过程上，复杂度为$o(N)$</p>
<h2>Guess the Word</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-86/problems/guess-the-word/</p>
<blockquote>
<p>his problem is an <strong>interactive problem</strong> new to the LeetCode platform.</p>
</blockquote>
<blockquote>
<p>We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as <strong>secret</strong>.</p>
</blockquote>
<blockquote>
<p>You may call <code>master.guess(word)</code> to guess a word.  The guessed word should have type <code>string</code> and must be from the original list with 6 lowercase letters.</p>
</blockquote>
<blockquote>
<p>This function returns an <code>integer</code> type, representing the number of exact matches (value and position) of your guess to the <strong>secret word</strong>.  Also, if your guess is not in the given wordlist, it will return <code>-1</code> instead.</p>
</blockquote>
<blockquote>
<p>For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to <code>master.guess</code> and at least one of these guesses was the <strong>secret</strong>, you pass the testcase.</p>
</blockquote>
<blockquote>
<p>Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from <code>'a'</code> to <code>'z'</code>, such that every word in the given word lists is unique.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: secret = &quot;acckzz&quot;, wordlist = [&quot;acckzz&quot;,&quot;ccbazz&quot;,&quot;eiowzz&quot;,&quot;abcczz&quot;]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">master.guess(&quot;aaaaaa&quot;) returns -1, because &quot;aaaaaa&quot; is not in wordlist.</span><br><span class="line">master.guess(&quot;acckzz&quot;) returns 6, because &quot;acckzz&quot; is secret and has all 6 matches.</span><br><span class="line">master.guess(&quot;ccbazz&quot;) returns 3, because &quot;ccbazz&quot; has 3 matches.</span><br><span class="line">master.guess(&quot;eiowzz&quot;) returns 2, because &quot;eiowzz&quot; has 2 matches.</span><br><span class="line">master.guess(&quot;abcczz&quot;) returns 4, because &quot;abcczz&quot; has 4 matches.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We made 5 calls to master.guess and one of them was the secret, so we pass the test case.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:  Any solutions that attempt to circumvent the judge will result in disqualification.</p>
</blockquote>
<p>新题型，不过没什么好慌的，无非是从长度为100的<code>wordlist</code>猜<code>secret</code>并且调用<code>master.guess(word)</code>次数<code>&lt;=10</code>的限制。注意：</p>
<ol>
<li><code>wordlist</code>的元素是随机生成的，且每个词都不同</li>
<li><code>secret</code>一定在<code>wordlist</code>中</li>
</ol>
<p>那么当得到上一次猜测<code>g</code>的返回值<code>n=master.guess(g)</code>，再次猜测的范围就可以缩小到<code>wordlist</code>中只有<code>n</code>个字符和<code>g</code>匹配的子集。这样一步步提高<code>n</code>的值，最后一定能找到<code>secret</code>。问题在于如何找第一个<code>g</code>，为了让最坏的情况，即<code>n=0</code>时下一轮猜测的范围也能减少到最小，每个<code>g</code>应该选择当前<code>wordlist</code>中匹配数为<code>0</code>的元素最少的元素。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment"># This is Master's API interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># """</span></span><br><span class="line"><span class="comment">#class Master(object):</span></span><br><span class="line"><span class="comment">#    def guess(self, word):</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"><span class="comment">#        :type word: str</span></span><br><span class="line"><span class="comment">#        :rtype int</span></span><br><span class="line"><span class="comment">#        """</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSecretWord</span><span class="params">(self, wordlist, master)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type wordlist: List[Str]</span></span><br><span class="line"><span class="string">        :type master: Master</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">match_count</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum(a[i]==b[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n&lt;<span class="number">6</span>:</span><br><span class="line">            match=collections.Counter(a <span class="keyword">for</span> (a,b) <span class="keyword">in</span> itertools.permutations(wordlist,<span class="number">2</span>) <span class="keyword">if</span> match_count(a,b)==<span class="number">0</span>)</span><br><span class="line">            g=min(wordlist,key=<span class="keyword">lambda</span> w:match[w])</span><br><span class="line">            n=master.guess(g)</span><br><span class="line">            wordlist=[w <span class="keyword">for</span> w <span class="keyword">in</span> wordlist <span class="keyword">if</span> match_count(g,w)==n]</span><br></pre></td></tr></table></figure></p>
<p>令$n$为<code>wordlist</code>长度，时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-86/" data-id="cjm54ylka0023fkw3pujiqza4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-85" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-85/">LeetCode Weekly Contest 85</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-85/" class="article-date"><time datetime="2018-05-20T13:21:27.819Z" itemprop="datePublished">2018-05-20</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-85</p>
<p>&lt;!-- more --&gt;</p>
<h2>Rectangle Overlap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/rectangle-overlap/</p>
<blockquote>
<p>A rectangle is represented as a list <code>[x1, y1, x2, y2]</code>, where <code>(x1, y1)</code> are the coordinates of its bottom-left corner, and <code>(x2, y2)</code> are the coordinates of its top-right corner.</p>
</blockquote>
<blockquote>
<p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p>
</blockquote>
<blockquote>
<p>Given two rectangles, return whether they overlap.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li>Both rectangles <code>rec1</code> and <code>rec2</code> are lists of 4 integers.</li>
<li>All coordinates in rectangles will be between <code>-10^9</code>and <code>10^9</code>.</li>
</ol>
<p>左下顶点和右上顶点给出的是整个矩形的x范围和y范围，比较两个矩阵的x范围和y范围是否都有重叠就可以判断两个矩形有无重叠。注意仅有顶点或边重叠时不算重叠。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(self, rec1, rec2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rec1: List[int]</span></span><br><span class="line"><span class="string">        :type rec2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r1x1,r1y1,r1x2,r1y2=rec1</span><br><span class="line">        r2x1,r2y1,r2x2,r2y2=rec2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (r2x1-r1x2)*(r2x2-r1x1)&lt;<span class="number">0</span> <span class="keyword">and</span> (r2y1-r1y2)*(r2y2-r1y1)&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2>Push Dominoes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/push-dominoes/</p>
<blockquote>
<p>There are <code>N</code> dominoes in a line, and we place each domino vertically upright.</p>
</blockquote>
<blockquote>
<p>In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png" alt=""></p>
</blockquote>
<blockquote>
<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left.</p>
</blockquote>
<blockquote>
<p>Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>
</blockquote>
<blockquote>
<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>
</blockquote>
<blockquote>
<p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p>
</blockquote>
<blockquote>
<p>Given a string &quot;S&quot; representing the initial state. <code>S[i] = 'L'</code>, if the <code>i</code>-th domino has been pushed to the left; <code>S[i] = 'R'</code>, if the i-th domino has been pushed to the right; <code>S[i] = '.'</code>, if the <code>i</code>-th domino has not been pushed.</p>
</blockquote>
<blockquote>
<p>Return a string representing the final state.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;.L.R...LR..L..&quot;</span><br><span class="line">Output: &quot;LL.RR.LLRRLL..&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;RR.L&quot;</span><br><span class="line">Output: &quot;RR.L&quot;</span><br><span class="line">Explanation: The first domino expends no additional force on the second domino.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= N &lt;= 10^5</code></li>
<li>String dominoes contains only <code>'L'</code>, <code>'R'</code> and <code>'.'</code></li>
</ol>
<p>对每一轮（秒）新产生的倾倒的多米诺，观察其倾倒方向的下一个多米诺：</p>
<ol>
<li>是否为已经在下一轮且反方向倾倒？如果是，则改为竖直且从下一轮中移除</li>
<li>是否未倾倒？如果是，则放入下一轮且改为该方向倾倒</li>
</ol>
<p>注意每轮需要处理的多米诺序号放入寻址比较方便的<code>set</code>，否则可能有TLE的危险。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushDominoes</span><span class="params">(self, dominoes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dominoes: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dominoes=list(dominoes)</span><br><span class="line">        now=set([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dominoes)) <span class="keyword">if</span> dominoes[i]!=<span class="string">'.'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> now:</span><br><span class="line">            temp=set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> now:</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> dominoes[i]==<span class="string">'L'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i<span class="number">-1</span> <span class="keyword">in</span> temp <span class="keyword">and</span> dominoes[i<span class="number">-1</span>]==<span class="string">'R'</span>:</span><br><span class="line">                        temp.remove(i<span class="number">-1</span>)</span><br><span class="line">                        dominoes[i<span class="number">-1</span>]=<span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">elif</span> dominoes[i<span class="number">-1</span>]==<span class="string">'.'</span>:</span><br><span class="line">                        temp.add(i<span class="number">-1</span>)</span><br><span class="line">                        dominoes[i<span class="number">-1</span>]=<span class="string">'L'</span></span><br><span class="line">                <span class="keyword">if</span> i&lt;len(dominoes)<span class="number">-1</span> <span class="keyword">and</span> dominoes[i]==<span class="string">'R'</span>:</span><br><span class="line">                    <span class="keyword">if</span> i+<span class="number">1</span> <span class="keyword">in</span> temp <span class="keyword">and</span> dominoes[i+<span class="number">1</span>]==<span class="string">'L'</span>:</span><br><span class="line">                        temp.remove(i+<span class="number">1</span>)</span><br><span class="line">                        dominoes[i+<span class="number">1</span>]=<span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">elif</span> dominoes[i+<span class="number">1</span>]==<span class="string">'.'</span>:</span><br><span class="line">                        temp.add(i+<span class="number">1</span>)</span><br><span class="line">                        dominoes[i+<span class="number">1</span>]=<span class="string">'R'</span></span><br><span class="line">            now=temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(dominoes)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度也为$o(n)$</p>
<h2>New 21 Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/new-21-game/</p>
<blockquote>
<p>Alice plays the following game, loosely based on the card game &quot;21&quot;.</p>
</blockquote>
<blockquote>
<p>Alice starts with <code>0</code> points, and draws numbers while she has less than <code>K</code> points.  During each draw, she gains an integer number of points randomly from the range <code>[1, W]</code>, where <code>W</code> is an integer.  Each draw is independent and the outcomes have equal probabilities.</p>
</blockquote>
<blockquote>
<p>Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 10, K = 1, W = 10</span><br><span class="line">Output: 1.00000</span><br><span class="line">Explanation:  Alice gets a single card, then stops.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 6, K = 1, W = 10</span><br><span class="line">Output: 0.60000</span><br><span class="line">Explanation:  Alice gets a single card, then stops.</span><br><span class="line">In 6 out of W = 10 possibilities, she is at or below N = 6 points.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 21, K = 17, W = 10</span><br><span class="line">Output: 0.73278</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li>
<li><code>1 &lt;= W &lt;= 10000</code></li>
<li>Answers will be accepted as correct if they are within <code>10^-5</code> of the correct answer.</li>
<li>The judging time limit has been reduced for this question.</li>
</ol>
<p>获得<code>i</code>点数的方法无非就是从某个<code>[i-W,i-1]</code>开始抽中一个正好相加得到<code>i</code>的整数，也就是说获得过点数<code>i</code>的概率$p(i)$可以表示为：</p>
<p><span>$p\left( i \right) = \sum\limits_{j = i - W}^{i - 1} {p\left( j \right) \cdot \frac{1}{W}}  = \frac{\sum\limits_{j = i - W}^{i - 1} {p\left( j \right)}}{W}$</span><!-- Has MathJax --></p>
<p>也就是说$p(i)$等于之前最近的<code>w</code>个数的概率和的平均数，当然需要注意一下边界，最小从0开始计数，当点数已经达到<code>K</code>时就停止继续取数，所以求和上界也不可以超过<code>K</code>。最后返回<code>&gt;K</code>且<code>&lt;=N</code>部分的概率即可</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N, K, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N&gt;=K+W <span class="keyword">or</span> K==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp=[<span class="number">1.0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            start=max(i-W,<span class="number">0</span>)</span><br><span class="line">            end=min(i,K)</span><br><span class="line">            dp[i]=sum(dp[start:end])/W</span><br><span class="line">        <span class="keyword">return</span> sum(dp[K:])</span><br></pre></td></tr></table></figure></p>
<p>这种写法是有问题的，浪费时间在反复求和上，最终导致TLE，因为是连续数，所以可以像以前在<a href="https://leetcode.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">Maximum Average Subarray I</a>的做法，只计算当前临时和的变化。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N, K, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N&gt;=K+W <span class="keyword">or</span> K==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp=[<span class="number">1.0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        temp=dp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            dp[i]=temp/W</span><br><span class="line">            <span class="keyword">if</span> i&lt;K:</span><br><span class="line">                temp+=dp[i]</span><br><span class="line">            <span class="keyword">if</span> i&gt;=W:</span><br><span class="line">                temp-=dp[i-W]</span><br><span class="line">        <span class="keyword">return</span> sum(dp[K:])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$，空间复杂度也为$o(N)$</p>
<h2>Similar String Groups</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-85/problems/similar-string-groups/</p>
<blockquote>
<p>Two strings <code>X</code> and <code>Y</code> are similar if we can swap two letters (in different positions) of <code>X</code>, so that it equals <code>Y</code>.</p>
</blockquote>
<blockquote>
<p>For example, <code>&quot;tars&quot;</code> and <code>&quot;rats&quot;</code> are similar (swapping at positions <code>0</code> and <code>2</code>), and <code>&quot;rats&quot;</code> and <code>&quot;arts&quot;</code> are similar, but <code>&quot;star&quot;</code> is not similar to &quot;tars&quot;, <code>&quot;rats&quot;</code>, or <code>&quot;arts&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Together, these form two connected groups by similarity: <code>{&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;}</code> and <code>{&quot;star&quot;}</code>.  Notice that <code>&quot;tars&quot;</code> and <code>&quot;arts&quot;</code> are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p>
</blockquote>
<blockquote>
<p>We are given a list <code>A</code> of unique strings.  Every string in <code>A</code> is an anagram of every other string in <code>A</code>.  How many groups are there?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A.length &lt;= 2000</code></li>
<li><code>A[i].length &lt;= 1000</code></li>
<li><code>A.length * A[i].length &lt;= 20000</code></li>
<li>All words in <code>A</code> consist of lowercase letters only.</li>
<li>All words in <code>A</code> have the same length and are anagrams of each other.</li>
<li>The judging time limit has been increased for this question.</li>
</ol>
<p>基本参考[这个解法][1]。</p>
<p>这题的时间限制稍微宽松一点，所以暴力搜索也不是很糟糕。当<code>A</code>的元素不是特别多的时候，使用暴力搜索，将相似的词两两等价合并。注意<code>A</code>的单词都是anagram所以当<code>A</code>的元素比较多而单词长度不是特别大的时候，可以通过穷举构造相似集检验这些词是否在<code>A</code>中以避开对<code>A</code>的遍历</p>
<p>[1]: https://leetcode.com/problems/similar-string-groups/discuss/132345/Python-Union-Find-Solution-with-Tricky-min(O(MN2)-O(NM2))</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n,m=len(A),len(A[<span class="number">0</span>])</span><br><span class="line">        leader=&#123;i: i <span class="keyword">for</span> i <span class="keyword">in</span> A&#125;</span><br><span class="line">        self.groups=n</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">similar</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> sum(i!=j <span class="keyword">for</span> (i,j) <span class="keyword">in</span> zip(x,y))==<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">label</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> leader[x]!=x:</span><br><span class="line">                <span class="keyword">return</span> label(leader[x])</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            x,y=label(x),label(y)</span><br><span class="line">            <span class="keyword">if</span> x!=y:</span><br><span class="line">                leader[x]=y</span><br><span class="line">                self.groups-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n&lt;m:</span><br><span class="line">            <span class="keyword">for</span> (x,y) <span class="keyword">in</span> itertools.combinations(A,<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> similar(x,y):</span><br><span class="line">                    union(x,y)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">                <span class="keyword">for</span> (i,j) <span class="keyword">in</span> itertools.combinations(range(m),<span class="number">2</span>):</span><br><span class="line">                    y=x[:i]+x[j]+x[i+<span class="number">1</span>:j]+x[i]+x[j+<span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> y <span class="keyword">in</span> leader:</span><br><span class="line">                        union(x,y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.groups</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$(mn\times min(m,n))$，空间复杂度为$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-85/" data-id="cjm54yll40028fkw36sd8tab1" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-84" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-84/">LeetCode Weekly Contest 84</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-84/" class="article-date"><time datetime="2018-05-13T07:31:11.615Z" itemprop="datePublished">2018-05-13</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-84</p>
<p>&lt;!-- more --&gt;</p>
<h2>Flipping an Image</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/flipping-an-image/</p>
<blockquote>
<p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.</p>
</blockquote>
<blockquote>
<p>To flip an image horizontally means that each row of the image is reversed.  For example, flipping <code>[1, 1, 0]</code> horizontally results in <code>[0, 1, 1]</code>.</p>
</blockquote>
<blockquote>
<p>To invert an image means that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>. For example, inverting <code>[0, 1, 1]</code> results in <code>[1, 0, 0]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">Output: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</span><br><span class="line">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].</span><br><span class="line">Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ol>
<p>随便写吧，<code>numpy</code>会更方便写，但也没必要</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[i])):</span><br><span class="line">                A[i][j]=<span class="number">1</span>-A[i][j]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[i])/<span class="number">2</span>):</span><br><span class="line">                A[i][j],A[i][-j<span class="number">-1</span>]=A[i][-j<span class="number">-1</span>],A[i][j]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure></p>
<h2>Find And Replace in String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/find-and-replace-in-string/</p>
<blockquote>
<p>To some string <code>S</code>, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
</blockquote>
<blockquote>
<p>Each replacement operation has <code>3</code> parameters: a starting index <code>i</code>, a source word x and a target word <code>y</code>.  The rule is that if <code>x</code> starts at position <code>i</code> in the <strong>original string</strong> <code>S</code>, then we will replace that occurrence of <code>x</code> with <code>y</code>.  If not, we do nothing.</p>
</blockquote>
<blockquote>
<p>For example, if we have <code>S = &quot;abcd&quot;</code> and we have some replacement operation <code>i = 2, x = &quot;cd&quot;, y = &quot;ffff&quot;</code>, then because <code>&quot;cd&quot;</code> starts at position <code>2</code> in the original string <code>S</code>, we will replace it with <code>&quot;ffff&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Using another example on <code>S = &quot;abcd&quot;</code>, if we have both the replacement operation <code>i = 0, x = &quot;ab&quot;, y = &quot;eee&quot;</code>, as well as another replacement operation <code>i = 2, x = &quot;ec&quot;, y = &quot;ffff&quot;</code>, this second operation does nothing because in the original string <code>S[2] = 'c'</code>, which doesn't match <code>x[0] = 'e'</code>.</p>
</blockquote>
<blockquote>
<p>All these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, <code>S = &quot;abc&quot;, indexes = [0, 1], sources = [&quot;ab&quot;,&quot;bc&quot;]</code> is not a valid test case.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeebffff&quot;</span><br><span class="line">Explanation: &quot;a&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;cd&quot; starts at index 2 in S, so it&apos;s replaced by &quot;ffff&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeecd&quot;</span><br><span class="line">Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= indexes.length = sources.length = targets.length &lt;= 100</code></li>
<li><code>0 &lt; indexes[i] &lt; S.length &lt;= 1000</code></li>
<li>All characters in given inputs are lowercase letters.</li>
</ol>
<p>比上面那题甚至更简单，Py的<code>str</code>还是不可更改的变量，不用动原地代替的想法，所以索引上都没什么特别要留心的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findReplaceString</span><span class="params">(self, S, indexes, sources, targets)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type indexes: List[int]</span></span><br><span class="line"><span class="string">        :type sources: List[str]</span></span><br><span class="line"><span class="string">        :type targets: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ptr=<span class="number">0</span></span><br><span class="line">        res=<span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> ptr&lt;len(S):</span><br><span class="line">            res+=S[ptr]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(indexes)):</span><br><span class="line">                <span class="keyword">if</span> ptr==indexes[i] <span class="keyword">and</span> ptr+len(sources[i])&lt;=len(S) <span class="keyword">and</span> S[ptr:ptr+len(sources[i])]==sources[i]:</span><br><span class="line">                    res=res[:<span class="number">-1</span>]+targets[i]</span><br><span class="line">                    ptr+=len(sources[i])<span class="number">-1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ptr+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Image Overlap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/image-overlap/</p>
<blockquote>
<p>Two images <code>A</code> and <code>B</code> are given, represented as binary, square matrices of the same size.  (A binary matrix has only 0s and 1s as values.)</p>
</blockquote>
<blockquote>
<p>We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images.</p>
</blockquote>
<blockquote>
<p>(Note also that a translation does <strong>not</strong> include any kind of rotation.)</p>
</blockquote>
<blockquote>
<p>What is the largest possible overlap?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [[1,1,0],</span><br><span class="line">            [0,1,0],</span><br><span class="line">            [0,1,0]]</span><br><span class="line">       B = [[0,0,0],</span><br><span class="line">            [0,1,1],</span><br><span class="line">            [0,0,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We slide A to right by 1 unit and down by 1 unit.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length = A[0].length = B.length = B[0].length &lt;= 30</code></li>
<li><code>0 &lt;= A[i][j], B[i][j] &lt;= 1</code></li>
</ol>
<p>因为只有平移后<code>1</code>位置相同才可以被看作重叠，也只有重叠的<code>1</code>的数目需要返回。没有特别好的方法，还是暴力搜索，记录<code>A</code>和<code>B</code>中所有<code>1</code>的坐标，并记录每个<code>A</code>中的<code>1</code>和每个<code>B</code>中的<code>1</code>之间的距离，距离的最大频数即为结果。这里为了节约空间，把这个距离表示成了一个一维线性的数值：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestOverlap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :type B: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(A)</span><br><span class="line">        ones_in_A=[i/n*(n*<span class="number">2</span>)+i%n <span class="keyword">for</span> i <span class="keyword">in</span> range(n*n) <span class="keyword">if</span> A[i/n][i%n]==<span class="number">1</span>]</span><br><span class="line">        ones_in_B=[i/n*(n*<span class="number">2</span>)+i%n <span class="keyword">for</span> i <span class="keyword">in</span> range(n*n) <span class="keyword">if</span> B[i/n][i%n]==<span class="number">1</span>]</span><br><span class="line">        c=collections.Counter([i-j <span class="keyword">for</span> i <span class="keyword">in</span> ones_in_A <span class="keyword">for</span> j <span class="keyword">in</span> ones_in_B])</span><br><span class="line">        <span class="keyword">return</span> max(c.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^4)$，空间复杂度也为$o(n^4)$</p>
<h2>Sum of Distances in Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-84/problems/sum-of-distances-in-tree/</p>
<blockquote>
<p>An undirected, connected tree with <code>N</code> nodes labelled <code>0...N-1</code> and <code>N-1</code> edges are given.</p>
</blockquote>
<blockquote>
<p>The <code>i</code>th edge connects nodes <code>edges[i][0]</code> and <code>edges[i][1]</code> together.</p>
</blockquote>
<blockquote>
<p>Return a list <code>ans</code>, where <code>ans[i]</code> is the sum of the distances between node i and all other nodes.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]</span><br><span class="line">Output: [8,12,6,10,10,10]</span><br><span class="line">Explanation:</span><br><span class="line">Here is a diagram of the given tree:</span><br><span class="line">  0</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /|\</span><br><span class="line">  3 4 5</span><br><span class="line">We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)</span><br><span class="line">equals 1 + 1 + 2 + 2 + 2 = 8.  Hence, answer[0] = 8, and so on.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: <code>1 &lt;= N &lt;= 10000</code></p>
</blockquote>
<p>直球去遍历算多源之间的路径长度和将面临$o(N^2)$的时间复杂度，但树是一种有良好性质的图，可以利用它的一些特性（连通且无回路，任一一个点可以作为根结点）简化计算，使得我们只要后序遍历和先序遍历一次就能得到结果。</p>
<p>我们用<code>subtree[i]</code>表示以<code>i</code>为根结点的子树的结点总数（包括<code>i</code>本身），用<code>s[i]</code>表示<code>i</code>到其他所有结点的距离的和。那么接下来可以做的工作是自底而上<strong>后序遍历</strong>一遍整根树，得到每个结点正确的<code>subtree[i]</code>值，即<code>subtree[i]=sum(subtree[j])+1</code>，<code>j</code>为<code>i</code>所有的子结点，再计算<code>i</code>来自及子树的距离和，相比<code>j</code>到其子树的所有距离和，显然需要对<code>j</code>子树的每个结点加上<code>i</code>到<code>j</code>距离（也就是1），所以有<code>s[i]=sum(s[j]+subtree[j])</code>。注意这时的<code>s[i]</code>仅包含来自子结点的距离和，不包含父结点部分，所以只有整个树的根结点<code>root</code>（可以假设这个根结点为<code>0</code>）的<code>subtree[root]</code>值是完整的。</p>
<p>接下来要得到该树除了根结点以外的结点的正确的<code>s[i]</code>值，只需要再进行一次自顶向下的<strong>先序遍历</strong>。对于结点<code>i</code>，“旋转”其与父结点<code>r</code>的边，使得<code>i</code>成为<code>r</code>的父结点，相比到<code>r</code>的距离和，计算到<code>i</code>的距离和时可以发现：以<code>r</code>为根且与<code>i</code>无关的部分即<code>N-subtree[i]</code>每个结点再加上<code>i-r</code>间距离（即<code>1</code>）就是到<code>i</code>的距离和，与<code>i</code>子树相关的部分则是到<code>r</code>的距离和再减去<code>1</code>构成。容易得到<code>s[i]=s[r]+(N-subtree[i])-subtree[i]</code>。完成这次自顶而下的遍历后返回<code>s</code>即最终结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfDistancesInTree</span><span class="params">(self, N, edges)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        subtree=[<span class="number">0</span>]*N</span><br><span class="line">        s=[<span class="number">0</span>]*N</span><br><span class="line">        adj=collections.defaultdict(set)</span><br><span class="line">        seen=set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> [i,j] <span class="keyword">in</span> edges:</span><br><span class="line">            adj[i].add(j)</span><br><span class="line">            adj[j].add(i)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            seen.add(root)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adj[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    post_dfs(i)</span><br><span class="line">                    subtree[root]+=subtree[i]</span><br><span class="line">                    s[root]+=s[i]+subtree[i]</span><br><span class="line">            subtree[root]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre_dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            seen.add(root)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adj[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    s[i]=s[root]+N<span class="number">-2</span>*subtree[i]</span><br><span class="line">                    pre_dfs(i)</span><br><span class="line"></span><br><span class="line">        post_dfs(<span class="number">0</span>)</span><br><span class="line">        seen=set()</span><br><span class="line">        pre_dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$，空间复杂度也为$o(N)$（这点注意是树结构，边也是$o(N)$，所以邻接表的空间代价只有$o(N)$）</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-84/" data-id="cjm54yll4002afkw3ffbgk19r" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-83" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-83/">LeetCode Weekly Contest 83</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-83/" class="article-date"><time datetime="2018-05-06T08:12:30.273Z" itemprop="datePublished">2018-05-06</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-83</p>
<p>&lt;!-- more --&gt;</p>
<h2>Positions of Large Groups</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/positions-of-large-groups/</p>
<blockquote>
<p>In a string <code>S</code> of lowercase letters, these letters form consecutive groups of the same character.</p>
</blockquote>
<blockquote>
<p>For example, a string like <code>S = &quot;abbxxxxzyy&quot;</code> has the groups <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> and <code>&quot;yy&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group.</p>
</blockquote>
<blockquote>
<p>The final answer should be in lexicographic order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbxxxxzzy&quot;</span><br><span class="line">Output: [[3,6]]</span><br><span class="line">Explanation: &quot;xxxx&quot; is the single large group with starting  3 and ending positions 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">Output: [[3,5],[6,9],[12,14]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 1000</code></li>
</ol>
<p>老题了，这种线性扫描一遍找指定子串的问题不知道写过多少次了。可能唯一值得注意的就是最后一个子串的最后一个字符是不是<code>len(S)-1</code>。然后就随便写写吧。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        interval=[]</span><br><span class="line">        lo=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            <span class="keyword">if</span> c!=S[lo]:</span><br><span class="line">                <span class="keyword">if</span> i-lo<span class="number">-1</span>&gt;<span class="number">1</span>:</span><br><span class="line">                    interval.append([lo,i<span class="number">-1</span>])</span><br><span class="line">                lo=i</span><br><span class="line">        <span class="keyword">if</span> len(S)<span class="number">-1</span>-lo&gt;<span class="number">1</span>:</span><br><span class="line">            interval.append([lo,len(S)<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> interval</span><br></pre></td></tr></table></figure></p>
<p>线性扫描的时间和空间复杂度都为$o(n)$</p>
<h2>Masking Personal Information</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/masking-personal-information/</p>
<blockquote>
<p>We are given a personal information string <code>S</code>, which may represent either <strong>an email address</strong> or <strong>a phone number</strong>.</p>
</blockquote>
<blockquote>
<p>We would like to mask this personal information according to the following rules:</p>
</blockquote>
<blockquote>
<p><strong>1. Email address</strong>:</p>
</blockquote>
<blockquote>
<p>We define a <strong>name</strong> to be a string of <code>length ≥ 2</code> consisting of only lowercase letters <code>a-z</code> or uppercase letters <code>A-Z</code>.</p>
</blockquote>
<blockquote>
<p>An email address starts with a name, followed by the symbol <code>'@'</code>, followed by a name, followed by the dot <code>'.'</code> and followed by a name.</p>
</blockquote>
<blockquote>
<p>All email addresses are guaranteed to be valid and in the format of <code>&quot;name1@name2.name3&quot;</code>.</p>
</blockquote>
<blockquote>
<p>To mask an email, <strong>all names must be converted to lowercase</strong> and <strong>all letters between the first and last letter of the first name</strong> must be replaced by 5 asterisks <code>'*'</code>.</p>
</blockquote>
<blockquote>
<p><strong>2. Phone number</strong>:</p>
</blockquote>
<blockquote>
<p>A phone number is a string consisting of only the digits <code>0-9</code> or the characters from the set <code>{'+', '-', '(', ')', ' '}</code>. You may assume a phone number contains 10 to 13 digits.</p>
</blockquote>
<blockquote>
<p>The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.</p>
</blockquote>
<blockquote>
<p>The local number should be formatted and masked as <code>&quot;***-***-1111&quot;</code>, where 1 represents the exposed digits.</p>
</blockquote>
<blockquote>
<p>To mask a phone number with country code like <code>&quot;+111 111 111 1111&quot;</code>, we write it in the form <code>&quot;+***-***-***-1111&quot;</code>.  The <code>'+'</code> sign and the first <code>'-'</code> sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with <code>&quot;+**-&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Note that extraneous characters like <code>&quot;(&quot;, &quot;)&quot;, &quot; &quot;</code>, as well as extra dashes or plus signs not part of the above formatting scheme should be removed.</p>
</blockquote>
<blockquote>
<p>Return the correct &quot;mask&quot; of the information provided.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LeetCode@LeetCode.com&quot;</span><br><span class="line">Output: &quot;l*****e@leetcode.com&quot;</span><br><span class="line">Explanation: All names are converted to lowercase, and the letters between the</span><br><span class="line">             first and last letter of the first name is replaced by 5 asterisks.</span><br><span class="line">             Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB@qq.com&quot;</span><br><span class="line">Output: &quot;a*****b@qq.com&quot;</span><br><span class="line">Explanation: There must be 5 asterisks between the first and last letter</span><br><span class="line">             of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1(234)567-890&quot;</span><br><span class="line">Output: &quot;***-***-7890&quot;</span><br><span class="line">Explanation: 10 digits in the phone number, which means all digits make up the local number.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;86-(10)12345678&quot;</span><br><span class="line">Output: &quot;+**-***-***-5678&quot;</span><br><span class="line">Explanation: 12 digits, 2 digits for country code and 10 digits for local number.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>S.length &lt;= 40</code>.</li>
<li>Emails have length at least 8.</li>
<li>Phone numbers have length at least 10.</li>
</ol>
<p>不涉及任何算法，只是处理不规范（其实还算非常规范）数据形式的“脏”活。邮箱地址容易就不说了，电话号码注意主体只有10位，多下来的就是区号，至于原数据是怎么划分电话号码怎么用括号怎么用分隔符的关我什么事，把<code>S</code>的所有数字提取出来然后按照位数处理，保留最后四位就完成了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maskPII</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'@'</span> <span class="keyword">in</span> S:</span><br><span class="line">            parts=S.lower().split(<span class="string">'@'</span>)</span><br><span class="line">            <span class="keyword">return</span> parts[<span class="number">0</span>][<span class="number">0</span>]+<span class="string">'*****'</span>+parts[<span class="number">0</span>][<span class="number">-1</span>]+<span class="string">'@'</span>+parts[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums=filter(<span class="keyword">lambda</span> c:c.isdigit(),S)</span><br><span class="line">            <span class="keyword">if</span> len(nums)&gt;<span class="number">10</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'+'</span>+<span class="string">'*'</span>*(len(nums)<span class="number">-10</span>)+<span class="string">'-***-***-'</span>+nums[<span class="number">-4</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'***-***-'</span>+nums[<span class="number">-4</span>:]</span><br></pre></td></tr></table></figure></p>
<h2>Consecutive Numbers Sum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/consecutive-numbers-sum/</p>
<blockquote>
<p>Given a positive integer <code>N</code>, how many ways can we write it as a sum of consecutive positive integers?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 = 5 = 2 + 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 15</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10 ^ 9</code>.</li>
</ol>
<p>假设<code>N</code>能写出<code>k</code>个连续正整数的和。那么这些正整数中最小的数为<code>N/k-(k-1)/2</code>，为了保证这个数为正整数，必然有:</p>
<ol>
<li><code>N/k-(k-1)/2&gt;0</code>即<code>k*(k-1)/2&lt;N</code></li>
<li>如果<code>k</code>是奇数，<code>N</code>必须能被<code>k</code>整除</li>
<li>如果<code>k</code>是偶数，<code>N/k</code>等于某个正整数+<code>1/2</code></li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k,res=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> k*(k<span class="number">-1</span>)/<span class="number">2</span>&lt;N:</span><br><span class="line">            <span class="keyword">if</span> (k%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> N%k==k/<span class="number">2</span>) <span class="keyword">or</span> (k%<span class="number">2</span>==<span class="number">1</span> <span class="keyword">and</span> N%k==<span class="number">0</span>):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(\sqrt{N})$</p>
<h2>Unique Letter String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-83/problems/unique-letter-string/</p>
<blockquote>
<p>A character is unique in string <code>S</code> if it occurs exactly once in it.</p>
</blockquote>
<blockquote>
<p>For example, in string <code>S = &quot;LETTER&quot;</code>, the only unique characters are &quot;L&quot; and &quot;R&quot;.</p>
</blockquote>
<blockquote>
<p>Let's define <code>UNIQ(S)</code> as the number of unique characters in string S.</p>
</blockquote>
<blockquote>
<p>For example, <code>UNIQ(&quot;LETTER&quot;) = 2</code>.</p>
</blockquote>
<blockquote>
<p>Given a string <code>S</code> with only uppercases, calculate the sum of <code>UNIQ(substring)</code> over all non-empty substrings of <code>S</code>.</p>
</blockquote>
<blockquote>
<p>If there are two or more equal substrings at different positions in <code>S</code>, we consider them different.</p>
</blockquote>
<blockquote>
<p>Since the answer can be very large, retrun the answer modulo <code>10 ^ 9 + 7</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ABC&quot;</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.</span><br><span class="line">Evey substring is composed with only unique letters.</span><br><span class="line">Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ABA&quot;</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The same as example 1, except uni(&quot;ABA&quot;) = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= S.length &lt;= 10000</code>.</li>
</ol>
<p>正向去考虑可以分割出多少个子串，每个子串有多少只出现过一次的字符，因为生成子串本身已经是$o(n^2)$级的，再去计算每个子串的<code>UNIQ</code>值则会上升到$o(n^3)$的复杂度。这时不妨反过来考虑，<code>S</code>的每个字符<code>S[i]</code>会在哪些子串中成为unique字符。</p>
<p>假设某个字符最近出现的三个位置为<code>k&lt;j&lt;i</code>，<code>S[k]==S[j]==S[i]</code>，那么<code>S[j]</code>在符合这些条件的子串中可以成为unique字符：</p>
<ol>
<li>子串第一个字符位置在<code>[k+1,j]</code>，一共<code>j-k</code>种可能</li>
<li>子串最后一个字符位置在<code>[j,i-1]</code>，一共<code>i-j</code>种可能</li>
</ol>
<p>所以<code>S[j]</code>在<code>(j-k)*(i-j)</code>个子串中贡献了1个计数。</p>
<p>为了方便设定初始条件，可以假设每个字符都在<code>-1</code>和<code>len(S)</code>位置出现过，这样对于每个字符的第一次出现和最后一次出现也可以用上面的方法计算在多少个子串中成为了unique字符。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueLetterString</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        pos=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            k,j=pos.get(c,(<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line">            res+=(j-k)*(i-j)</span><br><span class="line">            pos[c]=(j,i)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> pos:</span><br><span class="line">            k,j=pos[c]</span><br><span class="line">            res+=(j-k)*(len(S)-j)</span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-83/" data-id="cjm54ylkk0026fkw3ge8nedva" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-82" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-82/">LeetCode Weekly Contest 82</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-82/" class="article-date"><time datetime="2018-04-29T08:56:13.704Z" itemprop="datePublished">2018-04-29</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-82</p>
<p>&lt;!-- more --&gt;</p>
<h2>Goat Latin</h2>
<p>https://leetcode.com/contest/weekly-contest-82/problems/goat-latin/</p>
<blockquote>
<p>A sentence <code>S</code> is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>
</blockquote>
<blockquote>
<p>We would like to convert the sentence to &quot;Goat Latin&quot; (a made-up language similar to Pig Latin.)</p>
</blockquote>
<blockquote>
<p>The rules of Goat Latin are as follows:</p>
</blockquote>
<ul>
<li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.
For example, the word 'apple' becomes 'applema'.</li>
<li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add &quot;ma&quot;.
For example, the word <code>&quot;goat&quot;</code> becomes <code>&quot;oatgma&quot;</code>.</li>
<li>Add one letter <code>'a'</code> to the end of each word per its word index in the sentence, starting with 1.
For example, the first word gets <code>&quot;a&quot;</code> added to the end, the second word gets <code>&quot;aa&quot;</code> added to the end and so on.
Return the final sentence representing the conversion from <code>S</code> to Goat Latin.</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;I speak Goat Latin&quot;</span><br><span class="line">Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>Notes</strong>:</p>
<ol>
<li><code>S</code> contains only uppercase, lowercase and spaces. Exactly one space between each word.</li>
<li><code>1 &lt;= S.length &lt;= 100</code>.</li>
</ol>
<p>反正转换规则都给你写的很详细了，一个个分支照着做就行，注意元音大小写。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line">        vowel=[<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>]</span><br><span class="line">        <span class="keyword">for</span> i,w <span class="keyword">in</span> enumerate(S.split()):</span><br><span class="line">            <span class="keyword">if</span> w[<span class="number">0</span>] <span class="keyword">in</span> vowel <span class="keyword">or</span> len(w)&lt;<span class="number">2</span>:</span><br><span class="line">                res.append(w+<span class="string">'ma'</span>+<span class="string">'a'</span>*(i+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(w[<span class="number">1</span>:]+w[<span class="number">0</span>]+<span class="string">'ma'</span>+<span class="string">'a'</span>*(i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure></p>
<h2>Friends Of Appropriate Ages</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-82/problems/friends-of-appropriate-ages/</p>
<blockquote>
<p>Some people will make friend requests. The list of their ages is given and <code>ages[i]</code> is the age of the ith person.</p>
</blockquote>
<blockquote>
<p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p>
</blockquote>
<blockquote>
<ul>
<li><code>age[B] &lt;= 0.5 * age[A] + 7</code></li>
<li><code>age[B] &gt; age[A]</code></li>
<li><code>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</code>
Otherwise, A will friend request B.</li>
</ul>
</blockquote>
<blockquote>
<p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p>
</blockquote>
<blockquote>
<p>How many total friend requests are made?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,16]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 2 people friend request each other.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,17,18]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [20,30,100,110,120]</span><br><span class="line">Output:</span><br><span class="line">Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= ages.length &lt;= 20000</code>.</li>
<li><code>1 &lt;= ages[i] &lt;= 120</code>.</li>
</ol>
<p>如果按照这些条件对遍历<code>ages</code>中的排列，因为<code>o(n^2)</code>的时间复杂度可能会TLE，所以可以先试着对<code>ages</code>进行排序，然后对上面那些条件取反，也就是说对于给定的A来说，能接受交友请求的B必须同时满足</p>
<ul>
<li><code>ages[B]&gt;0.5*ages[A]+7</code></li>
<li><code>ages[B]&lt;=ages[A]</code></li>
<li><code>ages[B]&gt;=100</code>或<code>ages[A]&lt;=100</code></li>
</ul>
<p>前两个条件可以通过二分查找轻松划定一个比较宽泛的坐标范围，最后一个条件不取反直接按照正向去分<code>ages[A]&gt;=100</code>是否成立再取B的上界。需要注意的主要有两个：</p>
<ol>
<li><code>ages</code>的元素值可能存在重复，当<code>ages[A]==ages[B]</code>时也是符合前两个条件的</li>
<li>所以找上界<code>&lt;=ages[A]</code>时，最后的值要减去<code>A</code>本身所占的一个值（自己不能向自己发起好友请求）</li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numFriendRequests</span><span class="params">(self, ages)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ages: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        ages.sort()</span><br><span class="line">        hundred=bisect.bisect(ages,<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ages)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            a=bisect.bisect(ages,ages[i],lo=i)</span><br><span class="line">            b=bisect.bisect(ages,<span class="number">0.5</span>*ages[i]+<span class="number">7</span>,hi=a)</span><br><span class="line">            <span class="keyword">if</span> ages[i]&gt;=<span class="number">100</span>:</span><br><span class="line">                res+=a-b<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res+=max(min(a<span class="number">-1</span>,hundred)-b,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(1)$</p>
<h2>Most Profit Assigning Work</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-82/problems/most-profit-assigning-work/</p>
<blockquote>
<p>We have jobs: <code>difficulty[i]</code> is the difficulty of the <code>i</code>th job, and <code>profit[i]</code> is the profit of the <code>i</code>th job.</p>
</blockquote>
<blockquote>
<p>Now we have some workers. <code>worker[i]</code> is the ability of the <code>i</code>th worker, which means that this worker can only complete a job with difficulty at most <code>worker[i]</code>.</p>
</blockquote>
<blockquote>
<p>Every worker can be assigned at most one job, but one job can be completed multiple times.</p>
</blockquote>
<blockquote>
<p>For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0.</p>
</blockquote>
<blockquote>
<p>What is the most profit we can make?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">Output: 100</span><br><span class="line">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= difficulty.length = profit.length &lt;= 10000</code></li>
<li><code>1 &lt;= worker.length &lt;= 10000</code></li>
<li><code>difficulty[i]</code>, <code>profit[i]</code>, <code>worker[i]</code>  are in range <code>[1, 10^5]</code></li>
</ol>
<p>既然没有任务必须完成的次数限制，那就尽量把员工都安排到他们能力范围内利润最大的任务。先把任务按照利润大小排序，再把员工按照能力高低排序，双指针找到当前员工能胜任的利润最大的任务。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitAssignment</span><span class="params">(self, difficulty, profit, worker)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type difficulty: List[int]</span></span><br><span class="line"><span class="string">        :type profit: List[int]</span></span><br><span class="line"><span class="string">        :type worker: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        jobs=sorted(zip(profit,difficulty),reverse=<span class="keyword">True</span>)</span><br><span class="line">        worker.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> worker:</span><br><span class="line">            <span class="keyword">while</span> i&lt;len(profit) <span class="keyword">and</span> w&lt;jobs[i][<span class="number">1</span>]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==len(profit):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res+=jobs[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度主要来自排序的<code>o(max(length) log(max(length)))</code>，空间复杂度为<code>o(len(difficulty))</code></p>
<h2>Making A Large Island</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-82/problems/making-a-large-island/</p>
<blockquote>
<p>In a 2D grid of 0s and 1s, we change at most one <code>0</code> to a <code>1</code>.</p>
</blockquote>
<blockquote>
<p>After, what is the size of the largest island? (An island is a 4-directionally connected group of <code>1</code>s).</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 0], [0, 1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 1], [1, 0]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1, 1], [1, 1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Can&apos;t change any 0 to 1, only one island with area = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code>.</li>
<li><code>0 &lt;= grid[i][j] &lt;= 1</code>.</li>
</ol>
<p>暂时没想到什么特别好的方法，用比较直接的策略：先DFS找出所有的连通分支（岛屿）并标记编号和面积大小，再遍历<code>0</code>坐标计算每个<code>0</code>翻转为<code>1</code>后使几个分支合并（总面积等于这些分支的大小再加上1），找到最大的合并后面积。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(grid)</span><br><span class="line">        area=&#123;<span class="number">0</span>:<span class="number">0</span>&#125;</span><br><span class="line">        seen=set()</span><br><span class="line">        zeros=set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(index,x,y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> grid[x][y]&gt;<span class="number">0</span>:</span><br><span class="line">                grid[x][y]=index</span><br><span class="line">                area[index]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=x+dx&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y+dy&lt;n <span class="keyword">and</span> (x+dx,y+dy) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        seen.add((x+dx,y+dy))</span><br><span class="line">                        dfs(index,x+dx,y+dy)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                zeros.add((x,y))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            island=set()</span><br><span class="line">            <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x+dx&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y+dy&lt;n:</span><br><span class="line">                    island.add(grid[x+dx][y+dy])</span><br><span class="line">            <span class="keyword">return</span> sum(area[i] <span class="keyword">for</span> i <span class="keyword">in</span> island)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        tag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (i,j) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add((i,j))</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j]&gt;<span class="number">0</span>:</span><br><span class="line">                        tag+=<span class="number">1</span></span><br><span class="line">                        area[tag]=<span class="number">0</span></span><br><span class="line">                        dfs(tag,i,j)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        zeros.add((i,j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max([max(area.values())]+[connect(i,j) <span class="keyword">for</span> (i,j) <span class="keyword">in</span> zeros])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度与点集大小相关$o(n^2)$，空间复杂度也为$o(n^2)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-82/" data-id="cjm54ylkk0024fkw3inmzywtc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-81" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-81/">LeetCode Weekly Contest 81</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-81/" class="article-date"><time datetime="2018-04-22T14:11:52.857Z" itemprop="datePublished">2018-04-22</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-81</p>
<p>&lt;!-- more --&gt;</p>
<h2>Shortest Distance to a Character</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/shortest-distance-to-a-character/</p>
<blockquote>
<p>Given a string <code>S</code> and a character <code>C</code>, return an array of integers representing the shortest distance from the character <code>C</code> in the string.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;</span><br><span class="line">Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> string length is in <code>[1, 10000]</code>.</li>
<li><code>C</code> is a single character, and guaranteed to be in string <code>S</code>.
All letters in <code>S</code> and <code>C</code> are lowercase.</li>
</ol>
<p>找到所有<code>C</code>的索引，<code>S</code>的每个字符与所有<code>C</code>的索引值的绝对差取最小值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestToChar</span><span class="params">(self, S, C)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type C: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        targets=[i <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(S) <span class="keyword">if</span> c==C]</span><br><span class="line">        <span class="keyword">return</span> [min([abs(t-i) <span class="keyword">for</span> t <span class="keyword">in</span> targets]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S))]</span><br></pre></td></tr></table></figure></p>
<h2>Card Flipping Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/card-flipping-game/</p>
<blockquote>
<p>On a table are <code>N</code> cards, with a positive integer printed on the front and back of each card (possibly different).</p>
</blockquote>
<blockquote>
<p>We flip any number of cards, and after we choose one card.</p>
</blockquote>
<blockquote>
<p>If the number <code>X</code> on the back of the chosen card is not on the front of any card, then this number <code>X</code> is good.</p>
</blockquote>
<blockquote>
<p>What is the smallest number that is good?  If no number is good, output <code>0</code>.</p>
</blockquote>
<blockquote>
<p>Here, <code>fronts[i]</code> and <code>backs[i]</code> represent the number on the front and back of card <code>i</code>.</p>
</blockquote>
<blockquote>
<p>A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].</span><br><span class="line">We choose the second card, which has number 2 on the back, and it isn&apos;t on the front of any card, so 2 is good.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= fronts.length == backs.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= fronts[i] &lt;= 2000</code>.</li>
<li><code>1 &lt;= backs[i] &lt;= 2000</code>.</li>
</ol>
<p>除了正反两面一样的卡牌无法避免，其他数字都可以通过翻转操作使其只存在于<code>fronts</code>或<code>backs</code>中的一面，只要在这些数字中找到最小的数返回</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipgame</span><span class="params">(self, fronts, backs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type fronts: List[int]</span></span><br><span class="line"><span class="string">        :type backs: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        taboo=set(fronts[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(fronts)) <span class="keyword">if</span> fronts[i]==backs[i])</span><br><span class="line">        gn=set(fronts+backs)-taboo</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> gn:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min(gn)</span><br></pre></td></tr></table></figure></p>
<h2>Short Encoding of Words</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/short-encoding-of-words/</p>
<blockquote>
<p>Given a list of words, we may encode it by writing a reference string <code>S</code> and a list of indexes <code>A</code>.</p>
</blockquote>
<blockquote>
<p>For example, if the list of words is <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>, we can write it as <code>S = &quot;time#bell#&quot;</code> and <code>indexes = [0, 2, 5]</code>.</p>
</blockquote>
<blockquote>
<p>Then for each index, we will recover the word by reading from the reference string from that index until we reach a &quot;#&quot; character.</p>
</blockquote>
<blockquote>
<p>What is the length of the shortest reference string S possible that encodes the given words?</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: S = &quot;time#bell#&quot; and indexes = [0, 2, 5].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code>.</li>
<li><code>1 &lt;= words[i].length &lt;= 7</code>.</li>
<li>Each word has only lowercase letters.</li>
</ol>
<p>当一个词<code>a</code>的全部内容正好能与<code>b</code>的最后几个字母重合，那么在<code>S</code>中只要保留<code>b</code>串即可。那么在<code>words</code>去掉重复词后，对每个词<code>w</code>只要检查它的所有长度的后缀是否还在<code>words</code>中，如果在则移除，<code>words</code>剩下的词即<code>S</code>中所有的词，每个词后加上<code>#</code>标识即可组成<code>S</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumLengthEncoding</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s=set(words)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(w)):</span><br><span class="line">                <span class="keyword">if</span> w[i:] <span class="keyword">in</span> s:</span><br><span class="line">                    s.remove(w[i:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(len(w)+<span class="number">1</span> <span class="keyword">for</span> w <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure></p>
<h2>Binary Trees With Factors</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-81/problems/binary-trees-with-factors/</p>
<blockquote>
<p>Given an array of unique integers, each integer is strictly greater than 1.</p>
</blockquote>
<blockquote>
<p>We make a binary tree using these integers and each number may be used for any number of times.</p>
</blockquote>
<blockquote>
<p>Each non-leaf node's value should be equal to the product of the values of it's children.</p>
</blockquote>
<blockquote>
<p>How many binary trees can we make?  Return the answer <strong>modulo 10 ** 9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can make these trees: [2], [4], [4, 2, 2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4, 5, 10]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code>.</li>
<li><code>2 &lt;= A[i] &lt;= 10 ^ 9</code>.</li>
</ol>
<p>这题其实不能达到最后一题应有的难度。设每个数字<code>n</code>应有的以其为根的树的数量为<code>tree[n]</code>，<code>n</code>有<code>(i,n/i),...(j,n/k)</code>等<strong>不同</strong>的因数对在<code>A</code>中，因为左右子树可以交换构造不同的树，所有<code>tree[n]=2*tree[i]*tree[n/i]+...+2*tree[j]*tree[n/j]+1</code>，最后的<code>1</code>是因为仅有根结点<code>n</code>也可以形成符合要求的树，如果<code>sqrt(n)</code>也在<code>A</code>中出现，那么只需要再加上<code>tree[sqrt(n)]*tree[sqrt(n)]</code>不必考虑子树的顺序。写的时候可能需要注意一下检查<code>n/i</code>是否在<code>A</code>中的寻址时间过长导致的TLE，可以把<code>A</code>先转换成hash表（<code>set</code>）来适当规避。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        nums=set(A)</span><br><span class="line">        factor=collections.defaultdict(list)</span><br><span class="line">        tree=[<span class="number">1</span>]*len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[j]*A[j]&lt;=A[i] <span class="keyword">and</span> A[i]%A[j]==<span class="number">0</span> <span class="keyword">and</span> A[i]/A[j] <span class="keyword">in</span> nums:</span><br><span class="line">                    factor[i].append((j,A.index(A[i]/A[j])))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(A))):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> factor:</span><br><span class="line">                <span class="keyword">for</span> (x,y) <span class="keyword">in</span> factor[i]:</span><br><span class="line">                    <span class="keyword">if</span> x==y:</span><br><span class="line">                        tree[i]+=tree[x]*tree[y]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        tree[i]+=<span class="number">2</span>*tree[x]*tree[y]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(tree)%(<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(n^2)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-81/" data-id="cjm54ylje001sfkw3kuzwzwcp" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-80" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-80/">LeetCode Weekly Contest 80</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-80/" class="article-date"><time datetime="2018-04-15T15:20:34.341Z" itemprop="datePublished">2018-04-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-80</p>
<p>&lt;!-- more --&gt;</p>
<h2>Most Common Word</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/most-common-word/</p>
<blockquote>
<p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.</p>
</blockquote>
<blockquote>
<p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class="line">banned = [&quot;hit&quot;]</span><br><span class="line">Output: &quot;ball&quot;</span><br><span class="line">Explanation:</span><br><span class="line">&quot;hit&quot; occurs 3 times, but it is a banned word.</span><br><span class="line">&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.</span><br><span class="line">Note that words in the paragraph are not case sensitive,</span><br><span class="line">that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;),</span><br><span class="line">and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= paragraph.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= banned.length &lt;= 100</code>.</li>
<li><code>1 &lt;= banned[i].length &lt;= 10</code>.</li>
<li>The answer is unique, and written in lowercase (even if its occurrences in <code>paragraph</code> may have uppercase symbols, and even if it is a proper noun.)</li>
<li><code>paragraph</code> only consists of letters, spaces, or the punctuation symbols <code>!?',;</code>.</li>
<li>Different words in <code>paragraph</code> are always separated by a space.</li>
<li>There are no hyphens or hyphenated words.</li>
<li>Words only consist of letters, never apostrophes or other punctuation symbols.</li>
</ol>
<p>把<code>paragraph</code>去掉标点，转换成小写，然后统计词频</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostCommonWord</span><span class="params">(self, paragraph, banned)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type paragraph: str</span></span><br><span class="line"><span class="string">        :type banned: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        punc=<span class="string">"!?',;."</span></span><br><span class="line">        paragraph = str(paragraph).translate(string.maketrans(<span class="string">""</span>,<span class="string">""</span>), punc)</span><br><span class="line">        <span class="keyword">for</span> word,fre <span class="keyword">in</span> collections.Counter(paragraph.lower().split(<span class="string">" "</span>)).most_common():</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> banned:</span><br><span class="line">                <span class="keyword">return</span> word</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度都为$o(n)$</p>
<h2>Linked List Components</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/linked-list-components/</p>
<blockquote>
<p>We are given <code>head</code>, the head node of a linked list containing <strong>unique integer values</strong>.</p>
</blockquote>
<blockquote>
<p>We are also given the list <code>G</code>, a subset of the values in the linked list.</p>
</blockquote>
<blockquote>
<p>Return the number of connected components in <code>G</code>, where two values are connected if they appear consecutively in the linked list.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3</span><br><span class="line">G = [0, 1, 3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">0 and 1 are connected, so [0, 1] and [3] are the two connected components.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class="line">G = [0, 3, 1, 4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>If N is the length of the linked list given by <code>head</code>, <code>1 &lt;= N &lt;= 10000</code>.</li>
<li>The value of each node in the linked list will be in the range <code>[0, N - 1]</code>.</li>
<li><code>1 &lt;= G.length &lt;= 10000</code>.</li>
<li><code>G</code> is a subset of all values in the linked list.</li>
</ol>
<p>遍历链表找哪些连续的部分都出现在了<code>G</code>中，当然<code>list</code>寻值可能会导致TLE，可以转换为hashset之类的数据类型</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numComponents</span><span class="params">(self, head, G)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type G: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        start=<span class="keyword">False</span></span><br><span class="line">        G=set(G)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val <span class="keyword">in</span> G:</span><br><span class="line">                start=<span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> start:</span><br><span class="line">                    start=<span class="keyword">False</span></span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">            head=head.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start:</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，$n$为链表的长度</p>
<h2>Ambiguous Coordinates</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/ambiguous-coordinates/</p>
<blockquote>
<p>We had some 2-dimensional coordinates, like <code>&quot;(1, 3)&quot;</code> or <code>&quot;(2, 0.5)&quot;</code>.  Then, we removed all commas, decimal points, and spaces, and ended up with the string <code>S</code>.  Return a list of strings representing all possibilities for what our original coordinates could have been.</p>
</blockquote>
<blockquote>
<p>Our original representation never had extraneous zeroes, so we never started with numbers like &quot;00&quot;, &quot;0.0&quot;, &quot;0.00&quot;, &quot;1.0&quot;, &quot;001&quot;, &quot;00.01&quot;, or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like &quot;.1&quot;.</p>
</blockquote>
<blockquote>
<p>The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(123)&quot;</span><br><span class="line">Output: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(00011)&quot;</span><br><span class="line">Output:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">0.0, 00, 0001 or 00.01 are not allowed.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(0123)&quot;</span><br><span class="line">Output: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(100)&quot;</span><br><span class="line">Output: [(10, 0)]</span><br><span class="line">Explanation:</span><br><span class="line">1.0 is not allowed.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>4 &lt;= S.length &lt;= 12</code>.</li>
<li><code>S[0]</code> = &quot;(&quot;, <code>S[S.length - 1]</code> = &quot;)&quot;, and the other elements in <code>S</code> are digits.</li>
</ol>
<p>需要考虑情况比较多的就是每个坐标里面该不该放小数点？该往哪放？以0开始的数字只可能把小数点放在第二位，以0结尾的数字则不能有小数点，首尾都是0无论怎么放小数点都会是无效数字，单个0本身可以作为一个坐标值。至于x与y的分割没什么限制，只是放小数点的时候需要格外小心。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ambiguousCoordinates</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">SplitDot</span><span class="params">(num)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> num==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'0'</span>]</span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">-1</span>]==<span class="string">'0'</span> <span class="keyword">and</span> num[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">0</span>]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">'0.'</span>+num[<span class="number">1</span>:]]</span><br><span class="line">            <span class="keyword">if</span> num[<span class="number">-1</span>]==<span class="string">'0'</span>:</span><br><span class="line">                <span class="keyword">return</span> [num]</span><br><span class="line">            temp=[num]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(num)):</span><br><span class="line">                temp.append(num[:i]+<span class="string">'.'</span>+num[i:])</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(S)<span class="number">-1</span>):</span><br><span class="line">            x=SplitDot(S[<span class="number">1</span>:i])</span><br><span class="line">            y=SplitDot(S[i:len(S)<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> x:</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> y:</span><br><span class="line">                    res.append(<span class="string">'('</span>+a+<span class="string">', '</span>+b+<span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>最坏情况下的时间复杂度为$o(n^3)$</p>
<h2>Race Car</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-80/problems/race-car/</p>
<blockquote>
<p>Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)</p>
</blockquote>
<blockquote>
<p>Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).</p>
</blockquote>
<blockquote>
<p>When you get an instruction &quot;A&quot;, your car does the following: <code>position += speed</code>, <code>speed *= 2.</code></p>
</blockquote>
<blockquote>
<p>When you get an instruction &quot;R&quot;, your car does the following: if your speed is positive then <code>speed = -1</code> , otherwise <code>speed = 1</code>.  (Your position stays the same.)</p>
</blockquote>
<blockquote>
<p>For example, after commands &quot;AAR&quot;, your car goes to positions <code>0-&gt;1-&gt;3-&gt;3</code>, and your speed goes to <code>1-&gt;2-&gt;4-&gt;-1</code>.</p>
</blockquote>
<blockquote>
<p>Now for some target position, say the length of the shortest sequence of instructions to get there.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">target = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The shortest instruction sequence is &quot;AA&quot;.</span><br><span class="line">Your position goes from 0-&gt;1-&gt;3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">target = 6</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The shortest instruction sequence is &quot;AAARA&quot;.</span><br><span class="line">Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= target &lt;= 10000</code>.</li>
</ol>
<p>解法还是参考<a href="https://leetcode.com/problems/race-car/discuss/123834/C++JavaPython-DP-solution-average-O(logN)" target="_blank" rel="noopener">DP solution, average O(logN)</a>介绍的动态规划方法，可能很容易想到对于<code>2 ^ (n - 1) -1&lt; target &lt; 2 ^ n-1</code>来说有两种策略</p>
<ol>
<li>先用<code>n</code>个<code>A</code>达到<code>2 ^ n-1</code>位置，然后用一个<code>R</code>，再加上<code>dp[2^n-1-target]</code>的指令</li>
<li>先用<code>n-1</code>个<code>A</code>达到<code>2^(n-1)-1</code>位置，然后用两个<code>R</code>完成速度重置，再加上<code>dp[target-2^(n-1)+1]</code></li>
</ol>
<p>注意情况2是可能存在问题的，在这种情况下，<code>RR</code>操作后从<code>2^(n-1)-1</code>到<code>target</code>的路径可能会存在<code>R</code>，而这个<code>R</code>事实上又可以和前面的<code>R</code>合并，因此是多余的。所以需要在第二个<code>R</code>前先用<code>m</code>个<code>A</code>使其回退，再用<code>R</code>恢复速度方向，从<code>2^(n-1)-2^m</code>位置开始，再加上<code>dp[target-2^(n-1)+2^m)]</code></p>
<p>这里代码还是直接放上原讨论中使用的bottom-up的递归，避免计算了一些不需要了解的情况，非常高效：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> self.dp = &#123;<span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">racecar</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">in</span> self.dp: <span class="keyword">return</span> self.dp[t]</span><br><span class="line">        n = t.bit_length()</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span>**n - <span class="number">1</span> == t: self.dp[t] = n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dp[t] = self.racecar(<span class="number">2</span>**n - <span class="number">1</span> - t) + n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">                self.dp[t] = min(self.dp[t], self.racecar(t - <span class="number">2</span>**(n - <span class="number">1</span>) + <span class="number">2</span>**m) + n + m + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.dp[t]</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-80/" data-id="cjm54ylj4001ofkw3zec0o4jp" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-79" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-79/">LeetCode Weekly Contest 79</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-79/" class="article-date"><time datetime="2018-04-09T14:50:06.299Z" itemprop="datePublished">2018-04-09</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>因为最近时间线总是刷出如何看待2017 cs grad就业惨淡，如何看待秋季项目申请水涨船高这种信息，实在让我有点焦虑，所以可能以后社交网络会用的没有以前那么频繁了，不用报警我活的很好，谢谢大家的关心。对我来说刷题也算消遣，请千万不要被误导觉得专注刷题真的有什么用，保持手不生而已，主要还是要回去啃书和备考。</p>
<p>https://leetcode.com/contest/weekly-contest-79</p>
<p>&lt;!-- more --&gt;</p>
<h2>Largest Triangle Area</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/largest-triangle-area/</p>
<blockquote>
<p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The five points are show in the figure below. The red triangle is the largest.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= points.length &lt;= 50</code>.</li>
<li>No points will be duplicated.</li>
<li><code>-50 &lt;= points[i][j] &lt;= 50</code>.</li>
<li>Answers within <code>10^-6</code> of the true value will be accepted as correct.</li>
</ol>
<p>上来第一题，不要去考虑技巧，直接穷举找最大值就可以。顶点为<code>A(x1,y1)</code>，<code>B(x2,y2)</code>和<code>C(x3,y3)</code>的三角形面积为
<span>$S_{\Delta ABC} = \frac{1}{2} |{x_1}{y_2} + {x_2}{y_3} + {x_3}{y_1} - {x_1}{y_3} - {x_3}{y_2} - {x_2}{y_1}|$</span><!-- Has MathJax -->
用这个公式计算各个点组合的面积找到最大值
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestTriangleArea</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0.5</span>*abs(x1*y2+x2*y3+x3*y1-x1*y3-x2*y1-x3*y2) <span class="keyword">for</span> ([x1,y1],[x2,y2],[x3,y3]) <span class="keyword">in</span> itertools.combinations(points,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>当然如果像我这么无聊还能把公式写成
<span>$$S_{\Delta ABC} =  \frac{1}{2} |\det \left( {\left[ {\begin{array}{*{20}{c}}
{x_1}&amp;{y_1}&amp;1\\
{x_2}&amp;{y_2}&amp;1\\
{x_3}&amp;{y_3}&amp;1
\end{array}} \right]} \right)|$$</span><!-- Has MathJax -->
当然这样算有TLE的风险就是了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> max(<span class="number">0.5</span>*abs(float(np.linalg.det(np.array([a+[<span class="number">1</span>],b+[<span class="number">1</span>],c+[<span class="number">1</span>]])))) <span class="keyword">for</span> (a,b,c) <span class="keyword">in</span> itertools.combinations(points,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^3)$，$n$为点集大小</p>
<h2>Binary Tree Pruning</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/binary-tree-pruning/</p>
<blockquote>
<p>We are given the head node <code>root</code> of a binary tree, where additionally every node's value is either a 0 or a 1.</p>
</blockquote>
<blockquote>
<p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p>
</blockquote>
<blockquote>
<p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,0,0,1]</span><br><span class="line">Output: [1,null,0,null,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only the red nodes satisfy the property &quot;every subtree not containing a 1&quot;.</span><br><span class="line">The diagram on the right represents the answer.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,0,0,0,1]</span><br><span class="line">Output: [1,null,1,null,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,0,1,0]</span><br><span class="line">Output: [1,1,0,1,1,null,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The binary tree will have at most <code>100 nodes</code>.</li>
<li>The value of each node will only be <code>0</code> or <code>1</code>.</li>
</ol>
<p>DFS从最低层开始删去每个值为<code>0</code>的叶结点</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pre,cur,d)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    dfs(cur,cur.left,<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    dfs(cur,cur.right,<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> cur.val==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> d&gt;<span class="number">0</span>:</span><br><span class="line">                        pre.right=<span class="keyword">None</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.left=<span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            dfs(root,root.left,<span class="number">-1</span>)</span><br><span class="line">            dfs(root,root.right,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2>Largest Sum of Averages</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/largest-sum-of-averages/</p>
<blockquote>
<p>We partition a row of numbers <code>A</code> into at most <code>K</code> adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
</blockquote>
<blockquote>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [9,1,2,3,9]</span><br><span class="line">K = 3</span><br><span class="line">Output: 20</span><br><span class="line">Explanation:</span><br><span class="line">The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.</span><br><span class="line">We could have also partitioned A into [9, 1], [2], [3, 9], for example.</span><br><span class="line">That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code>.</li>
<li><code>1 &lt;= A[i] &lt;= 10000</code>.</li>
<li><code>1 &lt;= K &lt;= A.length</code>.</li>
<li>Answers within <code>10^-6</code> of the correct answer will be accepted as correct.</li>
</ol>
<p>没多想，直接动态规划暴力解决，<code>dp[n][k]</code>存储到第<code>n</code>个元素为止至多划分<code>k+1</code>组平均数和的最大值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumOfAverages</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp=[[<span class="number">-1</span>]*K <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(A))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            dp[i][<span class="number">0</span>]=sum(A[:i+<span class="number">1</span>])/float(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,min(n+<span class="number">1</span>,K)):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k<span class="number">-1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                        dp[n][k]=max(dp[n][k],dp[i][k<span class="number">-1</span>]+sum(A[i+<span class="number">1</span>:n+<span class="number">1</span>])/float(n-i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2K)$，空间复杂度为$o(nK)$，其中$n$为数组<code>A</code>的长度。也可以用自底而上的方法递归使辅助空间减少到$o(n)$</p>
<h2>Bus Routes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-79/problems/bus-routes/</p>
<blockquote>
<p>We have a list of bus routes. Each <code>routes[i]</code> is a bus route that the i-th bus repeats forever. For example if <code>routes[0] = [1, 5, 7]</code>, this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;... forever.</p>
</blockquote>
<blockquote>
<p>We start at bus stop <code>S</code> (initially not on a bus), and we want to go to bus stop <code>T</code>. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">routes = [[1, 2, 7], [3, 6, 7]]</span><br><span class="line">S = 1</span><br><span class="line">T = 6</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= routes.length &lt;= 500</code>.</li>
<li><code>1 &lt;= routes[i].length &lt;= 500</code>.</li>
<li><code>0 &lt;= routes[i][j] &lt; 10 ^ 6</code>.</li>
</ol>
<p>一开始我是看错了以为要找到的是最小站数，后来发现是最小换车次数，这样的话应该以公交车的路线为结点，而不是以公交站为结点。有共同站点的两条路线视为邻接结点，包含<code>S</code>的公交路线视为可以开始的源点集，用BFS找到可以到达包含<code>T</code>的公交路线目标点集中任意结点的最短路径。需要格外注意的是，当<code>S==T</code>时，不需要上车就可以到达，所以应该返回0</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination</span><span class="params">(self, routes, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type routes: List[List[int]]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :type T: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> S==T:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        start=set()</span><br><span class="line">        target=set()</span><br><span class="line">        graph=collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(routes)):</span><br><span class="line">            <span class="keyword">if</span> S <span class="keyword">in</span> routes[i]: start.add(i)</span><br><span class="line">            <span class="keyword">if</span> T <span class="keyword">in</span> routes[i]: target.add(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(routes)):</span><br><span class="line">                <span class="keyword">if</span> set(routes[i])&amp;set(routes[j]):</span><br><span class="line">                    graph[i].add(j)</span><br><span class="line">                    graph[j].add(i)</span><br><span class="line"></span><br><span class="line">        queue=[(i,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> start]</span><br><span class="line">        seen=set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node,dist <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> target:</span><br><span class="line">                <span class="keyword">return</span> dist</span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> graph[node]:</span><br><span class="line">                <span class="keyword">if</span> nei <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nei)</span><br><span class="line">                    queue.append((nei,dist+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-79/" data-id="cjm54ylj7001qfkw3xr5tl4rr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-78" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-78/">LeetCode Weekly Contest 78</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-78/" class="article-date"><time datetime="2018-04-01T12:58:44.467Z" itemprop="datePublished">2018-04-01</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新的一周，祝大家快乐。</p>
<p>直接看题</p>
<p>https://leetcode.com/contest/weekly-contest-78</p>
<p>&lt;!-- more --&gt;</p>
<h2>Subdomain Visit Count</h2>
<blockquote>
<p>A website domain like &quot;discuss.leetcode.com&quot; consists of various subdomains. At the top level, we have &quot;com&quot;, at the next level, we have &quot;leetcode.com&quot;, and at the lowest level, &quot;discuss.leetcode.com&quot;. When we visit a domain like &quot;discuss.leetcode.com&quot;, we will also visit the parent domains &quot;leetcode.com&quot; and &quot;com&quot; implicitly.</p>
</blockquote>
<blockquote>
<p>Now, call a &quot;count-paired domain&quot; to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be &quot;9001 discuss.leetcode.com&quot;.</p>
</blockquote>
<blockquote>
<p>We are given a list <code>cpdomains</code> of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">Output:</span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">Output:</span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li>The length of <code>cpdomains</code> will not exceed <code>100</code>.</li>
<li>The length of each domain name will not exceed <code>100</code>.</li>
<li>Each address will have either 1 or 2 &quot;.&quot; characters.</li>
<li>The input count in any count-paired domain will not exceed <code>10000</code>.</li>
</ol>
<p>普通的字典统计，从后往前统计各级域名访问次数</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span><span class="params">(self, cpdomains)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type cpdomains: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> cpdomains:</span><br><span class="line">            temp=r.split(<span class="string">' '</span>)</span><br><span class="line">            times,address=temp[<span class="number">0</span>],temp[<span class="number">1</span>].split(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(address)):</span><br><span class="line">                cnt[<span class="string">'.'</span>.join(address[i:])]=cnt.get(<span class="string">'.'</span>.join(address[i:]),<span class="number">0</span>)+int(times)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [str(times)+<span class="string">' '</span>+address <span class="keyword">for</span> (address,times) <span class="keyword">in</span> cnt.items()]</span><br></pre></td></tr></table></figure></p>
<h2>Expressive Words</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-78/problems/expressive-words/</p>
<blockquote>
<p>Sometimes people repeat letters to represent extra feeling, such as &quot;hello&quot; -&gt; &quot;heeellooo&quot;, &quot;hi&quot; -&gt; &quot;hiiii&quot;.  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so &quot;e&quot; and &quot;o&quot; would be extended in the first example, and &quot;i&quot; would be extended in the second example.  As another example, the groups of &quot;abbcccaaaa&quot; would be &quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;, and &quot;aaaa&quot;; and &quot;ccc&quot; and &quot;aaaa&quot; are the extended groups of that string.</p>
</blockquote>
<blockquote>
<p>For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters <code>c</code>, and add some number of the same character <code>c</code> to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like &quot;h&quot; to a group of size two like &quot;hh&quot; - all extensions must leave the group extended - ie., at least 3 characters long.</p>
</blockquote>
<blockquote>
<p>Given a list of query words, return the number of words that are stretchy.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S = &quot;heeellooo&quot;</span><br><span class="line">words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.</span><br><span class="line">We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= len(S) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words[i]) &lt;= 100</code>.</li>
<li><code>S</code> and all words in <code>words</code> consist only of lowercase letters</li>
</ol>
<p>双指针单次线性扫描，注意边界。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expressiveWords</span><span class="params">(self, S, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> len(S)&lt;len(w):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i&lt;len(S):</span><br><span class="line">                    <span class="comment">#print i,j</span></span><br><span class="line">                    <span class="keyword">if</span> j&lt;len(w) <span class="keyword">and</span> S[i]==w[j]:</span><br><span class="line">                        j+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span>&lt;i&lt;len(S)<span class="number">-1</span> <span class="keyword">and</span> S[i]==S[i<span class="number">-1</span>]==S[i+<span class="number">1</span>]:</span><br><span class="line">                            i+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">elif</span> <span class="keyword">not</span> (i&gt;<span class="number">1</span> <span class="keyword">and</span> S[i]==S[i<span class="number">-2</span>]==S[i<span class="number">-1</span>]):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i==len(S) <span class="keyword">and</span> j==len(w):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度<code>o(len(words)*len(S))</code>，空间复杂度<code>o(1)</code></p>
<h2>Soup Servings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-78/problems/soup-servings/</p>
<blockquote>
<p>There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:</p>
</blockquote>
<blockquote>
<ol>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
</ol>
</blockquote>
<ol start="2">
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ol>
<blockquote>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
</blockquote>
<blockquote>
<p>Note that we do not have the operation where all 100 ml's of soup B are used first.</p>
</blockquote>
<blockquote>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 50</span><br><span class="line">Output: 0.625</span><br><span class="line">Explanation:</span><br><span class="line">If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li>
<p><code>0 &lt;= N &lt;= 10^9</code>.</p>
</li>
<li>
<p>Answers within <code>10^-6</code> of the true value will be accepted as correct.</p>
</li>
<li>
<p>最后不满25ml的还是可以算一份，以25ml为一个单位先转换一下<code>N</code>的进制</p>
</li>
<li>
<p><code>f(a,b)=0.25*(f(a-4,b)+f(a-3,b-1)+f(a-2,b-2)+f(a-1,b-3))</code>是递归的递推式，同时用完算0.5的概率</p>
</li>
<li>
<p>使用一个字典来缓存之前计算的<code>f</code>值，避免TLE</p>
</li>
<li>
<p>当<code>N</code>过大时，概率接近1</p>
</li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">soupServings</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache=&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> N&gt;<span class="number">4800</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a&lt;=<span class="number">0</span> <span class="keyword">and</span> b&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">            <span class="keyword">if</span> a&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (a,b) <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[(a,b)]</span><br><span class="line">            cache[(a,b)]=<span class="number">0.25</span>*(f(a<span class="number">-4</span>,b)+f(a<span class="number">-3</span>,b<span class="number">-1</span>)+f(a<span class="number">-2</span>,b<span class="number">-2</span>)+f(a<span class="number">-1</span>,b<span class="number">-3</span>))</span><br><span class="line">            <span class="keyword">return</span> cache[(a,b)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(math.ceil(N/<span class="number">25.0</span>),math.ceil(N/<span class="number">25.0</span>))</span><br></pre></td></tr></table></figure></p>
<h2>Chalkboard XOR Game</h2>
<blockquote>
<p>We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)</p>
</blockquote>
<blockquote>
<p>Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.</p>
</blockquote>
<blockquote>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 1, 2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">Alice has two choices: erase 1 or erase 2.</span><br><span class="line">If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.</span><br><span class="line">If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code>.</li>
<li><code>0 &lt;= nums[i] &lt;= 2^16</code>.</li>
</ol>
<p>因为是Alice先手，首先判断<code>nums</code>中所有数<code>XOR</code>的结果是否为0，所以根据规则如果是这种情况Alice会赢。如果所有数<code>XOR</code>的结果不为0，那就至少存在两个不同的数（如果<code>len(nums)&gt;1</code>），因为假设玩家都会使用最优的策略，Alice总是可以选择保留这个“不同”的数，当<code>nums</code>的长度为奇数时，最后一手也是Alice的，所以最后必然会赢。</p>
<p>那么就只用考虑所有数的<code>XOR</code>结果是否为0和<code>nums</code>长度是否为奇数了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorGame</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s^=i</span><br><span class="line">        <span class="keyword">return</span> s==<span class="number">0</span> <span class="keyword">or</span> len(nums)%<span class="number">2</span>==<span class="number">0</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-78/" data-id="cjm54yli5001gfkw3ey9fdl24" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-77" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-77/">LeetCode Weekly Contest 77</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-77/" class="article-date"><time datetime="2018-03-26T15:17:24.492Z" itemprop="datePublished">2018-03-26</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>少说废话，多刷题。直接看题</p>
<p>https://leetcode.com/contest/weekly-contest-77</p>
<p>&lt;!-- more --&gt;</p>
<h2>Number of Lines To Write String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/number-of-lines-to-write-string/</p>
<blockquote>
<p>We are to write the letters of a given string <code>S</code>, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array <code>widths</code>, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'.</p>
</blockquote>
<blockquote>
<p>Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: [3, 60]</span><br><span class="line">Explanation:</span><br><span class="line">All letters have the same length of 10. To write all 26 letters,</span><br><span class="line">we need two full lines and one line with 60 units.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;bbbcccdddaaa&quot;</span><br><span class="line">Output: [2, 4]</span><br><span class="line">Explanation:</span><br><span class="line">All letters except &apos;a&apos; have the same length of 10, and</span><br><span class="line">&quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.</span><br><span class="line">For the last &apos;a&apos;, it is written on the second line because</span><br><span class="line">there is only 2 units left in the first line.</span><br><span class="line">So the answer is 2 lines, plus 4 units in the second line.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The length of <code>S</code> will be in the range <code>[1, 1000]</code>.</li>
<li><code>S</code> will only contain lowercase letters.</li>
<li><code>widths</code> is an array of length <code>26</code>.</li>
<li><code>widths[i]</code> will be in the range of <code>[2, 10]</code>.</li>
</ol>
<p>直接按题意写，注意单个字母写不下的时候判定换行：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfLines</span><span class="params">(self, widths, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type widths: List[int]</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> widths[ord(c)-ord(<span class="string">'a'</span>)]&gt;<span class="number">100</span>-r:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">                r=<span class="number">0</span></span><br><span class="line">            r+=widths[ord(c)-ord(<span class="string">'a'</span>)]</span><br><span class="line">        <span class="keyword">return</span> [l,r]</span><br></pre></td></tr></table></figure></p>
<h2>Unique Morse Code Words</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/unique-morse-code-words/</p>
<blockquote>
<p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code> maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>
</blockquote>
<blockquote>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, &quot;cab&quot; can be written as &quot;-.-.-....-&quot;, (which is the concatenation &quot;-.-.&quot; + &quot;-...&quot; + &quot;.-&quot;). We'll call such a concatenation, the transformation of a word.</p>
</blockquote>
<blockquote>
<p>Return the number of different transformations among all words we have.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The transformation of each word is:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The length of words will be at most <code>100</code>.</li>
<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>
<li><code>words[i]</code> will only consist of lowercase letters.</li>
</ol>
<p>这题比上面那题还直接，把每个词转换成Morse码就知道到底有几种形式：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alphabet=[<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>]</span><br><span class="line">        trans=set()</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            trans.add(<span class="string">''</span>.join([alphabet[ord(i)-ord(<span class="string">'a'</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> w]))</span><br><span class="line">        <span class="keyword">return</span> len(trans)</span><br></pre></td></tr></table></figure></p>
<h2>Max Increase to Keep City Skyline</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/max-increase-to-keep-city-skyline/</p>
<blockquote>
<p>In a 2 dimensional array <code>grid</code>, each value <code>grid[i][j]</code> represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.</p>
</blockquote>
<blockquote>
<p>At the end, the &quot;skyline&quot; when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.</p>
</blockquote>
<blockquote>
<p>What is the maximum total sum that the height of the buildings can be increased?</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">Output: 35</span><br><span class="line">Explanation:</span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4],</span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">The skyline viewed from top or bottom is: [9, 4, 8, 7]</span><br><span class="line">The skyline viewed from left or right is: [8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">The grid after increasing the height of buildings without affecting skylines is:</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt; grid.length = grid[0].length &lt;= 50</code>.</li>
<li>All heights <code>grid[i][j]</code> are in the range <code>[0, 100]</code>.</li>
<li>All buildings in <code>grid[i][j]</code> occupy the entire grid cell: that is, they are a <code>1 x 1 x grid[i][j]</code> rectangular prism.</li>
</ol>
<p>天际线取决于该视角下最高的大楼，自顶而下的天际线为各列的最大值，从左往右的天际线为各行的最大值。为了使天际线不变，而每个大楼都尽量增高，应该取该大楼所在的行和列的最大值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        m,n=len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        r=[max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        c=[max([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> grid]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                res+=min(r[i],c[j])-grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>
<h2>Split Array With Same Average</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/split-array-with-same-average/</p>
<blockquote>
<p>In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)</p>
</blockquote>
<blockquote>
<p>Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3,4,5,6,7,8]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The length of <code>A</code> will be in the range <code>[1, 30]</code>.</li>
<li><code>A[i]</code> will be in the range of <code>[0, 10000]</code>.</li>
</ol>
<p>这题如果一定要解，暴力搜索肯定可以，只是必然TLE，所以需要借助一些方法减少搜索次数。假设<code>B</code>是长度比较大的那个子数组，有<code>sum(A)/len(A)=sum(B)/len(B)=sum(C)/len(C)</code>,如果要存在这样的<code>B</code>和<code>C</code>，至少要求有更小的<code>sum(B)</code>和<code>len(B)</code>凑出<code>sum(A)/len(A)=sum(B)/len(B)</code>。记<code>g=gcd(sum(A),len(A))</code>，可以有<code>sum(A)=g*s</code>和<code>len(A)=g*n</code>其中<code>s</code>和<code>n</code>互质，所以搜索<code>sum(B)</code>和<code>len(B)</code>的可能的值的时候只需要找一个整数<code>0&lt;i&lt;g</code>构造<code>sum(B)=i*s</code>和<code>len(B)=i*n</code>，只有在这些情况下可能找到符合<code>sum(A)/len(A)=sum(B)/len(B)</code>的子数组<code>B</code>，当然由于考虑到<code>B</code>和<code>C</code>的对称性限定了<code>B</code>为较大的子数组，所以只要考虑<code>&lt;=g/2</code>的情况就可以覆盖所有可能了。</p>
<p>在构造出可能的目标<code>len(B)</code>和<code>sum(B)</code>后开始在<code>A</code>中用DFS取值看是否存在符合要求的<code>B</code>:可以先把<code>A</code>按照降序排列，然后从数组头部开始取数或跳到下一个值，遇到开始小于<code>sum(B)\len(B)</code>的数就跳出，这样的方法适用DFS常见的递归实现。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArraySameAverage</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pos,target,cnt)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span> <span class="keyword">and</span> cnt==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> pos&gt;=len(A) <span class="keyword">or</span> target&lt;<span class="number">0</span> <span class="keyword">or</span> target-cnt*A[pos]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> dfs(pos+<span class="number">1</span>,target-A[pos],cnt<span class="number">-1</span>) <span class="keyword">or</span> dfs(pos+<span class="number">1</span>,target,cnt)</span><br><span class="line"></span><br><span class="line">        g=fractions.gcd(sum(A),len(A))</span><br><span class="line">        s,n=sum(A)/g,len(A)/g</span><br><span class="line">        A.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,int(g/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dfs(<span class="number">0</span>,s*i,n*i):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为<code>o(g*(2^(len(A))))</code>，空间复杂度为<code>o(1)</code></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-77/" data-id="cjm54ylj0001mfkw3isp6cnwo" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><span class="page-number">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-next" rel="next" href="/page/4/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p> <p>随着一次次的失败，一无所有的作者我已经别无所求了，只想安静的生活下去，不想再被打扰。谢谢大家的关心和照顾，可惜我已经无力回报，非常对不起。有事请联系<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">43</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
        </li>
      
        <li>
          <a href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
