<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/3/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-explicit-control-evaluator" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/explicit-control-evaluator/">显式控制求值器</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/explicit-control-evaluator/" class="article-date"><time datetime="2018-12-27T11:38:08.069Z" itemprop="datePublished">2018-12-27</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要内容<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-34.html#%25_sec_5.4" target="_blank" rel="noopener">5.4  The Explicit-Control Evaluator</a>在<a href="http://notebook.xyli.me/SICP/the-structure-and-interpretation-of-register-machine/">寄存机器</a>模型实现的基础上，用更底层的视角去实现<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%25_sec_4.1" target="_blank" rel="noopener">The Metacircular Evaluator</a>所实现的用Scheme去解释Scheme的元循环求值器，也就是用底层的寄存机器语言去解释Scheme程序。这部分内容没有太大的难点和痛点，在理解eval-apply循环，寄存机器操作的前提下，除了尾递归优化以外，这些内容只是普通的炒冷饭。当然从前篇可以看到这种寄存机器语言也是通过Scheme模拟解释实现的，所以最后的模拟还是Scheme $\to$ 寄存机器语言 $\to$ Scheme这样绕了一大圈，性能上肯定是让人大失所望的，不过借此机会可以清楚看到程序是如何在底层被解释的，也可以通过自定义一些监控性能的指令来观察底层执行情况。</p>
<p>&lt;!-- more --&gt;</p>
<h2>求值器框架</h2>
<p>在低级机器语言中，原求值器的一些用于判断类型和包装类型的过程被扩展成更原始的底层操作。</p>
<h3>寄存器</h3>
<p>除了一个栈以外，全局活跃的还有7个寄存器</p>
<ul>
<li><code>exp</code> 用于存放被求值的表达式</li>
<li><code>env</code> 包含了求值发生时需要用的环境，即变量绑定</li>
<li><code>val</code> 存放求值结果</li>
<li><code>continue</code> 在递归中用于标记调用成功后应该返回的位置</li>
<li><code>proc</code> 在调用求值时，用于存放过程/操作符的求值结果</li>
<li><code>argl</code> 用于存放实参列表的求值结果</li>
<li><code>unev</code> 存放还没有被求值（unevaluated）的子表达式</li>
</ul>
<p><code>proc</code>，<code>argl</code>, 和<code>unev</code>都只在对组合求值时使用。</p>
<h3>主循环</h3>
<p>机器语言程序中在顶层用于读取求值的输入和显示输出也是用这样一个driver loop</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">read-eval-print-loop</span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> initialize-stack))</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> prompt-for-input) (<span class="name">const</span> <span class="string">";;; EC-Eval input:"</span>))</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> read))</span><br><span class="line">  (<span class="name">assign</span> env (<span class="name">op</span> get-global-environment))</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> print-result))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br><span class="line">print-result</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> announce-output) (<span class="name">const</span> <span class="string">";;; EC-Eval value:"</span>))</span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> user-print) (<span class="name">reg</span> val))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> read-eval-print-loop))</span><br></pre></td></tr></table></figure></p>
<p>这里假设所有IO操作都是原始操作，而<code>eval-dispatch</code>对应的位置开始就是按照类型开始分配对应求值操作的地方，后面会详谈。</p>
<p>另外对于一些异常的处理为
&lt;a name=&quot;exception&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unknown-expression-type</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">const</span> unknown-expression-type-error))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> signal-error))</span><br><span class="line">unknown-procedure-type</span><br><span class="line">  (<span class="name">restore</span> continue)    <span class="comment">; clean up stack (from apply-dispatch)</span></span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">const</span> unknown-procedure-type-error))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> signal-error))</span><br><span class="line">signal-error</span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> user-print) (<span class="name">reg</span> val))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> read-eval-print-loop))</span><br></pre></td></tr></table></figure></p>
<p>因为每次主循环都会先对栈初始化，所以<code>unknown-procedure-type</code>清理当前栈内的<code>continue</code>也显得有点多余。</p>
<h3>寄存机器构造</h3>
<p>运行这个求值器的寄存机器模拟器这样构造</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> eceval</span><br><span class="line">  (<span class="name">make-machine</span></span><br><span class="line">   '(exp env val proc argl continue unev)</span><br><span class="line">   eceval-operations</span><br><span class="line">  '(</span><br><span class="line">    read-eval-print-loop</span><br><span class="line">      &lt;entire machine controller as given above&gt;</span><br><span class="line">   )))</span><br></pre></td></tr></table></figure></p>
<p><code>controller</code>部分即<code>make-machine</code>的第三个参数为上文和下文中所有寄存机器语言代码内容。操作表，即第二个参数<code>eceval-operations</code>定义为</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> eceval-operations</span><br><span class="line">  (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'self-evaluating?</span> self-evaluating)</span><br><span class="line">        &lt;complete list of operations for eceval machine&gt;))</span><br></pre></td></tr></table></figure></p>
<p>这些原始判断过程用于判断表达式的类型。</p>
<h2>实现细节</h2>
<p>求值器的核心部分是从<code>eval-dispatch</code>开始的指令。类似于寻常见到的<code>(eval exp env)</code>的<code>cond</code>语句实现，先测试<code>exp</code>的类型再找到处理该类型表达式的求值指令，在当前被指定环境<code>env</code>下进行对应的求值指令操作，这些<code>ev-</code>完成后通过<code>continue</code>跳回到本次调用求值应该返回的位置，求值结果被存放在<code>val</code>寄存器中。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">eval-dispatch</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> self-evaluating?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-self-eval))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> variable?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-variable))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> quoted?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-quoted))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> assignment?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-assignment))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> definition?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-definition))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> if?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-if))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> lambda?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-lambda))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> begin?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-begin))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> application?) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-application))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> unknown-expression-type))</span><br></pre></td></tr></table></figure></p>
<p>对于输入非以上类型表达式的错误<code>label unknown-expression-type</code>需要跳回到<a href="#exception">异常处理</a>，其余则按照类型分别进行以下操作。</p>
<h3>简单表达式</h3>
<p>数值，字符串等常量是可以自求值（self-evaluating）的
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ev-self-eval</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>变量求值只需要在环境中找到相应的绑定
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ev-variable</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">op</span> lookup-variable-value) (<span class="name">reg</span> exp) (<span class="name">reg</span> env))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>quote表达式的值即文本部分
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ev-quoted</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">op</span> text-of-quotation) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>lambda表达式是延迟计算对象，只需要把函数体，形参列表，定义时环境封装打包成一个过程对象即为求值结果。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ev-lambda</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> lambda-parameters) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> lambda-body) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">op</span> make-procedure)</span><br><span class="line">              (<span class="name">reg</span> unev) (<span class="name">reg</span> exp) (<span class="name">reg</span> env))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>这些表达式都没有需要被求值的子表达式，所以不会在指令中再次调用<code>eval-dispatch</code>的指令，只需要简单的求值并返回到<code>continue</code>存储的上级调用入口。</p>
<h3>过程应用</h3>
<p>一个典型的过程应用有操作符和操作数两个部分，即我们一般所说的函数调用的函数和实参两个部分，都可以是需要被求值的子表达式，多次递归求值后才能进行真正的应用。</p>
<p>首先对操作符进行求值
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ev-application</span><br><span class="line">  (<span class="name">save</span> continue)</span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> operands) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">save</span> unev)</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> operator) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-appl-did-operator))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br></pre></td></tr></table></figure></p>
<p>把操作数暂时放进<code>unev</code>，当前<code>env</code>和<code>continue</code>都压入栈内，防止对操作数求值过程中产生的中间量污染这两个寄存器，<code>exp</code>只保留操作符，然后在当前<code>env</code>下对操作符求值，得到操作符的求值结果后到达<code>ev-appl-did-operator</code>开始进行操作数的求值。</p>
<p>在对操作数求值前，先恢复<code>unev</code>和<code>env</code>，把操作符的求值结果转移到<code>proc</code>寄存器，初始化实参列表<code>argl</code>寄存器为空，如果需要被求值的实参列表<code>unev</code>已经不包含任何操作数了，那么可以直接对过程进行调用求值了，否则还是需要把<code>proc</code>压进栈内，防止接下来对<code>unev</code>中的操作数的递归求值过程中污染外层的<code>proc</code>。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ev-appl-did-operator</span><br><span class="line">  (<span class="name">restore</span> unev)                  <span class="comment">; the operands</span></span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">assign</span> argl (<span class="name">op</span> empty-arglist))</span><br><span class="line">  (<span class="name">assign</span> proc (<span class="name">reg</span> val))         <span class="comment">; the operator</span></span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> no-operands?) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> apply-dispatch))</span><br><span class="line">  (<span class="name">save</span> proc)</span><br></pre></td></tr></table></figure></p>
<p>对于存放列表的寄存器<code>argl</code>，在模拟寄存机器语言的列表相关操作时还需要定义以下原始操作
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">empty-arglist</span>) '())</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">adjoin-arg</span> arg arglist) (<span class="name"><span class="builtin-name">append</span></span> arglist (<span class="name"><span class="builtin-name">list</span></span> arg)))</span><br></pre></td></tr></table></figure></p>
<p>接下来循环对<code>unev</code>中的操作数进行递归求值，每一轮循环对先保存相应寄存器防止污染，然后从<code>unev</code>取出第一个实参表达式进行求值，求值结果积累到<code>argl</code>上。一个比较特殊的情况是<code>unev</code>只剩最后一个操作数时，会进行一些特殊的处理。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ev-appl-operand-loop</span><br><span class="line">  (<span class="name">save</span> argl)</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> first-operand) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> last-operand?) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-appl-last-arg))</span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">save</span> unev)</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-appl-accumulate-arg))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br></pre></td></tr></table></figure></p>
<p>操作数求值完成后用于把结果累积到实参列表<code>argl</code>并准备下一轮循环求值的操作如下
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ev-appl-accumulate-arg</span><br><span class="line">  (<span class="name">restore</span> unev)</span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">restore</span> argl)</span><br><span class="line">  (<span class="name">assign</span> argl (<span class="name">op</span> adjoin-arg) (<span class="name">reg</span> val) (<span class="name">reg</span> argl))</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> rest-operands) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> ev-appl-operand-loop))</span><br></pre></td></tr></table></figure></p>
<p>检查是否为最后一个操作数的原始测试指令<code>last-operand?</code>定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">last-operand?</span> ops) (<span class="name"><span class="builtin-name">null?</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> ops)))</span><br></pre></td></tr></table></figure></p>
<p>处理最后一个操作数求值的特殊之处在于不再需要在求值前存储原来的<code>unev</code>和<code>env</code>，所以对此情况单独的入口写为：
&lt;a name=&quot;ev-appl-last-arg&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ev-appl-last-arg</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-appl-accum-last-arg))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br><span class="line">ev-appl-accum-last-arg</span><br><span class="line">  (<span class="name">restore</span> argl)</span><br><span class="line">  (<span class="name">assign</span> argl (<span class="name">op</span> adjoin-arg) (<span class="name">reg</span> val) (<span class="name">reg</span> argl))</span><br><span class="line">  (<span class="name">restore</span> proc)</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> apply-dispatch))</span><br></pre></td></tr></table></figure></p>
<p>在完成最后一次求值累积后，恢复本次调用的操作符<code>proc</code>，连同已经完成求值的所有实参<code>argl</code>，参与真正的调用计算<code>apply-dispatch</code>。</p>
<p>这里也和原求值器一样，只考虑原始过程和复合过程两种情况</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply-dispatch</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> primitive-procedure?) (<span class="name">reg</span> proc))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> primitive-apply))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> compound-procedure?) (<span class="name">reg</span> proc))  </span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> compound-apply))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> unknown-procedure-type))</span><br></pre></td></tr></table></figure></p>
<p>假设primitives都是已经由Scheme系统实现完成的，只需要用<code>apply-primitive-procedure</code>指令代入求值即可</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">primitive-apply</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">op</span> apply-primitive-procedure)</span><br><span class="line">              (<span class="name">reg</span> proc)</span><br><span class="line">              (<span class="name">reg</span> argl))</span><br><span class="line">  (<span class="name">restore</span> continue)</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>复合过程的操作符是由程序设计者自己定义的过程，那么就需要构造一个新的环境，把形参和实参的绑定扩展到过程被定义的环境，在新环境中把函数体当作一系列顺序操作指令进行求值</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compound-apply</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> procedure-parameters) (<span class="name">reg</span> proc))</span><br><span class="line">  (<span class="name">assign</span> env (<span class="name">op</span> procedure-environment) (<span class="name">reg</span> proc))</span><br><span class="line">  (<span class="name">assign</span> env (<span class="name">op</span> extend-environment)</span><br><span class="line">              (<span class="name">reg</span> unev) (<span class="name">reg</span> argl) (<span class="name">reg</span> env))</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> procedure-body) (<span class="name">reg</span> proc))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> ev-sequence))</span><br></pre></td></tr></table></figure></p>
<h3>顺序结构</h3>
<p><code>begin</code>语句和函数体都被当作顺序结构来处理，有一系列需要被求值的语句，但只返回最后一个语句的求值结果。</p>
<p>处理<code>begin</code>语句时直接取出其所有语句放进<code>unev</code>等待求值</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ev-begin</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> begin-actions) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">save</span> continue)</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> ev-sequence))</span><br></pre></td></tr></table></figure></p>
<p>在前文也看到了隐式顺序语句，即函数体在<code>compound-apply</code>也是把所有顺序语句存放到<code>unev</code>并跳转到<code>ev-sequence</code>开始对它们求值。</p>
<p><code>ev-sequence</code>和<code>ev-sequence-continue</code>构成了一个连续从<code>unev</code>取出表达式完成求值的循环，同样需要保护<code>unev</code>和<code>env</code>避免受到污染，在求值前先压入栈内，求值完成后从栈中恢复出来。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ev-sequence</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> first-exp) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> last-exp?) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-sequence-last-exp))</span><br><span class="line">  (<span class="name">save</span> unev)</span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-sequence-continue))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br><span class="line">ev-sequence-continue</span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">restore</span> unev)</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> rest-exps) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> ev-sequence))</span><br></pre></td></tr></table></figure></p>
<p>当然也要注意顺序结构列表的最后一个表达式需要特殊处理，不需要再存储<code>unev</code>和<code>env</code>，直接取出整个顺序结构<code>continue</code>，然后跳到<code>eval-dispatch</code>进行求值:
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ev-sequence-last-exp</span><br><span class="line">  (<span class="name">restore</span> continue)</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br></pre></td></tr></table></figure></p>
<p>这个特殊对待也是<strong>尾递归优化</strong>的底层基础，减少了不必要的压栈和弹栈操作，如果没有搭载这样的优化，把最后一个表达式像普通表达式一样处理，即
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ev-sequence</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> no-more-exps?) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-sequence-end))</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> first-exp) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">save</span> unev)</span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-sequence-continue))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br><span class="line">ev-sequence-continue</span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">restore</span> unev)</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> rest-exps) (<span class="name">reg</span> unev))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> ev-sequence))</span><br><span class="line">ev-sequence-end</span><br><span class="line">  (<span class="name">restore</span> continue)</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>其中<code>no-more-exps?</code>被定义为:
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">no-more-exps?</span> seq) (<span class="name"><span class="builtin-name">null?</span></span> seq))</span><br></pre></td></tr></table></figure></p>
<p>最后一个表达式的求值也会涉及栈操作，并且需要在完成求值后再返回原来的<code>ev-sequence</code>，这会使得一些本该被当作尾递归消耗$o(1)$空间的操作被处理成$o(n)$，造成浪费。这样的尾递归优化可以推广到所有处理最后一个子表达式的情况，如对过程调用求值时对最后一个实参求值的<a href="#ev-appl-last-arg"><code>ev-appl-last-arg</code></a>也是使用了evlis tail recursion&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</p>
<h3>条件分支结构</h3>
<p><code>if</code>语句被当作特殊形式处理：先对<code>predicate</code>部分进行求值，然后根据结果选择对哪个分支继续求值，其中有一个分支不会被求值。</p>
<p>因此，需要先把<code>exp</code>压入栈内，为了保证分支求值的结果正确也需要保存当前<code>env</code>的结果，为了整个<code>if</code>的返回位置正确保存当前<code>continue</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ev-if</span><br><span class="line">  (<span class="name">save</span> exp)                    <span class="comment">; save expression for later</span></span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">save</span> continue)</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-if-decide))</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> if-predicate) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))  <span class="comment">; evaluate the predicate</span></span><br></pre></td></tr></table></figure></p>
<p>在完成<code>predicate</code>部分的求值后，根据<code>val</code>的值开始决定接下来求值哪个分支
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ev-if-decide</span><br><span class="line">  (<span class="name">restore</span> continue)</span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">restore</span> exp)</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> true?) (<span class="name">reg</span> val))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> ev-if-consequent))</span><br><span class="line"></span><br><span class="line">ev-if-alternative</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> if-alternative) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))  </span><br><span class="line">ev-if-consequent</span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> if-consequent) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))</span><br></pre></td></tr></table></figure></p>
<p>在完成<code>predicate</code>部分求值后，就可以恢复原来的<code>env</code>和<code>continue</code>用于对分支求值并返回正确的位置。</p>
<h3>赋值与定义</h3>
<p>这些操作都是利用其副作用对当前环境<code>env</code>产生改变，原理相似。</p>
<p>先看赋值，首先对需要被赋的值（表达式）进行求值，完成后找到被赋值的变量，改变它在当前环境中被绑定的值。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ev-assignment</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> assignment-variable) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">save</span> unev)                   <span class="comment">; save variable for later</span></span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> assignment-value) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">save</span> continue)</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-assignment-1))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))  <span class="comment">; evaluate the assignment value</span></span><br><span class="line">ev-assignment-1</span><br><span class="line">  (<span class="name">restore</span> continue)</span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">restore</span> unev)</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> set-variable-value!) (<span class="name">reg</span> unev) (<span class="name">reg</span> val) (<span class="name">reg</span> env))</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">const</span> ok))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<p>假设<code>set-variable-value!</code>已经是一个原始机器操作。这里也利用了<code>unev</code>来暂时存放变量名，在对<code>value</code>部分的求值完成后进入<code>ev-assignment-1</code>真正开始改变<code>env</code>相关绑定，最后整个赋值操作的返回结果是<code>ok</code>，表示赋值成功。</p>
<p>对定义的处理也是相似的，假设<code>define-variable!</code>也是已有的机器操作，在<code>env</code>中添加新的变量与值的绑定。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ev-definition</span><br><span class="line">  (<span class="name">assign</span> unev (<span class="name">op</span> definition-variable) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">save</span> unev)                   <span class="comment">; save variable for later</span></span><br><span class="line">  (<span class="name">assign</span> exp (<span class="name">op</span> definition-value) (<span class="name">reg</span> exp))</span><br><span class="line">  (<span class="name">save</span> env)</span><br><span class="line">  (<span class="name">save</span> continue)</span><br><span class="line">  (<span class="name">assign</span> continue (<span class="name">label</span> ev-definition-1))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> eval-dispatch))  <span class="comment">; evaluate the definition value</span></span><br><span class="line">ev-definition-1</span><br><span class="line">  (<span class="name">restore</span> continue)</span><br><span class="line">  (<span class="name">restore</span> env)</span><br><span class="line">  (<span class="name">restore</span> unev)</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> define-variable!) (<span class="name">reg</span> unev) (<span class="name">reg</span> val) (<span class="name">reg</span> env))</span><br><span class="line">  (<span class="name">assign</span> val (<span class="name">const</span> ok))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br></pre></td></tr></table></figure></p>
<h2>小结</h2>
<p>至此，显式控制求值器<code>eceval</code>已经基本实现了，可以通过之前实现的模拟器开始运行：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">start</span> eceval)</span><br><span class="line"><span class="comment">;;; EC-Eval input:</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">append</span></span> x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> x)</span><br><span class="line">      y</span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> x)</span><br><span class="line">            (<span class="name"><span class="builtin-name">append</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> x) y))))</span><br><span class="line"><span class="comment">;;; EC-Eval value:</span></span><br><span class="line">ok</span><br><span class="line"><span class="comment">;;; EC-Eval input:</span></span><br><span class="line">(<span class="name"><span class="builtin-name">append</span></span> '(a b c) '(d e f))</span><br><span class="line"><span class="comment">;;; EC-Eval value:</span></span><br><span class="line">(<span class="name">a</span> b c d e f)</span><br></pre></td></tr></table></figure></p>
<p>当然不能去指望这个自定义的简易机器模拟的运行效率有多高，但通过在底层实现上微小的修改，可以在一些统计数据上可以更自由的进行模拟监控，比如栈的实时开销监控，设立断点调试等等，这里也不再详谈。</p>
<p>通过更底层视角去审视求值器的实现，可以了解到程序是如何利用几个简单的寄存器控制器被解释的，也帮助我们反思到底怎样写程序会更高效，比如这里就突出了尾递归实现的优越。</p>
<p>如果还有不理解的地方也可以去看<a href="https://www.bilibili.com/video/av8515129/?p=18" target="_blank" rel="noopener">MIT 6.001</a>对应部分的公开课，我自己暂时没时间也没心情所以没完整的去看完相关部分的讲解，但扫了一下字幕脚本感觉很多重要内容都被略过了。建议还是直接看本文或者SICP原书。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Wand, Mitchell. &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.8567&amp;rep=rep1&amp;type=pdf&quot;&gt;&quot;Continuation-based program transformation strategies.&quot;&lt;/a&gt; &lt;em&gt;Journal of the ACM (JACM)&lt;/em&gt; 27.1 (1980): 164-180.&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/explicit-control-evaluator/" data-id="cjuh9jx8a004qfww3tz52u99x" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-116" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-116/">LeetCode Weekly Contest 116</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-116/" class="article-date"><time datetime="2018-12-23T11:25:29.823Z" itemprop="datePublished">2018-12-23</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-116</p>
<p>&lt;!-- more --&gt;</p>
<h2>N-Repeated Element in Size 2N Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-116/problems/n-repeated-element-in-size-2n-array/</p>
<blockquote>
<p>In a array <code>A</code> of size <code>2N</code>, there are <code>N+1</code> unique elements, and exactly one of these elements is repeated N times.</p>
</blockquote>
<blockquote>
<p>Return the element repeated <code>N</code> times.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,5,2,5,3,5,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>4 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt; 10000</code></li>
<li><code>A.length</code> is even</li>
</ol>
<p>找出现次数是数组长度一半的元素：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedNTimes</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = collections.Counter(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cnt:</span><br><span class="line">            <span class="keyword">if</span> cnt[i] == len(A) / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure></p>
<h2>Maximum Width Ramp</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-116/problems/maximum-width-ramp/</p>
<blockquote>
<p>Given an array A of integers, a ramp is a tuple <code>(i, j)</code> for which <code>i &lt; j</code> and <code>A[i] &lt;= A[j]</code>.  The width of such a ramp is <code>j - i</code>.</p>
</blockquote>
<blockquote>
<p>Find the maximum width of a ramp in <code>A</code>.  If one doesn't exist, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [6,0,8,2,1,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= A.length &lt;= 50000</code></li>
<li><code>0 &lt;= A[i] &lt;= 50000</code></li>
</ol>
<p>受到<a href="http://notebook.xyli.me/LeetCode/LC891-alter/">LC891的变体：求所有连续子集的极差之和</a>的启发，维护一个单调栈，正序放进<code>mono</code>的元素保证是到目前为止的最小值，然后倒序遍历数组与栈顶元素比较，如果大于等于栈顶元素则弹出并记录ramp宽度，倒序保证了大于该栈顶元素中，当前元素是距离最远的一个。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxWidthRamp</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mono = []  <span class="comment"># min value so far</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mono <span class="keyword">or</span> A[mono[<span class="number">-1</span>]] &gt; num:</span><br><span class="line">                mono.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> mono <span class="keyword">and</span> A[i] &gt;= A[mono[<span class="number">-1</span>]]:</span><br><span class="line">                res = max(res, i - mono.pop())</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Area Rectangle II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-116/problems/minimum-area-rectangle-ii/</p>
<blockquote>
<p>Given a set of points in the xy-plane, determine the minimum area of <strong>any</strong> rectangle formed from these points, with sides <strong>not necessarily parallel</strong> to the x and y axes.</p>
</blockquote>
<blockquote>
<p>If there isn't any rectangle, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/21/1a.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[2,1],[1,0],[0,1]]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/22/2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,1],[1,1],[1,0],[2,0]]</span><br><span class="line">Output: 1.00000</span><br><span class="line">Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/22/3.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,3],[1,2],[3,1],[1,3],[2,1]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no possible rectangle to form from these points.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/21/4c.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= points.length &lt;= 50</code></li>
<li><code>0 &lt;= points[i][0] &lt;= 40000</code></li>
<li><code>0 &lt;= points[i][1] &lt;= 40000</code></li>
<li>All points are distinct.</li>
<li>Answers within <code>10^-5</code> of the actual value will be accepted as correct.</li>
</ol>
<p>最多50个点，数据量不大，就不考虑算法直接暴力穷举了。</p>
<p>同一个矩阵的两条对角线中点和长度是分别想到的，因此可以按照对角线长度和中点作为key建立dict，计算所有可能组成的矩形的面积取最大值。主要就是算术需要写的耐心一点。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaFreeRect</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dist</span><span class="params">(p1, p2)</span>:</span>  <span class="comment"># square of distance from i to j</span></span><br><span class="line">            x, y = p1[<span class="number">0</span>] - p2[<span class="number">0</span>], p1[<span class="number">1</span>] - p2[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> x * x + y * y</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(p1, p2)</span>:</span></span><br><span class="line">            x, y = p1[<span class="number">0</span>] + p2[<span class="number">0</span>], p1[<span class="number">1</span>] + p2[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> x / <span class="number">2.0</span>, y / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(p1, p2, p3, p4)</span>:</span></span><br><span class="line">            x1, y1 = p1[<span class="number">0</span>] - p2[<span class="number">0</span>], p1[<span class="number">1</span>] - p2[<span class="number">1</span>]</span><br><span class="line">            x2, y2 = p1[<span class="number">0</span>] - p4[<span class="number">0</span>], p1[<span class="number">1</span>] - p4[<span class="number">1</span>]</span><br><span class="line">            edge1, edge2 = math.sqrt(x1 * x1 + y1 * y1), math.sqrt(x2 * x2 + y2 * y2)</span><br><span class="line">            <span class="keyword">return</span> edge1 * edge2</span><br><span class="line"></span><br><span class="line">        n = len(points)</span><br><span class="line">        rect = collections.defaultdict(list)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                d = dist(points[i], points[j])</span><br><span class="line">                c = center(points[i], points[j])</span><br><span class="line">                rect[d, c].append((points[i], points[j]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d, c <span class="keyword">in</span> rect:</span><br><span class="line">            l = len(rect[d, c])</span><br><span class="line">            <span class="keyword">if</span> l &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">                    p1, p3 = rect[d, c][i]</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, l):</span><br><span class="line">                        p2, p4 = rect[d, c][j]</span><br><span class="line">                        res.append(area(p1, p2, p3, p4))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(res <span class="keyword">or</span> [<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<h2>Least Operators to Express Number</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-116/problems/least-operators-to-express-number/</p>
<blockquote>
<p>Given a single positive integer <code>x</code>, we will write an expression of the form <code>x (op1) x (op2) x (op3) x ...</code> where each operator <code>op1</code>, <code>op2</code>, etc. is either addition, subtraction, multiplication, or division (<code>+</code>, <code>-</code>, <code>*</code>, or <code>/</code>).  For example, with <code>x = 3</code>, we might write <code>3 * 3 / 3 + 3 - 3</code> which is a value of 3.</p>
</blockquote>
<blockquote>
<p>When writing such an expression, we adhere to the following conventions:</p>
</blockquote>
<ol>
<li>The division operator (<code>/</code>) returns rational numbers.</li>
<li>There are no parentheses placed anywhere.</li>
<li>We use the usual order of operations: multiplication and division happens before addition and subtraction.</li>
<li>It's not allowed to use the unary negation operator (<code>-</code>).  For example, &quot;<code>x - x</code>&quot; is a valid expression as it only uses subtraction, but &quot;<code>-x + x</code>&quot; is not because it uses negation.</li>
</ol>
<blockquote>
<p>We would like to write an expression with the least number of operators such that the expression equals the given <code>target</code>.  Return the least number of expressions used.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 3, target = 19</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 5, target = 501</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 100, target = 100000000</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 100 * 100 * 100 * 100.  The expression contains 3 operations.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= x &lt;= 100</code></li>
<li><code>1 &lt;= target &lt;= 2 * 10^8</code></li>
</ol>
<p>参考了<a href="https://leetcode.com/problems/least-operators-to-express-number/discuss/208349/JavaC%2B%2BPython-O(logY)-Time-and-O(1)-Space" target="_blank" rel="noopener">[Java/C++/Python] O(logY) Time and O(1) Space</a>的做法。</p>
<p><code>target</code>可以展开成<code>target=y*x+rem</code>或<code>target=(y+1)*x-(x-rem)</code>，其中<code>rem=target mod x</code>。<code>pos</code>是用于表示正的余项（即<code>rem</code>）需要用的<code>x</code>的数量，<code>neg</code>用于表示负的余项（即<code>x-rem</code>）需要用到的<code>x</code>的数量。把<code>target</code>表达成类似<code>x</code>进制的形式即<code>target=d0*x^k+d1*x^(k-1)+...+dk</code>就是最终需要的表达式，最低项即第一次得到的<code>rem</code>或<code>x-rem</code>，<code>x/x</code>一次只能表示出一个<code>1</code>，所以需要对应的数的两倍才可以表表示出来。而<code>x^k</code>项前系数<code>rem</code>或负的<code>(x-rem)</code>可以直接通过<code>k</code>个<code>x</code>相乘来表示并凑够<code>rem</code>或<code>(x-rem)</code>相加来表示。</p>
<p>总结一下，当<code>0</code>到<code>k-1</code>次项一共用了<code>pos</code>或<code>neg</code>来表示时，第<code>k</code>次项如果用<code>rem</code>来表达，那么当<code>k-1</code>次项也是用正的余数表达时，<code>0</code>到<code>k</code>次所有项只需要<code>k*rem+pos</code>个<code>x</code>来表达，如果<code>k-1</code>次是用<code>x</code>减去该项时的余数，那么负项<code>k-1</code>次已经在<code>neg</code>被计算而<code>x</code>本身却没算进去，因此还需要在<code>k*rem+neg</code>的基础上再加上<code>k</code>个<code>x</code>相乘，用于减去<code>k-1</code>次项凑出余数。同理，如果想用<code>x-rem</code>表示当前<code>k</code>次项，当<code>k-1</code>次项为正时，只需要在原来的基础再加上<code>(x-rem)*k</code>个<code>x</code>，即<code>k*(x-rem)+pos</code>；而<code>k-1</code>次项为负时，由于<code>k</code>次本来也是负项，前项需要加上正的1个<code>x^k</code>,本项又需要减去<code>x-rem</code>个<code>x^k</code>，所以总共是<code>k*(x-rem-1)+neg</code>。取每种情况的最小值。</p>
<p>因为最后需要返回的是操作符的数量，所以返回<code>x</code>总数减去1。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastOpsExpressTarget</span><span class="params">(self, x, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = pos = neg = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> target:</span><br><span class="line">            target, rem = divmod(target, x)</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                pos, neg = rem * <span class="number">2</span>, (x - rem) * <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pos, neg = min(k * rem + pos, (rem + <span class="number">1</span>) * k +</span><br><span class="line">                               neg), min(k * (x - rem) + pos, k * (x - rem - <span class="number">1</span>) + neg)</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(pos, k + neg) - <span class="number">1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-116/" data-id="cjuh9jwvg001bfww3pz8dstmh" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-115" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-115/">LeetCode Weekly Contest 115</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-115/" class="article-date"><time datetime="2018-12-16T12:25:03.526Z" itemprop="datePublished">2018-12-16</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-115</p>
<p>&lt;!-- more --&gt;</p>
<h2>Check Completeness of a Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-115/problems/check-completeness-of-a-binary-tree/</p>
<blockquote>
<p>Given a binary tree, determine if it is a <em>complete binary tree</em>.</p>
</blockquote>
<blockquote>
<p><strong>Definition of a complete binary tree from <a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank" rel="noopener">Wikipedia</a></strong>:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between $1$ and $2^h$ nodes inclusive at the last level h.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&apos;t as far left as possible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The tree will have between 1 and 100 nodes.</li>
</ol>
<p>BFS把二叉树写成数组形式（就是input的那种形式），检查中间是否含有<code>null</code>即可:</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        q = [root]</span><br><span class="line">        complete = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> i:</span><br><span class="line">                complete = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> complete:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                q.append(i.left)</span><br><span class="line">                q.append(i.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Prison Cells After N Days</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-115/problems/prison-cells-after-n-days/</p>
<blockquote>
<p>There are 8 prison cells in a row, and each cell is either occupied or vacant.</p>
</blockquote>
<blockquote>
<p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p>
</blockquote>
<blockquote>
<p>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.
Otherwise, it becomes vacant.
(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)</p>
</blockquote>
<blockquote>
<p>We describe the current state of the prison in the following way: <code>cells[i] == 1</code> if the <code>i</code>-th cell is occupied, else <code>cells[i] == 0</code>.</p>
</blockquote>
<blockquote>
<p>Given the initial state of the prison, return the state of the prison after <code>N</code> days (and <code>N</code> such changes described above.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: cells = [0,1,0,1,1,0,0,1], N = 7</span><br><span class="line">Output: [0,0,1,1,0,0,0,0]</span><br><span class="line">Explanation:</span><br><span class="line">The following table summarizes the state of the prison on each day:</span><br><span class="line">Day 0: [0, 1, 0, 1, 1, 0, 0, 1]</span><br><span class="line">Day 1: [0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">Day 2: [0, 0, 0, 0, 1, 1, 1, 0]</span><br><span class="line">Day 3: [0, 1, 1, 0, 0, 1, 0, 0]</span><br><span class="line">Day 4: [0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="line">Day 5: [0, 1, 1, 1, 0, 1, 0, 0]</span><br><span class="line">Day 6: [0, 0, 1, 0, 1, 1, 0, 0]</span><br><span class="line">Day 7: [0, 0, 1, 1, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000</span><br><span class="line">Output: [0,0,1,1,1,1,1,0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>cells.length == 8</code></li>
<li><code>cells[i]</code> is in <code>{0, 1}</code></li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>第<code>i</code>位的取值取决于<code>i-1</code>位和<code>i+1</code>位是否相同，而首位和末尾除了第0天都会是0。</p>
<p><code>cells</code>的变化以14天为一个周期，所以只需要看它对应这14天中的哪一天就可以了。当模14结果为0时对应第14天，其他则对应相应的模14余数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prisonAfterNDays</span><span class="params">(self, cells, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type cells: List[int]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range((N - <span class="number">1</span>) % <span class="number">14</span> + <span class="number">1</span>):</span><br><span class="line">            temp = [<span class="number">0</span>] * <span class="number">8</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                temp[i] = <span class="number">1</span> ^ cells[i - <span class="number">1</span>] ^ cells[i + <span class="number">1</span>]</span><br><span class="line">            cells = temp</span><br><span class="line">        <span class="keyword">return</span> cells</span><br></pre></td></tr></table></figure></p>
<h2>Regions Cut By Slashes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-115/problems/regions-cut-by-slashes/</p>
<blockquote>
<p>In a N x N <code>grid</code> composed of 1 x 1 squares, each 1 x 1 square consists of a <code>/</code>, <code>\</code>, or blank space.  These characters divide the square into contiguous regions.</p>
</blockquote>
<blockquote>
<p>(Note that backslash characters are escaped, so a <code>\</code> is represented as <code>&quot;\\&quot;</code>.)</p>
</blockquote>
<blockquote>
<p>Return the number of regions.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/15/1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;  &quot;</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/15/2.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;\\/&quot;,</span><br><span class="line">  &quot;/\\&quot;</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: (Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.)</span><br><span class="line">The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/15/3.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;/\\&quot;,</span><br><span class="line">  &quot;\\/&quot;</span><br><span class="line">]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (Recall that because \ characters are escaped, &quot;/\\&quot; refers to /\, and &quot;\\/&quot; refers to \/.)</span><br><span class="line">The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/15/4.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;//&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/15/5.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 30</code></li>
<li><code>grid[i][j]</code> is either <code>'/'</code>, <code>'\'</code>, or <code>' '</code>.</li>
</ol>
<p>把每个格子划分成顶部，左边，底部，右边四个部分，如
<img src="https://assets.leetcode.com/uploads/2018/12/15/3.png" alt=""></p>
<p>除了第一行的格子，其他格子的顶部都与上面邻接的格子的底部相通；除了最左边的格子，其他格子的左边部分都与左边邻接的格子的右边部分相通；如果这个格子里面没有<code>/</code>，那么左边和底部不会分开，右边和顶部也不会分开；如果这个格子里面没有<code>\</code>，那么左边和顶部不会分开，右边和底部也不会分开。</p>
<p>因此可以按照这个思路都这些小块进行union find，找到最后一共可以合并为多少块区域：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        parent = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">                parent[x] = x</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">while</span> parent[y] != y:</span><br><span class="line">                y = parent[y]</span><br><span class="line">            parent[x] = y</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            parent[find(y)] = find(x)</span><br><span class="line"></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="comment"># 0:top 1:left 2:bottom 3:right</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                    union((i, j, <span class="number">0</span>), (i - <span class="number">1</span>, j, <span class="number">2</span>))</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    union((i, j, <span class="number">1</span>), (i, j - <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] != <span class="string">'/'</span>:</span><br><span class="line">                    union((i, j, <span class="number">2</span>), (i, j, <span class="number">1</span>))</span><br><span class="line">                    union((i, j, <span class="number">0</span>), (i, j, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] != <span class="string">'\\'</span>:</span><br><span class="line">                    union((i, j, <span class="number">2</span>), (i, j, <span class="number">3</span>))</span><br><span class="line">                    union((i, j, <span class="number">0</span>), (i, j, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(set(map(find, parent.keys())))</span><br></pre></td></tr></table></figure></p>
<h2>Delete Columns to Make Sorted III</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-115/problems/delete-columns-to-make-sorted-iii/</p>
<blockquote>
<p>We are given an array <code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>
</blockquote>
<blockquote>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
</blockquote>
<blockquote>
<p>For example, if we have an array <code>A = [&quot;babca&quot;,&quot;bbazb&quot;]</code> and deletion indices <code>{0, 1, 4}</code>, then the final array after deletions is <code>[&quot;bc&quot;,&quot;az&quot;]</code>.</p>
</blockquote>
<blockquote>
<p>Suppose we chose a set of deletion indices D such that after deletions, the final array has <strong>every element (row) in lexicographic</strong> order.</p>
</blockquote>
<blockquote>
<p>For clarity, <code>A[0]</code> is in lexicographic order (ie. <code>A[0][0] &lt;= A[0][1] &lt;= ... &lt;= A[0][A[0].length - 1]</code>), <code>A[1]</code> is in lexicographic order (ie. <code>A[1][0] &lt;= A[1][1] &lt;= ... &lt;= A[1][A[1].length - 1]</code>), and so on.</p>
</blockquote>
<blockquote>
<p>Return the minimum possible value of <code>D.length</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;babca&quot;,&quot;bbazb&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: After deleting columns 0, 1, and 4, the final array is A = [&quot;bc&quot;, &quot;az&quot;].</span><br><span class="line">Both these rows are individually in lexicographic order (ie. A[0][0] &lt;= A[0][1] and A[1][0] &lt;= A[1][1]).</span><br><span class="line">Note that A[0] &gt; A[1] - the array A isn&apos;t necessarily in lexicographic order.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;edcba&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: If we delete less than 4 columns, the only row won&apos;t be lexicographically sorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ghi&quot;,&quot;def&quot;,&quot;abc&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: All rows are already lexicographically sorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
</ol>
<p>这题实际上反而比前面的题的简单一些。如果给一个数组，让你找最少删除几列可以得到一个递增序列的数组，那么用动态规划找递增序列是很容易的事，对于任意下标<code>i&gt;j</code>如果满足第<code>i</code>个元素大于第<code>j</code>个元素，那么以<code>i</code>位置结尾<strong>最长递增子序列</strong>长度可以更新为<code>dp[i]=max(dp[i],dp[j]+1)</code>，找到最长递增子序列的长度以后，用数组长度减去这个长度就是需要删掉的列的数量。</p>
<p>这题稍微特殊在判断递增必须满足每行的元素都需要满足在行内递增，也就是需要检查是否每行元素都满足第<code>i</code>行的元素大于第<code>j</code>行的元素，那么需要找的是<strong>共同</strong>最长递增子序列。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDeletionSize</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> all(s[j] &lt;= s[i] <span class="keyword">for</span> s <span class="keyword">in</span> A):</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n - max(dp)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-115/" data-id="cjuh9jwvk001dfww38yfzwr45" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-garbage-collection" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/garbage-collection/">垃圾回收</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/garbage-collection/" class="article-date"><time datetime="2018-12-13T09:20:53.752Z" itemprop="datePublished">2018-12-13</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面的<a href="http://notebook.xyli.me/SICP/the-structure-and-interpretation-of-register-machine/">寄存机器模型</a>的基础上，<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-33.html#%25_sec_5.3" target="_blank" rel="noopener">Storage Allocation and Garbage Collection</a>简单描述了数据在存储中的分配表示，以及不断分配空间给新数据必然带来的问题：存储耗尽，因此需要一个垃圾收集机制维护整个存储系统正常运转。这部分内容不是很多也不难理解，但文字内容比较密集叙述有点乏味，因此我另外简单写一篇重点看算法的代码实现。此外，可能因为原文一直都是在假设已经知道内存中哪些部分放的数据是需要被清理的垃圾，而哪些是还需要继续使用的数据，所以只需要在空间耗尽前通过一定的算法清理掉垃圾释放空间，但并没有解释怎样去区分垃圾和有用的数据，所以看着会有些困惑。这里同样不再讨论这个问题，有兴趣的自己找相关文本材料阅读。</p>
<p>&lt;!-- more --&gt;</p>
<h2>序对和其他数据的向量表示</h2>
<p>传统的计算机内存可以被想象成一些排列规划好的格子，用于存放数据，而每个格子都有一个唯一的名字或者说序号，可以通过它来访问和更改格子里的内容。而这个唯一的标识符就是它的地址/位置，地址也可以被当作普通的数据来对待，进行一些算术运算得到新的地址，再通过新的地址去访问其他数据，这也令诸如pair，list这样的树状数据结构可以在线性的内存中很好的被表达。</p>
<p>对这种存储结构的建模可以用向量来模拟，和C++ STL的<code>vector</code>相似，把它当成一种像数组一样可以直接用索引访问的容器，通过下面两个基本操作对向量中的元素进行访问和修改：</p>
<ul>
<li><code>(vector-ref &lt;vector&gt; &lt;n&gt;)</code>: 读取向量<code>&lt;vector&gt;</code>的第<code>n</code>个元素并返回</li>
<li><code>(vector-set! &lt;vector&gt; &lt;n&gt; &lt;value&gt;)</code>: 把向量<code>&lt;vector&gt;</code>的第<code>n</code>个元素的值设置为<code>&lt;value&gt;</code></li>
</ul>
<p>而这些操作的效率都是与<code>n</code>本身大小无关的，可以认为是$o(1)$，通过对<code>n</code>参数的算术运算可以连续取值。索引计数默认从0开始。</p>
<h3>列表</h3>
<p>我们用两个向量来存储所有的序对（pair）结构，<code>the-cars</code>向量表示用来存放所有序对的<code>car</code>部分，<code>the-cdrs</code>用来存放所有序对的<code>cdr</code>部分。指向一个序对的指针表示可以暂时想象成某个索引值<code>n</code>，<code>the-cars</code>的第<code>n</code>个元素是这个序对的<code>car</code>部分，<code>the-cdrs</code>的第<code>n</code>个元素是这个序对的<code>cdr</code>部分。</p>
<p>放在向量中的元素实际上都可以被看成指针，有些是指向其他序对（即索引值），有些则指向数值或symbol等常量。指针的内涵可以被扩展为类型指针（typed pointer），除了它指向什么的数据地址外，还需要在标识出它指向的东西的类型，一般实现这种结构的方法是在把指针的固定长度的前几位作为类型域（type field），在此不再多作讨论。</p>
<p>当指针指向不同类型的数据时，假设它的第一个部分用来标识数据的类型，如整数4被标识为<code>n4</code>，指向<code>nil</code>被标识为<code>e0</code>，指向另一个序对时，标识类型为<code>p</code>而后面的表示符表示那个序对在向量中对应的索引。</p>
<p>列表<code>((1 2) 3 4)</code>可以表示为</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/vector.png?inline=false" alt="每个序对左下角的数字表示在向量中的索引"></p>
<p>在寄存机器语言中，可以用两个同名寄存器<code>the-cars</code>和<code>the-cdrs</code>来表示这两个向量，利用前面提到的向量操作<code>vector-ref</code>和<code>vector-set!</code>把序对相关操作转换成对于寄存器的操作。</p>
<p>比如<code>car</code>和<code>cdr</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> car) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> cdr) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p>可以写为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p><code>reg2</code>即该序对在向量中对应的索引值</p>
<p>更改操作
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">perform</span> (<span class="name">op</span> set-car!) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">perform</span> (<span class="name">op</span> set-cdr!) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p>可以写为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p><code>free</code>是一个特殊的寄存器，指向下一个可用索引。使用<code>cons</code>来构造一个新的序对
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> cons) (<span class="name">reg</span> &lt;reg2&gt;) (<span class="name">reg</span> &lt;reg3&gt;))</span><br></pre></td></tr></table></figure></p>
<p>可以用这样的实现：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> free) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> free) (<span class="name">reg</span> &lt;reg3&gt;))</span><br><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">reg</span> free))</span><br><span class="line">(<span class="name">assign</span> free (<span class="name">op</span> +) (<span class="name">reg</span> free) (<span class="name">const</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h3>栈*</h3>
<p>用上述写法展开一些栈操作，比如对<code>the-stack</code>的压栈<code>(save &lt;reg&gt;)</code>操作可以实现为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> the-stack (<span class="name">op</span> cons) (<span class="name">reg</span> &lt;reg&gt;) (<span class="name">reg</span> the-stack))</span><br></pre></td></tr></table></figure></p>
<p>同样弹栈操作<code>(restore &lt;reg&gt;)</code>实现为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg&gt; (<span class="name">op</span> car) (<span class="name">reg</span> the-stack))</span><br><span class="line">(<span class="name">assign</span> the-stack (<span class="name">op</span> cdr) (<span class="name">reg</span> the-stack))</span><br></pre></td></tr></table></figure></p>
<p>初始化命令<code>(perform (op initialize-stack))</code>实现为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> the-stack (<span class="name">const</span> ()))</span><br></pre></td></tr></table></figure></p>
<p>这些内容也没什么可细说的，之前把栈作为list来实现，现在了解了list如何实现后再从底层重新写一遍而已。</p>
<h2>垃圾收集</h2>
<p>程序运行中会产生一些临时数据，使用过一次或几次后不需要再被使用。如果在内存中始终为它们保留这些空间，可能会导致内存耗尽，因为我们暂时做不到物理上的无限大小的内存。因此需要一个合适的垃圾收集（garbage collection）来回收处理这些<strong>对未来的计算不会产生任何影响</strong>（即不会有后续的<code>car</code> <code>cdr</code>等针对它的读写操作），给其他有用的数据让出更多的空间。</p>
<p>一种经典的，被用于Scheme的高速垃圾收集方法名为stop-and-copy算法，也就是通常所说的Minsky-Fenichel-Yochelson算法，接下来主要描述这种算法。另一种常见的方法mark-sweep方法可以见<a href="https://www.bilibili.com/video/av8515129/?p=20" target="_blank" rel="noopener">MIT6.001</a>相关课程材料中给出的实现和讨论，或直接阅读Allen原文&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;的完整讨论。</p>
<h3>Stop-and-copy</h3>
<p>基本思想是先把内存划分成两半：一半被称为工作内存（working memory），另一半为空闲内存（free memory）。</p>
<p>我们首先从当前的工作内存中分配空间来构造新的序对，这个过程中通过<code>free</code>指针的自增操作不断指引下一个可用的空间位置。当工作内存满了的时候，会混杂着垃圾和有用的数据。</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/before-gc.png?inline=false" alt=""></p>
<p>这时都该进行垃圾收集了。</p>
<p>垃圾收集过程中我们定位所有在工作内存中有用的数据，并把它们复制到空闲内存中的连续空间中。这里寻找有用的数据（序对）是通过追踪机器寄存器中的所有<code>car</code>和<code>cdr</code>指针，能通过它们访问到的数据就是有用的。因为我们没有复制垃圾，所以空闲内存被使用的空间是小于原工作内存的，那么空闲区域可以继续分配空间给新的序对。而工作内存现在的数据都已经没有继续保留的价值了，反正有用的数据也已经被复制了。所以，现在可以直接交换这两部分内存的角色，让原来的空闲内存从此成为当前的工作内存，而原来的工作内存也成了现在的空闲内存。至此，本次垃圾收集完成。</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/after-gc.png?inline=false" alt=""></p>
<p>当工作内存再次用完时，再进行如上操作并交替。</p>
<h3>实现细节</h3>
<p>接下来试图用寄存机器语言指令实现一个垃圾收集器（garbage collector），首先假设存在一个<code>root</code>寄存器，相当于其他树形数据结构的根结点的角色，通过它开始的遍历可以访问到所有机器中可访问的数据，维护<code>root</code>可以通过在垃圾收集前，把所有机器中的寄存器的内容存放到<code>root</code>指向的list。</p>
<p>当调用<code>cons</code>时发现<code>free</code>指针指向一个超出当前工作内存的位置，就说明内存已经耗尽，可以开始进行垃圾收集了。收集的过程中除了原来的<code>free</code>，还需要一个<code>scan</code>作为指针记录在工作空间中扫描到的位置。算法中，<code>root</code>用于指示新内存的起点，序对被复制过来后，<code>root</code>也会调整到新的位置，<code>free</code>也会相应增加。</p>
<p>旧位置的序对被复制完成后，内容会被更改为相应的标记来指示这个位置的内容已经转移了。这种标记表示为：在<code>car</code>位置放置一个特殊的标签（传统上我们叫它broken heart标签），在<code>cdr</code>位置放置指向这个数据被复制到新内存的位置的转发地址（forwarding address），可以直接通过这个地址达到它在新内存的位置进行取值访问。</p>
<p>首先来看最后交换工作内存和空闲内存的<code>gc-flip</code>部分，<code>new-cars</code>和<code>new-cdrs</code>是垃圾收集完成前的空闲内存，<code>the-cars</code>和<code>the-cdrs</code>是垃圾收集完成前的工作内存。简单的进行交换内容即可：</p>
<p>&lt;a name=&quot;gc-flip&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gc-flip</span><br><span class="line">  (<span class="name">assign</span> temp (<span class="name">reg</span> the-cdrs))</span><br><span class="line">  (<span class="name">assign</span> the-cdrs (<span class="name">reg</span> new-cdrs))</span><br><span class="line">  (<span class="name">assign</span> new-cdrs (<span class="name">reg</span> temp))</span><br><span class="line">  (<span class="name">assign</span> temp (<span class="name">reg</span> the-cars))</span><br><span class="line">  (<span class="name">assign</span> the-cars (<span class="name">reg</span> new-cars))</span><br><span class="line">  (<span class="name">assign</span> new-cars (<span class="name">reg</span> temp))</span><br></pre></td></tr></table></figure></p>
<p>核心操作<code>relocate-old-result-in-new</code>可以看成一个函数，以工作内存中被扫描到的内容<code>old</code>作为参数，返回它在空闲内存中被复制到的内容<code>new</code></p>
<p>如果<code>old</code>不是指向序对结构的指针，也就是说它指向数值符号等常量，这里假设常量被存储在另外一片不可更改只能被引用的空间，那么不需要另外开辟空间来存储它，<code>new</code>只需要沿用<code>old</code>的值。</p>
<p>如果<code>old</code>指向了一个已经被复制转移到新内存的序对（通过检查<code>old</code>指向的序对的<code>car</code>是否有broken heart标签），那么只需要从<code>cdr</code>读取原序对的新位置，就可以作为<code>new</code>的内容。</p>
<p>如果<code>old</code>指向的序对还没有被转移，那就需要我们来对它完成复制转移。先把它们复制到新内存的第一个可用位置(<code>free</code>指向的内容)记为<code>new</code>，增加<code>free</code>使之指向下一个可用位置，再在原来的<code>car</code>部分打上broken heart标签，并在原来的<code>cdr</code>位置设置<code>new</code>为转发地址。</p>
<p>&lt;a name=&quot;relocate-old-result-in-new&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">relocate-old-result-in-new</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> pointer-to-pair?) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> pair))</span><br><span class="line">  (<span class="name">assign</span> new (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> relocate-continue))</span><br><span class="line"></span><br><span class="line">pair</span><br><span class="line">  (<span class="name">assign</span> oldcr (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> broken-heart?) (<span class="name">reg</span> oldcr))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> already-moved))</span><br><span class="line">  (<span class="name">assign</span> new (<span class="name">reg</span> free)) <span class="comment">; new location for pair</span></span><br><span class="line">  <span class="comment">;; Update free pointer.</span></span><br><span class="line">  (<span class="name">assign</span> free (<span class="name">op</span> +) (<span class="name">reg</span> free) (<span class="name">const</span> <span class="number">1</span>))</span><br><span class="line">  <span class="comment">;; Copy the car and cdr to new memory.</span></span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> vector-set!)</span><br><span class="line">           (<span class="name">reg</span> new-cars) (<span class="name">reg</span> new) (<span class="name">reg</span> oldcr))</span><br><span class="line">  (<span class="name">assign</span> oldcr (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> vector-set!)</span><br><span class="line">           (<span class="name">reg</span> new-cdrs) (<span class="name">reg</span> new) (<span class="name">reg</span> oldcr))</span><br><span class="line">  <span class="comment">;; Construct the broken heart.</span></span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> vector-set!)</span><br><span class="line">           (<span class="name">reg</span> the-cars) (<span class="name">reg</span> old) (<span class="name">const</span> broken-heart))</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> old) (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> relocate-continue))</span><br><span class="line"></span><br><span class="line">already-moved</span><br><span class="line">  (<span class="name">assign</span> new (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> relocate-continue))</span><br></pre></td></tr></table></figure></p>
<p>中间寄存器<code>oldcr</code>用于分别在不同时间存放<code>old</code>指向的序对的<code>car</code>内容和<code>cdr</code>内容。</p>
<p>整个垃圾收集的过程开始时，先初始化<code>free</code>和<code>scan</code>，并找到旧内存的<code>root</code>迁移到新内存后的位置作为新的<code>root</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin-garbage-collection</span><br><span class="line">  (<span class="name">assign</span> free (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">  (<span class="name">assign</span> scan (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">  (<span class="name">assign</span> old (<span class="name">reg</span> root))</span><br><span class="line">  (<span class="name">assign</span> relocate-continue (<span class="name">label</span> reassign-root))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> relocate-old-result-in-new))</span><br><span class="line">reassign-root</span><br><span class="line">  (<span class="name">assign</span> root (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> gc-loop))</span><br></pre></td></tr></table></figure></p>
<p>然后开启<code>gc-loop</code>的循环。</p>
<p>在这个主循环中，如果<code>free</code>和<code>scan</code>指针相遇，则说明已经扫描完了新内存中所有数据，没有还需要复制转移的，那么直接跳转到最后的<a href="#gc-flip"><code>gc-flip</code></a>即可。</p>
<p>而如果还有没扫描完的数据，说明有些指针的内容在第一次被遇到后就复制到了，这些内容包含指向旧内存的指针，因此需要通过<a href="#relocate-old-result-in-new"><code>relocate-old-result-in-new</code></a>把这些被指向的旧内存内容复制转移到新内存，或者对于已经转移过来的，直接指向新内存。对每个<code>scan</code>指向的<code>new-cars</code>和<code>new-cdrs</code>两个部分都需要进行一次这样重新定位内容的操作。</p>
<p>所以主循环是这样的：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gc-loop</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> =) (<span class="name">reg</span> scan) (<span class="name">reg</span> free))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> gc-flip))</span><br><span class="line">  (<span class="name">assign</span> old (<span class="name">op</span> vector-ref) (<span class="name">reg</span> new-cars) (<span class="name">reg</span> scan))</span><br><span class="line">  (<span class="name">assign</span> relocate-continue (<span class="name">label</span> update-car))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> relocate-old-result-in-new))</span><br></pre></td></tr></table></figure></p>
<p>先对<code>scan</code>扫描到的<code>car</code>部分进行重定位，并修改<code>car</code>部分内容。再对<code>scan</code>指向的<code>cdr</code>部分重新定位并修改内容，完成后对<code>scan</code>进行自增操作扫描下一个位置重复入手操作，直至<code>scan</code>与<code>free</code>相遇为止。
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">update-car</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> vector-set!) (<span class="name">reg</span> new-cars) (<span class="name">reg</span> scan) (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">assign</span> old (<span class="name">op</span> vector-ref) (<span class="name">reg</span> new-cdrs) (<span class="name">reg</span> scan))</span><br><span class="line">  (<span class="name">assign</span> relocate-continue (<span class="name">label</span> update-cdr))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> relocate-old-result-in-new))</span><br><span class="line"></span><br><span class="line">update-cdr</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> vector-set!) (<span class="name">reg</span> new-cdrs) (<span class="name">reg</span> scan) (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">assign</span> scan (<span class="name">op</span> +) (<span class="name">reg</span> scan) (<span class="name">const</span> <span class="number">1</span>))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> gc-loop))</span><br></pre></td></tr></table></figure></p>
<h2>小结</h2>
<p>这篇算是我写过的比较短的内容了，介绍了一个至今还在服役的算法的基本思想。垃圾收集器无法被调试，且必须保证很高的效率，因此又必须写的小巧精致。后来有人把这个算法改进成了不用停下程序计算也能同时完成垃圾收集的实时垃圾回收机制&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，如果对垃圾回收很感兴趣，不妨可以先从大一统理论&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;开始看起来（笑）。</p>
<p>上面介绍的算法实现上可能会有时想不过来为什么需要复制后不断扫描修改和分配新地址，这也算不上什么巧妙高端的技术，你写二叉树复制或者更宽泛的深拷贝场景的时候肯定遇到过相似的问题，多回去写写自然会明白。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Allen, John. 1978. &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=542865&quot;&gt;Anatomy of Lisp&lt;/a&gt;. New York: McGraw-Hill&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Baker Jr, Henry G. &lt;a href=&quot;https://dspace.mit.edu/bitstream/handle/1721.1/41976/AI_WP_139.pdf?sequ&quot;&gt;&quot;List processing in real time on a serial computer.&quot;&lt;/a&gt; &lt;em&gt;Communications of the ACM&lt;/em&gt; 21.4 (1978): 280-294.&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;Bacon, David F., Perry Cheng, and V. T. Rajan. &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.439.1202&amp;rep=rep1&amp;type=pdf&quot;&gt;&quot;A unified theory of garbage collection.&quot;&lt;/a&gt; ACM SIGPLAN Notices 39.10 (2004): 50-68.&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/garbage-collection/" data-id="cjuh9jx8t004yfww3mgscuaaw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存分配/">内存分配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/垃圾回收/">垃圾回收</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-114" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-114/">LeetCode Weekly Contest 114</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-114/" class="article-date"><time datetime="2018-12-09T11:03:24.490Z" itemprop="datePublished">2018-12-09</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-114</p>
<p>&lt;!-- more --&gt;</p>
<h2>Verifying an Alien Dictionary</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-114/problems/verifying-an-alien-dictionary/</p>
<blockquote>
<p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different <code>order</code>. The <code>order</code> of the alphabet is some permutation of lowercase letters.</p>
</blockquote>
<blockquote>
<p>Given a sequence of <code>words</code> written in the alien language, and the <code>order</code> of the alphabet, return <code>true</code> if and only if the given <code>words</code> are sorted lexicographicaly in this alien language.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 20</code></li>
<li><code>order.length == 26</code></li>
<li>All characters in <code>words[i]</code> and order are english lowercase letters.</li>
</ol>
<p>按照题意估计是让你重写<code>strcmp</code>，我太懒了，直接把<code>order</code>映射到正常字母序对应的字母，重写把<code>words</code>中所有词写一遍。比较不需要自己写排序，检验排序是否正确，检查每个词是否大于等于前面的词就可以了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span><span class="params">(self, words, order)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type order: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;c: i <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(order)&#125;</span><br><span class="line"></span><br><span class="line">        cur = <span class="string">''</span>.join([chr(ord(<span class="string">'a'</span>) + d[c]) <span class="keyword">for</span> c <span class="keyword">in</span> words[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            temp = <span class="string">''</span>.join([chr(ord(<span class="string">'a'</span>) + d[c]) <span class="keyword">for</span> c <span class="keyword">in</span> w])</span><br><span class="line">            <span class="keyword">if</span> temp &lt; cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cur = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Array of Doubled Pairs</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-114/problems/array-of-doubled-pairs/</p>
<blockquote>
<p>Given an array of integers <code>A</code> with even length, return <code>true</code> if and only if it is possible to reorder it such that <code>A[2 * i + 1] = 2 * A[2 * i]</code> for every <code>0 &lt;= i &lt; len(A) / 2.</code></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,6]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,6]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,-2,2,-4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4,16,8,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 30000</code></li>
<li><code>A.length</code> is even</li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ol>
<p>先对<code>A</code>的所有元素计数，从最小的数开始找到足够的它的二倍数元素，然后删去，形成数对，如果不够则无法成立。如果能取完所有元素则成立。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canReorderDoubled</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = collections.Counter(A)</span><br><span class="line">        nums = sorted(d.keys(), key=abs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> d[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * i <span class="keyword">in</span> d <span class="keyword">and</span> d[<span class="number">2</span> * i] &gt;= d[i]:</span><br><span class="line">                d[<span class="number">2</span> * i] -= d[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2>Delete Columns to Make Sorted II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-114/problems/delete-columns-to-make-sorted-ii/</p>
<blockquote>
<p>We are given an array <code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>
</blockquote>
<blockquote>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
</blockquote>
<blockquote>
<p>For example, if we have an array <code>A = [&quot;abcdef&quot;,&quot;uvwxyz&quot;]</code> and deletion indices <code>{0, 2, 3}</code>, then the final array after deletions is <code>[&quot;bef&quot;,&quot;vyz&quot;]</code>.</p>
</blockquote>
<blockquote>
<p>Suppose we chose a set of deletion indices <code>D</code> such that after deletions, the final array has its elements in <strong>lexicographic</strong> order <code>(A[0] &lt;= A[1] &lt;= A[2] ... &lt;= A[A.length - 1])</code>.</p>
</blockquote>
<blockquote>
<p>Return the minimum possible value of <code>D.length</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">After deleting the first column, A = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].</span><br><span class="line">Now A is in lexicographic order (ie. A[0] &lt;= A[1] &lt;= A[2]).</span><br><span class="line">We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">A is already in lexicographic order, so we don&apos;t need to delete anything.</span><br><span class="line">Note that the rows of A are not necessarily in lexicographic order:</span><br><span class="line">ie. it is NOT necessarily true that (A[0][0] &lt;= A[0][1] &lt;= ...)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We have to delete every column.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
</ol>
<p>当时第一次做<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-111/#Delete-Columns-to-Make-Sorted">944. Delete Columns to Make Sorted</a>的时候看错题，当成这一题来理解了，所以这个改编也不是很复杂。</p>
<p>当<code>A</code>的第<code>i</code>列已经是严格的升序时，后面不需要再排就已经满足lexicographic order了；当<code>A</code>的第<code>i</code>列不满足字母排序，那么第<code>i</code>列必须被删除，然后继续从第<code>i+1</code>列开始检查；如果满足非递减，但存在一些相等的情况，那么只需要把这些相等的行单独找出来按照相同的第<code>i</code>列分组，接下来从第<code>i+1</code>开始只需要检查相同的分组的元素的第<code>i+1</code>列是否令组内元素满足lexicographic order……</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDeletionSize</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_sorted</span><span class="params">(arr, i)</span>:</span></span><br><span class="line">            cur = [arr[<span class="number">0</span>]]</span><br><span class="line">            tier = []</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> s[i] &lt; cur[<span class="number">-1</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span>, []</span><br><span class="line">                <span class="keyword">elif</span> s[i] == cur[<span class="number">-1</span>][i]:</span><br><span class="line">                    cur.append(s)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tier.append(cur)</span><br><span class="line">                    cur = [s]</span><br><span class="line">            <span class="keyword">if</span> len(cur) &gt; <span class="number">1</span>:</span><br><span class="line">                tier.append(cur)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>, tier</span><br><span class="line"></span><br><span class="line">        tier = [A]</span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            temp_tier = []</span><br><span class="line">            d = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tier:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> tier:</span><br><span class="line">                d, l = is_sorted(t, i)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp_tier += l</span><br><span class="line">            <span class="keyword">if</span> d:</span><br><span class="line">                tier = temp_tier</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Tallest Billboard</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-114/problems/tallest-billboard/</p>
<blockquote>
<p>You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height.</p>
</blockquote>
<blockquote>
<p>You have a collection of <code>rods</code> which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.</p>
</blockquote>
<blockquote>
<p>Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,6]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: We have two disjoint subsets &#123;1,2,3&#125; and &#123;6&#125;, which have the same sum = 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: We have two disjoint subsets &#123;2,3,5&#125; and &#123;4,6&#125;, which have the same sum = 10.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The billboard cannot be supported, so we return 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= rods.length &lt;= 20</code></li>
<li><code>1 &lt;= rods[i] &lt;= 1000</code></li>
<li>The sum of rods is at most <code>5000</code>.</li>
</ol>
<p>把它当成背包问题。放在第一个分组则乘以1，放在第二个分组乘以-1，不取用则系数为0，最后相加结果为0，<code>[1,2,3,4,5,6]</code>写为<code>0*1+1*2+1*3-1*4+1*5-1*6</code>，数组最大和为<code>max_sum</code>用<code>dp[i][j]</code>表示前<code>i</code>个数的和能否取到<code>j-max_sum</code>，如果能取到，这样的取法里面所有的正数最大和为<code>max_abs[i][j]</code>，那么第<code>i+1</code>个数可以取正或负，<code>dp[i+1][j]=dp[i][j-rods[i]]|dp[i][j]|dp[i+1][j+rods[i]]</code>，相应的更新<code>max_abs</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tallestBillboard</span><span class="params">(self, rods)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rods: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(rods)</span><br><span class="line">        max_sum = sum(rods)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (<span class="number">2</span> * max_sum + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        max_abs = [[<span class="number">0</span>] * (<span class="number">2</span> * max_sum + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            dp[i][max_sum] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(max_sum * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - rods[i] &gt;= <span class="number">0</span> <span class="keyword">and</span> dp[i][j - rods[i]]:</span><br><span class="line">                    dp[<span class="number">1</span> + i][j] = <span class="keyword">True</span></span><br><span class="line">                    max_abs[<span class="number">1</span> + i][j] = max(max_abs[<span class="number">1</span> + i]</span><br><span class="line">                                            [j], max_abs[i][j - rods[i]])</span><br><span class="line">                <span class="keyword">if</span> j + rods[i] &lt;= max_sum * <span class="number">2</span> <span class="keyword">and</span> dp[i][j + rods[i]]:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = <span class="keyword">True</span></span><br><span class="line">                    max_abs[i + <span class="number">1</span>][j] = max(max_abs[i + <span class="number">1</span>]</span><br><span class="line">                                            [j], max_abs[i][j + rods[i]] + rods[i])</span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    dp[<span class="number">1</span> + i][j] = <span class="keyword">True</span></span><br><span class="line">                    max_abs[i + <span class="number">1</span>][j] = max(max_abs[i + <span class="number">1</span>][j], max_abs[i][j])</span><br><span class="line">            res = max(res, max_abs[i + <span class="number">1</span>][max_sum])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这样做有些浪费。</p>
<p>相应的参考了一下别人的做法，通过交换分组可以发现<code>j</code>的取值是对称的，因此只要保存两组数之间的差值<code>k</code>，以及取这个差值时绝对值和较小的那组数的和<code>min_abs</code>，增加一个可以取的<code>r</code>时，<code>k+r</code>的值一定为正，保持它的<code>min_abs</code>不变即可，如果<code>k&gt;r</code>那么差值为<code>k-r</code>时较小的那组数会再加上<code>r</code>且小于较大的，<code>min_abs</code>应该在原来的基础上加上<code>r</code>；如果<code>r&gt;k</code>那么差值为<code>r-k</code>时，原来最小的那组数再加上<code>k</code>就是另一组数的和，而原来最小的那组数在加上<code>r</code>后变成较大的了，所以这时<code>min_abs</code>应该再加上<code>k</code>，最后返回差值为<code>0</code>时<code>min_abs</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tallestBillboard</span><span class="params">(self, rods)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rods: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_abs = &#123;<span class="number">0</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> rods:</span><br><span class="line">            <span class="keyword">for</span> k, v <span class="keyword">in</span> max_abs.items():</span><br><span class="line">                max_abs[k + r] = max(max_abs.get(k + r, <span class="number">0</span>), v)</span><br><span class="line">                max_abs[abs(k - r)] = max(max_abs.get(abs(k - r), <span class="number">0</span>),</span><br><span class="line">                                          v + min(r, k))</span><br><span class="line">        <span class="keyword">return</span> max_abs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-114/" data-id="cjuh9jwv00018fww33u22l60v" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-the-structure-and-interpretation-of-register-machine" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/the-structure-and-interpretation-of-register-machine/">寄存机器的构造与解释</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/the-structure-and-interpretation-of-register-machine/" class="article-date"><time datetime="2018-12-04T07:08:11.762Z" itemprop="datePublished">2018-12-04</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>传统计算机可以被抽象为一种寄存机器模型（register machine model），在这个模型里，执行程序的过程即按顺序依次执行一系列指令来操纵某些固定存储元素（寄存器）的内容，典型的寄存机器指令的内容为对一些寄存器内容进行操作并把结果赋给另一个寄存器。</p>
<p><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-30.html#%25_chap_5" target="_blank" rel="noopener">Chapter 5: Computing with Register Machines</a>整章内容都在介绍这个寄存机器模型，讨论怎样寄存机器怎样实现计算机程序的种种细节。目前我只详细看完了前两小节，<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-31.html#%25_sec_5.1" target="_blank" rel="noopener">5.1  Designing Register Machines</a>讨论怎样设计这样的寄存机器模型并用相应的符号和语言来表示程序，<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-32.html#%25_sec_5.2" target="_blank" rel="noopener">5.2  A Register-Machine Simulator</a>探讨了怎样用Scheme去模拟实现前面设计的寄存机器语言。相对而言，5.1的内容比较浅显且互联网上更容易找到相应的资料，我在本文就只粗略地介绍一下这种语言的用法，把全文的内容重点放到5.2对应的如何用高级语言去实现这种语言上，通过亲自设计实现模拟并利用它来观测寄存器和栈的使用情况以及指令执行的效率，可以从更接近底层和硬件的视角来审视高级程序设计的问题。</p>
<p>&lt;!-- more --&gt;</p>
<p>总之我还是很鼓励各位读者亲自去看一下原书动手实现和思考，毫无疑问本文确实是<strong>标题党</strong>，真正精彩的内容还在后面的章节我也没有细看，只是把我认为非常基础的两个小节内容做了解析和整理。如果实在觉得啃原著吃力我也希望我的笔记和解读能给困惑中的初学者带来帮助。5.2原文的编排顺序总体很不错，但如assembler部分有点混乱，再加上有点卖弄trick之嫌，会自学者造成很大的阅读压力。没有关系，我们之后会一步步解析这些内容。</p>
<h2>基本模型</h2>
<p>一个典型的计算过程：用辗转相除法（Euclid算法）求<code>a</code>与<code>b</code>的最大公约数</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">gcd</span></span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> b <span class="number">0</span>)</span><br><span class="line">      a</span><br><span class="line">      (<span class="name"><span class="builtin-name">gcd</span></span> b (<span class="name"><span class="builtin-name">remainder</span></span> a b))))</span><br></pre></td></tr></table></figure></p>
<p>在寄存机器上运行该过程的过程，可以从数据流的角度建立数据通路（data path）模型来描述数据的产生，流向和存储，也可以根据基本操作的顺序建立控制器（controller）模型来演示指令的推进过程。</p>
<h3>数据通路</h3>
<p><code>(gcd a b)</code>的数据通路可以简单的表示为
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/gcd-data-path-1.png" alt=""></p>
<p><div class="bs-callout bs-callout-default"><h4>&lt;i class=&quot;fa fa-map&quot;&gt;&lt;/i&gt; 图例</h4>
<ul>
<li><strong>矩形</strong>：寄存器，如<code>a</code>,<code>b</code>,<code>t</code></li>
<li><strong>指向矩形箭头</strong>：表示对寄存器的赋值操作，上面标记的$\otimes$可以看成一个决定操作是否进行的按钮，标记如$a \leftarrow b$按钮表示把<code>b</code>寄存器的值赋给<code>a</code>。</li>
<li><strong>三角形</strong>：表示常量</li>
<li><strong>梯形</strong>：计算操作，一般为原语（primitive）操作。用常数或寄存器内容产生计算结果。</li>
<li><strong>圆形</strong>：测试，与计算操作类似，但测试的输出结果为是或否，这个结果也由控制器来使用，在数据通路图中不直接体现。</li>
</ul>
</div></p>
<p>因为发生递归时寄存器<code>a</code>和<code>b</code>都会重新被赋一个关于另一个寄存器的值，所以引入临时寄存器<code>t</code>来完成这样的交换赋值。</p>
<p>数据通路也可以用这样的语言描述为</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">data-paths</span></span><br><span class="line"> (<span class="name">registers</span></span><br><span class="line">  ((<span class="name">name</span> a)</span><br><span class="line">   (<span class="name">buttons</span> ((<span class="name">name</span> a&lt;-b) (<span class="name">source</span> (<span class="name">register</span> b)))))</span><br><span class="line">  ((<span class="name">name</span> b)</span><br><span class="line">   (<span class="name">buttons</span> ((<span class="name">name</span> b&lt;-t) (<span class="name">source</span> (<span class="name">register</span> t)))))</span><br><span class="line">  ((<span class="name">name</span> t)</span><br><span class="line">   (<span class="name">buttons</span> ((<span class="name">name</span> t&lt;-r) (<span class="name">source</span> (<span class="name">operation</span> rem))))))</span><br></pre></td></tr></table></figure></p>
<p>这样的描述虽然很好的反映了数据流的变化，但想要数据正确地在这些元件之间流动并最终从寄存器<code>a</code>中取出最终结果，需要谨慎的按照一定顺序去按下这些按钮，这件不那么容易表述清楚的事在此完全没有体现，还需要从控制器模型获得相关的信息。</p>
<p>这个表示法和用于描述这种表示法的DSL相对来说并不怎么重要，之后我也不会再在关于数据路径的问题上展开讨论太多，只是辅助理解。</p>
<h3>控制器</h3>
<p>控制器负责安排这些指令操作发生的顺序，<code>(gcd a b)</code>的控制器为
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/gcd-controller-1.png?inline=false" alt="">
图示为我们所熟悉的流程图表示法。</p>
<p>在这个模型的基础上，可以表达一个程序究竟按照什么顺序去执行了哪些指令。为了直观表达，<code>gcd</code>寄存机器的控制器模型也可以用这样类似于Lisp的自定义语言（你可以把它看作一种粗糙的伪代码）去描述</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">controller</span></span><br><span class="line"> test-b                           <span class="comment">; label</span></span><br><span class="line">   (<span class="name">test</span> =)                       <span class="comment">; test</span></span><br><span class="line">   (<span class="name">branch</span> (<span class="name">label</span> gcd-done))      <span class="comment">; conditional branch</span></span><br><span class="line">   (<span class="name">t&lt;-r</span>)                         <span class="comment">; button push</span></span><br><span class="line">   (<span class="name">a&lt;-b</span>)                         <span class="comment">; button push</span></span><br><span class="line">   (<span class="name">b&lt;-t</span>)                         <span class="comment">; button push</span></span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> test-b))          <span class="comment">; unconditional branch</span></span><br><span class="line"> gcd-done)                        <span class="comment">; label</span></span><br></pre></td></tr></table></figure></p>
<p>这也是接下来通篇重点探究的寄存机器语言的雏形。</p>
<hr>
<h2>寄存机器语言</h2>
<p>上述基于控制器的语言描述仍然有很多模糊的地方，为了更精准的描述，可以调整为这样的形式</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">controller</span></span><br><span class="line"> test-b</span><br><span class="line">   (<span class="name">test</span> (<span class="name">op</span> =) (<span class="name">reg</span> b) (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">   (<span class="name">branch</span> (<span class="name">label</span> gcd-done))</span><br><span class="line">   (<span class="name">assign</span> t (<span class="name">op</span> rem) (<span class="name">reg</span> a) (<span class="name">reg</span> b))</span><br><span class="line">   (<span class="name">assign</span> a (<span class="name">reg</span> b))</span><br><span class="line">   (<span class="name">assign</span> b (<span class="name">reg</span> t))</span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> test-b))</span><br><span class="line"> gcd-done)</span><br></pre></td></tr></table></figure></p>
<p>如果你曾经写过汇编语言，对此应该是有些亲切感的。接下来直接规定这些指令的用法和意义，并讨论如何把高级程序转换成可以直接执行的寄存机器语言指令</p>
<h3>基本用法</h3>
<p>常见操作对应的指令</p>
<ul>
<li><code>(const &lt;constant-value&gt;)</code>：表示常量</li>
<li><code>(reg &lt;register-name&gt;)</code>：寄存器的内容</li>
</ul>
<p>以及以下稍微复杂的指令，其中<code>&lt;input&gt;</code>为上述常量或寄存器内容</p>
<ul>
<li><code>(assign &lt;register-name&gt; (reg &lt;register-name&gt;))</code>: 将一个寄存器的内容放入另一个寄存器</li>
<li><code>(assign &lt;register-name&gt; (const &lt;constant-value&gt;))</code>: 将常量值放入寄存器</li>
<li><code>(assign &lt;register-name&gt; (op &lt;operation-name&gt;) &lt;input1&gt; ... &lt;inputn&gt;)</code>：将这些<code>&lt;input&gt;</code>作为输入的<code>&lt;operation-name&gt;</code>操作的结果放入寄存器</li>
<li><code>(perform (op &lt;operation-name&gt;) &lt;input1&gt; ... &lt;inputn&gt;)</code>：用这些<code>&lt;input&gt;</code>进行<code>&lt;operation-name&gt;</code>操作</li>
<li><code>(test (op &lt;operation-name&gt;) &lt;input1&gt; ... &lt;inputn&gt;)</code>: 测试这些<code>&lt;input&gt;</code>进行<code>&lt;operation-name&gt;</code>操作是否为真，如果是则进入执行接下来的<code>branch</code>语句，否则跳过这个<code>branch</code>指令</li>
<li><code>(branch (label &lt;label-name&gt;))</code>：如果上一步测试结果为真，跳转到<code>&lt;label-name&gt;</code>对应的<code>label</code>处</li>
<li><code>(goto (label &lt;label-name&gt;))</code>: 跳转到<code>&lt;label-name&gt;</code>对应的<code>label</code>处</li>
</ul>
<p>寄存器不仅可以用来存放数值，也可以用来存放需要被跳转的目标<code>label</code></p>
<ul>
<li><code>(assign &lt;register-name&gt; (label &lt;label-name&gt;))</code>:把<code>&lt;label-name&gt;</code>对应<code>label</code>值放入寄存器<code>&lt;register-name&gt;</code></li>
<li><code>(goto (reg &lt;register-name&gt;))</code>: 跳转到寄存器存放的<code>label</code>位置</li>
</ul>
<p>后面会看到，处理递归时会用到一个栈（stack）来管理后续指令（像<code>gcd</code>那样的尾递归不需要），因此有相应的栈操作：</p>
<ul>
<li><code>(save &lt;register-name&gt;)</code>： 把寄存器内容压入栈内</li>
<li><code>(restore &lt;register-name&gt;)</code>：弹出栈顶元素并放入寄存器内</li>
</ul>
<p>接下来我们将以一些例子演示用这些指令描述高级程序在寄存机器上是如何运行的。</p>
<h3>I/O GCD machine</h3>
<p>增加一些读写操作，调用<code>gcd</code>过程使之循环接收输入值<code>a</code>和<code>b</code>并输出计算结果，类似于以前写evaluator程序的driver-loop主循环。数据通路可以表示为
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/gcd-data-path-2.png?inline=false" alt="">
用寄存机器语言表示为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">controller</span></span><br><span class="line"> gcd-loop</span><br><span class="line">   (<span class="name">assign</span> a (<span class="name">op</span> read))</span><br><span class="line">   (<span class="name">assign</span> b (<span class="name">op</span> read))</span><br><span class="line"> test-b</span><br><span class="line">   (<span class="name">test</span> (<span class="name">op</span> =) (<span class="name">reg</span> b) (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">   (<span class="name">branch</span> (<span class="name">label</span> gcd-done))</span><br><span class="line">   (<span class="name">assign</span> t (<span class="name">op</span> rem) (<span class="name">reg</span> a) (<span class="name">reg</span> b))</span><br><span class="line">   (<span class="name">assign</span> a (<span class="name">reg</span> b))</span><br><span class="line">   (<span class="name">assign</span> b (<span class="name">reg</span> t))</span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> test-b))</span><br><span class="line"> gcd-done</span><br><span class="line">   (<span class="name">perform</span> (<span class="name">op</span> print) (<span class="name">reg</span> a))</span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> gcd-loop)))</span><br></pre></td></tr></table></figure></p>
<p>这里出现了只需要副作用的<code>print</code>操作所以用前面提到的<code>perform</code>来表示执行这个指令。另外，<code>rem</code>操作并不是像其他运算那样的primitives，需要被转换成更底层的操作，如：
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rem-loop</span><br><span class="line">   (<span class="name">test</span> (<span class="name">op</span> &lt;) (<span class="name">reg</span> t) (<span class="name">reg</span> b))</span><br><span class="line">   (<span class="name">branch</span> (<span class="name">label</span> rem-done))</span><br><span class="line">   (<span class="name">assign</span> t (<span class="name">op</span> -) (<span class="name">reg</span> t) (<span class="name">reg</span> b))</span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> rem-loop))</span><br><span class="line"> rem-done</span><br></pre></td></tr></table></figure></p>
<p>不过这也并不那么重要，所以为了理解<code>gcd</code>先把它当作primitives看待也无妨。</p>
<h3>阶乘</h3>
<p>一个一拍大腿写成的计算$n!$的过程大概是这样的：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">1</span>)</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">factorial</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)) n)))</span><br></pre></td></tr></table></figure></p>
<p>对比<code>gcd</code>在发生递归时，新<code>gcd</code>过程的结果就是原来的<code>gcd</code>的结果，这类递归被称为尾递归（tail recursion），可以转换成迭代形式。在寄存器中不需要再原来的<code>gcd</code>中保留任何内容，直接进入新的<code>gcd</code>执行新的指令，不需要再执行任何上一层<code>gcd</code>遗留下来的任何指令。而<code>(factorial n)</code>则需要在计算完<code>(factorial (- n 1))</code>后把它的结果再返回到被调用的地方再乘<code>n</code>，因此需要维护在计算完成前需要维护原<code>factorial</code>的环境。那么在<code>n</code>减至1之前，所有<code>factorial</code>的环境都必须保留着，等着下一级调用传回的操作数与当前的<code>n</code>相乘。举个例子，简单的看一下计算$6!$需要的展开</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/factorial.png?inline=false" alt=""></p>
<p>除了需要显性的保存<code>n</code>的值，调用函数计算完成<code>(factorial n)</code>后的接下来的操作（有点类似我们上一篇提到的continuation）也是由上一级<code>factorial</code>决定的，最外层可以直接跳出回到其他程序，而第一次递归调用则需要返回最外层<code>factorial</code>发生乘法操作的位置……依次类推，存储计算完成后应该跳转的位置的寄存器<code>continue</code>也需要像<code>n</code>那样被保留。为了实现这一切，在控制器中需要再引入一个先进先出的栈，每当递归发生时，把<code>n</code>和<code>continue</code>寄存器的内容用<code>save</code>压入栈中，子函数计算完成后再从栈中用<code>restore</code>指令弹出恢复到相应的寄存器中。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">controller</span></span><br><span class="line">   (<span class="name">assign</span> continue (<span class="name">label</span> fact-done))     <span class="comment">; set up final return address</span></span><br><span class="line"> fact-loop</span><br><span class="line">   (<span class="name">test</span> (<span class="name">op</span> =) (<span class="name">reg</span> n) (<span class="name">const</span> <span class="number">1</span>))</span><br><span class="line">   (<span class="name">branch</span> (<span class="name">label</span> base-case))</span><br><span class="line">   <span class="comment">;; Set up for the recursive call by saving n and continue.</span></span><br><span class="line">   <span class="comment">;; Set up continue so that the computation will continue</span></span><br><span class="line">   <span class="comment">;; at after-fact when the subroutine returns.</span></span><br><span class="line">   (<span class="name">save</span> continue)</span><br><span class="line">   (<span class="name">save</span> n)</span><br><span class="line">   (<span class="name">assign</span> n (<span class="name">op</span> -) (<span class="name">reg</span> n) (<span class="name">const</span> <span class="number">1</span>))</span><br><span class="line">   (<span class="name">assign</span> continue (<span class="name">label</span> after-fact))</span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> fact-loop))</span><br><span class="line"> after-fact</span><br><span class="line">   (<span class="name">restore</span> n)</span><br><span class="line">   (<span class="name">restore</span> continue)</span><br><span class="line">   (<span class="name">assign</span> val (<span class="name">op</span> *) (<span class="name">reg</span> n) (<span class="name">reg</span> val))   <span class="comment">; val now contains n(n - 1)!</span></span><br><span class="line">   (<span class="name">goto</span> (<span class="name">reg</span> continue))                   <span class="comment">; return to caller</span></span><br><span class="line"> base-case</span><br><span class="line">   (<span class="name">assign</span> val (<span class="name">const</span> <span class="number">1</span>))                  <span class="comment">; base case: 1! = 1</span></span><br><span class="line">   (<span class="name">goto</span> (<span class="name">reg</span> continue))                   <span class="comment">; return to caller</span></span><br><span class="line"> fact-done)</span><br></pre></td></tr></table></figure></p>
<p>对应的数据通路图如下，不需要完全看懂数据通路，只是用于理解上述控制器发生了哪些操作的参考：
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/fact-data-path.png?inline=false" alt=""></p>
<p>注意到<code>n</code>和<code>continue</code>都是与同一个栈发生的数据交流，所以对这两个寄存器压栈和弹栈操作时需要注意两个寄存器之间的顺序，否则弹出的值会被放入错误的寄存器。这个问题在一些寄存机器的实现中是通过对每个变量都指定一个栈来解决的，但这里为了经济和效率考虑，只给整个机器分配了一个栈。</p>
<p>另外，我们其实都很清楚<code>(factorial n)</code>完全可以改写成尾递归形式：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> product counter)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> counter n)</span><br><span class="line">        product</span><br><span class="line">        (<span class="name">iter</span> (<span class="name"><span class="builtin-name">*</span></span> counter product)</span><br><span class="line">              (<span class="name"><span class="builtin-name">+</span></span> counter <span class="number">1</span>))))</span><br><span class="line">  (<span class="name">iter</span> <span class="number">1</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<p>这个版本的<code>factorial</code>转换成的寄存机器指令就不会需要额外的栈操作开销，这也是尾递归相比普通的树形递归（tree recursion）运行效率上的优越的根源。</p>
<h3>Fibonacci序列</h3>
<p>一个典型的求Fibonacci数的递归过程：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fib</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n <span class="number">2</span>)</span><br><span class="line">      n</span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">fib</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)) (<span class="name">fib</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">2</span>)))))</span><br></pre></td></tr></table></figure></p>
<p>相比前面写的那些递归过程，<code>(fib n)</code>在过程内还显式调用了两次<code>fib</code>，并把两次的返回结果进行了加法运算，但把它改写为寄存机器语言时，有了前面<code>factorial</code>使用栈的经验，<code>fib</code>也没有非常特殊的地方，无非是在<code>(fib n)</code>的两个关键节点：计算<code>(fib (- n 1))</code>前后和计算<code>(fib (- n 2)</code>前后分别需要压栈和弹栈的操作而已，而两次操作也是互相独立各不干扰的。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">controller</span></span><br><span class="line">   (<span class="name">assign</span> continue (<span class="name">label</span> fib-done))</span><br><span class="line"> fib-loop</span><br><span class="line">   (<span class="name">test</span> (<span class="name">op</span> &lt;) (<span class="name">reg</span> n) (<span class="name">const</span> <span class="number">2</span>))</span><br><span class="line">   (<span class="name">branch</span> (<span class="name">label</span> immediate-answer))</span><br><span class="line">   <span class="comment">;; set up to compute Fib(n-1)</span></span><br><span class="line">   (<span class="name">save</span> continue)</span><br><span class="line">   (<span class="name">assign</span> continue (<span class="name">label</span> afterfib-n-1))</span><br><span class="line">   (<span class="name">save</span> n)                           <span class="comment">; save old value of n</span></span><br><span class="line">   (<span class="name">assign</span> n (<span class="name">op</span> -) (<span class="name">reg</span> n) (<span class="name">const</span> <span class="number">1</span>))<span class="comment">; clobber n to n-1</span></span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> fib-loop))            <span class="comment">; perform recursive call</span></span><br><span class="line"> afterfib-n-1                         <span class="comment">; upon return, val contains Fib(n-1)</span></span><br><span class="line">   (<span class="name">restore</span> n)</span><br><span class="line">   (<span class="name">restore</span> continue)</span><br><span class="line">   <span class="comment">;; set up to compute Fib(n-2)</span></span><br><span class="line">   (<span class="name">assign</span> n (<span class="name">op</span> -) (<span class="name">reg</span> n) (<span class="name">const</span> <span class="number">2</span>))</span><br><span class="line">   (<span class="name">save</span> continue)</span><br><span class="line">   (<span class="name">assign</span> continue (<span class="name">label</span> afterfib-n-2))</span><br><span class="line">   (<span class="name">save</span> val)                         <span class="comment">; save Fib(n-1)</span></span><br><span class="line">   (<span class="name">goto</span> (<span class="name">label</span> fib-loop))</span><br><span class="line"> afterfib-n-2                         <span class="comment">; upon return, val contains Fib(n-2)</span></span><br><span class="line">   (<span class="name">assign</span> n (<span class="name">reg</span> val))               <span class="comment">; n now contains Fib(n-2)</span></span><br><span class="line">   (<span class="name">restore</span> val)                      <span class="comment">; val now contains Fib(n-1)</span></span><br><span class="line">   (<span class="name">restore</span> continue)</span><br><span class="line">   (<span class="name">assign</span> val                        <span class="comment">; Fib(n-1)+Fib(n-2)</span></span><br><span class="line">           (<span class="name">op</span> +) (<span class="name">reg</span> val) (<span class="name">reg</span> n))</span><br><span class="line">   (<span class="name">goto</span> (<span class="name">reg</span> continue))              <span class="comment">; return to caller, answer is in val</span></span><br><span class="line"> immediate-answer</span><br><span class="line">   (<span class="name">assign</span> val (<span class="name">reg</span> n))               <span class="comment">; base case: Fib(n)=n</span></span><br><span class="line">   (<span class="name">goto</span> (<span class="name">reg</span> continue))</span><br><span class="line"> fib-done)</span><br></pre></td></tr></table></figure></p>
<p>在每一个<code>(goto (label fib-loop))</code>即递归发生前，都会先把<code>n</code>和<code>continue</code>的内容压入栈内，并重新赋为接下来的递归调用需要用的<code>n</code>和<code>continue</code>值，<code>n-1</code>和<code>(label afterfib-n-1)</code>，或者<code>n-2</code>和<code>(label afterfib-n-2)</code>，当到达<code>afterfib-n-1</code>或<code>afterfib-n-2</code>时表示上一次调用已经完成了，计算结果被放在了<code>val</code>寄存器中，此时只要恢复<code>n</code>和<code>continue</code>的值就可以继续计算了。当然，<code>(fib (- n 1))</code>的值即当时的<code>val</code>需要被压入栈内，当<code>(fib (- n 2))</code>计算完成后<code>val</code>会被覆盖为<code>(fib (- n 2))</code>，此时需要从栈中取出当时存放的<code>val</code>放入<code>n</code>寄存器（在完成<code>(fib (- n 2))</code>的计算后<code>n</code>值已经没有保留的必要了，所以拿来当<code>(fib (-n 1))</code>的临时容器了），相加得到最终的<code>val</code>后返回到当前<code>fib</code>被调用的地方。</p>
<p>观察力敏锐的人可能已经注意到了，第14行的<code>(restore continue)</code>和第17行的<code>(save continue)</code>之间并没有任何关于<code>continue</code>的读写操作，只是单纯的把一个元素从栈中弹出来又压回去，虽然遵循了谨慎保存及时恢复上下文的原则，但仍然是冗余的操作，一般在编译时会利用窥孔优化（peephole optimization）技术移除。</p>
<h3>小结</h3>
<p>到此为止，我们通过一些例子熟悉了机器寄存语言的语法规则，也对程序的底层实现稍有了解。关于这部分内容的材料很多，原书5.1对此的阐述十分详尽，对于这些做法的必要性论述也很清晰，有兴趣的可以去认真阅读以下，因为内容太多但并不复杂也不难以理解所以我就不展开详细讲述了，只挑了一些对于寄存机器模型重要的例子和通用规则来演示，以方便下文侧重详谈如何用高级语言去模拟实现它。</p>
<p>另外，这部分资料和工具也很充足，比如公开课MIT 6.001&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;的<a href="https://www.bilibili.com/video/av8515129/?p=17" target="_blank" rel="noopener">Lec9b 寄存机器</a>部分lecture就细谈了这种语言的设计和使用。虽然这种语言这是被构造出来的DSL，但与汇编语言有很大的相似之处，如果没接触过汇编也在闲暇无聊想解压时试试小游戏<a href="https://tomorrowcorporation.com/humanresourcemachine" target="_blank" rel="noopener">human resource machine</a>&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，以简单的基于汇编风格的语言为基础的编程入门教学游戏，不涉及递归，但也大量涉及寄存器和分支跳转操作。</p>
<p>总之，了解它的必要性和基本语法后，好戏刚刚开始，让我们开始用Scheme来模拟实现它吧!</p>
<hr>
<h2>解释器设计细节</h2>
<p>为了体验和模拟寄存机器语言的使用，我们用Scheme来实现对它的解释。用高级语言去实现，模拟和解释这些指令固然是损耗效率的做法，但通过这种尝试不但可以理解这些指令本身的作用，也会对如何用Scheme来构造一种新的语言有更深的见解。</p>
<p>为了顺应思维习惯，我会调整一些原文给出的顺序。</p>
<h3>模拟机的目标</h3>
<p>对于外部用户，使用这个封装好的模拟寄存机器相关操作只需要通过以下命令：</p>
<ul>
<li><code>(make-machine &lt;register-names&gt; &lt;operations&gt; &lt;controller&gt;)</code> 以<code>&lt;register-names&gt;</code>为所用的寄存器列表，<code>&lt;operations&gt;</code>为操作列表，<code>&lt;controller&gt;</code>为需要模拟的指令控制器，构造一个新的寄存机器模型并返回。</li>
<li><code>(set-register-contents! &lt;machine-model&gt; &lt;register-name&gt; &lt;value&gt;)</code> 把寄存机器模型<code>&lt;machine-model&gt;</code>的寄存器<code>&lt;register-name&gt;</code>内容设置为<code>&lt;value&gt;</code>，通常用于模拟输入</li>
<li><code>(get-register-contents &lt;machine-model&gt; &lt;register-name&gt;)</code> 取出机器模型<code>&lt;machine-model&gt;</code>中的寄存器<code>&lt;register-name&gt;</code>的内容并返回，通常用于得到模拟结果</li>
<li><code>(start &lt;machine-model&gt;)</code> 开始机器模型<code>&lt;machine-model&gt;</code>的模拟，即开始执行指令</li>
</ul>
<p>以前面的<code>gcd</code>过程为例的<code>gcd-machine</code>构造如下：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> gcd-machine</span><br><span class="line">  (<span class="name">make-machine</span></span><br><span class="line">   '(a b t) <span class="comment">;registers list</span></span><br><span class="line">   (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'rem</span> remainder) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'=</span> =)) <span class="comment">;operations list</span></span><br><span class="line">   '(test-b ;controller</span><br><span class="line">       (test (op =) (reg b) (const <span class="number">0</span>))</span><br><span class="line">       (branch (label gcd-done))</span><br><span class="line">       (assign t (op rem) (reg a) (reg b))</span><br><span class="line">       (assign a (reg b))</span><br><span class="line">       (assign b (reg t))</span><br><span class="line">       (goto (label test-b))</span><br><span class="line">     gcd-done)))</span><br></pre></td></tr></table></figure></p>
<p><code>'(a b t)</code>是<code>gcd</code>用到的所有寄存器，<code>rem</code>运算符等对应Scheme原语<code>remainder</code>过程，<code>=</code>也对应操作符<code>=</code>，Controller部分即前面所使用的寄存语言描述的指令操作。用<code>gcd-machine</code>计算<code>gcd</code>需要先把输入<code>a</code>和<code>b</code>初始化，用<code>start</code>开始模拟过程后，从<code>a</code>寄存器得到最终结果。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-register-contents!</span> gcd-machine <span class="symbol">'a</span> <span class="number">206</span>)</span><br><span class="line"><span class="comment">;done</span></span><br><span class="line">(<span class="name">set-register-contents!</span> gcd-machine <span class="symbol">'b</span> <span class="number">40</span>)</span><br><span class="line"><span class="comment">;done</span></span><br><span class="line">(<span class="name">start</span> gcd-machine)</span><br><span class="line"><span class="comment">;done</span></span><br><span class="line">(<span class="name">get-register-contents</span> gcd-machine <span class="symbol">'a</span>)</span><br><span class="line"><span class="comment">;2</span></span><br></pre></td></tr></table></figure></p>
<p>接下来演示如何一步步实现机器模型的构造和使用。</p>
<h3>寄存器</h3>
<p>寄存器包含一个局部状态变量作为它的存放内容，可以通过get/set进行读写内容。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-register</span> name)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">contents</span> <span class="symbol">'*unassigned*</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> message)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'get</span>) contents)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'set</span>)</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (value) (<span class="name"><span class="builtin-name">set!</span></span> contents value)))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">             (<span class="name">error</span> <span class="string">"Unknown request -- REGISTER"</span> message))))</span><br><span class="line">    dispatch))</span><br></pre></td></tr></table></figure></p>
<p>典型的message passing风格的过程，返回一个<code>dispatch</code>函数，依照惯例用语法糖来包装这两种方法，使其更符合我们的编程习惯：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-contents</span> register)</span><br><span class="line">  (<span class="name">register</span> <span class="symbol">'get</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-contents!</span> register value)</span><br><span class="line">  ((<span class="name">register</span> <span class="symbol">'set</span>) value))</span><br></pre></td></tr></table></figure></p>
<p>仔细观察可以发现<code>make-register</code>的参数<code>name</code>在过程中没有被用到，可以不传入。寄存器的名字本来也是人为规定在，后面可以看到机器中的处理是把每个名字都都与<code>make-register</code>构造的新的寄存器绑定来实现对应寄存器的取用。</p>
<h3>栈</h3>
<p>栈是我们在其他语言里面经常实现的数据结构了，在Scheme中也是用<code>(make-stack)</code>构造返回一个新的栈对象。这里是用一个局部状态变量list来表示栈所使用的空间，它的第一个元素<code>car</code>就是栈顶，初始化为空列表。在用<code>pop</code>弹出元素时需要注意检查是否为空。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-stack</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">s</span> '()))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">push</span> x)</span><br><span class="line">      (<span class="name"><span class="builtin-name">set!</span></span> s (<span class="name"><span class="builtin-name">cons</span></span> x s)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">pop</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> s)</span><br><span class="line">          (<span class="name">error</span> <span class="string">"Empty stack -- POP"</span>)</span><br><span class="line">          (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">top</span> (<span class="name"><span class="builtin-name">car</span></span> s)))</span><br><span class="line">            (<span class="name"><span class="builtin-name">set!</span></span> s (<span class="name"><span class="builtin-name">cdr</span></span> s))</span><br><span class="line">            top)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">initialize</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">set!</span></span> s '())</span><br><span class="line">      <span class="symbol">'done</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> message)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'push</span>) push)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'pop</span>) (<span class="name">pop</span>))</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'initialize</span>) (<span class="name">initialize</span>))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Unknown request -- STACK"</span></span><br><span class="line">                         message))))</span><br><span class="line">    dispatch))</span><br></pre></td></tr></table></figure></p>
<p>封装为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">pop</span> stack)</span><br><span class="line">  (<span class="name">stack</span> <span class="symbol">'pop</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">push</span> stack value)</span><br><span class="line">  ((<span class="name">stack</span> <span class="symbol">'push</span>) value))</span><br></pre></td></tr></table></figure></p>
<h3>机器框架</h3>
<p>一个新的寄存机器除了需要前面提到的寄存器列表，操作列表，控制器文本以外，内部还会需要一些数据结构来推进指令操作的进行。</p>
<p>首先需要两个辅助寄存器：</p>
<ul>
<li><code>flag</code>：保存测试操作的结果（<code>true</code>或<code>false</code>），用以决定跳转到接下来遇到的分支语句<code>branch</code>是否跳转</li>
<li><code>pc</code>: 即program counter指针，用于保存下一步需要进行的指令操作</li>
</ul>
<p>以及前面提到需要管理递归使用的栈<code>stack</code>。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-new-machine</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">pc</span> (<span class="name">make-register</span> <span class="symbol">'pc</span>))</span><br><span class="line">        (<span class="name">flag</span> (<span class="name">make-register</span> <span class="symbol">'flag</span>))</span><br><span class="line">        (<span class="name">stack</span> (<span class="name">make-stack</span>))</span><br><span class="line">        (<span class="name">the-instruction-sequence</span> '()))</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">the-ops</span></span><br><span class="line">           (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'initialize-stack</span></span><br><span class="line">                       (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">stack</span> <span class="symbol">'initialize</span>)))))</span><br><span class="line">          (<span class="name">register-table</span></span><br><span class="line">           (<span class="name"><span class="builtin-name">list</span></span> (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'pc</span> pc) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'flag</span> flag))))</span><br><span class="line"></span><br><span class="line">      (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">allocate-register</span> name)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">assoc</span></span> name register-table)</span><br><span class="line">            (<span class="name">error</span> <span class="string">"Multiply defined register: "</span> name)</span><br><span class="line">            (<span class="name"><span class="builtin-name">set!</span></span> register-table</span><br><span class="line">                  (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">list</span></span> name (<span class="name">make-register</span> name))</span><br><span class="line">                        register-table)))</span><br><span class="line">        <span class="symbol">'register-allocated</span>)</span><br><span class="line"></span><br><span class="line">      (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lookup-register</span> name)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">val</span> (<span class="name"><span class="builtin-name">assoc</span></span> name register-table)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">if</span></span> val</span><br><span class="line">              (<span class="name"><span class="builtin-name">cadr</span></span> val)</span><br><span class="line">              (<span class="name">error</span> <span class="string">"Unknown register:"</span> name))))</span><br><span class="line"></span><br><span class="line">      (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">execute</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">insts</span> (<span class="name">get-contents</span> pc)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> insts)</span><br><span class="line">              <span class="symbol">'done</span></span><br><span class="line">              (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">                ((<span class="name">instruction-execution-proc</span> (<span class="name"><span class="builtin-name">car</span></span> insts)))</span><br><span class="line">                (<span class="name">execute</span>)))))</span><br><span class="line"></span><br><span class="line">      (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> message)</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'start</span>)</span><br><span class="line">               (<span class="name">set-contents!</span> pc the-instruction-sequence)</span><br><span class="line">               (<span class="name">execute</span>))</span><br><span class="line">              ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'install-instruction-sequence</span>)</span><br><span class="line">               (<span class="name"><span class="builtin-name">lambda</span></span> (seq) (<span class="name"><span class="builtin-name">set!</span></span> the-instruction-sequence seq)))</span><br><span class="line">              ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'allocate-register</span>) allocate-register)</span><br><span class="line">              ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'get-register</span>) lookup-register)</span><br><span class="line">              ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'install-operations</span>)</span><br><span class="line">               (<span class="name"><span class="builtin-name">lambda</span></span> (ops) (<span class="name"><span class="builtin-name">set!</span></span> the-ops (<span class="name"><span class="builtin-name">append</span></span> the-ops ops))))</span><br><span class="line">              ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'stack</span>) stack)</span><br><span class="line">              ((<span class="name"><span class="builtin-name">eq?</span></span> message <span class="symbol">'operations</span>) the-ops)</span><br><span class="line">              (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Unknown request -- MACHINE"</span> message))))</span><br><span class="line"></span><br><span class="line">      dispatch)))</span><br></pre></td></tr></table></figure></p>
<p>加载寄存器列表时会调用<code>allocate-register</code>给每个寄存器名字构造一个新的寄存器，被把这对绑定放进<code>register-table</code>，用户可以在外部通过调用<code>'get-register</code>获取相应的寄存器。</p>
<p>机器运行开始的则调用<code>(execute)</code>过程，首先取出<code>pc</code>指向的内容即下一步需要执行的，<strong>完成汇编的</strong> 指令，它由原始的指令文本和经过汇编分析得到的该指令实际需要调用的操作过程组成，这个过程函数被称为指令执行过程（instruction execution procedure），即<a href="#instruction-execution-proc"><code>instruction-execution-proc</code></a>部分，它们内部会包含对<code>pc</code>内容的改变（指令的继续或跳转），所以<code>(execute)</code>的递归调用对于正确的寄存机器语言保证能使得<code>pc</code>指向空内容从而终止。而怎样完成汇编会在之后的内容中看到。</p>
<p>对机器提供的方法的封装：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">start</span> machine)</span><br><span class="line">  (<span class="name">machine</span> <span class="symbol">'start</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-register-contents</span> machine register-name)</span><br><span class="line">  (<span class="name">get-contents</span> (<span class="name">get-register</span> machine register-name)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-register-contents!</span> machine register-name value)</span><br><span class="line">  (<span class="name">set-contents!</span> (<span class="name">get-register</span> machine register-name) value)</span><br><span class="line">  <span class="symbol">'done</span>)</span><br></pre></td></tr></table></figure></p>
<p>另外为了更方便的得到机器中的寄存器，可以定义
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-register</span> machine reg-name)</span><br><span class="line">  ((<span class="name">machine</span> <span class="symbol">'get-register</span>) reg-name))</span><br></pre></td></tr></table></figure></p>
<p>利用<code>(make-new-machine)</code>得到的未初始化的新的寄存机器，通过编写特定的寄存机器语言程序得到特定的寄存机器，即<a href="#%E6%A8%A1%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%AE%E6%A0%87">最终目标</a>所提及的<code>make-machine</code></p>
<p>&lt;a name=&quot;instantiate&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-machine</span> register-names ops controller-text)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">machine</span> (<span class="name">make-new-machine</span>)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">for-each</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (register-name)</span><br><span class="line">                ((<span class="name">machine</span> <span class="symbol">'allocate-register</span>) register-name))</span><br><span class="line">              register-names)</span><br><span class="line">    ((<span class="name">machine</span> <span class="symbol">'install-operations</span>) ops)    </span><br><span class="line">    ((<span class="name">machine</span> <span class="symbol">'install-instruction-sequence</span>)</span><br><span class="line">     (<span class="name">assemble</span> controller-text machine))</span><br><span class="line">    machine))</span><br></pre></td></tr></table></figure></p>
<p>实例化机器模型时，先构造一个新的机器模型，再初始化这个机器中的寄存器列表和操作符列表，当然最关键的是需要对这些控制器指令文本进行汇编，转换为带有可执行的过程的列表，载入机器的指令序列列表，最后返回机器模型。</p>
<h3>生成指令执行过程</h3>
<p>关于<code>assemble</code>具体做了什么先暂时放着，先来理解汇编过程中最基础的操作，如何把原始的指令转文本转换成可以直接执行的过程。</p>
<p>与在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%25_sec_4.1.7" target="_blank" rel="noopener">Separating Syntactic Analysis from Execution</a>实现的分析器相似，<code>make-execution-procedure</code>承担的也是把某个原始指令文本<code>inst</code>预先“翻译”成目标语言可执行的过程并返回，需要执行这个指令时，直接调用对应零参过程即可。当然，这些<code>inst</code>会涉及一系列对于寄存器，栈，操作符的读写，以及它们所在的机器模型本身，所以都要作为参数传入。另外，<code>labels</code>是一个存放<code>label</code>与其对应位置开始的指令序列的表，用于快速找到需要跳转的位置，获得<code>labels</code>表是在汇编期间完成的，这里先假设已经得到了这个表可以直接使用，后面再详谈获得的过程。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-execution-procedure</span> inst labels machine</span><br><span class="line">                                  pc flag stack ops)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'assign</span>)</span><br><span class="line">         (<span class="name">make-assign</span> inst machine labels ops pc))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'test</span>)</span><br><span class="line">         (<span class="name">make-test</span> inst machine labels ops flag pc))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'branch</span>)</span><br><span class="line">         (<span class="name">make-branch</span> inst machine labels flag pc))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'goto</span>)</span><br><span class="line">         (<span class="name">make-goto</span> inst machine labels pc))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'save</span>)</span><br><span class="line">         (<span class="name">make-save</span> inst machine stack pc))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'restore</span>)</span><br><span class="line">         (<span class="name">make-restore</span> inst machine stack pc))</span><br><span class="line">        ((<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> inst) <span class="symbol">'perform</span>)</span><br><span class="line">         (<span class="name">make-perform</span> inst machine labels ops pc))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Unknown instruction type -- ASSEMBLE"</span></span><br><span class="line">                     inst))))</span><br></pre></td></tr></table></figure></p>
<p>类似于以前写过的<code>eval</code>，按照指令的类型进行不同的解释，这里没有把predicate封装成过程而是直接检查列表第一个元素，得到对应的分类。指令操作涉及的内存操作也是不同的，所以并必要把所有<code>make-execution-procedure</code>的参数全数传入，按照需求取用就已经足够了。那么开始看<code>cond</code>语句中每一个类型对应的做法吧。</p>
<h4>assign</h4>
<p>赋值操作会先找到需要被赋值的寄存器<code>target</code>，再计算被赋的值是一个操作结果还是原语表达式（如<code>reg</code>表达式或常数或<code>label</code>等），最后返回一个把<code>target</code>赋值为该结果并把令<code>pc</code>指向下一个指令的零参过程。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-assign</span> inst machine labels operations pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">target</span></span><br><span class="line">         (<span class="name">get-register</span> machine (<span class="name">assign-reg-name</span> inst)))</span><br><span class="line">        (<span class="name">value-exp</span> (<span class="name">assign-value-exp</span> inst)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">value-proc</span></span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">operation-exp?</span> value-exp)</span><br><span class="line">               (<span class="name">make-operation-exp</span></span><br><span class="line">                value-exp machine labels operations)</span><br><span class="line">               (<span class="name">make-primitive-exp</span></span><br><span class="line">                (<span class="name"><span class="builtin-name">car</span></span> value-exp) machine labels))))</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> ()                <span class="comment">; execution procedure for assign</span></span><br><span class="line">        (<span class="name">set-contents!</span> target (<span class="name">value-proc</span>))</span><br><span class="line">        (<span class="name">advance-pc</span> pc)))))</span><br></pre></td></tr></table></figure></p>
<p>注意这里在lambda表达式内用的是<code>(value-proc)</code>，因为<code>value-proc</code>无论是<code>make-operation-exp</code>还是<code>make-primitive-exp</code>的返回结果也都和<code>make-assign</code>一样是一个零参的过程。</p>
<p>分割<code>assign</code>指令文本需要的选择器（selector）为：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">assign-reg-name</span> assign-instruction)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cadr</span></span> assign-instruction))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">assign-value-exp</span> assign-instruction)</span><br><span class="line">  (<span class="name">cddr</span> assign-instruction))</span><br></pre></td></tr></table></figure></p>
<p>令<code>pc</code>指向下一个指令的过程<code>advance-pc</code>定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">advance-pc</span> pc)</span><br><span class="line">  (<span class="name">set-contents!</span> pc (<span class="name"><span class="builtin-name">cdr</span></span> (<span class="name">get-contents</span> pc))))</span><br></pre></td></tr></table></figure></p>
<p>除了<code>branch</code>和<code>goto</code>指令外，<code>advance-pc</code>是所有操作的一般结尾。</p>
<h4>test</h4>
<p>处理<code>test</code>指令的<code>make-test</code>过程与上面的<code>make-assign</code>过程相似，计算其条件部分操作的结果并存放到<code>flag</code>寄存器，然后让<code>pc</code>指向下一个指令</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-test</span> inst machine labels operations flag pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">condition</span> (<span class="name">test-condition</span> inst)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">operation-exp?</span> condition)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">condition-proc</span></span><br><span class="line">               (<span class="name">make-operation-exp</span></span><br><span class="line">                condition machine labels operations)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">            (<span class="name">set-contents!</span> flag (<span class="name">condition-proc</span>))</span><br><span class="line">            (<span class="name">advance-pc</span> pc)))</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Bad TEST instruction -- ASSEMBLE"</span> inst))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">test-condition</span> test-instruction)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cdr</span></span> test-instruction))</span><br></pre></td></tr></table></figure></p>
<h4>branch</h4>
<p>跟随着<code>test</code>指令而来的<code>branch</code>指令表示测试成功应该跳到哪个位置。<code>make-branch</code>先获得<code>branch</code>的跳转目标<code>dest</code>，并从<code>labels</code>表中获取这个标签对应的指令序列<code>insts</code>，当<code>flag</code>寄存器的内容为真时，跳转到<code>dest</code>即把 <code>pc</code>置为<code>insts</code>，否则推进到当前指令的下一个指令。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-branch</span> inst machine labels flag pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">dest</span> (<span class="name">branch-dest</span> inst)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">label-exp?</span> dest)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">insts</span></span><br><span class="line">               (<span class="name">lookup-label</span> labels (<span class="name">label-exp-label</span> dest))))</span><br><span class="line">          (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">get-contents</span> flag)</span><br><span class="line">                (<span class="name">set-contents!</span> pc insts)</span><br><span class="line">                (<span class="name">advance-pc</span> pc))))</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Bad BRANCH instruction -- ASSEMBLE"</span> inst))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">branch-dest</span> branch-instruction)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cadr</span></span> branch-instruction))</span><br></pre></td></tr></table></figure></p>
<p>注意到对<code>dest</code>会先检查是否为<code>label</code>，所以我们的解释程序只能对在<code>branch</code>指令直接给出的<code>label</code>值做出正确的处理，如果用寄存器内容表达它就可能出问题，而这个局限在<code>goto</code>指令上就不存在。</p>
<h4>goto</h4>
<p><code>goto</code>是无条件跳转指令，不需要检查<code>flag</code>的内容。对于其跳转目标<code>dest</code>可以是寄存器内容也可以是<code>label</code>表达式，从寄存器内容中可以直接读出<code>label</code>表达式，再找到<code>labels</code>表中对应的指令序列<code>insts</code>，把<code>pc</code>内容设置为<code>insts</code></p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-goto</span> inst machine labels pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">dest</span> (<span class="name">goto-dest</span> inst)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">label-exp?</span> dest)</span><br><span class="line">           (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">insts</span></span><br><span class="line">                  (<span class="name">lookup-label</span> labels</span><br><span class="line">                                (<span class="name">label-exp-label</span> dest))))</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">set-contents!</span> pc insts))))</span><br><span class="line">          ((<span class="name">register-exp?</span> dest)</span><br><span class="line">           (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">reg</span></span><br><span class="line">                  (<span class="name">get-register</span> machine</span><br><span class="line">                                (<span class="name">register-exp-reg</span> dest))))</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">               (<span class="name">set-contents!</span> pc (<span class="name">get-contents</span> reg)))))</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Bad GOTO instruction -- ASSEMBLE"</span></span><br><span class="line">                       inst)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">goto-dest</span> goto-instruction)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cadr</span></span> goto-instruction))</span><br></pre></td></tr></table></figure></p>
<h4>栈操作</h4>
<p><code>save</code>和<code>restore</code>分别执行压栈和弹栈操作，获取指令中的寄存器后，用<a href="#%E6%A0%88">前文</a>封装的<code>push</code>和<code>pop</code>过程即可。最后不要忘记把<code>pc</code>指向下一个指令。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-save</span> inst machine stack pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">reg</span> (<span class="name">get-register</span> machine</span><br><span class="line">                           (<span class="name">stack-inst-reg-name</span> inst))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">      (<span class="name">push</span> stack (<span class="name">get-contents</span> reg))</span><br><span class="line">      (<span class="name">advance-pc</span> pc))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-restore</span> inst machine stack pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">reg</span> (<span class="name">get-register</span> machine</span><br><span class="line">                           (<span class="name">stack-inst-reg-name</span> inst))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">      (<span class="name">set-contents!</span> reg (<span class="name">pop</span> stack))    </span><br><span class="line">      (<span class="name">advance-pc</span> pc))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">stack-inst-reg-name</span> stack-instruction)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cadr</span></span> stack-instruction))</span><br></pre></td></tr></table></figure></p>
<h4>perform</h4>
<p><code>perform</code>指令要求执行某个操作但不需要把结果返回给任何寄存器，一般只是想要这个操作的副作用（side effect）。<code>make-perform</code>只需要把指令的操作表达式部分对应的过程调用一次，然后推进<code>pc</code>即可。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-perform</span> inst machine labels operations pc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">action</span> (<span class="name">perform-action</span> inst)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">operation-exp?</span> action)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">action-proc</span></span><br><span class="line">               (<span class="name">make-operation-exp</span></span><br><span class="line">                action machine labels operations)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">            (<span class="name">action-proc</span>)</span><br><span class="line">            (<span class="name">advance-pc</span> pc)))</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Bad PERFORM instruction -- ASSEMBLE"</span> inst))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">perform-action</span> inst) (<span class="name"><span class="builtin-name">cdr</span></span> inst))</span><br></pre></td></tr></table></figure></p>
<h4>子表达式</h4>
<p>指令内含有一些需要计算的子表达式，通过相应的过程也可以生成这些子表达式对应的执行过程，也是形容上面几个过程返回的零参过程。你可能会疑惑为什么不直接返回这些自表达式的计算结果而要返回一个延迟对象呢？比如<code>label</code>表达式，在指令序列没有被汇编完成时，<code>labels</code>表是不完整的，而提取生成<code>labels</code>表的过程又是和生成指令执行过程的过程是同时交替进行的；另外，寄存器的内容会在执行指令时实时更新，无法一劳永逸的固定它的读取结果。所以需要把这些子表达式的求值相应的作出延迟，让它们在真正开始执行指令模拟时才被计算，这样才能保证得到准确的结果。</p>
<p><code>reg</code>,<code>label</code>,<code>const</code>表达式会被用于赋值给寄存器或作为操作的输入，但不涉及运算操作，用来生成执行过程的<code>make-primitive-exp</code>如下：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-primitive-exp</span> exp machine labels)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">constant-exp?</span> exp)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">c</span> (<span class="name">constant-exp-value</span> exp)))</span><br><span class="line">           (<span class="name"><span class="builtin-name">lambda</span></span> () c)))</span><br><span class="line">        ((<span class="name">label-exp?</span> exp)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">insts</span></span><br><span class="line">                (<span class="name">lookup-label</span> labels</span><br><span class="line">                              (<span class="name">label-exp-label</span> exp))))</span><br><span class="line">           (<span class="name"><span class="builtin-name">lambda</span></span> () insts)))</span><br><span class="line">        ((<span class="name">register-exp?</span> exp)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">r</span> (<span class="name">get-register</span> machine</span><br><span class="line">                                (<span class="name">register-exp-reg</span> exp))))</span><br><span class="line">           (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">get-contents</span> r))))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">         (<span class="name">error</span> <span class="string">"Unknown expression type -- ASSEMBLE"</span> exp))))</span><br></pre></td></tr></table></figure></p>
<p>选择器语法：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">register-exp?</span> exp) (<span class="name">tagged-list?</span> exp <span class="symbol">'reg</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">register-exp-reg</span> exp) (<span class="name"><span class="builtin-name">cadr</span></span> exp))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">constant-exp?</span> exp) (<span class="name">tagged-list?</span> exp <span class="symbol">'const</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">constant-exp-value</span> exp) (<span class="name"><span class="builtin-name">cadr</span></span> exp))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">label-exp?</span> exp) (<span class="name">tagged-list?</span> exp <span class="symbol">'label</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">label-exp-label</span> exp) (<span class="name"><span class="builtin-name">cadr</span></span> exp))</span><br></pre></td></tr></table></figure></p>
<p>而<code>assign</code>，<code>test</code>，<code>perform</code>会包含一些<code>operations</code>表规定的机器操作，用<code>make-operation-exp</code>生成可执行过程为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-operation-exp</span> exp machine labels operations)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">op</span> (<span class="name">lookup-prim</span> (<span class="name">operation-exp-op</span> exp) operations))</span><br><span class="line">        (<span class="name">aprocs</span></span><br><span class="line">         (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (e)</span><br><span class="line">                (<span class="name">make-primitive-exp</span> e machine labels))</span><br><span class="line">              (<span class="name">operation-exp-operands</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">      (<span class="name"><span class="builtin-name">apply</span></span> op (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (p) (<span class="name">p</span>)) aprocs)))))</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里默认了操作数的输入必须是可以用<code>make-primitive-exp</code>生成执行过程的简单子表达式，即<code>reg</code>,<code>label</code>,<code>const</code>表达式。最终需要返回的执行过程中，得到这些输入值后用对应的操作符调用它们，返回操作结果。</p>
<p><code>op</code>指令相关的操作语法对照：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">operation-exp?</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">pair?</span></span> exp) (<span class="name">tagged-list?</span> (<span class="name"><span class="builtin-name">car</span></span> exp) <span class="symbol">'op</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">operation-exp-op</span> operation-exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cadr</span></span> (<span class="name"><span class="builtin-name">car</span></span> operation-exp)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">operation-exp-operands</span> operation-exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cdr</span></span> operation-exp))</span><br></pre></td></tr></table></figure></p>
<p>在<code>operations</code>表中查找操作符对应的函数过程用到的<code>lookup-prim</code>函数定义：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lookup-prim</span> symbol operations)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">val</span> (<span class="name"><span class="builtin-name">assoc</span></span> symbol operations)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> val</span><br><span class="line">        (<span class="name"><span class="builtin-name">cadr</span></span> val)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Unknown operation -- ASSEMBLE"</span> symbol))))</span><br></pre></td></tr></table></figure></p>
<p>注意以上所有子表达式生成的执行过程都不包含对<code>pc</code>的操作，计算子表达式只需要返回结果给它被调用的指令执行过程，而重置<code>pc</code>应该是由这些完整的指令执行过程来完成的。</p>
<h3>汇编器</h3>
<p>汇编器（assembler）真正的把机器的控制器表达式转换为指令执行过程列表，也是由它来调用<code>make-execution-procedure</code>进行所谓的对指令的解释。</p>
<p>每一条控制器文本指令<code>text</code>都会被转换成一个序对（pair），这个序对结构为<code>instruction</code>，第一部分是原始文本<code>text</code>，第二部分是真正会被执行的对应过程。</p>
<p>&lt;a name=&quot;instruction-execution-proc&quot;&gt;&lt;/a&gt;
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-instruction</span> text)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> text '()))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">instruction-text</span> inst)</span><br><span class="line">  (<span class="name"><span class="builtin-name">car</span></span> inst))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">instruction-execution-proc</span> inst)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cdr</span></span> inst))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-instruction-execution-proc!</span> inst proc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-cdr!</span></span> inst proc))</span><br></pre></td></tr></table></figure></p>
<p>假设我们已经分离得到了控制器文本中的所有指令<code>instruction</code>结构（但<code>instruction-execution-proc</code>部分为空，还未被初始化）的<code>insts</code>和标签列表<code>labels</code>，那么初始化<code>insts</code>获取每个指令对应的指令执行过程并放到它的<code>instruction-execution-proc</code>中需要用到的<code>update-insts!</code>可以写为：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">update-insts!</span> insts labels machine)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">pc</span> (<span class="name">get-register</span> machine <span class="symbol">'pc</span>))</span><br><span class="line">        (<span class="name">flag</span> (<span class="name">get-register</span> machine <span class="symbol">'flag</span>))</span><br><span class="line">        (<span class="name">stack</span> (<span class="name">machine</span> <span class="symbol">'stack</span>))</span><br><span class="line">        (<span class="name">ops</span> (<span class="name">machine</span> <span class="symbol">'operations</span>)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">for-each</span></span></span><br><span class="line">     (<span class="name"><span class="builtin-name">lambda</span></span> (inst)</span><br><span class="line">       (<span class="name">set-instruction-execution-proc!</span></span><br><span class="line">        inst</span><br><span class="line">        (<span class="name">make-execution-procedure</span></span><br><span class="line">         (<span class="name">instruction-text</span> inst) labels machine</span><br><span class="line">         pc flag stack ops)))</span><br><span class="line">     insts)))</span><br></pre></td></tr></table></figure></p>
<p>而分离文本中的指令和标签则需要扫描一遍整个文本列表，如果被扫描到的是标签（通过<code>symbol?</code>检查）则用<code>make-label-entry</code>把这个标签的名字和接下来所有指令列表组成一条记录添加到<code>labels</code>表并保持指令列表不变</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-label-entry</span> label-name insts)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> label-name insts))</span><br></pre></td></tr></table></figure></p>
<p>如果被扫描到的是操作指令，则保持<code>labels</code>表不变，用<code>make-instruction</code>新建一个<a href="instruction-execution-proc"><code>instruction</code></a>记录并添加到指令列表。</p>
<p>整个过程<code>extract-labels</code>定义如下</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">extract-labels</span> text receive)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> text)</span><br><span class="line">      (<span class="name">receive</span> '() '())</span><br><span class="line">      (<span class="name">extract-labels</span> (<span class="name"><span class="builtin-name">cdr</span></span> text)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (insts labels)</span><br><span class="line">         (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next-inst</span> (<span class="name"><span class="builtin-name">car</span></span> text)))</span><br><span class="line">           (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">symbol?</span></span> next-inst)</span><br><span class="line">               (<span class="name">receive</span> insts</span><br><span class="line">                        (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-label-entry</span> next-inst</span><br><span class="line">                                                insts)</span><br><span class="line">                              labels))</span><br><span class="line">               (<span class="name">receive</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-instruction</span> next-inst)</span><br><span class="line">                              insts)</span><br><span class="line">                        labels)))))))</span><br></pre></td></tr></table></figure></p>
<p><code>receive</code>函数的作用有些类似于在前篇<a href="http://notebook.xyli.me/SICP/continuations-for-nondeterministic-evaluator/">用continuation实现非确定计算</a>使用的continuation函数相似，每处理一条控制器文本（<code>next-inst</code>）就重新构造一个<code>receive</code>，把<code>next-inst</code>的处理结果累积到新的<code>receive</code>，当扫描到最后即<code>text</code>为空时，传递到这里的<code>receive</code>已经包含了前面所有文本的处理结果，调用这个被层层构造累加的<code>receive '() '()</code>相当于直接用原始的<code>receive</code>来调用处理构造完成的<code>insts</code>和<code>labels</code>列表。那么完整的汇编过程<code>assemble</code>为</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">assemble</span> controller-text machine)</span><br><span class="line">  (<span class="name">extract-labels</span> controller-text</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (insts labels)</span><br><span class="line">      (<span class="name">update-insts!</span> insts labels machine)</span><br><span class="line">      insts)))</span><br></pre></td></tr></table></figure></p>
<p>调用<code>assemble</code>结束后，返回经过<code>ipdate-insts!</code>给每个指令分配好相应的指令执行过程的指令列表<code>insts</code>，在<a href="#instantiate">实例化机器</a>时，把整个<code>insts</code>放入机器的指令序列<code>the-instruction-sequence</code>，在开始运行机器时，<code>pc</code>的内容为<code>the-instruction-sequence</code>。</p>
<blockquote>
<h4><i class="fa fa-exclamation-circle"></i> 注意！</h4>
<p>如果觉得用<code>receive</code>函数来接受累计的处理结果这种编程技巧并不优雅，或者不够直观难以理解，也可以用更直接的方式改写：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">extract-labels</span> text)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> text)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> '() '())</span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">result</span> (<span class="name">extract-labels</span> (<span class="name"><span class="builtin-name">cdr</span></span> text))))</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">insts</span> (<span class="name"><span class="builtin-name">car</span></span> result)) (<span class="name">labels</span> (<span class="name"><span class="builtin-name">cdr</span></span> result)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">next-inst</span> (<span class="name"><span class="builtin-name">car</span></span> text)))</span><br><span class="line">            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">symbol?</span></span> next-inst)</span><br><span class="line">                (<span class="name"><span class="builtin-name">cons</span></span> insts</span><br><span class="line">                      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-label-entry</span> next-inst insts) labels))</span><br><span class="line">                (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-instruction</span> next-inst) insts)</span><br><span class="line">                      labels)))))))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>相应的
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">assemble</span> controller-text machine)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">result</span> (<span class="name">extract-labels</span> controller-text)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">insts</span> (<span class="name"><span class="builtin-name">car</span></span> result)) (<span class="name">labels</span> (<span class="name"><span class="builtin-name">cdr</span></span> result)))</span><br><span class="line">      (<span class="name">update-insts!</span> insts labels machine)</span><br><span class="line">      insts)))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2>总结</h2>
<p>至此，用Scheme模拟解释寄存机器语言已经完成了。通过这样编写程序来模拟更简单的寄存机器模型，可以观察我们的平时所写的程序在更底层的视角上是如何被机器理解的。除此之外，可以在此基础上修改我们模拟实现的细节，比如安置探针监测栈、寄存器的使用情况，增加指令的执行计数，可以更方便的监测寄存机器程序运行的性能，相关内容也可以见<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-32.html#%25_sec_5.2.4" target="_blank" rel="noopener">5.2.4  Monitoring Machine Performance</a>的示例和讨论，我就不展开详细解读了。本文的重点还是放在怎样来实现寄存机器语言的模拟解释实现，希望大家能理解寄存机器模型并对怎样由一种语言构造另一种有新的感悟。谢谢阅读！
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;原课程材料可以在mit ocw找到，这里为了方便读者观看，直接链接到B站汉化版，真诚感谢&lt;a href=&quot;https://github.com/DeathKing/Learning-SICP&quot;&gt;Learning-SICP 项目团队&lt;/a&gt;为此做出的贡献。&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;在Steam, Google Pay, App Store等平台上均有正版发售，定价大约$5，鼓励有消费余力者支持一下开发团队。这类游戏的定位似乎是针对儿童的亲子娱乐/益智教学/编程启蒙，我个人阴差阳错在朋友推荐下接触了它，感觉确实是很不错的幼儿编程启蒙游戏，考虑到我本人在以后的人生中几乎必然找不到对象，也没有孩子，就没去细究应该怎么用于幼儿编程教学，恬不知耻的自己玩上了。&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/the-structure-and-interpretation-of-register-machine/" data-id="cjuh9jxbp005yfww3fox13bmk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-113" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-113/">LeetCode Weekly Contest 113</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-113/" class="article-date"><time datetime="2018-12-02T11:29:07.049Z" itemprop="datePublished">2018-12-02</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-113</p>
<p>&lt;!-- more --&gt;</p>
<h2>Largest Time for Given Digits</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-113/problems/largest-time-for-given-digits/</p>
<blockquote>
<p>Given an array of 4 digits, return the largest 24 hour time that can be made.</p>
</blockquote>
<blockquote>
<p>The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, a time is larger if more time has elapsed since midnight.</p>
</blockquote>
<blockquote>
<p>Return the answer as a string of length 5.  If no valid time can be made, return an empty string.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: &quot;23:41&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,5]</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A.length == 4</code></li>
<li><code>0 &lt;= A[i] &lt;= 9</code></li>
</ol>
<p>一开始我是想每位取限制下的最大值，如果没有可选的数字则回溯bfs，后来感觉不需要那么麻烦，一共只有4位，穷举找符合要求的排列中数值最大的就可以了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestTimeFromDigits</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> A]</span><br><span class="line">        times = [a + b + c + d <span class="keyword">for</span> (a, b, c, d) <span class="keyword">in</span> itertools.permutations(A)</span><br><span class="line">                 <span class="keyword">if</span> int(a + b) &lt; <span class="number">24</span> <span class="keyword">and</span> int(c + d) &lt; <span class="number">60</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> times:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        res = max(times, key=int)</span><br><span class="line">        <span class="keyword">return</span> res[:<span class="number">2</span>] + <span class="string">':'</span> + res[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure></p>
<h2>Flip Equivalent Binary Trees</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-113/problems/flip-equivalent-binary-trees/</p>
<blockquote>
<p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
</blockquote>
<blockquote>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
</blockquote>
<blockquote>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes <code>root1</code> and <code>root2</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We flipped at nodes with values 1, 3, and 5.</span><br><span class="line">Flipped Trees Diagram</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Each tree will have at most <code>100</code> nodes.</li>
<li>Each value in each tree will be a unique integer in the range <code>[0, 99]</code>.</li>
</ol>
<p>当<code>root1</code>和<code>root2</code>的左右子树都分别相同或可以通过一次翻转相同时，两棵树相同，所以这又是一个递归问题。当然有个基础条件是两个根结点的值相同（包括都为空结点）。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipEquiv</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root1 <span class="keyword">and</span> root2:</span><br><span class="line">            <span class="keyword">if</span> root1.val == root2.val:</span><br><span class="line">                <span class="keyword">return</span> (self.flipEquiv(root1.left, root2.left) <span class="keyword">and</span> self.flipEquiv(root1.right, root2.right)) <span class="keyword">or</span> (self.flipEquiv(root1.left, root2.right) <span class="keyword">and</span> self.flipEquiv(root1.right, root2.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2>Reveal Cards In Increasing Order</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-113/problems/reveal-cards-in-increasing-order/</p>
<blockquote>
<p>In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.</p>
</blockquote>
<blockquote>
<p>Initially, all the cards start face down (unrevealed) in one deck.</p>
</blockquote>
<blockquote>
<p>Now, you do the following steps repeatedly, until all cards are revealed:</p>
</blockquote>
<ol>
<li>Take the top card of the deck, reveal it, and take it out of the deck.</li>
<li>If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.</li>
<li>If there are still unrevealed cards, go back to step 1.  Otherwise, stop.</li>
</ol>
<blockquote>
<p>Return an ordering of the deck that would reveal the cards in <strong>increasing</strong> order.</p>
</blockquote>
<blockquote>
<p>The first entry in the answer is considered to be the top of the deck.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: [17,13,11,2,3,5,7]</span><br><span class="line">Output: [2,13,3,11,5,17,7]</span><br><span class="line">Explanation:</span><br><span class="line">We get the deck in the order [17,13,11,2,3,5,7] (this order doesn&apos;t matter), and reorder it.</span><br><span class="line">After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.</span><br><span class="line">We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].</span><br><span class="line">We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].</span><br><span class="line">We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].</span><br><span class="line">We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].</span><br><span class="line">We reveal 11, and move 17 to the bottom.  The deck is now [13,17].</span><br><span class="line">We reveal 13, and move 17 to the bottom.  The deck is now [17].</span><br><span class="line">We reveal 17.</span><br><span class="line">Since all the cards revealed are in increasing order, the answer is correct.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[i] &lt;= 10^6</code></li>
<li><code>A[i] != A[j]</code> for all <code>i != j</code></li>
</ol>
<p>先按照流程模拟一下卡牌按<code>0</code>-<code>n-1</code>编号开始抽出时，翻开的顺序应该是什么，为了使翻开的牌大小递增，就应该以升序去安排这些抽出的牌的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deckRevealedIncreasing</span><span class="params">(self, deck)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type deck: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(deck)</span><br><span class="line">        cur = []</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        pos = range(n)</span><br><span class="line">        deck.sort()</span><br><span class="line">        <span class="keyword">while</span> pos:</span><br><span class="line">            cur.append(pos.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> pos:</span><br><span class="line">                pos.append(pos.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res[cur[i]] = deck[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Largest Component Size by Common Factor</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-113/problems/largest-component-size-by-common-factor/</p>
<blockquote>
<p>Given a non-empty array of unique positive integers <code>A</code>, consider the following graph:</p>
</blockquote>
<ul>
<li>There are <code>A.length</code> nodes, labelled <code>A[0]</code> to <code>A[A.length - 1];</code></li>
<li>There is an edge between <code>A[i]</code> and <code>A[j]</code> if and only if <code>A[i]</code> and <code>A[j]</code> share a common factor greater than 1.</li>
</ul>
<blockquote>
<p>Return the size of the largest connected component in the graph.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,6,15,35]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/01/ex1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [20,50,9,63]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/01/ex2.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,6,7,4,12,21,39]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2018/12/01/ex3.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>1 &lt;= A[i] &lt;= 100000</code></li>
</ol>
<p>写了几次都是TLE很挫败，太吃时间了，不难看出这题的算法内核就是union find，但实现起来尤其是Python必须非常小心了，想清楚怎样去找所有有邻接关系的结点。</p>
<p>先对每个数<code>x</code>进行质因数分解，每个分解出质因数<code>i</code>的<code>x</code>都会被放进<code>adj[i]</code>这个列表，我这里写的可能会导致同一个<code>x</code>重复被放进同一个<code>adj[i]</code>多次，不过后续处理没有影响，不用担心。这样一来每个<code>adj[i]</code>列表中所有结点都是邻接的。那么之后只需要对每个<code>adj[i]</code>进行<code>adj[i][0]</code>和其他结点进行合并，也就是只需要找一个第一个元素的<code>parent</code>，然后找到后面元素的<code>parent</code>合并到第一个元素的<code>parent</code>，那么相对于一般的<code>union(x,y)</code>的写法，我这里默认了<code>x</code>就是<code>x</code>所在分支的根结点，可以省去一些寻找根结点的时间。另外我在每次进行合并操作时顺序计算了合并之后的分支结点总数<code>size</code>。对每个质因数<code>i</code>都进行一次这样的合并，不仅可以连接当前所有包含<code>i</code>因数的数，如果有在因数<code>j</code>的处理时被合并的数，还可以让它们再连通起来成为更大的连通分支。并计算合并后形成的以<code>adj[i][0]</code>为根的连通分支的大小，并取所有<code>i</code>中使其最大的值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestComponentSize</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">                parent[x] = x</span><br><span class="line">            <span class="keyword">while</span> parent[x] != x:</span><br><span class="line">                x = parent[x]</span><br><span class="line">            <span class="keyword">return</span> parent[x]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x, y)</span>:</span>  <span class="comment"># ensure x's parent is x itself</span></span><br><span class="line">            yset = find(y)</span><br><span class="line">            <span class="keyword">if</span> x != yset:</span><br><span class="line">                size[x] = size.get(x, <span class="number">1</span>) + size.get(yset, <span class="number">1</span>)</span><br><span class="line">                parent[yset] = x</span><br><span class="line"></span><br><span class="line">        adj = collections.defaultdict(list)</span><br><span class="line">        parent = &#123;&#125;</span><br><span class="line">        size = &#123;&#125;</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            num, i = x, <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> i * i &lt;= num:</span><br><span class="line">                <span class="keyword">while</span> num % i == <span class="number">0</span>:</span><br><span class="line">                    adj[i].append(x)</span><br><span class="line">                    num /= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                adj[num].append(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> adj:</span><br><span class="line">            i = find(adj[num][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> adj[num][<span class="number">1</span>:]:</span><br><span class="line">                union(i, j)</span><br><span class="line">            res = max(res, size.get(i, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-113/" data-id="cjuh9jwus0016fww3x4x0uk4g" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-112" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-112/">LeetCode Weekly Contest 112</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-112/" class="article-date"><time datetime="2018-11-25T11:04:33.151Z" itemprop="datePublished">2018-11-25</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-112</p>
<p>&lt;!-- more --&gt;</p>
<h2>Minimum Increment to Make Array Unique</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-112/problems/minimum-increment-to-make-array-unique/</p>
<blockquote>
<p>Given an array of integers A, a <em>move</em> consists of choosing any <code>A[i]</code>, and incrementing it by <code>1</code>.</p>
</blockquote>
<blockquote>
<p>Return the least number of moves to make every value in <code>A</code> unique.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:  After 1 move, the array could be [1, 2, 3].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,2,1,7]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].</span><br><span class="line">It can be shown with 5 or less moves that it is impossible for the array to have all unique values.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt; 40000</code></li>
</ol>
<p>对<code>A</code>进行排序，把每个元素都增加到与前面的元素不重合的最小数字，增量总和即结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minIncrementForUnique</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt;= A[i - <span class="number">1</span>]:</span><br><span class="line">                res += A[i - <span class="number">1</span>] + <span class="number">1</span> - A[i]</span><br><span class="line">                A[i] = A[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Validate Stack Sequences</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-112/problems/validate-stack-sequences/</p>
<blockquote>
<p>Given two sequences <code>pushed</code> and <code>popped</code> <strong>with distinct values</strong>, return <code>true</code> if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> is a permutation of <code>popped</code>.</li>
<li><code>pushed</code> and <code>popped</code> have distinct values.</li>
</ol>
<p>我用的方法很笨拙。先把<code>popped</code>的元素值重写为它们在<code>pushed</code>中的顺序大小，然后开始模拟压栈和弹栈操作：假设<code>0</code>至<code>top</code>都被按顺序压入了栈中，弹出栈顶元素<code>top</code>以后，栈内剩下<code>[0:top-1]</code>，如果上一个弹出的元素是<code>x</code>,那么接下来弹出的值有两种情况</p>
<ol>
<li><code>x-1</code>，没有新的压栈操作，顺序弹出栈内剩余元素</li>
<li>某个比<code>top</code>更大的元素<code>y</code>，那么说明又在原来的栈内顺序压入了<code>[top+1:y]</code>，<code>top</code>被更新为<code>y</code>，在<code>top+1</code>被弹出之前不可能弹出任何小于<code>top</code>的元素。</li>
</ol>
<p>当遇到2的情况时也随之模拟新元素的压栈。如果出现这两种以外的元素则不是合法的弹出序列，直接返回<code>False</code>就可以了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed, popped)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pushed: List[int]</span></span><br><span class="line"><span class="string">        :type popped: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pushed:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        pos = &#123;c: i <span class="keyword">for</span> (i, c) <span class="keyword">in</span> enumerate(pushed)&#125;</span><br><span class="line">        popped = [pos[i] <span class="keyword">for</span> i <span class="keyword">in</span> popped]</span><br><span class="line">        top = popped[<span class="number">0</span>]</span><br><span class="line">        stack = list(range(popped[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> popped[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i == stack[<span class="number">-1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; top:</span><br><span class="line">                    stack += list(range(top + <span class="number">1</span>, i))</span><br><span class="line">                    top = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Most Stones Removed with Same Row or Column</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-112/problems/most-stones-removed-with-same-row-or-column/</p>
<blockquote>
<p>On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.</p>
</blockquote>
<blockquote>
<p>Now, a move consists of removing a stone that shares a column or row with another stone on the grid.</p>
</blockquote>
<blockquote>
<p>What is the largest possible number of moves we can make?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [[0,0]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
<li><code>0 &lt;= stones[i][j] &lt; 10000</code></li>
</ol>
<p>转化成图的问题，每个石头所在的坐标是一个结点，与同行或列的其他结点直接相连，每次move做的只是移除一个度不为0的结点。</p>
<p>那么每个连通分支都可以被move到只剩最后一个结点，所以最终结果是结点总数减去连通分支的个数。</p>
<p>求连通分支数量时，可以直接把x坐标和y坐标当作结点，通过石头所在的坐标连接，用dfs找出所有连通分支。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeStones</span><span class="params">(self, stones)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type stones: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adj = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> stones:</span><br><span class="line">            adj[x].append(-y - <span class="number">1</span>)</span><br><span class="line">            adj[-y - <span class="number">1</span>].append(x)</span><br><span class="line"></span><br><span class="line">        seen = set()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> nei <span class="keyword">in</span> adj[node]:</span><br><span class="line">                <span class="keyword">if</span> nei <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(nei)</span><br><span class="line">                    dfs(nei)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> adj:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(i)</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                dfs(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(stones) - count</span><br></pre></td></tr></table></figure></p>
<h2>Bag of Tokens</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-112/problems/bag-of-tokens/</p>
<blockquote>
<p>You have an initial power <code>P</code>, an initial score of <code>0</code> points, and a bag of tokens.</p>
</blockquote>
<blockquote>
<p>Each token can be used at most once, has a value <code>token[i]</code>, and has potentially two ways to use it.</p>
</blockquote>
<ul>
<li>If we have at least <code>token[i]</code> power, we may play the token face up, losing <code>token[i]</code> power, and gaining <code>1</code> point.</li>
<li>If we have at least <code>1</code> point, we may play the token face down, gaining <code>token[i]</code> power, and losing <code>1</code> point.</li>
</ul>
<blockquote>
<p>Return the largest number of points we can have after playing any number of tokens.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [100], P = 50</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [100,200], P = 150</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: tokens = [100,200,300,400], P = 200</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>tokens.length &lt;= 1000</code></li>
<li><code>0 &lt;= tokens[i] &lt; 10000</code></li>
<li><code>0 &lt;= P &lt; 10000</code></li>
</ol>
<p>注意这里并不要求按照顺序使用token，也不要求全用完，所以可以使用简单的贪心策略。先把<code>tokens</code>从小到大排序，在power耗尽之前不停取数值小的token积攒score，耗尽之后取一个数值大的token补充power，再继续取数值小的token增加score，返回整个过程中出现的最大score</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bagOfTokensScore</span><span class="params">(self, tokens, P)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type tokens: List[int]</span></span><br><span class="line"><span class="string">        :type P: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tokens.sort()</span><br><span class="line">        score = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tokens:</span><br><span class="line">            <span class="keyword">while</span> tokens <span class="keyword">and</span> P &gt;= tokens[<span class="number">0</span>]:</span><br><span class="line">                score, P = score + <span class="number">1</span>, P - tokens.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> score == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = max(res, score)</span><br><span class="line">            <span class="keyword">if</span> tokens <span class="keyword">and</span> score &gt; <span class="number">0</span>:</span><br><span class="line">                score, P = score - <span class="number">1</span>, P + tokens.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-112/" data-id="cjuh9jwuc0013fww32vp5o2zf" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-111" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-111/">LeetCode Weekly Contest 111</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-111/" class="article-date"><time datetime="2018-11-18T11:30:04.015Z" itemprop="datePublished">2018-11-18</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-111</p>
<p>&lt;!-- more --&gt;</p>
<h2>Valid Mountain Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-111/problems/valid-mountain-array/</p>
<blockquote>
<p>Given an array <code>A</code> of integers, return <code>true</code> if and only if it is a valid mountain array.</p>
</blockquote>
<blockquote>
<p>Recall that A is a mountain array if and only if:</p>
</blockquote>
<ul>
<li><code>A.length &gt;= 3</code></li>
<li>There exists some <code>i</code> with <code>0 &lt; i &lt; A.length - 1</code> such that:
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[B.length - 1]</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<p>先检查数组长度是否满足基本要求，然后找到开始递减的地方，如果之后单调性再有所改变可以直接返回<code>false</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        asc = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>] &gt;= A[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] == A[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> asc:</span><br><span class="line">                <span class="keyword">if</span> A[i] &lt; A[i - <span class="number">1</span>]:</span><br><span class="line">                    asc = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> A[i] &gt; A[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> asc</span><br></pre></td></tr></table></figure></p>
<h2>Delete Columns to Make Sorted</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-111/problems/delete-columns-to-make-sorted/</p>
<blockquote>
<p>We are given an array <code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>
</blockquote>
<blockquote>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
</blockquote>
<blockquote>
<p>For example, if we have a string <code>&quot;abcdef&quot;</code> and deletion indices <code>{0, 2, 3}</code>, then the final string after deletion is <code>&quot;bef&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Suppose we chose a set of deletion indices <code>D</code> such that after deletions, each remaining column in A is in <strong>non-decreasing</strong> sorted order.</p>
</blockquote>
<blockquote>
<p>Formally, the <code>c</code>-th column is <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code></p>
</blockquote>
<blockquote>
<p>Return the minimum possible value of <code>D.length</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 1000</code></li>
</ol>
<p>只需要找到不满足非递减的列数</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDeletionSize</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] &lt; A[i - <span class="number">1</span>][j]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>DI String Match</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-111/problems/di-string-match/</p>
<blockquote>
<p>Given a string S that only contains &quot;I&quot; (increase) or &quot;D&quot; (decrease), let <code>N = S.length</code>.</p>
</blockquote>
<blockquote>
<p>Return any permutation <code>A</code> of <code>[0, 1, ..., N]</code> such that for all <code>i = 0, ..., N-1</code>:</p>
</blockquote>
<ul>
<li>If <code>S[i] == &quot;I&quot;,</code> then <code>A[i] &lt; A[i+1]</code></li>
<li>If <code>S[i] == &quot;D&quot;</code>, then <code>A[i] &gt; A[i+1]</code></li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IDID&quot;</span><br><span class="line">Output: [0,4,1,3,2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: [0,1,2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;DDI&quot;</span><br><span class="line">Output: [3,2,0,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 10000</code></li>
<li><code>S</code> only contains characters <code>&quot;I&quot;</code> or <code>&quot;D&quot;</code>.</li>
</ol>
<p>很简单的递归思路是先处理<code>S[1:]</code>对应的<code>0</code>到<code>n-1</code>的重排列，再根据<code>S[0]</code>决定如何调整第一个元素和后面元素的大小关系使之满足<code>S[0]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diStringMatch</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> S:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> S[<span class="number">0</span>] == <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>] + [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> self.diStringMatch(S[<span class="number">1</span>:])]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [len(S)] + self.diStringMatch(S[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p>
<p>当然这么直接写递归肯定会超时，所以稍微修改一下，暂时允许负数的出现，最后再统一加一个值使得数组元素大小在<code>0</code>和<code>n</code>之间</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diStringMatch</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lower, upper = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'I'</span>:</span><br><span class="line">                upper += <span class="number">1</span></span><br><span class="line">                res.append(upper)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lower -= <span class="number">1</span></span><br><span class="line">                res.append(lower)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [i - lower <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure></p>
<h2>Find the Shortest Superstring</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-111/problems/find-the-shortest-superstring/</p>
<blockquote>
<p>Given an array A of strings, find any smallest string that contains each string in <code>A</code> as a substring.</p>
</blockquote>
<blockquote>
<p>We may assume that no string in <code>A</code> is substring of another string in A.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot;]</span><br><span class="line">Output: &quot;alexlovesleetcode&quot;</span><br><span class="line">Explanation: All permutations of &quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot; would also be accepted.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;catg&quot;,&quot;ctaagt&quot;,&quot;gcta&quot;,&quot;ttca&quot;,&quot;atgcatc&quot;]</span><br><span class="line">Output: &quot;gctaagttcatgcatc&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 12</code></li>
<li><code>1 &lt;= A[i].length &lt;= 20</code></li>
</ol>
<p>把它当作<a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank" rel="noopener">TSP</a>来求解。</p>
<p>字符串<code>s1</code>和<code>s2</code>之间的距离为它们首尾重叠子串的长度，用<code>overlap</code>函数计算，并初始化到图中距离<code>dist[i][j]</code>。</p>
<p>接下来就是处理TSP所用的动态规划了。状态<code>state</code>的每个bit表示是否已经经过了该结点，<code>dp[state][i]</code>表示以状态<code>state</code>到达结点<code>i</code>时总距离（总重叠长度）的<strong>最大值</strong>，如果<code>state</code>经这么一个中间结点<code>j</code>，除了<code>i</code>和<code>j</code>剩下的路径<code>prev</code>相同的情况下，到达结点<code>j</code>的总距离加上<code>dist[j][i]</code>大于等于当前的<code>dp[state][i]</code>就可以更新<code>dp[state][i]</code>的值为<code>dp[prev][j]+dist[j][i]</code>，并记录<code>i</code>在这个状态下的前驱结点<code>pre[state][i]</code>为j。</p>
<p>最后找到使<code>dp[-1]</code>最大的终结点<code>last</code>，并根据<code>pre</code>还原出最大总距离对应的路径，然后拼接成字符串返回。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSuperstring</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">overlap</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">            l = min(len(s1), len(s2))</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> s2[:i] == s1[len(s1) - i:]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = len(A)</span><br><span class="line">        dist = [[<span class="number">-1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">        pre = [[<span class="number">-1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                dist[i][j] = overlap(A[i], A[j])</span><br><span class="line">                dist[j][i] = overlap(A[j], A[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> state &amp; (<span class="number">1</span> &lt;&lt; i):</span><br><span class="line">                    prev = state ^ (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                            <span class="keyword">if</span> prev &amp; (<span class="number">1</span> &lt;&lt; j) <span class="keyword">and</span> dp[prev][j] + dist[j][i] &gt;= dp[state][i]:</span><br><span class="line">                                dp[state][i] = dp[prev][j] + dist[j][i]</span><br><span class="line">                                pre[state][i] = j</span><br><span class="line"></span><br><span class="line">        last = dp[<span class="number">-1</span>].index(max(dp[<span class="number">-1</span>]))</span><br><span class="line">        state = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">while</span> last &gt;= <span class="number">0</span>:</span><br><span class="line">            path.append(last)</span><br><span class="line">            last, state = pre[state][last], state ^ (<span class="number">1</span> &lt;&lt; last)</span><br><span class="line"></span><br><span class="line">        path = path[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        res = A[path[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(path)):</span><br><span class="line">            res += A[path[i]][dist[path[i - <span class="number">1</span>]][path[i]]:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这是NP困难问题，这么解效率不高，不过还是将就着用吧。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-111/" data-id="cjuh9jwu50011fww3s7cls0le" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-110" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-110/">LeetCode Weekly Contest 110</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-110/" class="article-date"><time datetime="2018-11-11T10:24:31.710Z" itemprop="datePublished">2018-11-11</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-110/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Reorder Log Files</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-110/problems/reorder-log-files/</p>
<blockquote>
<p>You have an array of <code>logs</code>.  Each log is a space delimited string of words.</p>
</blockquote>
<blockquote>
<p>For each log, the first word in each log is an alphanumeric <em>identifier</em>.  Then, either:</p>
</blockquote>
<ul>
<li>Each word after the identifier will consist only of lowercase letters, or;</li>
<li>Each word after the identifier will consist only of digits.</li>
</ul>
<blockquote>
<p>We will call these two varieties of logs <em>letter-logs</em> and <em>digit-logs</em>.  It is guaranteed that each log has at least one word after its identifier.</p>
</blockquote>
<blockquote>
<p>Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.</p>
</blockquote>
<blockquote>
<p>Return the final order of the logs.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]</span><br><span class="line">Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= logs.length &lt;= 100</code></li>
<li><code>3 &lt;= logs[i].length &lt;= 100</code></li>
<li><code>logs[i]</code> is guaranteed to have an identifier, and a word after the identifier.</li>
</ol>
<p>先把log分类为<code>alpha_logs</code>和<code>digit_logs</code>，前者按照主次序内容，第二次序id进行排序，然后拼接上后者。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type logs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alpha_logs = []</span><br><span class="line">        digit_logs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> logs:</span><br><span class="line">            log = i.split(<span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">if</span> log[<span class="number">1</span>].isalpha():</span><br><span class="line">                alpha_logs.append(log)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digit_logs.append(i)</span><br><span class="line">        sorted_alpha_logs = [<span class="string">' '</span>.join(log) <span class="keyword">for</span> log <span class="keyword">in</span> sorted(</span><br><span class="line">            alpha_logs, key=<span class="keyword">lambda</span> x: (x[<span class="number">1</span>:], x[<span class="number">0</span>]))]</span><br><span class="line">        <span class="keyword">return</span> sorted_alpha_logs + digit_logs</span><br></pre></td></tr></table></figure></p>
<h2>Range Sum of BST</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-110/problems/range-sum-of-bst/</p>
<blockquote>
<p>Given the <code>root</code> node of a binary search tree, return the sum of values of all nodes with value between <code>L</code> and <code>R</code> (inclusive).</p>
</blockquote>
<blockquote>
<p>The binary search tree is guaranteed to have unique values.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [10,5,15,3,7,null,18], L = 7, R = 15</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the tree is at most <code>10000</code>.</li>
<li>The final answer is guaranteed to be less than <code>2^31</code>.</li>
</ol>
<p>简单粗暴的办法，中序遍历，然后对<code>L</code>和<code>R</code>之间的元素求和：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span><span class="params">(self, root, L, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> in_order(r.left) + [r.val] + in_order(r.right)</span><br><span class="line"></span><br><span class="line">        nodes = in_order(root)</span><br><span class="line">        l, r = nodes.index(L), nodes.index(R)</span><br><span class="line">        <span class="keyword">return</span> sum(nodes[l:r + <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Area Rectangle</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-110/problems/minimum-area-rectangle/</p>
<blockquote>
<p>Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.</p>
</blockquote>
<blockquote>
<p>If there isn't any rectangle, return 0.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[2,2]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= points.length &lt;= 500</code></li>
<li><code>0 &lt;= points[i][0] &lt;= 40000</code></li>
<li><code>0 &lt;= points[i][1] &lt;= 40000</code></li>
<li>All points are distinct.</li>
</ol>
<p>直接找最小面积的矩形好像没有特别好的方法，还是需要从头开始检查能不能构成一个矩形。找到矩形的存在可以通过检查<code>x1</code>和<code>x2</code>是否共享了两个相同的<code>y</code>坐标：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        h = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> [i, j] <span class="keyword">in</span> points:</span><br><span class="line">            h[i].add(j)</span><br><span class="line">        res = sys.maxint</span><br><span class="line">        <span class="keyword">for</span> x1 <span class="keyword">in</span> h:</span><br><span class="line">            <span class="keyword">for</span> x2 <span class="keyword">in</span> h:</span><br><span class="line">                <span class="keyword">if</span> x1 &gt;= x2:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y = h[x1] &amp; h[x2]</span><br><span class="line">                    <span class="keyword">if</span> len(y) &lt; <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        y = sorted(list(y))</span><br><span class="line">                        sides = [y[i] - y[i - <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(y))]</span><br><span class="line">                        res = min(res, (x2 - x1) * min(sides))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res == sys.maxint:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Distinct Subsequences II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-110/problems/distinct-subsequences-ii/</p>
<blockquote>
<p>Given a string <code>S</code>, count the number of distinct, non-empty subsequences of <code>S</code> .</p>
</blockquote>
<blockquote>
<p>Since the result may be large, <strong>return the answer modulo <code>10^9 + 7</code></strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: The 7 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, and &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aba&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The 6 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;aa&quot; and &quot;aba&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aaa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The 3 distinct subsequences are &quot;a&quot;, &quot;aa&quot; and &quot;aaa&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> contains only lowercase letters.</li>
<li><code>1 &lt;= S.length &lt;= 2000</code></li>
</ol>
<p>参考了这个做法<a href="https://leetcode.com/problems/distinct-subsequences-ii/discuss/192017/C++JavaPython-4-lines-O(N)-Time-O(1)-Space" target="_blank" rel="noopener">[C++/Java/Python] 4 lines O(N) Time, O(1) Space</a>，使用动态规划，维护<code>dp[c]</code>表示到目前为止以<code>c</code>结尾的非空subsequence有多少个，以<code>c</code>结尾的subsequence来源于扫描到<code>c</code>之前每个subsequence加上<code>c</code>即可，另外还有一个单独的<code>c</code>作为<code>&quot;&quot;+c</code>的结果，因此有<code>dp[c]=sum(c)+1</code>，最后返回整个<code>sum(dp)</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distinctSubseqII</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            dp[ord(c) - ord(<span class="string">'a'</span>)] = (sum(dp) + <span class="number">1</span>) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> sum(dp) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-110/" data-id="cjuh9jwty000yfww34dmq7gd4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><span class="page-number">3</span></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-number" href="/page/5/">5</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/4/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
