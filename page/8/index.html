<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/page/8/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-78" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-78/">LeetCode Weekly Contest 78</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-78/" class="article-date"><time datetime="2018-04-01T12:58:44.467Z" itemprop="datePublished">2018-04-01</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新的一周，祝大家快乐。</p>
<p>直接看题</p>
<p>https://leetcode.com/contest/weekly-contest-78</p>
<p>&lt;!-- more --&gt;</p>
<h2>Subdomain Visit Count</h2>
<blockquote>
<p>A website domain like &quot;discuss.leetcode.com&quot; consists of various subdomains. At the top level, we have &quot;com&quot;, at the next level, we have &quot;leetcode.com&quot;, and at the lowest level, &quot;discuss.leetcode.com&quot;. When we visit a domain like &quot;discuss.leetcode.com&quot;, we will also visit the parent domains &quot;leetcode.com&quot; and &quot;com&quot; implicitly.</p>
</blockquote>
<blockquote>
<p>Now, call a &quot;count-paired domain&quot; to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be &quot;9001 discuss.leetcode.com&quot;.</p>
</blockquote>
<blockquote>
<p>We are given a list <code>cpdomains</code> of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">Output:</span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">Output:</span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">Explanation:</span><br><span class="line">We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li>The length of <code>cpdomains</code> will not exceed <code>100</code>.</li>
<li>The length of each domain name will not exceed <code>100</code>.</li>
<li>Each address will have either 1 or 2 &quot;.&quot; characters.</li>
<li>The input count in any count-paired domain will not exceed <code>10000</code>.</li>
</ol>
<p>普通的字典统计，从后往前统计各级域名访问次数</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subdomainVisits</span><span class="params">(self, cpdomains)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type cpdomains: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> cpdomains:</span><br><span class="line">            temp=r.split(<span class="string">' '</span>)</span><br><span class="line">            times,address=temp[<span class="number">0</span>],temp[<span class="number">1</span>].split(<span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(address)):</span><br><span class="line">                cnt[<span class="string">'.'</span>.join(address[i:])]=cnt.get(<span class="string">'.'</span>.join(address[i:]),<span class="number">0</span>)+int(times)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [str(times)+<span class="string">' '</span>+address <span class="keyword">for</span> (address,times) <span class="keyword">in</span> cnt.items()]</span><br></pre></td></tr></table></figure></p>
<h2>Expressive Words</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-78/problems/expressive-words/</p>
<blockquote>
<p>Sometimes people repeat letters to represent extra feeling, such as &quot;hello&quot; -&gt; &quot;heeellooo&quot;, &quot;hi&quot; -&gt; &quot;hiiii&quot;.  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so &quot;e&quot; and &quot;o&quot; would be extended in the first example, and &quot;i&quot; would be extended in the second example.  As another example, the groups of &quot;abbcccaaaa&quot; would be &quot;a&quot;, &quot;bb&quot;, &quot;ccc&quot;, and &quot;aaaa&quot;; and &quot;ccc&quot; and &quot;aaaa&quot; are the extended groups of that string.</p>
</blockquote>
<blockquote>
<p>For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters <code>c</code>, and add some number of the same character <code>c</code> to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like &quot;h&quot; to a group of size two like &quot;hh&quot; - all extensions must leave the group extended - ie., at least 3 characters long.</p>
</blockquote>
<blockquote>
<p>Given a list of query words, return the number of words that are stretchy.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S = &quot;heeellooo&quot;</span><br><span class="line">words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.</span><br><span class="line">We can&apos;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not extended.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= len(S) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words[i]) &lt;= 100</code>.</li>
<li><code>S</code> and all words in <code>words</code> consist only of lowercase letters</li>
</ol>
<p>双指针单次线性扫描，注意边界。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expressiveWords</span><span class="params">(self, S, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> len(S)&lt;len(w):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> i&lt;len(S):</span><br><span class="line">                    <span class="comment">#print i,j</span></span><br><span class="line">                    <span class="keyword">if</span> j&lt;len(w) <span class="keyword">and</span> S[i]==w[j]:</span><br><span class="line">                        j+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span>&lt;i&lt;len(S)<span class="number">-1</span> <span class="keyword">and</span> S[i]==S[i<span class="number">-1</span>]==S[i+<span class="number">1</span>]:</span><br><span class="line">                            i+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">elif</span> <span class="keyword">not</span> (i&gt;<span class="number">1</span> <span class="keyword">and</span> S[i]==S[i<span class="number">-2</span>]==S[i<span class="number">-1</span>]):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i==len(S) <span class="keyword">and</span> j==len(w):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度<code>o(len(words)*len(S))</code>，空间复杂度<code>o(1)</code></p>
<h2>Soup Servings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-78/problems/soup-servings/</p>
<blockquote>
<p>There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:</p>
</blockquote>
<blockquote>
<ol>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
</ol>
</blockquote>
<ol start="2">
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ol>
<blockquote>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
</blockquote>
<blockquote>
<p>Note that we do not have the operation where all 100 ml's of soup B are used first.</p>
</blockquote>
<blockquote>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 50</span><br><span class="line">Output: 0.625</span><br><span class="line">Explanation:</span><br><span class="line">If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li>
<p><code>0 &lt;= N &lt;= 10^9</code>.</p>
</li>
<li>
<p>Answers within <code>10^-6</code> of the true value will be accepted as correct.</p>
</li>
<li>
<p>最后不满25ml的还是可以算一份，以25ml为一个单位先转换一下<code>N</code>的进制</p>
</li>
<li>
<p><code>f(a,b)=0.25*(f(a-4,b)+f(a-3,b-1)+f(a-2,b-2)+f(a-1,b-3))</code>是递归的递推式，同时用完算0.5的概率</p>
</li>
<li>
<p>使用一个字典来缓存之前计算的<code>f</code>值，避免TLE</p>
</li>
<li>
<p>当<code>N</code>过大时，概率接近1</p>
</li>
</ol>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">soupServings</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache=&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> N&gt;<span class="number">4800</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a&lt;=<span class="number">0</span> <span class="keyword">and</span> b&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">            <span class="keyword">if</span> a&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> b&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (a,b) <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[(a,b)]</span><br><span class="line">            cache[(a,b)]=<span class="number">0.25</span>*(f(a<span class="number">-4</span>,b)+f(a<span class="number">-3</span>,b<span class="number">-1</span>)+f(a<span class="number">-2</span>,b<span class="number">-2</span>)+f(a<span class="number">-1</span>,b<span class="number">-3</span>))</span><br><span class="line">            <span class="keyword">return</span> cache[(a,b)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(math.ceil(N/<span class="number">25.0</span>),math.ceil(N/<span class="number">25.0</span>))</span><br></pre></td></tr></table></figure></p>
<h2>Chalkboard XOR Game</h2>
<blockquote>
<p>We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)</p>
</blockquote>
<blockquote>
<p>Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.</p>
</blockquote>
<blockquote>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1, 1, 2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">Alice has two choices: erase 1 or erase 2.</span><br><span class="line">If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose.</span><br><span class="line">If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code>.</li>
<li><code>0 &lt;= nums[i] &lt;= 2^16</code>.</li>
</ol>
<p>因为是Alice先手，首先判断<code>nums</code>中所有数<code>XOR</code>的结果是否为0，所以根据规则如果是这种情况Alice会赢。如果所有数<code>XOR</code>的结果不为0，那就至少存在两个不同的数（如果<code>len(nums)&gt;1</code>），因为假设玩家都会使用最优的策略，Alice总是可以选择保留这个“不同”的数，当<code>nums</code>的长度为奇数时，最后一手也是Alice的，所以最后必然会赢。</p>
<p>那么就只用考虑所有数的<code>XOR</code>结果是否为0和<code>nums</code>长度是否为奇数了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorGame</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s^=i</span><br><span class="line">        <span class="keyword">return</span> s==<span class="number">0</span> <span class="keyword">or</span> len(nums)%<span class="number">2</span>==<span class="number">0</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-78/" data-id="cjuh9fxbl003cu0w3evw25i26" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-77" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-77/">LeetCode Weekly Contest 77</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-77/" class="article-date"><time datetime="2018-03-26T15:17:24.492Z" itemprop="datePublished">2018-03-26</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>少说废话，多刷题。直接看题</p>
<p>https://leetcode.com/contest/weekly-contest-77</p>
<p>&lt;!-- more --&gt;</p>
<h2>Number of Lines To Write String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/number-of-lines-to-write-string/</p>
<blockquote>
<p>We are to write the letters of a given string <code>S</code>, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array <code>widths</code>, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'.</p>
</blockquote>
<blockquote>
<p>Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: [3, 60]</span><br><span class="line">Explanation:</span><br><span class="line">All letters have the same length of 10. To write all 26 letters,</span><br><span class="line">we need two full lines and one line with 60 units.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;bbbcccdddaaa&quot;</span><br><span class="line">Output: [2, 4]</span><br><span class="line">Explanation:</span><br><span class="line">All letters except &apos;a&apos; have the same length of 10, and</span><br><span class="line">&quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.</span><br><span class="line">For the last &apos;a&apos;, it is written on the second line because</span><br><span class="line">there is only 2 units left in the first line.</span><br><span class="line">So the answer is 2 lines, plus 4 units in the second line.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The length of <code>S</code> will be in the range <code>[1, 1000]</code>.</li>
<li><code>S</code> will only contain lowercase letters.</li>
<li><code>widths</code> is an array of length <code>26</code>.</li>
<li><code>widths[i]</code> will be in the range of <code>[2, 10]</code>.</li>
</ol>
<p>直接按题意写，注意单个字母写不下的时候判定换行：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfLines</span><span class="params">(self, widths, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type widths: List[int]</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l,r=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> widths[ord(c)-ord(<span class="string">'a'</span>)]&gt;<span class="number">100</span>-r:</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">                r=<span class="number">0</span></span><br><span class="line">            r+=widths[ord(c)-ord(<span class="string">'a'</span>)]</span><br><span class="line">        <span class="keyword">return</span> [l,r]</span><br></pre></td></tr></table></figure></p>
<h2>Unique Morse Code Words</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/unique-morse-code-words/</p>
<blockquote>
<p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code> maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>
</blockquote>
<blockquote>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, &quot;cab&quot; can be written as &quot;-.-.-....-&quot;, (which is the concatenation &quot;-.-.&quot; + &quot;-...&quot; + &quot;.-&quot;). We'll call such a concatenation, the transformation of a word.</p>
</blockquote>
<blockquote>
<p>Return the number of different transformations among all words we have.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The transformation of each word is:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The length of words will be at most <code>100</code>.</li>
<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>
<li><code>words[i]</code> will only consist of lowercase letters.</li>
</ol>
<p>这题比上面那题还直接，把每个词转换成Morse码就知道到底有几种形式：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        alphabet=[<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>]</span><br><span class="line">        trans=set()</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            trans.add(<span class="string">''</span>.join([alphabet[ord(i)-ord(<span class="string">'a'</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> w]))</span><br><span class="line">        <span class="keyword">return</span> len(trans)</span><br></pre></td></tr></table></figure></p>
<h2>Max Increase to Keep City Skyline</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/max-increase-to-keep-city-skyline/</p>
<blockquote>
<p>In a 2 dimensional array <code>grid</code>, each value <code>grid[i][j]</code> represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.</p>
</blockquote>
<blockquote>
<p>At the end, the &quot;skyline&quot; when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.</p>
</blockquote>
<blockquote>
<p>What is the maximum total sum that the height of the buildings can be increased?</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">Output: 35</span><br><span class="line">Explanation:</span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4],</span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">The skyline viewed from top or bottom is: [9, 4, 8, 7]</span><br><span class="line">The skyline viewed from left or right is: [8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">The grid after increasing the height of buildings without affecting skylines is:</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Notes</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt; grid.length = grid[0].length &lt;= 50</code>.</li>
<li>All heights <code>grid[i][j]</code> are in the range <code>[0, 100]</code>.</li>
<li>All buildings in <code>grid[i][j]</code> occupy the entire grid cell: that is, they are a <code>1 x 1 x grid[i][j]</code> rectangular prism.</li>
</ol>
<p>天际线取决于该视角下最高的大楼，自顶而下的天际线为各列的最大值，从左往右的天际线为各行的最大值。为了使天际线不变，而每个大楼都尽量增高，应该取该大楼所在的行和列的最大值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        m,n=len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        r=[max(row) <span class="keyword">for</span> row <span class="keyword">in</span> grid]</span><br><span class="line">        c=[max([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> grid]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                res+=min(r[i],c[j])-grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>
<h2>Split Array With Same Average</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-77/problems/split-array-with-same-average/</p>
<blockquote>
<p>In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)</p>
</blockquote>
<blockquote>
<p>Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3,4,5,6,7,8]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The length of <code>A</code> will be in the range <code>[1, 30]</code>.</li>
<li><code>A[i]</code> will be in the range of <code>[0, 10000]</code>.</li>
</ol>
<p>这题如果一定要解，暴力搜索肯定可以，只是必然TLE，所以需要借助一些方法减少搜索次数。假设<code>B</code>是长度比较大的那个子数组，有<code>sum(A)/len(A)=sum(B)/len(B)=sum(C)/len(C)</code>,如果要存在这样的<code>B</code>和<code>C</code>，至少要求有更小的<code>sum(B)</code>和<code>len(B)</code>凑出<code>sum(A)/len(A)=sum(B)/len(B)</code>。记<code>g=gcd(sum(A),len(A))</code>，可以有<code>sum(A)=g*s</code>和<code>len(A)=g*n</code>其中<code>s</code>和<code>n</code>互质，所以搜索<code>sum(B)</code>和<code>len(B)</code>的可能的值的时候只需要找一个整数<code>0&lt;i&lt;g</code>构造<code>sum(B)=i*s</code>和<code>len(B)=i*n</code>，只有在这些情况下可能找到符合<code>sum(A)/len(A)=sum(B)/len(B)</code>的子数组<code>B</code>，当然由于考虑到<code>B</code>和<code>C</code>的对称性限定了<code>B</code>为较大的子数组，所以只要考虑<code>&lt;=g/2</code>的情况就可以覆盖所有可能了。</p>
<p>在构造出可能的目标<code>len(B)</code>和<code>sum(B)</code>后开始在<code>A</code>中用DFS取值看是否存在符合要求的<code>B</code>:可以先把<code>A</code>按照降序排列，然后从数组头部开始取数或跳到下一个值，遇到开始小于<code>sum(B)\len(B)</code>的数就跳出，这样的方法适用DFS常见的递归实现。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArraySameAverage</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pos,target,cnt)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> target==<span class="number">0</span> <span class="keyword">and</span> cnt==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> pos&gt;=len(A) <span class="keyword">or</span> target&lt;<span class="number">0</span> <span class="keyword">or</span> target-cnt*A[pos]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> dfs(pos+<span class="number">1</span>,target-A[pos],cnt<span class="number">-1</span>) <span class="keyword">or</span> dfs(pos+<span class="number">1</span>,target,cnt)</span><br><span class="line"></span><br><span class="line">        g=fractions.gcd(sum(A),len(A))</span><br><span class="line">        s,n=sum(A)/g,len(A)/g</span><br><span class="line">        A.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,int(g/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dfs(<span class="number">0</span>,s*i,n*i):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为<code>o(g*(2^(len(A))))</code>，空间复杂度为<code>o(1)</code></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-77/" data-id="cjuh9fxb8003au0w3ud6d6rc2" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-76" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-76/">LeetCode Weekly Contest 76</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-76/" class="article-date"><time datetime="2018-03-18T13:51:31.062Z" itemprop="datePublished">2018-03-18</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>说个好消息，这个域名我又续费了一年<s>好在有优惠码所以省了顿饭钱啦hhhh但还是肉疼</s>，所以我还得再写一年呢。另外我还开了个微信公众号搬运和分享我的内容，直接搜索<code>yangzhou-301</code>或者扫二维码。顺便在这里打广告招收编辑和创作者，我要更专注的学习和生产内容嘛。</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode_for_yangzhou_301.jpg" alt="扬州计划"></p>
<p>好吧，废话完了直接看这周的题吧。</p>
<p>https://leetcode.com/contest/weekly-contest-76/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Similar RGB Color</h2>
<blockquote>
<p>In the following, every capital letter represents some hexadecimal digit from <code>0</code> to <code>f</code>.</p>
</blockquote>
<blockquote>
<p>The red-green-blue color <code>&quot;#AABBCC&quot;</code> can be written as <code>&quot;#ABC&quot;</code> in shorthand.  For example, <code>&quot;#15c&quot;</code> is shorthand for the color <code>&quot;#1155cc&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Now, say the similarity between two colors <code>&quot;#ABCDEF&quot;</code> and <code>&quot;#UVWXYZ&quot;</code> is <code>-(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2</code>.</p>
</blockquote>
<blockquote>
<p>Given the color <code>&quot;#ABCDEF&quot;</code>, return a 7 character color that is most similar to <code>#ABCDEF</code>, and has a shorthand (that is, it can be represented as some <code>&quot;#XYZ&quot;</code></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: color = &quot;#09f166&quot;</span><br><span class="line">Output: &quot;#11ee66&quot;</span><br><span class="line">Explanation:  </span><br><span class="line">The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.</span><br><span class="line">This is the highest among any shorthand color.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>color</code> is a string of length <code>7</code>.</li>
<li><code>color</code>is a valid RGB color: for <code>i &gt; 0</code>, <code>color[i]</code> is a hexadecimal digit from <code>0</code> to <code>f</code></li>
<li>Any answer which has the same (highest) similarity as the best answer will be accepted.</li>
<li>All inputs and outputs should use lowercase letters, and the output is 7 characters.</li>
</ol>
<p>可以缩写的形式要求三个颜色的数值都是17的整数倍，那么找距离每个颜色最近的在<code>[0,255]</code>范围内的<code>17*n</code>即可，这里是用模17的余数判断：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">similarRGB</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type color: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="string">'#'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>):</span><br><span class="line">            c=int(color[i:i+<span class="number">2</span>],<span class="number">16</span>)</span><br><span class="line">            r=c%<span class="number">17</span></span><br><span class="line">            <span class="keyword">if</span> r&lt;=<span class="number">8</span>:</span><br><span class="line">                res+=hex(max(<span class="number">0</span>,c-r))[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res+=hex(min(<span class="number">17</span>*<span class="number">15</span>,c-r+<span class="number">17</span>))[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Swaps To Make Sequences Increasing</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-76/problems/minimum-swaps-to-make-sequences-increasing/</p>
<blockquote>
<p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p>
</blockquote>
<blockquote>
<p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.  Note that both elements are in the same index position in their respective sequences.</p>
</blockquote>
<blockquote>
<p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.  (A sequence is strictly increasing if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p>
</blockquote>
<blockquote>
<p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,5,4], B = [1,2,3,7]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Swap A[3] and B[3].  Then the sequences are:</span><br><span class="line">A = [1, 3, 5, 7] and B = [1, 2, 3, 4]</span><br><span class="line">which are both strictly increasing.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A, B</code> are arrays with the same length, and that length will be in the range <code>[1, 1000]</code>.</li>
<li><code>A[i], B[i]</code> are integer values in the range <code>[0, 2000]</code>.</li>
</ol>
<p>在进行一轮线性扫描时，决定是否交换<code>A</code>和<code>B</code>的元素取决于<code>A[i]</code>,<code>A[i+1]</code>,<code>B[i]</code>和<code>B[i+1]</code>之间的关系，分开讨论<code>A[i]&amp;B[i]</code>是否交换，对<code>A[i+1]&amp;B[i+1]</code>是否需要交换及代价的影响，这样的思路很适合考虑动态规划。在动态规划的逻辑上清晰的解释可以见<a href="https://leetcode.com/articles/minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">官方题解</a>和<a href="https://t.co/5Tjz0p69Ve" target="_blank" rel="noopener">Python 14-line O(1) space O(n) time DP solution</a>，简要的来说参见我的代码：</p>
<ul>
<li><code>pre_swap</code>:<code>A[i]</code>和<code>B[i]</code>交换使得到<code>A[0-i]</code>和<code>B[0-i]</code>递增的代价</li>
<li><code>pre_unswap</code>:<code>A[i]</code>和<code>B[i]</code>不交换使得到<code>A[0-i]</code>和<code>B[0-i]</code>递增的代价</li>
<li><code>cur_swap</code>:<code>A[i+1]</code>和<code>B[i+1]</code>交换使得到<code>A[0-i+1]</code>和<code>B[0-i+1]</code>递增的代价</li>
<li><code>cur_unswap</code>:<code>A[i+1]</code>和<code>B[i+1]</code>不交换使得到<code>A[0-i+1]</code>和<code>B[0-i+1]</code>递增的代价</li>
</ul>
<p>当<code>A[i+1]&gt;A[i]</code>且<code>B[i+1]&gt;B[i]</code>时，要保证数组的<code>0-i+1</code>位递增，要么第<code>i</code>和<code>i+1</code>位都进行交换，要么都不进行交换，那么<code>cur_unswap=min(cur_unswap,pre_unswap)</code>而<code>cur_swap=min(cur_swap,pre_swap+1)</code></p>
<p>当<code>A[i+1]&gt;B[i]</code>且<code>B[i+1]&gt;A[i]</code>时（注意这个情况可以和上面同时存在，所以只是在原来的基础上再增加一种缩小代价的可能性），要保证数组的<code>0-i+1</code>位递增，可以只换<code>i</code>和<code>i+1</code>其中的一组，如果换的是<code>i</code>那么<code>i+1</code>不换所以有<code>cur_unswap=min(cur_unswap,pre_swap)</code>，反之如果换的是<code>i+1</code>而保持<code>i</code>不变则有<code>cur_swap=min(cur_swap,pre_unswap+1)</code></p>
<p>而每个<code>cur_swap</code>的最大值为数组<code>0-i+1</code>的长度<code>i+2</code>，<code>cur_unswap</code>的最大值为数组<code>0-i</code>的长度<code>i+1</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSwap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        pre_swap,pre_unswap=<span class="number">1</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>):</span><br><span class="line">            cur_swap,cur_unswap=i+<span class="number">2</span>,i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[i]&lt;A[i+<span class="number">1</span>] <span class="keyword">and</span> B[i]&lt;B[i+<span class="number">1</span>]:</span><br><span class="line">                cur_swap=min(cur_swap,pre_swap+<span class="number">1</span>)</span><br><span class="line">                cur_unswap=min(cur_unswap,pre_unswap)</span><br><span class="line">            <span class="keyword">if</span> A[i]&lt;B[i+<span class="number">1</span>] <span class="keyword">and</span> B[i]&lt;A[i+<span class="number">1</span>]:</span><br><span class="line">                cur_swap=min(cur_swap,pre_unswap+<span class="number">1</span>)</span><br><span class="line">                cur_unswap=min(cur_unswap,pre_swap)</span><br><span class="line">            pre_swap,pre_unswap=cur_swap,cur_unswap</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(pre_swap,pre_unswap)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>
<h2>Find Eventual Safe States</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-76/problems/find-eventual-safe-states/</p>
<blockquote>
<p>n a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
</blockquote>
<blockquote>
<p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number <code>K</code> so that for any choice of where to walk, we must have stopped at a terminal node in less than <code>K</code> steps.</p>
</blockquote>
<blockquote>
<p>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
</blockquote>
<blockquote>
<p>The directed graph has <code>N</code> nodes with labels <code>0, 1, ..., N-1</code>, where <code>N</code> is the length of <code>graph</code>.  The graph is given in the following form: <code>graph[i]</code> is a list of labels <code>j</code> such that <code>(i, j)</code> is a directed edge of the graph.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>graph</code> will have length at most <code>10000</code>.</li>
<li>The number of edges in the graph will not exceed <code>32000</code>.</li>
<li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li>
</ol>
<p>无非就是保证从这个结点出发不会进入回路。可以试试找回路常用的拓扑排序法，从出度为0的结点开始删去结点与其所有入边，循环操作至不存在出度为0的结点，删去的所有结点都是安全的。为了找到所有入边可以一开始对邻接表进行逆转操作，记录每个结点的所有入边，这样在删去入边时会高效一些。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[i <span class="keyword">for</span> (i,e) <span class="keyword">in</span> enumerate(graph) <span class="keyword">if</span> <span class="keyword">not</span> e]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        in_edges=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(graph))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,edges <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> edges:</span><br><span class="line">                in_edges[j].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> res:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> in_edges[node]:</span><br><span class="line">                graph[i].remove(node)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> graph[i]:</span><br><span class="line">                    res.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N+E)$，空间复杂度为$o(N)$，其中$N$为结点数，$E$为边数</p>
<h2>Bricks Falling When Hit</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-76/problems/bricks-falling-when-hit/</p>
<blockquote>
<p>We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p>
</blockquote>
<blockquote>
<p>We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</p>
</blockquote>
<blockquote>
<p>Return an array representing the number of bricks that will drop after each erasure in sequence.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">grid = [[1,0,0,0],[1,1,1,0]]</span><br><span class="line">hits = [[1,0]]</span><br><span class="line">Output: [2]</span><br><span class="line">Explanation:</span><br><span class="line">If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">grid = [[1,0,0,0],[1,1,0,0]]</span><br><span class="line">hits = [[1,1],[1,0]]</span><br><span class="line">Output: [0,0]</span><br><span class="line">Explanation:</span><br><span class="line">When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of rows and columns in the grid will be in the range [1, 200].</li>
<li>The number of erasures will not exceed the area of the grid.</li>
<li>It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.
An erasure may refer to a location with no brick - if it does, no bricks drop.</li>
</ol>
<p>首先需要理解一下题意，不会掉下来的砖是指第0层的砖（天花板）和与第0层砖连通的砖块。可以说只有有结点在第0层的连通分支中的砖块可以保留，其他砖块都会掉落。正向地去考虑删去每块砖可能不容易，那么可以像<a href="https://leetcode.com/problems/bricks-falling-when-hit/discuss/119829/Python-Solution-by-reversely-adding-hits-bricks-back" target="_blank" rel="noopener">这里</a>提到的思路，逆向的去添加<code>hits</code>中的砖块，看看每次添加可以让<code>grid</code>增加多少砖块。这样一来，可以从增加的<code>hit</code>出发进行DFS更容易找出有多少砖块通过这块砖被连接到了“天花板”。</p>
<p>我们先去掉<code>hits</code>中所有的砖块（指定位置为空的标记为<code>-1</code>，在之后重新添加的过程中这个<code>hit</code>对应的结果直接返回0），再从天花板开始做DFS，找到所有不会掉落的砖块并进行标记，再从后往前依次添加<code>hits</code>中的砖块，并以当前添加的这个砖块为根结点做DFS找到新的不会掉落的砖块数量，就是这次<code>hit</code>的对应掉落砖块数，即返回结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitBricks</span><span class="params">(self, grid, hits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :type hits: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        adj=[(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]</span><br><span class="line">        m,n=len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n <span class="keyword">and</span> grid[i][j]==<span class="number">1</span>:</span><br><span class="line">                grid[i][j]=<span class="number">2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+sum([dfs(i+dx,j+dy) <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> adj])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_fixed</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i==<span class="number">0</span> <span class="keyword">or</span> any([<span class="number">0</span>&lt;=i+dx&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j+dy&lt;n <span class="keyword">and</span> grid[i+dx][j+dy]==<span class="number">2</span> <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> adj])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> hits:</span><br><span class="line">            grid[i][j]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dfs(<span class="number">0</span>,j)</span><br><span class="line"></span><br><span class="line">        res=[<span class="number">0</span>]*len(hits)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(hits)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            i,j=hits[k]</span><br><span class="line">            grid[i][j]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="number">1</span> <span class="keyword">and</span> is_fixed(i,j):</span><br><span class="line">                res[k]=dfs(i,j)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>总共需要进行<code>o(m+len(hits))</code>次DFS</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-76/" data-id="cjuh9fxb50038u0w3p3clbwxh" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-75" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-75/">LeetCode Weekly Contest 75</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-75/" class="article-date"><time datetime="2018-03-11T14:02:22.262Z" itemprop="datePublished">2018-03-11</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>这一天终于要到来了，这个域名也马上到期了。正如之前所说，写到最后一刻吧。直接看题：</p>
<p>https://leetcode.com/contest/weekly-contest-75/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Rotate String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/rotate-string/</p>
<blockquote>
<p>We are given two strings, <code>A</code> and <code>B</code>.</p>
</blockquote>
<blockquote>
<p>A shift on <code>A</code> consists of taking string <code>A</code> and moving the leftmost character to the rightmost position. For example, if <code>A = 'abcde'</code>, then it will be <code>'bcdea'</code> after one shift on <code>A</code>. Return <code>True</code> if and only if <code>A</code>can become <code>B</code> after some number of shifts on <code>A</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &apos;abcde&apos;, B = &apos;cdeab&apos;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &apos;abcde&apos;, B = &apos;abced&apos;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code> and <code>B</code> will have length at most 100.</li>
</ol>
<p>这个问题本质就是字符串的“左移”，我的直觉做法是找到<code>A[0]</code>或者<code>A[-1]</code>在<code>B</code>的位置，然后把<code>B</code>分割成两个子串，分别找到这两个子串在<code>A</code>中的对应：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateString</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i,n=<span class="number">0</span>,len(A)</span><br><span class="line">        <span class="keyword">while</span> A[<span class="number">0</span>] <span class="keyword">in</span> B[i:]:</span><br><span class="line">            sp=B.index(A[<span class="number">0</span>],i)</span><br><span class="line">            <span class="keyword">if</span> B[sp:]==A[<span class="number">0</span>:n-sp] <span class="keyword">and</span> B[:sp]==A[n-sp:]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            i=sp+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(1)$</p>
<h2>All Paths From Source to Target</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/all-paths-from-source-to-target</p>
<blockquote>
<p>Given a directed, acyclic graph of <code>N</code> nodes.  Find all possible paths from node <code>0</code> to node <code>N-1</code>, and return them in any order.</p>
</blockquote>
<blockquote>
<p>The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [3], [3], []]</span><br><span class="line">Output: [[0,1,3],[0,2,3]]</span><br><span class="line">Explanation: The graph looks like this:</span><br><span class="line">0---&gt;1</span><br><span class="line">|    |</span><br><span class="line">v    v</span><br><span class="line">2---&gt;3</span><br><span class="line">There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the graph will be in the range <code>[2, 15]</code>.</li>
<li>You can print different paths in any order, but you should keep the order of nodes inside one path.</li>
</ol>
<p>直接用递归实现DFS即可</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path)</span>:</span></span><br><span class="line">            root=path[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">if</span> i==len(graph)<span class="number">-1</span>:</span><br><span class="line">                        res.append(path+[i])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dfs(path+[i])</span><br><span class="line"></span><br><span class="line">        dfs([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度和空间复杂度为$o(E)$，$E$为图的边集大小</p>
<h2>Champagne Tower</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/champagne-tower/</p>
<blockquote>
<p>We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.</p>
</blockquote>
<blockquote>
<p>Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)</p>
</blockquote>
<blockquote>
<p>For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.</p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png" alt=""></p>
</blockquote>
<blockquote>
<p>Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: poured = 1, query_glass = 1, query_row = 1</span><br><span class="line">Output: 0.0</span><br><span class="line">Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: poured = 2, query_glass = 1, query_row = 1</span><br><span class="line">Output: 0.5</span><br><span class="line">Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>poured</code> will be in the range of <code>[0, 10 ^ 9]</code>.</li>
<li><code>query_glass</code> and <code>query_row</code> will be in the range of <code>[0, 99]</code>.</li>
</ol>
<p>有点类似于动态规划，先把<code>poured</code>全算到最顶端的杯子，每层杯子溢出的酒再算到下一层。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">champagneTower</span><span class="params">(self, poured, query_row, query_glass)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type poured: int</span></span><br><span class="line"><span class="string">        :type query_row: int</span></span><br><span class="line"><span class="string">        :type query_glass: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        row=[[<span class="number">0</span>]*(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(query_row+<span class="number">1</span>)]</span><br><span class="line">        row[<span class="number">0</span>][<span class="number">0</span>]=poured</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(query_row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> row[i][j]&gt;<span class="number">1</span>:</span><br><span class="line">                    row[i+<span class="number">1</span>][j]+=(row[i][j]<span class="number">-1</span>)/<span class="number">2.0</span></span><br><span class="line">                    row[i+<span class="number">1</span>][j+<span class="number">1</span>]+=(row[i][j]<span class="number">-1</span>)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> min(row[query_row][query_glass],<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度也为$o(n^2)$，这里的$n$是指<code>query_row</code>，当然实际上的实现也可以用两个一维数组互相迭代，也就是空间复杂度可以减小到$o(n)$，我为了方便写所以用了一个二维数组。</p>
<h2>Smallest Rotation with Highest Score</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-75/problems/smallest-rotation-with-highest-score/</p>
<blockquote>
<p>Given an array <code>A</code>, we may rotate it by a non-negative integer <code>K</code> so that the array becomes <code>A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]</code>.  Afterward, any entries that are less than or equal to their index are worth 1 point.</p>
</blockquote>
<blockquote>
<p>For example, if we have <code>[2, 4, 1, 3, 0]</code>, and we rotate by <code>K = 2</code>, it becomes <code>[1, 3, 0, 2, 4]</code>.  This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point].</p>
</blockquote>
<blockquote>
<p>Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [2, 3, 1, 4, 0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:  </span><br><span class="line">Scores for each K are listed below:</span><br><span class="line">K = 0,  A = [2,3,1,4,0],    score 2</span><br><span class="line">K = 1,  A = [3,1,4,0,2],    score 3</span><br><span class="line">K = 2,  A = [1,4,0,2,3],    score 3</span><br><span class="line">K = 3,  A = [4,0,2,3,1],    score 4</span><br><span class="line">K = 4,  A = [0,2,3,1,4],    score 3</span><br><span class="line">So we should choose K = 3, which has the highest score.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1, 3, 0, 2, 4]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:  A will always have 3 points no matter how it shifts.</span><br><span class="line">So we will choose the smallest K, which is 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code> will have length at most <code>20000</code>.</li>
<li><code>A[i]</code> will be in the range <code>[0, A.length]</code>.</li>
</ol>
<p>没有太大必要去关注<code>K=0</code>时的 <code>score</code>具体是多少，或者说任何<code>K</code>值下的<code>score</code>都不重要，要找的只是<code>score</code>最大时的<code>K</code>取值，那么需要记录的只有每个<code>K</code>值相比前一个的变化值。</p>
<p>首先，<code>K</code>每增加1时，上一个<code>A[0]</code>就会变成下一个数组的<code>A[N-1]</code>，满足<code>A[N-1]&lt;=N-1</code>，除非对于上一个数组来说<code>A[0]=0</code>所以本来就满足<code>A[0]&lt;=0</code>，否则，因为这样“旋转”每次会增加一分。</p>
<p>接下来，我们思考什么时候会减分。当<code>K=(i-A[i])%N</code>时会有<code>A[i]=(i-K)%N</code><s>(这不是废话吗)</s>，即在这个旋转操作后，<code>A[i]</code>左移到了<code>A[i-K]</code>的位置，此时有<code>A[i-k]=(i-K)%N</code>，由于<code>K</code>的取值范围是由1到<code>N-1</code>递增的，这也是这个元素在回到数组末尾前最后一次满足值小于等于索引，所以每当<code>K=(i-A[i]+1)%N</code>，都会因为<code>A[i]</code>丢掉一分。</p>
<p>当然我这样的描述有点冗余，当前数组第一个元素为0时，再进行下一次旋转，会因为<code>K=(i-A[i]+1)%N</code>失去1分，但是同样会因为回到数组末尾重新得到1分，所以实际上<code>A[i]=0</code>在回到数组末尾时对<code>score</code>没有影响，情况已经被上面两种情形覆盖了。</p>
<p>所以再次强调不要去在意一开始的<code>score[0]</code>到底是多少，只需要在意每个<code>K</code>在此基础上的得分变化，因为上面两种情况的讨论都是讨论<code>K=i+1</code>时相对于前一个值<code>K=i</code>时的变化，所以只需计算<code>score[i+1]=score[i]+changes[i+1]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bestRotation</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        changes=[<span class="number">1</span>]*len(A)</span><br><span class="line">        score=[<span class="number">0</span>]*len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            changes[(i-A[i]+<span class="number">1</span>)%len(A)] -=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            score[i]=score[i<span class="number">-1</span>]+changes[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score.index(max(score))</span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度为$o(N)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-75/" data-id="cjuh9fxb00036u0w3qbz7ckqe" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-74" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-74/">LeetCode Weekly Contest 74</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-74/" class="article-date"><time datetime="2018-03-04T15:35:23.283Z" itemprop="datePublished">2018-03-04</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>没什么好说的，直接看题。</p>
<p>https://leetcode.com/contest/weekly-contest-74/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Valid Tic-Tac-Toe State</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/valid-tic-tac-toe-state/</p>
<blockquote>
<p>A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.</p>
</blockquote>
<blockquote>
<p>The board is a 3 x 3 array, and consists of characters <code>&quot; &quot;</code>, <code>&quot;X&quot;</code>, and <code>&quot;O&quot;</code>.  The <code>&quot; &quot;</code> character represents an empty square.</p>
</blockquote>
<blockquote>
<p>Here are the rules of Tic-Tac-Toe:</p>
</blockquote>
<blockquote>
<ul>
<li>Players take turns placing characters into empty squares (&quot; &quot;).</li>
</ul>
</blockquote>
<ul>
<li>The first player always places &quot;X&quot; characters, while the second player always places &quot;O&quot; characters.</li>
<li>&quot;X&quot; and &quot;O&quot; characters are always placed into empty squares, never filled ones.</li>
<li>The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.</li>
<li>The game also ends if all squares are non-empty.</li>
<li>No more moves can be played if the game is over.
<strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [&quot;O  &quot;, &quot;   &quot;, &quot;   &quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first player always plays &quot;X&quot;.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: board = [&quot;XOX&quot;, &quot; X &quot;, &quot;   &quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Players take turns making moves.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: board = [&quot;XXX&quot;, &quot;   &quot;, &quot;OOO&quot;]</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: board = [&quot;XOX&quot;, &quot;O O&quot;, &quot;XOX&quot;]</span><br><span class="line">Output: true</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board</code> is a length-3 array of strings, where each string <code>board[i]</code> has length 3.</li>
<li>Each <code>board[i][j]</code> is a character in the set <code>{&quot; &quot;, &quot;X&quot;, &quot;O&quot;}</code>.</li>
</ol>
<p>题目问的是游戏过程中是否会出现给出的<code>board</code>情景，不涉及算法问题，理清游戏的规则就好。首先，轮流保证了<code>X</code>和<code>O</code>的数量差值永远不会大于1，而且由于<code>X</code>先执，所以如果有多出的1个也必须是<code>X</code>。如果游戏出现了一方获胜的结局，那么需要满足：</p>
<p>因为轮流的顺序，如果是执<code>X</code>方获胜，则需要满足<code>X</code>三连以及<code>X-O==1</code>，同理，如果执<code>O</code>方获胜则需要<code>O</code>三连以及<code>X==O</code>。所以不存在同时获胜的可能性，因为九宫格和<code>X-O&lt;=1</code>的限制，也不会出现一方有多个三连的可能性。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTicTacToe</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x_r=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        o_r=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        x_c=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        o_c=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        x_d=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        o_d=[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">        x,o=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'X'</span>:</span><br><span class="line">                    x+=<span class="number">1</span></span><br><span class="line">                    x_r[i]+=<span class="number">1</span></span><br><span class="line">                    x_c[j]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i==j:</span><br><span class="line">                        x_d[<span class="number">0</span>]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i+j==<span class="number">2</span>:</span><br><span class="line">                        x_d[<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j]==<span class="string">'O'</span>:</span><br><span class="line">                    o+=<span class="number">1</span></span><br><span class="line">                    o_r[i]+=<span class="number">1</span></span><br><span class="line">                    o_c[j]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i==j:</span><br><span class="line">                        o_d[<span class="number">0</span>]+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i+j==<span class="number">2</span>:</span><br><span class="line">                        o_d[<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> o&gt;x <span class="keyword">or</span> x-o&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> x_r+x_c+x_d <span class="keyword">and</span> x-o!=<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="number">3</span> <span class="keyword">in</span> o_r+o_c+o_d <span class="keyword">and</span> x!=o:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Number of Matching Subsequences</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/number-of-matching-subsequences/</p>
<blockquote>
<p>Given string <code>S</code> and a dictionary of words words, find the number of <code>words[i]</code> that is a subsequence of <code>S</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S = &quot;abcde&quot;</span><br><span class="line">words = [&quot;a&quot;, &quot;bb&quot;, &quot;acd&quot;, &quot;ace&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three words in words that are a subsequence of S: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>All words in words and <code>S</code> will only consists of lowercase letters.</li>
<li>The length of <code>S</code> will be in the range of <code>[1, 50000]</code>.</li>
<li>The length of <code>words</code> will be in the range of <code>[1, 5000]</code>.</li>
<li>The length of <code>words[i]</code> will be in the range of <code>[1, 50]</code>.</li>
</ol>
<p>题目的逻辑不难，但因为<code>S</code>和<code>words</code>的大小客观，直接上去按照题意写容易TLE。先用字典记录<code>S</code>中的字符出现的索引，再对<code>words[i]</code>中每个字符在字典中二分查找是否存在比上一个索引更大的索引值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMatchingSubseq</span><span class="params">(self, S, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">26</span>)]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            d[ord(c)-ord(<span class="string">'a'</span>)].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            last=<span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">                x=bisect.bisect(d[ord(c)-ord(<span class="string">'a'</span>)],last)</span><br><span class="line">                <span class="keyword">if</span> x==len(d[ord(c)-ord(<span class="string">'a'</span>)]):</span><br><span class="line">                    res+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                last=d[ord(c)-ord(<span class="string">'a'</span>)][x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(words)-res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为<code>o(len(S)+sum(len(word[i])))</code>，空间复杂度为<code>o(len(S))</code></p>
<h2>Number of Subarrays with Bounded Maximum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/number-of-subarrays-with-bounded-maximum/</p>
<blockquote>
<p>We are given an array <code>A</code> of positive integers, and two positive integers <code>L</code> and <code>R</code> (<code>L &lt;= R</code>).</p>
</blockquote>
<blockquote>
<p>Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least <code>L</code> and at most <code>R</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">A = [2, 1, 4, 3]</span><br><span class="line">L = 2</span><br><span class="line">R = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>L, R  and <code>A[i]</code> will be an integer in the range <code>[0, 10^9]</code>.</li>
<li>The length of <code>A</code> will be in the range of <code>[1, 50000]</code>.</li>
</ol>
<p>理解题目的contiguous指的是在原列表的顺序，和正数大小是否连续无关。我们先进行线性扫描，假设遇到不符合题意的即<code>&gt;R</code>的元素为<code>A[i]</code>，之后遇到的任意符合<code>L&lt;=A[j]&lt;R</code>，都可以组成符合要求的<code>A[i+1]-A[j]</code>最长子数组，其子数组<code>A[k]-A[j]</code>（<code>i+1&lt;=k&lt;=j</code>）也是都是符合题意的，所有公有<code>j-i</code>个子数组。当再次出现<code>&gt;R</code>的元素时更新<code>i</code>和<code>j</code>值再次累加即可。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(self, A, L, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res,left,right=<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> (i,num) <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> num&gt;R:</span><br><span class="line">                left=i</span><br><span class="line">            <span class="keyword">if</span> num&gt;=L:</span><br><span class="line">                right=i</span><br><span class="line">            res+=right-left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>毫无疑问，线性扫描的时间复杂度为$o(n)$，空间复杂度为$o(1)$</p>
<h2>Preimage Size of Factorial Zeroes Function</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-74/problems/preimage-size-of-factorial-zeroes-function/</p>
<blockquote>
<p>Let <code>f(x)</code> be the number of zeroes at the end of <code>x!</code>. (Recall that <code>x! = 1 * 2 * 3 * ... * x</code>, and by convention, <code>0! = 1</code>.)</p>
</blockquote>
<blockquote>
<p>For example,<code>f(3) = 0</code> because <code>3! = 6</code> has no zeroes at the end, while<code>f(11) = 2</code> because <code>11! = 39916800</code> has <code>2</code> zeroes at the end. Given <code>K</code>, find how many non-negative integers <code>x</code> have the property that <code>f(x) = K</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 0</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 5</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no x such that x! ends in K = 5 zeroes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>K</code> will be an integer in the range <code>[0, 10^9]</code>.</li>
</ol>
<p>我们不妨反过来看这个问题，已知了$x$如何求$f(x)$？这个问题简单的多，只要数这个阶乘里面包含多少<code>2</code>和<code>5</code>，众所周知，阶乘里面的<code>2</code>多于<code>5</code>，所以有多少个<code>5</code>就等同于末位有多少<code>0</code>。<code>[1,x]</code>一共有多少个5也很容易计算
$$f\left( x \right) = x/5 + x/{5^2} +  \cdots  + x/{5^n} = \sum\limits_{i = 1}^n {x/{5^i}}$$
容易观察出$g(x)$和$x$模$5$余数无关，也就是说每个$g(x)$可以对应5个不同的$x$，所以给定<code>K</code>值后要找有多少个<code>x</code>要么有5个要么有0个。
接下来把$x$写成某种五进制数形式：
$$x = {a_0} + 5{a_1} + {5^2}{a_2} +  \cdots  + {5^n}{a_n} = \sum\limits_{i = 0}^n {5^i}{a_i}$$
其中各项系数$0 \le a_i \le 4$，$f(x)$重写为$$\begin{align}
f\left( x \right) &amp;= \sum\limits_{i = 1}^n {5^{i - 1}{a_i}}  + \sum\limits_{i = 2}^n {5^{i - 2}{a_i} + }  \cdots  + a_n \\
&amp; = a_1 + (1 + 5){a_2} + (1 + 5 + 5^2)a_3 +  \cdots  + {a_n}\sum\limits_{i = 1}^n {5^{i - 1}}
\end{align}
$$可以通过预先计算$a_i$前各项系数$\sum\limits_{j = 0}^i {5^{i - 1}}$然后从最大的项开始对$f(x)=K$取模，找出是否存在符合$0 \le a_i \le 4$约束的$a_i$，如果不存在即说明这个$K$并不在$f(x)$的值域，返回0</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preimageSizeFZF</span><span class="params">(self, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=int(math.floor(math.log(<span class="number">10</span>**<span class="number">9</span>/<span class="number">4</span>,<span class="number">5</span>)))+<span class="number">1</span></span><br><span class="line">        coef=[sum([<span class="number">5</span>**j <span class="keyword">for</span> j <span class="keyword">in</span> range(n-i)]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coef:</span><br><span class="line">            <span class="keyword">if</span> K/c &gt;=<span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            K%=c</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>我在上面的分析中始终没有提到这个最高次$n$如何确定，根据公式来看$${5^n}{a_n} \le K$$那么简单地取一个<code>K/4</code>在5为底的对数取整，当然这只是<code>n</code>的大小，实际多项式的项数为<code>n+1</code>，那么容易得出算法的时间度为$o(n)$，我在实现上使用了列表存放系数所以空间复杂度$o(n)$，实际上$o(1)$足够。当然我为了避免计算<code>K</code>在边界和零点的各种复杂情况，为了快速把题先做出来，直接按照<code>K</code>的最大值<code>10^9</code>放进去算了，好在数据不大，代码中的<code>n</code>（实际上是<code>n+1</code>）只有13而已。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-74/" data-id="cjuh9fxax0034u0w3c5uum4yt" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-73" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-73/">LeetCode Weekly Contest 73</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-73/" class="article-date"><time datetime="2018-02-25T15:29:39.742Z" itemprop="datePublished">2018-02-25</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>感谢每一个看到这里的读者的关注，总之这周我过的非常高兴hhhhh，是的，虽然我本质的失败人士身份没改变，但这周真的特别幸福，与周赛本身无关。这周的题整体并不难，主要也是偏重算法（或许叫算术更好）</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-73/</p>
<h2>Rotated Digits</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/rotated-digits/</p>
<blockquote>
<p>X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number.</p>
</blockquote>
<blockquote>
<p>Now given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">There are four good numbers in the range [1, 10] : 2, 5, 6, 9.</span><br><span class="line">Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>N</code>  will be in range <code>[1, 10000]</code>.</li>
</ol>
<p>各个位数为<code>0,1,8,2,5,6,9</code>且不全为<code>0,1,8</code>即符合要求，我我没文化就直接转成字符串上去直接做了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotatedDigits</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        valid_set_self=[<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'8'</span>]</span><br><span class="line">        valid_set_diff=[<span class="string">'2'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'9'</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> all([(i <span class="keyword">in</span> valid_set_self) <span class="keyword">for</span> i <span class="keyword">in</span> str(num)]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> all([(i <span class="keyword">in</span> valid_set_self+valid_set_diff) <span class="keyword">for</span> i <span class="keyword">in</span> str(num)]):</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(N)$</p>
<h2>Escape The Ghosts</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/escape-the-ghosts/</p>
<blockquote>
<p>You are playing a simplified Pacman game. You start at the point <code>(0, 0)</code>, and your destination is <code>(target[0], target[1])</code>. There are several ghosts on the map, the i-th ghost starts at <code>(ghosts[i][0], ghosts[i][1])</code>.</p>
</blockquote>
<blockquote>
<p>Each turn, you and all ghosts simultaneously <em>may</em> move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.</p>
</blockquote>
<blockquote>
<p>You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.</p>
</blockquote>
<blockquote>
<p>Return True if and only if it is possible to escape.</p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">ghosts = [[1, 0], [0, 3]]</span><br><span class="line">target = [0, 1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">ghosts = [[1, 0]]</span><br><span class="line">target = [2, 0]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line">Input:</span><br><span class="line">ghosts = [[2, 0]]</span><br><span class="line">target = [1, 0]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The ghost can reach the target at the same time as you.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>All points have coordinates with absolute value &lt;= <code>10000</code>.</li>
<li>The number of ghosts will not exceed <code>100</code>.</li>
</ol>
<p>理解题意要考虑的是<code>ghost</code>在所有方向运动，而玩家需要在所有的可能性下找到一条不遇上<code>ghost</code>就到达终点的路。但这里并不适用任何寻路算法，要考虑的只有是不是有<code>ghost</code>比你离终点更近，只要它更近就可以在到达终点之后折回到你去终点的路。根据游戏的移动路径这里的“近”指的是Manhattan距离。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">escapeGhosts</span><span class="params">(self, ghosts, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type ghosts: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m=abs(target[<span class="number">0</span>])+abs(target[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> ghosts:</span><br><span class="line">            <span class="keyword">if</span> abs(x-target[<span class="number">0</span>])+abs(y-target[<span class="number">1</span>])&lt;=m:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n)$，这里的<code>n</code>指<code>ghost</code>的数量。</p>
<h2>Custom Sort String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/custom-sort-string/</p>
<blockquote>
<p><code>S</code> and <code>T</code> are strings composed of lowercase letters. In <code>S</code>, no letter occurs more than once.</p>
</blockquote>
<blockquote>
<p><code>S</code> was sorted in some custom order previously. We want to permute the characters of <code>T</code> so that they match the order that <code>S</code> was sorted. More specifically, if <code>x</code> occurs before <code>y</code> in <code>S</code>, then <code>x</code> should occur before <code>y</code> in the returned string.</p>
</blockquote>
<blockquote>
<p>Return any permutation of <code>T</code> (as a string) that satisfies this property.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">S = &quot;cba&quot;</span><br><span class="line">T = &quot;abcd&quot;</span><br><span class="line">Output: &quot;cbad&quot;</span><br><span class="line">Explanation:</span><br><span class="line">&quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;.</span><br><span class="line">Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> has length at most <code>26</code>, and no character is repeated in <code>S</code>.</li>
<li><code>T</code> has length at most <code>200</code>.</li>
<li><code>S</code> and <code>T</code> consist of lowercase letters only.</li>
</ol>
<p>没什么好说的，我本人没文化，也不太会写什么排序，直接就在<code>sorted</code>的<code>key</code>参数上指定按照<code>S</code>的索引值排序了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">customSortString</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(sorted(list(T),key=<span class="keyword">lambda</span> c: S.index(c) <span class="keyword">if</span> c <span class="keyword">in</span> S <span class="keyword">else</span> len(T)))</span><br></pre></td></tr></table></figure></p>
<p>显然时间复杂度就是<code>sorted</code>函数本身的$o(n \log n)$</p>
<p>如果真的按照题意用比较naive的方法去做的话，也是同理，元素的key值按照<code>S</code>去写排序算法，不过排序算法的复杂度天花板就是这样了，我暂时也没想到什么特别好的方法。</p>
<h2>Domino and Tromino Tiling</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-73/problems/domino-and-tromino-tiling/</p>
<blockquote>
<p>We have two types of tiles: a 2x1 domino shape, and an &quot;L&quot; tromino shape. These shapes may be rotated.</p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XX  &lt;- domino</span><br><span class="line"></span><br><span class="line">XX  &lt;- &quot;L&quot; tromino</span><br><span class="line">X</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p>(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The five different ways are listed below, different letters indicates different tiles:</span><br><span class="line">XYZ XXZ XYY XXY XYY</span><br><span class="line">XYZ YYZ XZZ XYY XXY</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>N  will be in range <code>[1, 1000]</code>.</li>
</ol>
<p>很典型的动态规划，递推式<code>dp[n]=2*dp[n-1]+dp[n-3]</code>的推导可以见<a href="https://leetcode.com/problems/domino-and-tromino-tiling/discuss/116664/Schematic-explanation-of-two-equivalent-DP-recurrence-formula" target="_blank" rel="noopener">这个讨论</a>，周赛为了赶时间先xjb写提交上了再说</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilings</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">        m=<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        dp=[<span class="number">0</span>]*N</span><br><span class="line">        dp[<span class="number">0</span>],dp[<span class="number">1</span>],dp[<span class="number">2</span>]=<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,N):</span><br><span class="line">            dp[i]=(<span class="number">2</span>*dp[i<span class="number">-1</span>]+dp[i<span class="number">-3</span>])%m</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度都为$o(N)$，但是正如我之前所说，这种一维的索引差值不大的动态规划，不需要额外浪费空间，3个变量迭代着也行。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-73/" data-id="cjuh9fxat0032u0w3kvb10ipt" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-72" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-72/">LeetCode Weekly Contest 72</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-72/" class="article-date"><time datetime="2018-02-18T13:01:08.646Z" itemprop="datePublished">2018-02-18</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新年快乐！这几天都会在图书馆专心学习，直到天气回暖吧。因为之前的不学无术不但坑了自己，也给别人带来了困扰。我不会再犯相同的错误了，我将专注学习和输出一些真正有价值的东西。</p>
<p>&lt;!-- more --&gt;</p>
<p>https://leetcode.com/contest/weekly-contest-72/</p>
<h2>Letter Case Permutation</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/letter-case-permutation/</p>
<blockquote>
<p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a1b2&quot;</span><br><span class="line">Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">Input: S = &quot;3z4&quot;</span><br><span class="line">Output: [&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class="line"></span><br><span class="line">Input: S = &quot;12345&quot;</span><br><span class="line">Output: [&quot;12345&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> will be a string with length at most <code>12</code>.</li>
<li><code>S</code> will consist only of letters or digits.</li>
</ol>
<p>思路很简单，遍历字符串找到字母然后将所有已有结果进行该字母大小写的转换再放入结果，所以最后返回的列表长度必然为<code>2^n</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res=[S]</span><br><span class="line">        <span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            <span class="keyword">if</span> c.isalpha():</span><br><span class="line">                temp=[]</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">                    base=s[:i]+c.swapcase()+s[i+<span class="number">1</span>:] <span class="keyword">if</span> i&lt;len(S) <span class="keyword">else</span> s[:i]+c.swapcase()</span><br><span class="line">                    temp.append(base)</span><br><span class="line">                res+=temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>在最坏情况下，时间复杂度为$o(n)$，空间复杂度为$o(2^n)$</p>
<h2>Is Graph Bipartite?</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/is-graph-bipartite/</p>
<blockquote>
<p>Given a <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
</blockquote>
<blockquote>
<p>Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
</blockquote>
<blockquote>
<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists.  Each node is an integer between <code>0</code> and <code>graph.length - 1</code>.  There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn't contain any element twice.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent ubsets.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>graph</code> will have length in range <code>[1, 100]</code>.</li>
<li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li>
<li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li>
</ol>
<p>注意一下<code>graph</code>实际上是一个邻接表而非边集。可以尝试用DFS标记节点，将相邻节点标记为两个不同的集合。没有必要纠结新访问的根结点放到哪个集合，实际上是等价的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(graph)</span><br><span class="line">        color=[<span class="number">-1</span>]*n</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">                <span class="keyword">if</span> color[i]==color[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> color[j]&lt;<span class="number">0</span>:</span><br><span class="line">                    color[j]=<span class="number">1</span>-color[i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dfs(j):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> color[i]&lt;<span class="number">0</span>:</span><br><span class="line">                color[i]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度与边数线性相关，空间复杂度与节点数线性相关。</p>
<h2>Cheapest Flights Within K Stops</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/cheapest-flights-within-k-stops/</p>
<blockquote>
<p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u</code> and arrives at <code>v</code> with a price w.</p>
</blockquote>
<blockquote>
<p>Now given all the cities and fights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 1</span><br><span class="line">Output: 200</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png" alt="">
<strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 0</span><br><span class="line">Output: 500</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes <code>n</code> will be in range <code>[1, 100]</code>, with nodes labeled from <code>0</code> to <code>n - 1</code>.</li>
<li>The size of <code>flights</code> will be in range <code>[0, n * (n - 1) / 2]</code>.</li>
<li>The format of each flight will be <code>(src, dst, price)</code>.</li>
<li>The price of each flight will be in the range <code>[1, 10000]</code>.</li>
<li><code>k</code> is in the range of <code>[0, n - 1]</code>.</li>
<li>There will not be any duplicated flights or self cycles.</li>
</ol>
<p>非常典型的单源最短路径，我们没文化的人就直接用Dijkstra算法解决了，增加一个字段去记录源结点到当前结点经过的结点数，第一次取出最近的结点为目标结点且经过的结点数小于<code>K</code>即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n, flights, src, dst, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type flights: List[List[int]]</span></span><br><span class="line"><span class="string">        :type src: int</span></span><br><span class="line"><span class="string">        :type dst: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        h=[(<span class="number">0</span>,src,<span class="number">0</span>)]</span><br><span class="line">        d=dict(&#123;src:<span class="number">0</span>&#125;)</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            dist,node,p=heapq.heappop(h)</span><br><span class="line">            <span class="keyword">if</span> node==dst <span class="keyword">and</span> p&lt;=K+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> dist</span><br><span class="line">            <span class="keyword">for</span> [i,j,price] <span class="keyword">in</span> flights:</span><br><span class="line">                <span class="keyword">if</span> i==node:</span><br><span class="line">                    <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> d <span class="keyword">or</span> d[j]&gt;d[i]+price:</span><br><span class="line">                        d[j]=d[i]+price</span><br><span class="line">                        heapq.heappush(h,(d[j],j,p+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n \log n)$，空间复杂度为$o(n)$</p>
<h2>K-th Smallest Prime Fraction</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-72/problems/k-th-smallest-prime-fraction/</p>
<blockquote>
<p>A sorted list <code>A</code> contains 1, plus some number of primes.  Then, for every p &lt; q in the list, we consider the fraction p/q.</p>
</blockquote>
<blockquote>
<p>What is the <code>K</code>-th smallest fraction considered?  Return your answer as an array of ints, where <code>answer[0] = p</code> and <code>answer[1] = q</code>.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1, 2, 3, 5], K = 3</span><br><span class="line">Output: [2, 5]</span><br><span class="line">Explanation:</span><br><span class="line">The fractions to be considered in sorted order are:</span><br><span class="line">1/5, 1/3, 2/5, 1/2, 3/5, 2/3.</span><br><span class="line">The third fraction is 2/5.</span><br><span class="line"></span><br><span class="line">Input: A = [1, 7], K = 1</span><br><span class="line">Output: [1, 7]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>A</code> will have length between <code>2</code> and <code>2000</code>.</li>
<li>Each <code>A[i]</code> will be between <code>1</code> and <code>30000</code>.</li>
<li><code>K</code> will be between <code>1</code> and<code>A.length * (A.length + 1) / 2</code>.</li>
</ol>
<p>参考<a href="https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115538/Python-solution-using-Binary-Search" target="_blank" rel="noopener">Python solution using Binary Search</a>提到的二分查找策略。<code>A</code>是有序列表，找到<code>A[i]/m</code>在<code>A</code>中的插入位置，在<code>A[i]/m</code>右边的<code>A</code>的元素<code>A[j]</code>，因为有<code>A[i]/m &lt; A[j]</code>，所以<code>A[i]/A[j] &lt; m</code>,那么<code>border</code>求和得到的<code>cur</code>就是小于<code>m</code>的分数的个数，使用二分法不断调整<code>m</code>的大小使之接近最后想要的那个分数。最后，当<code>cur==K</code>时，恰好有<code>K</code>个<code>A[i]/A[j] &lt; m</code>，<code>border</code>中的元素<code>j</code>即为对于每个<code>i</code>来说满足<code>A[i]/A[j] &lt; m</code>时<code>A[i]/A[j]</code>最大的值，那么找到最大的那个<code>A[i]/A[j]</code>就是找到了第<code>K</code>个分数。至于实现的问题，因为题中已经保证了<code>A</code>中元素不重复，所以不需要另外考虑<code>bisect</code>的方向，以及最后注意一下精度问题，<code>l,r,m</code>都是<code>[0,1]</code>之间的数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallestPrimeFraction</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l, r, N = <span class="number">0</span>, <span class="number">1</span>, len(A)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            m = (l + r) / <span class="number">2.0</span></span><br><span class="line">            border = [bisect.bisect(A, A[i] / m) <span class="keyword">for</span> i <span class="keyword">in</span> range(N)]</span><br><span class="line">            cur = sum(N - i <span class="keyword">for</span> i <span class="keyword">in</span> border)</span><br><span class="line">            <span class="keyword">if</span> cur &gt; K:</span><br><span class="line">                r = m</span><br><span class="line">            <span class="keyword">elif</span> cur &lt; K:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> max([(A[i], A[j]) <span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(border) <span class="keyword">if</span> j &lt; N], key=<span class="keyword">lambda</span> x: float(x[<span class="number">0</span>]) / x[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>除了二分查找以外，比较典型的解法如优先队列可以参阅<a href="https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115531/C++-9lines-priority-queue" target="_blank" rel="noopener">其他讨论</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-72/" data-id="cjuh9fxao0030u0w308yge4hz" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-71" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-71/">LeetCode Weekly Contest 71</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-71/" class="article-date"><time datetime="2018-02-11T10:34:39.539Z" itemprop="datePublished">2018-02-11</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>预祝各位新春快乐！今天本来在图书馆准备打的周赛，结果做完三道题后赶上午休，被管理员轰出去了。作为码渣正好借口休息，我心也是够大的直接出去吃饭了（我是反面教材，请大家不要有样学样），剩下那道等回来继续做。整体不难，不涉及什么特别复杂的算法。</p>
<p>https://leetcode.com/contest/weekly-contest-71/</p>
<p>提醒一下大家想跟着水周赛的，千万不要忘记提前Register，我不知道是我穷疯了还是LeetCode穷疯了，周赛题都开始突然收费了，不想花钱的话只能保证每周都要Register一下，哪怕Register了以后当天没完成，一周内还是可以免费做的。<s>我们穷人就是这个样子的，不服请打钱</s></p>
<p>&lt;!-- more --&gt;</p>
<h2>Minimum Distance Between BST Nodes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-71/problems/minimum-distance-between-bst-nodes/</p>
<blockquote>
<p>Given a Binary Search Tree (BST) with the root node <code>root</code>, return the minimum difference between the values of any two different nodes in the tree.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong> :
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,6,1,3,null,null]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Note that root is a TreeNode object, not an array.</span><br><span class="line"></span><br><span class="line">The given tree [4,2,6,1,3,null,null] is represented by the following diagram:</span><br><span class="line"></span><br><span class="line">          4</span><br><span class="line">        /   \</span><br><span class="line">      2      6</span><br><span class="line">     / \    </span><br><span class="line">    1   3  </span><br><span class="line"></span><br><span class="line">while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The size of the BST will be between <code>2</code> and <code>100</code>.</li>
<li>The BST is always valid, each node's value is an integer, and each node's value is different.</li>
</ol>
<p>我思维比较Naive，直接中序遍历，然后找相邻数之间的最小差值</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDiffInBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vals=[]</span><br><span class="line">        res=sys.maxint</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                in_order(root.left)</span><br><span class="line">                vals.append(root.val)</span><br><span class="line">                in_order(root.right)</span><br><span class="line"></span><br><span class="line">        in_order(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(vals)<span class="number">-1</span>):</span><br><span class="line">            res=min(res,vals[i+<span class="number">1</span>]-vals[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>显然时间和空间复杂度都是$o(n)$，当然一开始我想的是先找每个结点的左子树的最大值和右子树的最小值，与结点值比较，递归找出最小差值，但想想写起来麻烦，赶时间就用了上面简单粗暴的笨办法。</p>
<h2>Rabbits in Forest</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-71/problems/rabbits-in-forest/</p>
<blockquote>
<p>In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those <code>answers</code> are placed in an array.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of rabbits that could be in the forest.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: answers = [1, 1, 2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The two rabbits that answered &quot;1&quot; could both be the same color, say red.</span><br><span class="line">The rabbit than answered &quot;2&quot; can&apos;t be red or the answers would be inconsistent.</span><br><span class="line">Say the rabbit that answered &quot;2&quot; was blue.</span><br><span class="line">Then there should be 2 other blue rabbits in the forest that didn&apos;t answer into the array.</span><br><span class="line">The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&apos;t.</span><br><span class="line"></span><br><span class="line">Input: answers = [10, 10, 10]</span><br><span class="line">Output: 11</span><br><span class="line"></span><br><span class="line">Input: answers = []</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>answers</code> will have length at most <code>1000</code>.</li>
<li>Each <code>answers[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<p>先考虑一个情况即有13只兔子声称有其他13只兔子和它自己同色，很显然我们知道这里面至少有1只和其他12只是不同色的，这里面至少有2种毛色和14只兔子。假设有<code>r</code>只兔子都说除了自己以外还有<code>nums</code>只兔子和自己同色，那么这里至少有<code>(r-1)/(nums+1)+1</code>种毛色，每种至少有<code>nums+1</code>只兔子，说出不同<code>nums</code>的兔子们又必然不同色，所以很容易有
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRabbits</span><span class="params">(self, answers)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type answers: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        <span class="keyword">return</span> sum([(int((r<span class="number">-1</span>)/(nums+<span class="number">1</span>))+<span class="number">1</span>)*(nums+<span class="number">1</span>) <span class="keyword">for</span> (nums,r) <span class="keyword">in</span> collections.Counter(answers).items()])</span><br></pre></td></tr></table></figure></p>
<p>时间和空间代价也是线性的。</p>
<h2>Reaching Points</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-71/problems/reaching-points/</p>
<blockquote>
<p>A move consists of taking a point <code>(x, y)</code> and transforming it to either <code>(x, x+y)</code> or <code>(x+y, y)</code>.</p>
</blockquote>
<blockquote>
<p>Given a starting point <code>(sx, sy)</code> and a target point <code>(tx, ty)</code>, return True if and only if a sequence of moves exists to transform the point <code>(sx, sy)</code> to <code>(tx, ty)</code>. Otherwise, return <code>False</code>.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: sx = 1, sy = 1, tx = 3, ty = 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">One series of moves that transforms the starting point to the target is:</span><br><span class="line">(1, 1) -&gt; (1, 2)</span><br><span class="line">(1, 2) -&gt; (3, 2)</span><br><span class="line">(3, 2) -&gt; (3, 5)</span><br><span class="line"></span><br><span class="line">Input: sx = 1, sy = 1, tx = 2, ty = 2</span><br><span class="line">Output: False</span><br><span class="line"></span><br><span class="line">Input: sx = 1, sy = 1, tx = 1, ty = 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>sx, sy, tx, ty</code> will all be integers in the range <code>[1, 10^9]</code>.</li>
</ol>
<p>想清楚以后解法本身不难，我是一开始直接用递归辗转相减，但这会超过递归的最大深度，于是我改成迭代，增加了<code>tx==sx</code>和<code>ty==sy</code>时直接判断<code>(ty-sy)</code>和<code>(tx-sx)</code>语句以后可以通过：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachingPoints</span><span class="params">(self, sx, sy, tx, ty)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type sx: int</span></span><br><span class="line"><span class="string">        :type sy: int</span></span><br><span class="line"><span class="string">        :type tx: int</span></span><br><span class="line"><span class="string">        :type ty: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        <span class="keyword">while</span> tx&gt;<span class="number">0</span> <span class="keyword">and</span> ty&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> tx==sx <span class="keyword">and</span> ty==sy:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> tx==sx: <span class="comment">#cut down runtime for special cases</span></span><br><span class="line">                <span class="keyword">return</span> ty&gt;sy <span class="keyword">and</span> (ty-sy)%sx==<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> ty==sy:</span><br><span class="line">                <span class="keyword">return</span> tx&gt;sx <span class="keyword">and</span> (tx-sx)%sy==<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> tx&gt;ty:</span><br><span class="line">                tx-=ty</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ty-=tx</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(\max \left( {tx,ty} \right))$，空间复杂度为$o(1)$</p>
<h2>Transform to Chessboard</h2>
<p>原题地址 https://leetcode.com/problems/transform-to-chessboard/description/</p>
<blockquote>
<p>An N x N <code>board</code> contains only <code>0</code>s and <code>1</code>s. In each move, you can swap any <code>2</code> rows with each other, or any 2 columns with each other.</p>
</blockquote>
<blockquote>
<p>What is the minimum number of moves to transform the board into a &quot;chessboard&quot; - a board where no <code>0</code>s and no <code>1</code>s are 4-directionally adjacent? If the task is impossible, return -1.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">One potential sequence of moves is shown below, from left to right:</span><br><span class="line"></span><br><span class="line">0110     1010     1010</span><br><span class="line">0110 --&gt; 1010 --&gt; 0101</span><br><span class="line">1001     0101     1010</span><br><span class="line">1001     0101     0101</span><br><span class="line"></span><br><span class="line">The first move swaps the first and second column.</span><br><span class="line">The second move swaps the second and third row.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board = [[0, 1], [1, 0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">Also note that the board with 0 in the top left corner,</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">is also a valid chessboard.</span><br><span class="line"></span><br><span class="line">Input: board = [[1, 0], [1, 0]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">No matter what sequence of moves you make, you cannot end with a valid chessboard.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board</code> will have the same number of rows and columns, a number in the range <code>[2, 30]</code>.</li>
<li><code>board[i][j]</code> will be only <code>0</code>s or <code>1</code>s.</li>
</ol>
<p>直接参考<a href="https://leetcode.com/problems/transform-to-chessboard/discuss/114843/Key-Observation-on-property-of-ChessBoard" target="_blank" rel="noopener">这个讨论</a>提出的关键点，注意一下奇偶。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movesToChessboard</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(board)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (board[<span class="number">0</span>][<span class="number">0</span>]^board[<span class="number">0</span>][i])^(board[j][<span class="number">0</span>]^board[j][i]):</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum(board[<span class="number">0</span>])&lt;n/<span class="number">2</span> <span class="keyword">or</span> sum(board[<span class="number">0</span>])&gt;n/<span class="number">2</span>+n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n/<span class="number">2</span>&lt;=sum(board[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n))&lt;=n/<span class="number">2</span>+n%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        c=sum(board[<span class="number">0</span>][i]==i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">        r=sum(board[i][<span class="number">0</span>]==i%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> c%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                c=n-c</span><br><span class="line">            <span class="keyword">if</span> r%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                r=n-r</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c=min(n-c,c)</span><br><span class="line">            r=min(n-r,r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (r+c)/<span class="number">2</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-71/" data-id="cjuh9fxag002wu0w35gw07ecc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-70" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-70/">LeetCode Weekly Contest 70</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-70/" class="article-date"><time datetime="2018-02-04T13:06:59.544Z" itemprop="datePublished">2018-02-04</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>又是新的一周，希望各位安好。最近生病，写的可能有点慢，之前欠的债也要慢慢补上，各位见谅。直接看题。</p>
<p>https://leetcode.com/contest/weekly-contest-70/</p>
<p>&lt;!-- more --&gt;</p>
<h2>K-th Symbol in Grammar</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-70/problems/k-th-symbol-in-grammar/</p>
<blockquote>
<p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code> with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p>
</blockquote>
<blockquote>
<p>Given row <code>N</code> and index <code>K</code>, return the K-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Input: N = 2, K = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: N = 4, K = 5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">row 1: 0</span><br><span class="line">row 2: 01</span><br><span class="line">row 3: 0110</span><br><span class="line">row 4: 01101001</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li>
<li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li>
</ol>
<p>上来直接难度分类为<code>Medium</code>有点吓人，但实际这题没有<code>Medium</code>的难度。你可以把这种数据结构理解成类似二叉树的东西，每一行都是一层第<code>N</code>层有<code>2**(N-1)</code>个结点。求深度为<code>N</code>的树第<code>K</code>个叶结点上的元素？很直接的就想到递归了：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthGrammar</span><span class="params">(self, N, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span> <span class="keyword">and</span> K==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> K&gt;<span class="number">2</span>**(N<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>-self.kthGrammar(N<span class="number">-1</span>,K<span class="number">-2</span>**(N<span class="number">-2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.kthGrammar(N<span class="number">-1</span>,K)</span><br></pre></td></tr></table></figure></p>
<p>递归的深度为$o(N)$，所以这个方法明显是关于$N$线性时间复杂度的。</p>
<h2>Swap Adjacent in LR String</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-70/problems/swap-adjacent-in-lr-string/</p>
<blockquote>
<p>In a string composed of <code>'L'</code>, <code>'R'</code>, and <code>'X'</code> characters, like <code>&quot;RXXLRXRXL&quot;</code>, a move consists of either replacing one occurrence of <code>&quot;XL&quot;</code> with <code>&quot;LX&quot;</code>, or replacing one occurrence of <code>&quot;RX&quot;</code> with &quot;<code>XR&quot;</code>. Given the starting string <code>start</code> and the ending string <code>end</code>, return True if and only if there exists a sequence of moves to transform one string to the other.</p>
</blockquote>
<blockquote>
<p><strong>Example</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">We can transform start to end following these steps:</span><br><span class="line">RXXLRXRXL -&gt;</span><br><span class="line">XRXLRXRXL -&gt;</span><br><span class="line">XRLXRXRXL -&gt;</span><br><span class="line">XRLXXRRXL -&gt;</span><br><span class="line">XRLXXRRLX</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>.</li>
<li>Both <code>start</code> and <code>end</code> will only consist of characters in <code>{'L', 'R', 'X'}</code>.</li>
</ol>
<p>对于<code>start</code>中的<code>L</code>可以通过<code>XL</code>$\to$<code>LX</code>操作进行左移，<code>R</code>可以通过<code>RX</code>$\to$<code>XR</code>操作进行右移，前提是<code>L</code>的左边和<code>R</code>的右边都全是<code>X</code>，<code>L</code>和<code>R</code>的相对次序不能改变。所以可以提取<code>start</code>和<code>end</code>中的所有<code>L</code>和<code>R</code>，保证相对次序上的<code>L</code>和<code>R</code>数量一致，<code>start</code>中的<code>L</code>相对<code>end</code>中的<code>L</code>可以相对左移一些，同理，<code>start</code>中的<code>R</code>相对<code>end</code>中的<code>R</code>可以相对右移一些。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s_lr=[(i,c) <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(start) <span class="keyword">if</span> c!=<span class="string">'X'</span>]</span><br><span class="line">        e_lr=[(i,c) <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(end) <span class="keyword">if</span> c!=<span class="string">'X'</span>]</span><br><span class="line">        <span class="keyword">if</span> len(s_lr)!=len(e_lr):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> ((s_i,s_c),(e_i,e_c)) <span class="keyword">in</span> zip(s_lr,e_lr):</span><br><span class="line">            <span class="keyword">if</span> s_c!=e_c:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s_c==<span class="string">'L'</span> <span class="keyword">and</span> s_i&lt;e_i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s_c==<span class="string">'R'</span> <span class="keyword">and</span> s_i&gt;e_i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>时间和空间复杂度都为$o(N)$，当然相同的思路<a href="https://discuss.leetcode.com/topic/119538/python-simple-solution-3-lines-o-n" target="_blank" rel="noopener">这位</a>写的比我好的多，建议直接看这位的解法。</p>
<h2>Swim in Rising Water</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-70/problems/swim-in-rising-water/</p>
<blockquote>
<p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i,j)</code>.</p>
</blockquote>
<blockquote>
<p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>
</blockquote>
<blockquote>
<p>You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,2],[1,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">At time 0, you are in grid location (0, 0).</span><br><span class="line">You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.</span><br><span class="line"></span><br><span class="line">You cannot reach point (1, 1) until time 3.</span><br><span class="line">When the depth of water is 3, we can swim anywhere inside the grid.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]</span><br><span class="line">Output: 16</span><br><span class="line">Explanation:</span><br><span class="line"> 0  1  2  3  4</span><br><span class="line">24 23 22 21  5</span><br><span class="line">12 13 14 15 16</span><br><span class="line">11 17 18 19 20</span><br><span class="line">10  9  8  7  6</span><br><span class="line"></span><br><span class="line">The final route is marked in bold.</span><br><span class="line">We need to wait until time 16 so that (0, 0) and (4, 4) are connected.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= N &lt;= 50</code>.</li>
<li><code>grid[i][j]</code> is a permutation of <code>[0, ..., N*N - 1]</code>.</li>
</ol>
<p>读题觉得有点被水淹没不知所措的感觉，差不多说的是在<code>t</code>时刻能经过的位置只有值小于等于<code>t</code>的位置。需要做的是找到<code>(0,0)-&gt;(N-1,N-1)</code>途经结点最大值最小的路径。直觉上可以采用类似于Dijkstra的贪心特性的寻路算法，一步步根据前驱结点找下一个代价最小的结点，直到触及<code>(N-1,N-1)</code>为止：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N=len(grid)</span><br><span class="line">        seen=&#123;(<span class="number">0</span>,<span class="number">0</span>)&#125;</span><br><span class="line">        h=[(grid[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            d,r,c=heapq.heappop(h)</span><br><span class="line">            res=max(res,d)</span><br><span class="line">            <span class="keyword">if</span> r==c==N<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> (dx,dy) <span class="keyword">in</span> [(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=r+dx&lt;N <span class="keyword">and</span> <span class="number">0</span>&lt;=c+dy&lt;N <span class="keyword">and</span> (r+dx,c+dy) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    heapq.heappush(h,(grid[r+dx][c+dy],r+dx,c+dy))</span><br><span class="line">                    seen.add((r+dx,c+dy))</span><br></pre></td></tr></table></figure></p>
<p>在最坏的情况需要遍历所有结点，再加上堆排序，时间复杂度为$o(N^2 \log N)$，空间复杂度为$o(N^2)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-70/" data-id="cjuh9fxal002yu0w3l3mlwzx0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-69" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-69/">LeetCode Weekly Contest 69</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-69/" class="article-date"><time datetime="2018-01-28T12:28:32.280Z" itemprop="datePublished">2018-01-28</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>新的一周又开始了，祝大家愉快。上周因为我个人原因坑没填完，这周的题写完我一起补上，谢谢体谅。</p>
<p>https://leetcode.com/contest/weekly-contest-69/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Jewels and Stones</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-69/problems/jewels-and-stones/</p>
<blockquote>
<p>You're given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.  Each character in <code>S</code> is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p>
</blockquote>
<blockquote>
<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.
The characters in <code>J</code> are distinct.</li>
</ol>
<p>没什么好说的，题目很直接，我也就瞎姬儿写了一个通过了</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numJewelsInStones</span><span class="params">(self, J, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type J: str</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len([<span class="number">1</span> <span class="keyword">for</span> s <span class="keyword">in</span> S <span class="keyword">if</span> s <span class="keyword">in</span> J])</span><br></pre></td></tr></table></figure></p>
<h2>Global and Local Inversions</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-69/problems/global-and-local-inversions/</p>
<blockquote>
<p>We have some permutation <code>A</code> of <code>[0, 1, ..., N - 1]</code>, where <code>N</code> is the length of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>The number of (global) inversions is the number of <code>i &lt; j</code> with <code>0 &lt;= i &lt; j &lt; N</code> and <code>A[i] &gt; A[j]</code>.</p>
</blockquote>
<blockquote>
<p>The number of local inversions is the number of <code>i</code> with <code>0 &lt;= i &lt; N</code> and <code>A[i] &gt; A[i+1]</code>.</p>
</blockquote>
<blockquote>
<p>Return true if and only if the number of global inversions is equal to the number of local inversions.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,0,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is 1 global inversion, and 1 local inversion.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,0]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are 2 global inversions, and 1 local inversion.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>A will be a permutation of <code>[0, 1, ..., A.length - 1]</code>.</li>
<li>A will have length in range <code>[1, 5000]</code>.</li>
<li>The time limit for this problem has been reduced.</li>
</ol>
<p>注意<code>A</code>是一个<code>[0,n]</code>的排列，所以判断<code>A</code>中的元素能否与其他元素构成一个inversion只要看下标<code>i</code>和元素值<code>num</code>是否相等，而local inversion只要看<code>num</code>和<code>i</code>的绝对差值是否为1，所以可以写成：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIdealPermutation</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> (i,num) <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            <span class="keyword">if</span> abs(i-num)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>只需要线性的时间和常数的空间，容易通过。</p>
<h2>Sliding Puzzle</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-69/problems/sliding-puzzle/</p>
<blockquote>
<p>On a 2x3 <code>board</code>, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.</p>
</blockquote>
<blockquote>
<p>A move consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>
</blockquote>
<blockquote>
<p>The state of the board is solved if and only if the <code>board</code> is <code>[[1,2,3],[4,5,0]]</code>.</p>
</blockquote>
<blockquote>
<p>Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.</p>
</blockquote>
<blockquote>
<p><strong>Examples</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[1,2,3],[4,0,5]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Swap the 0 and the 5 in one move.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[1,2,3],[5,4,0]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: No number of moves will make the board solved.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[4,1,2],[5,0,3]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 5 is the smallest number of moves that solves the board.</span><br><span class="line">An example path:</span><br><span class="line">After move 0: [[4,1,2],[5,0,3]]</span><br><span class="line">After move 1: [[4,1,2],[0,5,3]]</span><br><span class="line">After move 2: [[0,1,2],[4,5,3]]</span><br><span class="line">After move 3: [[1,0,2],[4,5,3]]</span><br><span class="line">After move 4: [[1,2,0],[4,5,3]]</span><br><span class="line">After move 5: [[1,2,3],[4,5,0]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[3,2,4],[1,5,0]]</span><br><span class="line">Output: 14</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board</code> will be a 2 x 3 array as described above.</li>
<li><code>board[i][j]</code> will be a permutation of <code>[0, 1, 2, 3, 4, 5]</code></li>
</ol>
<p>一开始我是想试试和<a href="https://discuss.leetcode.com/topic/118671/simple-python-solution-using-a-search" target="_blank" rel="noopener">这位</a>一样用A*搜索，也算学习一个新的启发式方法，关于这个方法的简单介绍和直观演示可以见<a href="http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html" target="_blank" rel="noopener">Introduction to A*</a>，简单来说相比经典Dijkstra算法，每轮寻找最小距离结点时，会在原有的到源点距离的基础上增加一个heuristic score值，在这里这个值是用每个被编号的Puzzle块的最终位置和当前位置的坐标差之和。但是这里计算heuristic score过于麻烦，这个值的引入也没给原有算法的性能带来显著的性能提升，所以我还是选择就用经典Dijkstra算法做了：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slidingPuzzle</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        goal=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>]]</span><br><span class="line">        seen=[board]</span><br><span class="line">        h=[(<span class="number">0</span>,board)]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_neighbors</span><span class="params">(d,b)</span>:</span></span><br><span class="line">            r,c=(<span class="number">0</span>,b[<span class="number">0</span>].index(<span class="number">0</span>)) <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> b[<span class="number">0</span>] <span class="keyword">else</span> (<span class="number">1</span>,b[<span class="number">1</span>].index(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;= r+dx &lt;<span class="number">2</span> <span class="keyword">and</span> <span class="number">0</span>&lt;=c+dy&lt;<span class="number">3</span>:</span><br><span class="line">                    temp=copy.deepcopy(b)</span><br><span class="line">                    temp[r+dx][c+dy],temp[r][c]=temp[r][c],temp[r+dx][c+dy]</span><br><span class="line">                    <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        seen.append(temp)</span><br><span class="line">                        heapq.heappush(h,(d+<span class="number">1</span>,temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            d,b=heapq.heappop(h)</span><br><span class="line">            <span class="keyword">if</span> b==goal:</span><br><span class="line">                <span class="keyword">return</span> d</span><br><span class="line">            get_neighbors(d,b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>时空复杂度都与结点数相关，最坏情况为Puzzle块数n的排列数即$o(n!)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-69/" data-id="cjuh9fxae002uu0w344tugnse" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/7/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-number" href="/page/7/">7</a></li><li class="active"><span class="page-number">8</span></li><li><a class="page-number" href="/page/9/">9</a></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/9/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
