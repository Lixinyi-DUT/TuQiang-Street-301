<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-132" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-132/" class="article-date"><time datetime="2019-04-14T16:58:05.439Z" itemprop="datePublished">2019-04-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-132</p>
<p>&lt;!-- more --&gt;</p>
<h2>Divisor Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-132/problems/divisor-game/</p>
<blockquote>
<p>Alice and Bob take turns playing a game, with Alice starting first.</p>
</blockquote>
<blockquote>
<p>Initially, there is a number <code>N</code> on the chalkboard.  On each player's turn, that player makes a move consisting of:</p>
</blockquote>
<ul>
<li>Choosing any <code>x</code> with <code>0 &lt; x &lt; N</code> and <code>N % x == 0</code>.</li>
<li>Replacing the number <code>N</code> on the chalkboard with <code>N - x</code>.</li>
</ul>
<blockquote>
<p>Also, if a player cannot make a move, they lose the game.</p>
</blockquote>
<blockquote>
<p>Return <code>True</code> if and only if Alice wins the game, assuming both players play optimally.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice chooses 1, and Bob has no more moves.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ol>
<p>当遇到<code>N=1</code>的时候，玩家会输，这也是所有输家最后一轮面临的唯一一种可能，否则都可以通过选择<code>x=1</code>进入下一轮。</p>
<p>当<code>N=2</code>时，一定能够使得对手面临上面的状况，那么就赢定了……</p>
<p>当<code>N</code>为偶数时，一定有一个约数是奇数，减去奇数可以使得对手面临<code>N</code>为奇数的情况。而<code>N</code>为奇数时，所有约数都为奇数，轮到对手时就只可能是偶数了。也就是轮到奇数的玩家最终会一直面临<code>N</code>为奇数，直至最终到<code>N=1</code>一定会输，反之开局为偶数就会赢。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2>Maximum Difference Between Node and Ancestor</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-132/problems/maximum-difference-between-node-and-ancestor/</p>
<blockquote>
<p>Given the <code>root</code> of a binary tree, find the maximum value <code>V</code> for which there exists different nodes <code>A</code> and <code>B</code> where <code>V = |A.val - B.val|</code> and <code>A</code> is an ancestor of <code>B</code>.</p>
</blockquote>
<blockquote>
<p>(A node <code>A</code> is an ancestor of <code>B</code> if either: any child of <code>A</code> is equal to <code>B</code>, or any child of <code>A</code> is an ancestor of <code>B</code>.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="http://i68.tinypic.com/2whqcep.jpg" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">We have various ancestor-node differences, some of which are given below :</span><br><span class="line">|8 - 3| = 5</span><br><span class="line">|3 - 7| = 4</span><br><span class="line">|8 - 1| = 7</span><br><span class="line">|10 - 13| = 3</span><br><span class="line">Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the tree is between <code>2</code> and <code>5000</code>.</li>
<li>Each node will have value between <code>0</code> and <code>100000</code>.</li>
</ol>
<p>从根结点进行一次后序遍历，<code>post_dfs</code>返回整个树的最大值，最小值，和题中要求的有直系关系最大差值。<code>post_dfs</code>的具体过程为：一个结点的值<code>val</code>需要分别与左右子树的最值作绝对差，再与左右子树本身包含的最大绝对差比较，然后更新为以该结点为根的整个树的最大绝对差，相似的，再把这些最值与<code>val</code>本身比较得到整个树的最值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAncestorDiff</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_dfs</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100001</span>, <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">            l_min, l_max, l_abs_diff = post_dfs(r.left)</span><br><span class="line">            r_min, r_max, r_abs_diff = post_dfs(r.right)</span><br><span class="line">            min_v, max_v = min(l_min, r_min), max(l_max, r_max)</span><br><span class="line">            temp = max(l_abs_diff, r_abs_diff)</span><br><span class="line">            <span class="keyword">if</span> min_v &lt; <span class="number">100001</span>:</span><br><span class="line">                temp = max(temp, abs(r.val - min_v))</span><br><span class="line">            <span class="keyword">if</span> max_v &gt; <span class="number">-1</span>:</span><br><span class="line">                temp = max(temp, abs(r.val - max_v))</span><br><span class="line">            <span class="keyword">return</span> min(min_v, r.val), max(max_v, r.val), temp</span><br><span class="line"></span><br><span class="line">        _, _, res = post_dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Longest Arithmetic Sequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-132/problems/longest-arithmetic-sequence/</p>
<blockquote>
<p>Given an array <code>A</code> of integers, return the <strong>length</strong> of the longest arithmetic subsequence in <code>A</code>.</p>
</blockquote>
<blockquote>
<p>Recall that a <em>subsequence</em> of <code>A</code> is a list <code>A[i_1], A[i_2], ..., A[i_k]</code> with <code>0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1</code>, and that a sequence B is arithmetic if <code>B[i+1] - B[i]</code> are all the same value (for <code>0 &lt;= i &lt; B.length - 1</code>).</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,6,9,12]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The whole array is an arithmetic sequence with steps of length = 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,4,7,2,10]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The longest arithmetic subsequence is [4,7,10].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [20,1,15,3,10,5,8]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">The longest arithmetic subsequence is [20,15,10,5].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= A.length &lt;= 2000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<p>找相对顺序不变的等差数列，还是先考虑动态规划。用<code>dp[i][diff]</code>表示到第<code>i</code>个元素为止，公差为<code>diff</code>的序列至多有多长。二层循环顺序遍历每一对<code>(i,j)</code>来更新序列长度。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestArithSeqLength</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        dp = collections.defaultdict(dict)</span><br><span class="line">        n = len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                diff = A[j] - A[i]</span><br><span class="line">                <span class="keyword">if</span> diff <span class="keyword">in</span> dp[i]:</span><br><span class="line">                    temp = dp[i][diff] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp = <span class="number">2</span></span><br><span class="line">                dp[j][diff] = max(dp[j].get(diff, <span class="number">1</span>), temp)</span><br><span class="line">                res = max(res, temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Recover a Tree From Preorder Traversal</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-132/problems/recover-a-tree-from-preorder-traversal/</p>
<blockquote>
<p>We run a preorder depth first search on the <code>root</code> of a binary tree.</p>
</blockquote>
<blockquote>
<p>At each node in this traversal, we output <code>D</code> dashes (where <code>D</code> is the <em>depth</em> of this node), then we output the value of this node.  <em>(If the depth of a node is <code>D</code>, the depth of its immediate child is <code>D+1</code>.  The depth of the root node is <code>0</code>.)</em></p>
</blockquote>
<blockquote>
<p>If a node has only one child, that child is guaranteed to be the left child.</p>
</blockquote>
<blockquote>
<p>Given the output <code>S</code> of this traversal, recover the tree and return its <code>root</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/04/08/recover-a-tree-from-preorder-traversal.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">Output: [1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/04/11/screen-shot-2019-04-10-at-114101-pm.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">Output: [1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/04/11/screen-shot-2019-04-10-at-114955-pm.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1-401--349---90--88&quot;</span><br><span class="line">Output: [1,401,null,349,88,90]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the original tree is between <code>1</code> and <code>1000</code>.</li>
<li>Each node will have a value between <code>1</code> and <code>10^9</code>.</li>
</ol>
<p>第一个数字为根结点的值。找到深度为1也就是只有一个<code>-</code>开始引导的子串，把这些（最多2个）子串的深度都减去1，即把所有数字之间的<code>-</code>都去掉一个，然后对子串递归构造成树，作为根结点的子结点。思想很简单，麻烦的字符串操作，不多说了，直接看代码。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverFromPreorder</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> S:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        start = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n) <span class="keyword">if</span> S[i] == <span class="string">'-'</span> <span class="keyword">and</span> S[i - <span class="number">1</span>] != <span class="string">'-'</span>]</span><br><span class="line">        end = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>) <span class="keyword">if</span> S[i] == <span class="string">'-'</span> <span class="keyword">and</span> S[i + <span class="number">1</span>] != <span class="string">'-'</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> start:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(int(S))</span><br><span class="line">        root = TreeNode(int(S[:start[<span class="number">0</span>]]))</span><br><span class="line">        children = [start[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(start)) <span class="keyword">if</span> start[i] == end[i]]</span><br><span class="line">        S = list(S)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> start:</span><br><span class="line">            S[i] = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> len(children) == <span class="number">1</span>:</span><br><span class="line">            l = <span class="string">''</span>.join(S[children[<span class="number">0</span>]:])</span><br><span class="line">            r = <span class="string">''</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = <span class="string">''</span>.join(S[children[<span class="number">0</span>]:children[<span class="number">1</span>]])</span><br><span class="line">            r = <span class="string">''</span>.join(S[children[<span class="number">1</span>]:])</span><br><span class="line">        root.left = self.recoverFromPreorder(l)</span><br><span class="line">        root.right = self.recoverFromPreorder(r)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-132/" data-id="cjuh9fx8z0029u0w3pomifcen" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-131" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-131/" class="article-date"><time datetime="2019-04-07T10:52:38.541Z" itemprop="datePublished">2019-04-07</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-131</p>
<p>&lt;!-- more --&gt;</p>
<h2>Remove Outermost Parentheses</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-131/problems/remove-outermost-parentheses/</p>
<blockquote>
<p>A valid parentheses string is either empty <code>(&quot;&quot;)</code>, <code>&quot;(&quot; + A + &quot;)&quot;</code>, or <code>A + B</code>, where<code>A</code> and <code>B</code>are valid parentheses strings, and <code>+</code> represents string concatenation.  For example, <code>&quot;&quot;</code>, <code>&quot;()&quot;</code>, <code>&quot;(())()&quot;</code>, and <code>&quot;(()(()))&quot;</code> are all valid parentheses strings.</p>
</blockquote>
<blockquote>
<p>A valid parentheses string <code>S</code> is <strong>primitive</strong> if it is nonempty, and there does not exist a way to split it into <code>S = A+B</code>, with <code>A</code> and <code>B</code> nonempty valid parentheses strings.</p>
</blockquote>
<blockquote>
<p>Given a valid parentheses string S, consider its primitive decomposition: <code>S = P_1 + P_2 + ... + P_k</code>, where <code>P_i</code> are primitive valid parentheses strings.</p>
</blockquote>
<blockquote>
<p>Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of <code>S</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())&quot;</span><br><span class="line">Output: &quot;()()()&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())(()(()))&quot;</span><br><span class="line">Output: &quot;()()()()(())&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>S.length &lt;= 10000</code></li>
<li><code>S[i]</code> is <code>&quot;(&quot;</code> or <code>&quot;)&quot;</code></li>
<li><code>S</code> is a valid parentheses string</li>
</ol>
<p>一般做括号匹配会用到一个栈，遇到<code>&quot;(&quot;</code>压栈，遇到<code>&quot;)&quot;</code>弹出，栈的深度表示括号的层级，当栈深度为1时，表示是最外层括号。这里只有一种括号所以用不着用栈，只需要<code>left</code>记录未被匹配的<code>&quot;(&quot;</code>数量，遇到最外层括号的时候忽略，然后返回结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'('</span>:</span><br><span class="line">                <span class="keyword">if</span> left:</span><br><span class="line">                    res.append(i)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> left != <span class="number">1</span>:</span><br><span class="line">                    res.append(i)</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure></p>
<h2>Sum of Root To Leaf Binary Numbers</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-131/problems/sum-of-root-to-leaf-binary-numbers/</p>
<blockquote>
<p>Given a binary tree, each node has value <code>0</code> or <code>1</code>.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</p>
</blockquote>
<blockquote>
<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</p>
</blockquote>
<blockquote>
<p>Return the sum of these numbers.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,0,1,0,1]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the tree is between <code>1</code> and <code>1000</code>.</li>
<li><code>node.val</code> is <code>0</code> or <code>1</code>.</li>
<li>The answer will not exceed <code>2^31 - 1.</code></li>
</ol>
<p>DFS找到每个到叶结点的路径对应的二进制数，遍历到叶结点时直接把路径代表的数字加到最终结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRootToLeaf</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r, acc)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r.left <span class="keyword">and</span> <span class="keyword">not</span> r.right:</span><br><span class="line">                self.res += int(acc + str(r.val), <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> r.left:</span><br><span class="line">                dfs(r.left, acc + str(r.val))</span><br><span class="line">            <span class="keyword">if</span> r.right:</span><br><span class="line">                dfs(r.right, acc + str(r.val))</span><br><span class="line"></span><br><span class="line">        dfs(root, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></p>
<h2>Camelcase Matching</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-131/problems/camelcase-matching/</p>
<blockquote>
<p>A query word matches a given <code>pattern</code> if we can insert <strong>lowercase</strong> letters to the pattern word so that it equals the <code>query</code>. (We may insert each character at any position, and may insert 0 characters.)</p>
</blockquote>
<blockquote>
<p>Given a list of <code>queries</code>, and a <code>pattern</code>, return an <code>answer</code> list of booleans, where <code>answer[i]</code> is true if and only if <code>queries[i]</code> matches the pattern.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;</span><br><span class="line">Output: [true,false,true,true,false]</span><br><span class="line">Explanation:</span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;.</span><br><span class="line">&quot;FrameBuffer&quot; can be generated like this &quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;</span><br><span class="line">Output: [true,false,true,false,false]</span><br><span class="line">Explanation:</span><br><span class="line">&quot;FooBar&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;.</span><br><span class="line">&quot;FootBall&quot; can be generated like this &quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;</span><br><span class="line">Output: [false,true,false,false,false]</span><br><span class="line">Explanation:</span><br><span class="line">&quot;FooBarTest&quot; can be generated like this &quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= queries.length &lt;= 100</code></li>
<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>
<li><code>1 &lt;= pattern.length &lt;= 100</code></li>
<li>All strings consists only of lower and upper case English letters.</li>
</ol>
<p>双指针遍历<code>pattern</code>和目标串，目标串中与<code>pattern</code>对应位置的字符不同时，如果在目标串中遇到的是小写字母，可以把指针跳到下一个位置，如果不是小写字母，则匹配失败，当遍历完<code>pattern</code>后，目标串剩下的内容如果都是小写字母则可以跳过，如果不是，匹配失败。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">camelMatch</span><span class="params">(self, queries, pattern)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type queries: List[str]</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :rtype: List[bool]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_match</span><span class="params">(q, p)</span>:</span></span><br><span class="line">            i = j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; len(p):</span><br><span class="line">                <span class="keyword">if</span> q[i] == p[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> q[i].islower():</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= len(q):</span><br><span class="line">                    <span class="keyword">return</span> j == len(p)</span><br><span class="line">            <span class="keyword">return</span> q[i:].islower()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [is_match(q, pattern) <span class="keyword">for</span> q <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure></p>
<h2>Video Stitching</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-131/problems/video-stitching/</p>
<blockquote>
<p>You are given a series of video clips from a sporting event that lasted <code>T</code> seconds.  These video clips can be overlapping with each other and have varied lengths.</p>
</blockquote>
<blockquote>
<p>Each video clip <code>clips[i]</code> is an interval: it starts at time <code>clips[i][0]</code> and ends at time <code>clips[i][1]</code>.  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments <code>[0, 1] + [1, 3] + [3, 7]</code>.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event (<code>[0, T]</code>).  If the task is impossible, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.</span><br><span class="line">Then, we can reconstruct the sporting event as follows:</span><br><span class="line">We cut [1,9] into segments [1,2] + [2,8] + [8,9].</span><br><span class="line">Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[1,2]], T = 5</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">We can&apos;t cover [0,5] with only [0,1] and [0,2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We can take clips [0,4], [4,7], and [6,9].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: clips = [[0,4],[2,8]], T = 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">Notice you can have extra video after the event ends.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= clips.length &lt;= 100</code></li>
<li><code>0 &lt;= clips[i][0], clips[i][1] &lt;= 100</code></li>
<li><code>0 &lt;= T &lt;= 100</code></li>
</ol>
<p>题很简单，就是太啰嗦了，既然可以重叠，也不用考虑去剪了，直接找最少需要多少clip来覆盖。</p>
<p><code>dp[i]</code>表示保证覆盖到第<code>i</code>秒时最少需要多少clip，如果有一个区间为<code>[x,y]</code>的clip，且<code>x&lt;=i</code>，那么<code>dp[i]+1</code>可以作为<code>dp[y]</code>的一个备选。先把区间按照<code>x</code>排序，然后计算每个<code>[x,y]</code>可以续接哪些<code>i</code>，然后更新<code>dp[y]</code>以及<code>i</code>到<code>y</code>之间所有<code>dp</code>不超过<code>dp[y]</code>，最后检查<code>dp[T]</code>是否还是未被更新的默认值，如果是则返回<code>-1</code>，否则直接返回<code>dp[y]</code>。</p>
<p>当<code>x1&lt;x2&lt;y2&lt;y1</code>时，可以把<code>[x2,y2]</code>合并到<code>[x1,y1]</code>，只考虑<code>[x1,y1]</code>，那么在排序时可以直接以<code>(x,-y)</code>排序，把排序后<code>y</code>值小于前面的元素的去掉，可以减少部分工作量。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">videoStitching</span><span class="params">(self, clips, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type clips: List[List[int]]</span></span><br><span class="line"><span class="string">        :type T: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(clips)</span><br><span class="line">        clips.sort()</span><br><span class="line">        dp = [<span class="number">0</span>] + [n + <span class="number">1</span>] * <span class="number">100</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> [x, y] <span class="keyword">in</span> clips:</span><br><span class="line">            <span class="keyword">if</span> y &lt;= end:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[y] = min(dp[x:y]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x + <span class="number">1</span>, y):</span><br><span class="line">                dp[i] = min(dp[i], dp[y])</span><br><span class="line">            end = y</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[T] &lt; n + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[T]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-131/" data-id="cjuh9fx8m0027u0w3i3bd5ny7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-130" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-130/" class="article-date"><time datetime="2019-04-01T15:16:32.486Z" itemprop="datePublished">2019-04-01</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-130</p>
<p>&lt;!-- more --&gt;</p>
<h2>Binary Prefix Divisible By 5</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-130/problems/binary-prefix-divisible-by-5/</p>
<blockquote>
<p>Given an array <code>A</code> of <code>0</code>s and <code>1</code>s, consider <code>N_i</code>: the i-th subarray from <code>A[0]</code> to <code>A[i]</code> interpreted as a binary number (from most-significant-bit to least-significant-bit.)</p>
</blockquote>
<blockquote>
<p>Return a list of booleans <code>answer</code>, where <code>answer[i]</code> is <code>true</code> if and only if <code>N_i</code> is divisible by 5.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1]</span><br><span class="line">Output: [true,false,false]</span><br><span class="line">Explanation:</span><br><span class="line">The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: [false,false,false]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,1,1,1,1]</span><br><span class="line">Output: [true,false,false,false,true,false]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,1]</span><br><span class="line">Output: [false,false,false,false,false]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>A[i]</code> is <code>0</code> or <code>1</code></li>
</ol>
<p>没什么好说的，一位位构造然后模5看余数</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prefixesDivBy5</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[bool]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            acc = (acc &lt;&lt; <span class="number">1</span>) + i</span><br><span class="line">            res.append(acc % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Convert to Base -2</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-130/problems/convert-to-base-2/</p>
<blockquote>
<p>Given a number <code>N</code>, return a string consisting of <code>&quot;0&quot;</code>s and <code>&quot;1&quot;</code>s that represents its value in base <code>-2</code> (negative two).</p>
</blockquote>
<blockquote>
<p>The returned string must have no leading zeroes, unless the string is &quot;0&quot;.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: &quot;110&quot;</span><br><span class="line">Explantion: (-2) ^ 2 + (-2) ^ 1 = 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: &quot;111&quot;</span><br><span class="line">Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;100&quot;</span><br><span class="line">Explantion: (-2) ^ 2 = 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>先把<code>N</code>转成二进制数，从低到高第<code>i</code>位为<code>2^i</code>前系数，当<code>i</code>为奇数时，如果保持当前系数为原来的1不变，则比与同表示法下-2进制数多了<code>2*2^i</code>，需要向前进一位到<code>2^(i+1)</code>的系数。可以在原二进制数上先留出两个前导0，然后从低位开始进行如上的进位计算，最后注意去掉多余的前导0，特别是当<code>N=0</code>时保留一位0</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">baseNeg2</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">0</span>, <span class="number">0</span>] + map(int, (bin(N)[<span class="number">2</span>:]))</span><br><span class="line">        n = len(res)</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            s, res[n - <span class="number">1</span> - i] = divmod(res[n - <span class="number">1</span> - i] + s, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> res[n - <span class="number">1</span> - i]:</span><br><span class="line">                s = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> res <span class="keyword">and</span> <span class="keyword">not</span> res[<span class="number">0</span>]:</span><br><span class="line">            res.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(map(str, res <span class="keyword">or</span> [<span class="number">0</span>]))</span><br></pre></td></tr></table></figure></p>
<h2>Next Greater Node In Linked List</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-130/problems/next-greater-node-in-linked-list/</p>
<blockquote>
<p>We are given a linked list with <code>head</code> as the first node.  Let's number the nodes in the list: <code>node_1, node_2, node_3, ...</code> etc.</p>
</blockquote>
<blockquote>
<p>Each node may have a <em>next larger</em> <strong>value</strong>: for <code>node_i</code>, <code>next_larger(node_i)</code> is the <code>node_j.val</code> such that <code>j &gt; i</code>, <code>node_j.val &gt; node_i.val</code>, and <code>j</code> is the smallest possible choice.  If such a <code>j</code> does not exist, the next larger value is <code>0</code>.</p>
</blockquote>
<blockquote>
<p>Return an array of integers <code>answer</code>, where <code>answer[i] = next_larger(node_{i+1})</code>.</p>
</blockquote>
<blockquote>
<p>Note that in the example <strong>inputs</strong> (not outputs) below, arrays such as <code>[2,1,5]</code> represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,4,3,5]</span><br><span class="line">Output: [7,0,5,5,0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,7,5,1,9,2,5,1]</span><br><span class="line">Output: [7,9,9,9,0,5,0,0]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= node.val &lt;= 10^9</code> for each node in the linked list.</li>
<li>The given list has length in the range <code>[0, 10000]</code>.</li>
</ol>
<p>单调栈的基础问题，除了这里链表不能直接用索引寻址，所以压栈的时候需要把索引和值一起放进去，遇到大于栈顶元素的值就不断弹栈到栈顶大于当前值为止。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        p = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            res.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] &lt; p.val:</span><br><span class="line">                res[stack.pop()[<span class="number">0</span>]] = p.val</span><br><span class="line">            stack.append((i, p.val))</span><br><span class="line">            p = p.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Number of Enclaves</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-130/problems/number-of-enclaves/</p>
<blockquote>
<p>Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)</p>
</blockquote>
<blockquote>
<p>A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.</p>
</blockquote>
<blockquote>
<p>Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three 1s that are enclosed by 0s, and one 1 that isn&apos;t enclosed because its on the boundary.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">All 1s are either on the boundary or can reach the boundary.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 500</code></li>
<li><code>1 &lt;= A[i].length &lt;= 500</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
<li>All rows have the same size.</li>
</ol>
<p>这题反而真的没什么好说的，从边界开始bfs找到所有可以访问的1，然后从所有的1中减去</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numEnclaves</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n, m = len(A), len(A[<span class="number">0</span>])</span><br><span class="line">        seen = set()</span><br><span class="line">        ones = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            seen.add((x, y))</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= x + dx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y + dy &lt; m <span class="keyword">and</span> A[x + dx][y + dy] <span class="keyword">and</span> (x + dx, y + dy) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    dfs(x + dx, y + dy)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                    ones += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">0</span>][i] <span class="keyword">and</span> A[<span class="number">0</span>][i] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(<span class="number">0</span>, i)</span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">-1</span>][i] <span class="keyword">and</span> A[<span class="number">-1</span>][i] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(n - <span class="number">1</span>, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>] <span class="keyword">and</span> A[i][<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(i, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">-1</span>] <span class="keyword">and</span> A[i][<span class="number">-1</span>] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                dfs(i, m - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ones - len(seen)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-130/" data-id="cjuh9fx8i0025u0w3147egstx" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-129" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-129/" class="article-date"><time datetime="2019-04-01T09:45:17.082Z" itemprop="datePublished">2019-04-01</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-129</p>
<p>&lt;!-- more --&gt;</p>
<h2>Partition Array Into Three Parts With Equal Sum</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-129/problems/partition-array-into-three-parts-with-equal-sum/</p>
<blockquote>
<p>Given an array <code>A</code> of integers, return <code>true</code> if and only if we can partition the array into three non-empty parts with equal sums.</p>
</blockquote>
<blockquote>
<p>Formally, we can partition the array if we can find indexes <code>i+1 &lt; j</code> with <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>3 &lt;= A.length &lt;= 50000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<p>按顺序凑出第一个和为<code>sum(A)/3</code>，然后找第二个，如果都存在则返回<code>true</code></p>
<p>注意可能存在负数，所以不能在第一次超过<code>sum(A)/3</code>时过早判定<code>false</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canThreePartsEqualSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sum(A)</span><br><span class="line">        <span class="keyword">if</span> s % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">print</span> s</span><br><span class="line">        cur, part = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> cur + i == s / <span class="number">3</span>:</span><br><span class="line">                part += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> part == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<h2>Smallest Integer Divisible by K</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-129/problems/smallest-integer-divisible-by-k/</p>
<blockquote>
<p>Given a positive integer <code>K</code>, you need find the smallest positive integer N such that <code>N</code> is divisible by <code>K</code>, and N only contains the digit 1.</p>
</blockquote>
<blockquote>
<p>Return the length of <code>N</code>.  If there is no such N, return -1.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The smallest answer is N = 1, which has length 1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: There is no such positive integer N divisible by 2.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The smallest answer is N = 111, which has length 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= 10^5</code></li>
</ol>
<p>只包含1的$n$位数可以表示为$(10^n-1)/9$，要求找到最小的$n$满足$$(10^n-1)/9=xK$$其中$x$为正整数。众所周知根据<a href="http://mathworld.wolfram.com/EulersTotientTheorem.html" target="_blank" rel="noopener">Euler's Totient Theorem</a>如果$a$和$p$互质一定有$${a^{\varphi (n)}} \equiv 1 \quad (\bmod  n)$$所以只要<code>9K</code>和10互质，即<code>K</code>不能被2或5整除，就可以保证一定存在这个$n$，但可惜的是Euler函数$\varphi (n)$并不保证是使得等式成立的最小值，所以还需要长度为<code>K</code>的遍历来找到最小值，至于为什么长度<code>K</code>可以保证找到结果，证明参加Fermat小定理。</p>
<p>这里用类似除法竖式的方法，把上一位的余数<code>r</code>添上后面一位1再与<code>K</code>求余数，直到可以整除为止。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestRepunitDivByK</span><span class="params">(self, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> K % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> K % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> r % K == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            r = (r * <span class="number">10</span> + <span class="number">1</span>) % K</span><br></pre></td></tr></table></figure></p>
<h2>Best Sightseeing Pair</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-129/problems/best-sightseeing-pair/</p>
<blockquote>
<p>Given an array <code>A</code> of positive integers, <code>A[i]</code> represents the value of the <code>i</code>-th sightseeing spot, and two sightseeing spots <code>i</code> and <code>j</code> have distance <code>j - i</code> between them.</p>
</blockquote>
<blockquote>
<p>The score of a pair (<code>i &lt; j</code>) of sightseeing spots is (<code>A[i] + A[j] + i - j</code>) : the sum of the values of the sightseeing spots, <strong>minus</strong> the distance between them.</p>
</blockquote>
<blockquote>
<p>Return the maximum score of a pair of sightseeing spots.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,1,5,2,6]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= A.length &lt;= 50000</code></li>
<li><code>1 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<p>线性扫描一次：到目前（<code>j</code>）为止最佳的起始点<code>i</code>满足使得<code>A[i]+i</code>最大，如果上式加上<code>A[j]-j</code>大于目前为止最好的sightseeing，那就再把sightseeing记录也更新，完成后计算<code>A[j]+j</code>即<code>j</code>是否比最佳起始点更好。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = max_val = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            temp = start + v - i</span><br><span class="line">            max_val = max(max_val, temp)</span><br><span class="line">            start = max(start, v + i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_val</span><br></pre></td></tr></table></figure></p>
<h2>Binary String With Substrings Representing 1 To N</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-129/problems/binary-string-with-substrings-representing-1-to-n/</p>
<blockquote>
<p>Given a binary string <code>S</code> (a string consisting only of '0' and '1's) and a positive integer <code>N</code>, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0110&quot;, N = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;0110&quot;, N = 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 1000</code></li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>本来可能需要KMP算法，不过暴力做也没什么。</p>
<p>只需要检查<code>N/2+1</code>到<code>N</code>是否在<code>S</code>中就可以了，更小的数也是前面这些数的子串。越大的数越可能难以在<code>S</code>中找到匹配，因此倒序检查可以提高效率。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queryString</span><span class="params">(self, S, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N, N / <span class="number">2</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> bin(i)[<span class="number">2</span>:] <span class="keyword">not</span> <span class="keyword">in</span> S:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-129/" data-id="cjuh9fx8f0023u0w3gzn5a9xj" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-128" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-128/" class="article-date"><time datetime="2019-03-17T15:31:58.438Z" itemprop="datePublished">2019-03-17</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-128</p>
<p>&lt;!-- more --&gt;</p>
<h2>Complement of Base 10 Integer</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-128/problems/complement-of-base-10-integer/</p>
<blockquote>
<p>Every non-negative integer <code>N</code> has a binary representation.  For example, <code>5</code> can be represented as <code>&quot;101&quot;</code> in binary, <code>11</code> as <code>&quot;1011&quot;</code> in binary, and so on.  Note that except for <code>N = 0</code>, there are no leading zeroes in any binary representation.</p>
</blockquote>
<blockquote>
<p>The complement of a binary representation is the number in binary you get when changing every <code>1</code> to a <code>0</code> and <code>0</code> to a <code>1</code>.  For example, the complement of <code>&quot;101&quot;</code> in binary is <code>&quot;010&quot;</code> in binary.</p>
</blockquote>
<blockquote>
<p>For a given number N in base-10, return the complement of it's binary representation as a base-10 integer.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 is &quot;101&quot; in binary, with complement &quot;010&quot; in binary, which is 2 in base-10.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 7 is &quot;111&quot; in binary, with complement &quot;000&quot; in binary, which is 0 in base-10.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 10 is &quot;1010&quot; in binary, with complement &quot;0101&quot; in binary, which is 5 in base-10.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= N &lt; 10^9</code></li>
</ol>
<p>虽然题目说的是complement但不是我们一般说的补码（也就是two's complement），而是反码，不需要像补码那样填充前导0并把每一位翻转然后再加上1,只需要翻转当前所有位就可以了，所有不能直接用<code>~</code>，需要先计算出相应的掩码并做位异运算。</p>
<p>注意python文档提到过0的<code>bit_length</code>被规定为0，需要另外处理一下。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bitwiseComplement</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; N.bit_length()) - <span class="number">1</span> - N</span><br></pre></td></tr></table></figure></p>
<h2>Pairs of Songs With Total Durations Divisible by 60</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-128/problems/pairs-of-songs-with-total-durations-divisible-by-60/</p>
<blockquote>
<p>In a list of songs, the i-th song has a duration of <code>time[i]</code> seconds.</p>
</blockquote>
<blockquote>
<p>Return the number of pairs of songs for which their total duration in seconds is divisible by <code>60</code>.  Formally, we want the number of indices <code>i &lt; j</code> with <code>(time[i] + time[j]) % 60 == 0</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [30,20,150,100,40]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three pairs have a total duration divisible by 60:</span><br><span class="line">(time[0] = 30, time[2] = 150): total duration 180</span><br><span class="line">(time[1] = 20, time[3] = 100): total duration 120</span><br><span class="line">(time[1] = 20, time[4] = 40): total duration 60</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [60,60,60]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: All three pairs have a total duration of 120, which is divisible by 60.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= time.length &lt;= 60000</code></li>
<li><code>1 &lt;= time[i] &lt;= 500</code></li>
</ol>
<p>统计模60后的余数在数组中出现的次数，然后找到每个<code>(x,60-x)</code>且<code>x&lt;60-x</code>的组合中每个<code>x</code>和<code>60-x</code>分别出现的次数并相乘，注意当<code>x=0</code>和<code>x=30</code>时，与它配对的数余数与它相等但不能是它自己，所以需要按照从<code>n</code>个元素中选出2个的组合数计算：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(self, time)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type time: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cnt = collections.Counter([t % <span class="number">60</span> <span class="keyword">for</span> t <span class="keyword">in</span> time])</span><br><span class="line">        res = cnt[<span class="number">0</span>] * (cnt[<span class="number">0</span>] - <span class="number">1</span>) / <span class="number">2</span> + cnt[<span class="number">30</span>] * (cnt[<span class="number">30</span>] - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cnt:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt; i &lt; <span class="number">30</span>:</span><br><span class="line">                res += cnt[i] * cnt[<span class="number">60</span> - i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Capacity To Ship Packages Within D Days</h2>
<blockquote>
<p>A conveyor belt has packages that must be shipped from one port to another within <code>D</code> days.</p>
</blockquote>
<blockquote>
<p>The <code>i</code>-th package on the conveyor belt has a weight of <code>weights[i]</code>.  Each day, we load the ship with packages on the conveyor belt (in the order given by <code>weights</code>). We may not load more weight than the maximum weight capacity of the ship.</p>
</blockquote>
<blockquote>
<p>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within <code>D</code> days.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">Output: 15</span><br><span class="line">Explanation:</span><br><span class="line">A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:</span><br><span class="line">1st day: 1, 2, 3, 4, 5</span><br><span class="line">2nd day: 6, 7</span><br><span class="line">3rd day: 8</span><br><span class="line">4th day: 9</span><br><span class="line">5th day: 10</span><br><span class="line"></span><br><span class="line">Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:</span><br><span class="line">1st day: 3, 2</span><br><span class="line">2nd day: 2, 4</span><br><span class="line">3rd day: 1, 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: weights = [1,2,3,1,1], D = 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">1st day: 1</span><br><span class="line">2nd day: 2</span><br><span class="line">3rd day: 3</span><br><span class="line">4th day: 1, 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Note:</p>
</blockquote>
<ol>
<li><code>1 &lt;= D &lt;= weights.length &lt;= 50000</code></li>
<li><code>1 &lt;= weights[i] &lt;= 500</code></li>
</ol>
<p>它的母题非常经典，有兴趣可以自己搜一下painter’s partition problem，说的是一个长度为<code>n</code>的数组如何划分出<code>K</code>个连续的非空子数组并使得这些子数组的和的最大值最小，也就是说切割成尽可能均衡的<code>K</code>个分片。</p>
<p>比较直接的做法是动态规划，用<code>dp[i][k]</code>表示到<code>i</code>位置为止划分出<code>k</code>个分片时每个分片的和的最大值最少可以取到多少。</p>
<p>基础情况：</p>
<ul>
<li><code>dp[i][1]=sum(weights[:i])</code> 把前<code>i</code>个元素分到同一个分片，一共只有一个和，就是目前为止所有元素的和</li>
</ul>
<p>递推式：</p>
<ul>
<li><code>dp[i][k]=min(max(dp[j][k-1]+sum(weights[j+1:i])) foreach j in [k-1:i-1])</code> 如果到<code>j</code>位置为止可以划分出<code>k-1</code>个分片，那么从<code>j+1</code>到<code>i</code>可以构成一个分片，这些分片的最大值要么在前<code>k-1</code>个分片中已经出现，要么在最后一个新分片中，取最大即可。而<code>j</code>可以<code>&gt;=k-1</code>并<code>&lt;i</code>的任意位置来确定最后一个分片的长度。</li>
</ul>
<p>这里为了减少运行时间，我用了<code>acc[i]</code>预先计算了到<code>i</code>为止的数组和，方便直接用减法找到任意分片的和。</p>
<p><strong>当然，请注意，这个算法的复杂度是O(DN^2)，虽然思路简单粗暴，但肯定会TLE，不要模仿</strong></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span><span class="params">(self, weights, D)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type weights: List[int]</span></span><br><span class="line"><span class="string">        :type D: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(weights)</span><br><span class="line">        acc = [weights[<span class="number">0</span>]] + [<span class="number">0</span>] * (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            acc[i] = acc[i - <span class="number">1</span>] + weights[i]</span><br><span class="line"></span><br><span class="line">        dp = list(acc)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(D - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, k, <span class="number">-1</span>):</span><br><span class="line">                dp[i] = min([max(dp[j], acc[i] - acc[j]) <span class="keyword">for</span> j <span class="keyword">in</span> range(i)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>接下来用二分查找的方法来降低复杂度。</p>
<p>如果规定了分片和的最大值为某个<code>x</code>，那么可以按照顺序可以划分出最少<code>k</code>个分片，如果定义<code>k=f(x)</code>，那么<code>f</code>是一种<strong>不严格的</strong>单调递减关系，<code>x</code>越大，限制越宽松，<code>k</code>就可以越小。而且这个<code>f</code>是可以很容易写出实现方法的（见代码中的<code>min_days(max_load)</code>），顺序遍历数组，一旦到目前为止累积的和超过了<code>x</code>就把当前元素之前的累积和重置为当前元素，并在<code>k</code>的计数上增加1个，这就是在不分片和超过<code>x</code>时划分出最少<code>k</code>的算法。</p>
<p><code>x</code>取值最小为<code>max(weights)</code>，对应<code>k=n</code>，最大为<code>sum(weights)</code>，对应<code>k=1</code>，那么对于<code>1&lt;=D&lt;=n</code>，<code>D</code>对应的某个分片和的最大值<code>k</code>一定在<code>max(weights)</code>和<code>sum(weights)</code>，可以利用二分查找对<code>x</code>的范围逐步缩减，测试每个范围的中点<code>mid</code>所对应的<code>k</code>是否为目标<code>D</code>。</p>
<p>写到这里，我也很羞耻的分享一件事：我之前阅读过很多实现二分查找的源代码，可以看到大多数情况不会去检查<code>mid</code>是否正好符合需要的目标，而是用不等号合并到<code>&gt;=</code>或者<code>&lt;=</code>的情况，我当时没特别注意，只是觉得写的人太偷懒了，明明找到<code>==</code>的情况就可以直接<code>return</code>了也不愿意多写一个case。直到我遇到这个问题的时候，才发现了这样杜绝early return的意义所在，比如在这题中，我前面强调过单调关系是<strong>不严格的</strong>，也就是有多个<code>x</code>可以对应同一个<code>f(x)=k</code>，用二分查找遇到的第一个能满足<code>f(x)=k</code>并不能保证这个<code>x</code>就是使等式成立的最小的那个<code>x</code>,所以需要合并到<code>&lt;=D</code>的情况，更新下一次查找的上界为当前的<code>x</code>（即<code>mid</code>），直至找到满足要求的最小的<code>x</code>就是需要返回的结果。这也是二分查找在很多情况下的基本需求，不是仅仅让你找元素是否在给定范围中，而是还需要返回一些该元素的其他信息，甚至对这个元素的其他信息还有一些要求，比如常见的返回元素在数组中的位置，Python有一个库<code>bisect</code>就是实现这个功能的，可以去看文档，<code>bisect</code>返回的是最左的位置，而<code>bisect_right</code>返回的是最右的位置，都是需要在处理<code>==</code>时合并到对应的不等式情形的。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span><span class="params">(self, weights, D)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type weights: List[int]</span></span><br><span class="line"><span class="string">        :type D: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(weights)</span><br><span class="line">        acc = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            acc[i + <span class="number">1</span>] = acc[i] + weights[i]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">min_days</span><span class="params">(max_load)</span>:</span></span><br><span class="line">            start = <span class="number">0</span></span><br><span class="line">            d = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> acc[i + <span class="number">1</span>] - acc[start] &gt; max_load:</span><br><span class="line">                    d += <span class="number">1</span></span><br><span class="line">                    start = i</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">        l, r = max(weights), acc[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span></span><br><span class="line">            k = min_days(mid)</span><br><span class="line">            <span class="keyword">if</span> k &lt;= D:</span><br><span class="line">                r = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure></p>
<h2>Numbers With Repeated Digits</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-128/problems/numbers-with-repeated-digits/</p>
<blockquote>
<p>Given a positive integer <code>N</code>, return the number of positive integers less than or equal to <code>N</code> that have at least 1 repeated digit.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 20</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The only positive number (&lt;= 20) with at least 1 repeated digit is 11.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 100</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: The positive numbers (&lt;= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1000</span><br><span class="line">Output: 262</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>先找<code>&lt;N+1</code>的所有无重复位的整数。假设<code>N+1</code>一共有<code>n</code>位。<code>A(m,k)</code>表示从<code>m</code>个数中取出<code>k</code>个数的排列数，即<code>m!/(m-k)!</code></p>
<p><code>1</code>-<code>n-1</code>位数没有大小限制，只需要考虑无重复即可</p>
<ul>
<li>如果不包含<code>0</code>，那么<code>i</code>位数可以在<code>1-9</code>中任选排列，共有<code>A(9,i)</code>个数</li>
<li>如果包含<code>0</code>，那么<code>i</code>位数有<code>i-1</code>位非<code>0</code>，在<code>i-1</code>位无0数中可以选择<code>i-1</code>位后面的位置插入一个<code>0</code>形成包含<code>0</code>的<code>i</code>位数，共有<code>(i-1)*A(9,i-1)</code>个数</li>
</ul>
<p><code>n</code>位数考虑逐步扩大前缀长度，从首位开始，如果<code>N+1</code>在这一位上的数字是<code>d1</code>，那么每个小于<code>d1</code>的数字都可以作为前缀，后面<code>n-1</code>位可以取任何与<code>d1</code>不同的值，共有<code>A(9,n-1)*(d1-1)</code>个数，接下来考虑固定首位与<code>d1</code>一致，第二位可以比与<code>N+1</code>的第二位<code>d2</code>小的任意值，当也要求与<code>d1</code>不一致，然后像上面那样考虑剩下的<code>n-2</code>位……</p>
<p>如果已经固定的前缀中出现了重复的数字，那么后面的位置也不需要再考虑了，所以当需要固定某一位作为前缀的最后一位时，如果前缀中已经出现了，那么就可以直接跳出扩大前缀的循环了。</p>
<p>最后得到共有<code>res</code>个没有重复数字的<code>&lt;N+1</code>的数，那么就有<code>N-res</code>个带有重复数字的数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDupDigitsAtMostN</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        L = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> str(N + <span class="number">1</span>)]</span><br><span class="line">        n = len(L)</span><br><span class="line">        f = [<span class="number">1</span>] * <span class="number">10</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            f[i + <span class="number">1</span>] = f[i] * (i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">(m, k)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> f[m] / f[m - k]</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):  <span class="comment"># not contain 0</span></span><br><span class="line">            res += A(<span class="number">9</span>, i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):  <span class="comment"># contain 0</span></span><br><span class="line">            res += A(<span class="number">9</span>, i) * i</span><br><span class="line"></span><br><span class="line">        prefix = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(L):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span> <span class="keyword">if</span> i <span class="keyword">else</span> <span class="number">1</span>, d):</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> prefix:</span><br><span class="line">                    res += A(<span class="number">9</span> - i, n - i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> prefix:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            prefix.add(d)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> N - res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-128/" data-id="cjuh9fx8a0021u0w33frx1pa3" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-127" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-127/">LeetCode Weekly Contest 127</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-127/" class="article-date"><time datetime="2019-03-10T15:35:25.831Z" itemprop="datePublished">2019-03-10</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-127</p>
<p>&lt;!-- more --&gt;</p>
<h2>Maximize Sum Of Array After K Negations</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-127/problems/maximize-sum-of-array-after-k-negations/</p>
<blockquote>
<p>Given an array A of integers, we <strong>must</strong> modify the array in the following way: we choose an <code>i</code> and replace <code>A[i]</code> with <code>-A[i]</code>, and we repeat this process <code>K</code> times in total.  (We may choose the same index <code>i</code> multiple times.)</p>
</blockquote>
<blockquote>
<p>Return the largest possible sum of the array after modifying it in this way.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,2,3], K = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Choose indices (1,) and A becomes [4,-2,3].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,-1,0,2], K = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,-3,-1,5,-4], K = 2</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= K &lt;= 10000</code></li>
<li><code>-100 &lt;= A[i] &lt;= 100</code></li>
</ol>
<p>找出<code>A</code>中最小的元素取相反数，考虑到可以对同一个元素多次操作，每次取完还要再放回去。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumAfterKNegations</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = sum(A)</span><br><span class="line">        heapq.heapify(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K):</span><br><span class="line">            cur = heapq.heappop(A)</span><br><span class="line">            res += <span class="number">-2</span> * cur</span><br><span class="line">            heapq.heappush(A, -cur)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Clumsy Factorial</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-127/problems/clumsy-factorial/</p>
<blockquote>
<p>Normally, the factorial of a positive integer <code>n</code> is the product of all positive integers less than or equal to <code>n</code>.  For example, <code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>.</p>
</blockquote>
<blockquote>
<p>We instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.</p>
</blockquote>
<blockquote>
<p>For example, <code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.</p>
</blockquote>
<blockquote>
<p>Additionally, the division that we use is floor division such that <code>10 * 9 / 8</code> equals <code>11</code>.  This guarantees the result is an integer.</p>
</blockquote>
<blockquote>
<p>Implement the <code>clumsy</code> function as defined above: given an integer <code>N</code>, it returns the clumsy factorial of <code>N</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 7 = 4 * 3 / 2 + 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10000</code></li>
<li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code>  (The answer is guaranteed to fit within a 32-bit integer.)</li>
</ol>
<p>先实现一个辅助函数<code>iter_op</code>，<code>num</code>表示当前需要放入的运算数。为了保持四则元素的优先级，用<code>cur</code>处理<code>n*(n-1)/(n-2)+(n-3)</code>子表达式的顺序累积求和，遇到下一个<code>*</code>前再把<code>cur</code>累加到全局的结果<code>acc</code>上，也就是在遇到<code>-</code>时完成<code>acc</code>的积累，并把<code>cur</code>重置为当前<code>num</code>的相反数。通过改变第一个参数<code>op</code>实现状态的正确转移。</p>
<p>需要小心的是负数的floor division不能直接用<code>/</code>，会向下取整，还是用<code>int</code>直接抹掉小数点后面的部分吧。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clumsy</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">iter_op</span><span class="params">(op, num, acc, cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> acc + cur</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> iter_op(<span class="number">1</span>, num - <span class="number">1</span>, acc, cur * num)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> iter_op(<span class="number">2</span>, num - <span class="number">1</span>, acc, int(<span class="number">1.0</span> * cur / num))</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> iter_op(<span class="number">3</span>, num - <span class="number">1</span>, acc, cur + num)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> iter_op(<span class="number">0</span>, num - <span class="number">1</span>, acc + cur, -num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> iter_op(<span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N)</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Domino Rotations For Equal Row</h2>
<blockquote>
<p>In a row of dominoes, <code>A[i]</code> and <code>B[i]</code> represent the top and bottom halves of the <code>i</code>-th domino.  (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)</p>
</blockquote>
<blockquote>
<p>We may rotate the i-th domino, so that <code>A[i]</code> and <code>B[i]</code> swap values.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of rotations so that all the values in <code>A</code> are the same, or all the values in <code>B</code> are the same.</p>
</blockquote>
<blockquote>
<p>If it cannot be done, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/03/08/domino.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The first figure represents the dominoes as given by A and B: before we do any rotations.</span><br><span class="line">If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [3,5,1,2,3], B = [3,6,3,3,4]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:</span><br><span class="line">In this case, it is not possible to rotate the dominoes to make one row of values equal.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A[i], B[i] &lt;= 6</code></li>
<li><code>2 &lt;= A.length == B.length &lt;= 20000</code></li>
</ol>
<p>反正一共也就6个可以取的数值，直接从数值上检查有没有可以凑成一排的数值，即对于每个<code>i</code>，<code>A[i]</code>或<code>B[i]</code>一定有一个是这个数。对于所有可以凑出<code>n</code>个<code>A[i] or B[i]=x</code>的数值<code>x</code>，如果有<code>count_a</code>个<code>i</code>满足<code>A[i]=x</code>，有<code>count_b</code>个<code>i</code>满足<code>B[i]=x</code>，有<code>both_count</code>个<code>i</code>同时满足<code>A[i]=B[i]=x</code>，找到那些只有一行是<code>x</code>所以不得不翻转的元素比较少的行，即<code>count_a-both_count</code>和<code>count_b-both_count</code>中较小的那一个进行翻转，就可能是最终使得操作数最少的做法，当然这里<code>both_count</code>可以像我一样通过直接遍历计数，也可以容斥原理推算。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDominoRotations</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        a_count, b_count = collections.Counter(A), collections.Counter(B)</span><br><span class="line">        both_count = collections.Counter([A[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">if</span> A[i] == B[i]])</span><br><span class="line">        res = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">if</span> a_count[x + <span class="number">1</span>] + b_count[x + <span class="number">1</span>] - both_count[x + <span class="number">1</span>] == n:</span><br><span class="line">                res = min(res, min(a_count[x + <span class="number">1</span>],</span><br><span class="line">                                   b_count[x + <span class="number">1</span>]) - both_count[x + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt; n <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2>Construct Binary Search Tree from Preorder Traversal</h2>
<blockquote>
<p>Return the root node of a binary <strong>search</strong> tree that matches the given <code>preorder</code> traversal.</p>
</blockquote>
<blockquote>
<p><em>(Recall that a binary search tree is a binary tree where for every node, any descendant of <code>node.left</code> has a value <code>&lt;</code> <code>node.val</code>, and any descendant of <code>node.right</code> has a value <code>&gt;</code> <code>node.val</code>.  Also recall that a preorder traversal displays the value of the <code>node</code> first, then traverses <code>node.left</code>, then traverses <code>node.right</code>.)</em></p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= preorder.length &lt;= 100</code></li>
<li>The values of preorder are distinct.</li>
</ol>
<p>这个是完全没什么难度的问题，我今天为了赶往异地见一个对我来说非常重要的人，所以没在weekly contest现场没机会感受这次比赛如何被吐槽简单，但看提交数真的远比往常多。</p>
<p>众所周知，有了先序遍历+中序遍历的结果，还原构造一个二叉树，是非常基础常见的问题，BST等于直接把中序遍历的结果告诉你了。这里甚至比直接用中序结果更容易，只要以<code>preorder[0]</code>为轴，找到所有目前小于它的元素的列表<code>l</code>，以及开始大于它的元素的列表<code>r</code>，以<code>preorder[0]</code>为根结点，左子树再通过<code>l</code>递归构造，右子树用<code>r</code>递归构造。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span><span class="params">(self, preorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(x, A)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(A):</span><br><span class="line">                <span class="keyword">if</span> num &gt; x:</span><br><span class="line">                    <span class="keyword">return</span> A[:i], A[i:]</span><br><span class="line">            <span class="keyword">return</span> A, []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        l, r = split(preorder[<span class="number">0</span>], preorder[<span class="number">1</span>:])</span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        root.left, root.right = self.bstFromPreorder(</span><br><span class="line">            l), self.bstFromPreorder(r)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-127/" data-id="cjuh9fx7z001zu0w3nrsmvpwt" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-126" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-126/">LeetCode Weekly Contest 126</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-126/" class="article-date"><time datetime="2019-03-03T10:14:10.134Z" itemprop="datePublished">2019-03-03</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-126</p>
<p>&lt;!-- more --&gt;</p>
<h2>Find Common Characters</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-126/problems/find-common-characters/</p>
<blockquote>
<p>Given an array <code>A</code> of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list <strong>(including duplicates)</strong>.  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
</blockquote>
<blockquote>
<p>You may return the answer in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">Output: [&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> is a lowercase letter</li>
</ol>
<p>我比较懒，直接用<code>collections.Counter</code>的交运算了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commonChars</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> list(reduce((<span class="keyword">lambda</span> x, y: x &amp; y), [collections.Counter(s) <span class="keyword">for</span> s <span class="keyword">in</span> A]).elements())</span><br></pre></td></tr></table></figure></p>
<h2>Check If Word Is Valid After Substitutions</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-126/problems/check-if-word-is-valid-after-substitutions/</p>
<blockquote>
<p>We are given that the string <code>&quot;abc&quot;</code> is valid.</p>
</blockquote>
<blockquote>
<p>From any valid string <code>V</code>, we may split <code>V</code> into two pieces <code>X</code> and <code>Y</code> such that <code>X + Y</code> (<code>X</code> concatenated with <code>Y</code>) is equal to <code>V</code>.  (<code>X</code> or <code>Y</code> may be empty.)  Then, <code>X + &quot;abc&quot; + Y</code> is also valid.</p>
</blockquote>
<blockquote>
<p>If for example <code>S = &quot;abc&quot;</code>, then examples of valid strings are: <code>&quot;abc&quot;, &quot;aabcbc&quot;, &quot;abcabc&quot;, &quot;abcabcababcc&quot;</code>.  Examples of invalid strings are: <code>&quot;abccba&quot;</code>, <code>&quot;ab&quot;</code>, <code>&quot;cababc&quot;</code>, <code>&quot;bac&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the given string <code>S</code> is valid.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aabcbc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We start with the valid string &quot;abc&quot;.</span><br><span class="line">Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcababcc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">&quot;abcabcabc&quot; is valid after consecutive insertings of &quot;abc&quot;.</span><br><span class="line">Then we can insert &quot;abc&quot; before the last letter, resulting in &quot;abcabcab&quot; + &quot;abc&quot; + &quot;c&quot; which is &quot;abcabcababcc&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abccba&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cababc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S[i]</code> is <code>'a'</code>, <code>'b'</code>, or <code>'c'</code></li>
</ol>
<p>找到一个完整的子串<code>&quot;abc&quot;</code>然后从<code>S</code>中移除，不断重复操作至无法再找到子串，这时如果<code>S</code>为空则是有效的，有其他字符剩余则无效。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start = S.find(<span class="string">'abc'</span>)</span><br><span class="line">        <span class="keyword">while</span> start &gt; <span class="number">-1</span>:</span><br><span class="line">            S = S[:start] + S[start + <span class="number">3</span>:]</span><br><span class="line">            start = S.find(<span class="string">'abc'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> S</span><br></pre></td></tr></table></figure></p>
<h2>Max Consecutive Ones III</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-126/problems/max-consecutive-ones-iii/</p>
<blockquote>
<p>Given an array <code>A</code> of 0s and 1s, we may change up to <code>K</code> values from 0 to 1.</p>
</blockquote>
<blockquote>
<p>Return the length of the longest (contiguous) subarray that contains only 1s.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= K &lt;= A.length</code></li>
<li><code>A[i]</code> is <code>0</code> or <code>1</code></li>
</ol>
<p>找到包含至多<code>K</code>个<code>0</code>的连续最长子数组。</p>
<p>这里可能会比较麻烦的是<code>K=0</code>时的情况，为了统一起来可以试着用最长容量为<code>K+1</code>的队列<code>zeros</code>，并把<code>-1</code>初始化到队列中。在遍历结束后，也不要忘记考虑到最后一个元素为止的最长长度。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        zeros = [<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> len(zeros) &lt;= K:</span><br><span class="line">                    zeros.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = zeros.pop(<span class="number">0</span>)</span><br><span class="line">                    res = max(res, i - start - <span class="number">1</span>)</span><br><span class="line">                    zeros.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(res, len(A) - zeros[<span class="number">0</span>] - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Cost to Merge Stones</h2>
<blockquote>
<p>here are <code>N</code> piles of stones arranged in a row.  The <code>i</code>-th pile has <code>stones[i]</code> stones.</p>
</blockquote>
<blockquote>
<p>A move consists of merging <strong>exactly <code>K</code> consecutive</strong> piles into one pile, and the cost of this move is equal to the total number of stones in these <code>K</code> piles.</p>
</blockquote>
<blockquote>
<p>Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [3,2,4,1], K = 2</span><br><span class="line">Output: 20</span><br><span class="line">Explanation:</span><br><span class="line">We start with [3, 2, 4, 1].</span><br><span class="line">We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].</span><br><span class="line">We merge [4, 1] for a cost of 5, and we are left with [5, 5].</span><br><span class="line">We merge [5, 5] for a cost of 10, and we are left with [10].</span><br><span class="line">The total cost was 20, and this is the minimum possible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [3,2,4,1], K = 3</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: After any merge operation, there are 2 piles left, and we can&apos;t merge anymore.  So the task is impossible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [3,5,1,2,6], K = 3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">We start with [3, 5, 1, 2, 6].</span><br><span class="line">We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].</span><br><span class="line">We merge [3, 8, 6] for a cost of 17, and we are left with [17].</span><br><span class="line">The total cost was 25, and this is the minimum possible.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>2 &lt;= K &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code></li>
</ol>
<p>首先考虑无法被合并到1个堆的情况：每合并<code>K</code>个堆会减少<code>K</code>个堆并增加1个，为了使最后只剩下一个堆，必须满足当<code>K&gt;2</code>时，<code>n%(K-1)=1</code>。</p>
<p>接下来考虑一般的动规做法：用<code>dp[i][j][k]</code>表示把第<code>i</code>到<code>j</code>个元素（包含<code>i</code>和<code>j</code>）合并成<code>k</code>堆需要的最小代价，初始状态时把它们都初始化为<code>inf</code>，除了本来就是<code>k</code>堆的，即<code>j-i+1=k</code>时代价为0。更新<code>dp</code>时遵循这样的原则</p>
<ul>
<li>当<code>k&gt;1</code>时，只需要从任意<code>m</code>开始分隔，<code>i-m</code>为一堆，剩下的<code>m+1-j</code>是<code>k-1</code>堆，不需要发生任何合并操作，即：<code>dp[i][j][k]=min(dp[i][m][1]+dp[m+1][j][k-1])</code></li>
<li>当<code>k=1</code>时，必须合并<code>K</code>个元素，对于可以分割的点<code>m</code>，<code>i-m</code>为一堆，<code>m+1-j</code>为剩下的<code>K-1</code>堆，这样才可以被合并成一个堆，发生合并时所有元素的值都会被计入成本。</li>
</ul>
<p>然后以<code>i-j</code>长度递增的顺序对<code>dp</code>更新</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeStones</span><span class="params">(self, stones, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type stones: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(stones)</span><br><span class="line">        <span class="keyword">if</span> n % (K - <span class="number">1</span>) != <span class="number">1</span> <span class="keyword">and</span> K != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        acc = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            acc[i + <span class="number">1</span>] = acc[i] + stones[i]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_sum</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; i:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> acc[j + <span class="number">1</span>] - acc[i]</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i] = [<span class="number">0</span>] * n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dp[i][j] = [inf] * (K + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j - i + <span class="number">1</span> == k:</span><br><span class="line">                        dp[i][j][k] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - step + <span class="number">1</span>):</span><br><span class="line">                j = i + step - <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> m <span class="keyword">in</span> range(i, j):</span><br><span class="line">                        <span class="keyword">if</span> k != <span class="number">1</span>:</span><br><span class="line">                            dp[i][j][k] = min(</span><br><span class="line">                                dp[i][j][k], dp[i][m][<span class="number">1</span>] + dp[m + <span class="number">1</span>][j][k - <span class="number">1</span>])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            dp[i][j][k] = min(</span><br><span class="line">                                dp[i][j][k], dp[i][m][<span class="number">1</span>] + dp[m + <span class="number">1</span>][j][K - <span class="number">1</span>] + get_sum(i, j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-126/" data-id="cjuh9fx7l001xu0w34i6a2pfk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-learn-lambda-calculus-in-y-minutes" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/lambda-calculus/learn-lambda-calculus-in-y-minutes/">Y分钟入门lambda演算</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/lambda-calculus/learn-lambda-calculus-in-y-minutes/" class="article-date"><time datetime="2019-02-28T07:42:44.599Z" itemprop="datePublished">2019-02-28</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/lambda-calculus/">lambda calculus</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>本文为我个人对<a href="https://learnxinyminutes.com/" target="_blank" rel="noopener">Learn X in Y minutes</a>系列的<a href="https://learnxinyminutes.com/docs/lambda-calculus/" target="_blank" rel="noopener">Lambda Calculus</a>部分内容的中文翻译。<strong>非常推荐有能力的读者直接去阅读原文。</strong></p>
<p>&lt;!-- more --&gt;</p>
<p><em>包含部分译者添加的细节补充</em></p>
<hr>
<p>最初由<a href="https://en.wikipedia.org/wiki/Alonzo_Church" target="_blank" rel="noopener">Alonzo Church</a>创造的lambda演算（λ-演算）是世界上最小的程序设计语言。虽然没有数（number），字符串（string），布尔型（boolean）或其他任何非函数（non-function）的数据类型，但lambda演算能用于表示任何图灵机。</p>
<p>lambda演算由3个元素组成：<strong>变量</strong>，<strong>函数</strong>，和 <strong>应用</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">语法</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">变量</td>
<td style="text-align:left"><code>&lt;name&gt;</code></td>
<td style="text-align:left">$x$</td>
<td style="text-align:left">一个名为$x$的变量</td>
</tr>
<tr>
<td style="text-align:left">函数</td>
<td style="text-align:left"><code>λ&lt;parameters&gt;.&lt;body&gt;</code></td>
<td style="text-align:left">$\lambda x.x$</td>
<td style="text-align:left">一个形参为$x$主体为$x$的函数</td>
</tr>
<tr>
<td style="text-align:left">应用</td>
<td style="text-align:left"><code>&lt;function&gt;&lt;variable or function&gt;</code></td>
<td style="text-align:left">$(\lambda x.x)a$</td>
<td style="text-align:left">以实参$a$调用函数$(λx.x)$</td>
</tr>
</tbody>
</table>
<p>最基本的函数是恒等函数：$\lambda x.x$，等同于$f(x)=x$，第一个$x$是函数的参数，第二个是函数体。</p>
<h2>自由 vs. 约束变量：</h2>
<ul>
<li>在函数$\lambda x.x$中$x$被称为约束变量，$x$被称为约束变量，因为它既在函数体中又是形参。</li>
<li>在$\lambda x.y$中$y$被称为自由变量，因为它没有被预先声明。</li>
</ul>
<h2>求值：</h2>
<p>求值通过<a href="https://en.wikipedia.org/wiki/Lambda_calculus#Beta_reduction" target="_blank" rel="noopener">β化简（β-Reduction）</a>完成，本质上是词法作用域的替换。</p>
<p>当对表达式$(\lambda x.x)a$求值时，我们把函数体中所有出现的$x$都替换为$a$。</p>
<ul>
<li>$(\lambda x.x)a$求值结果为: $a$</li>
<li>$(\lambda x.y)a$求值结果为: $y$</li>
</ul>
<p>你甚至可以创造高阶函数：</p>
<ul>
<li>$(\lambda x.(\lambda y.x))a$求值结果为：$λy.a$</li>
</ul>
<p>虽然lambda演算传统上只支持单参数函数，但我们可以用一种被称为<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">柯里化（currying）</a>的技巧来创造多参数函数。</p>
<ul>
<li>$(\lambda x.\lambda y.\lambda z.xyz)$等同于$f(x,y,z) = ((x, y), z)$</li>
</ul>
<p>有时$\lambda xy.&lt;body&gt;$也可以与$\lambda x.\lambda y.&lt;body&gt;$在用法上互换。</p>
<hr>
<p>必须意识到传统的<strong>lambda演算没有数，字符，或任何非函数的数据类型！</strong></p>
<h2>布尔逻辑：</h2>
<p>在lambda演算中没有True或False，甚至没有1或0。</p>
<p>而是有：</p>
<p>$T$ 表示为：$\lambda x.\lambda y.x$</p>
<p>$F$ 表示为：$\lambda x.\lambda y.y$</p>
<p>首先，我们定义一个if函数 $\lambda btf$，如果 $b$ 为True返回 $t$ ，如果 $b$ 为False返回$f$</p>
<p>IF等价于 $\lambda b.\lambda t.\lambda f.b , t , f$</p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-comment&quot;&gt;&lt;/i&gt; 译者注</h4>
<p>在理论上这样的做法在该演算系统没有问题，但实践中的<code>if</code>语句<code>if a then b else c</code>要求<code>b</code>和<code>c</code>有且只有一个被求值，在严格求值的语言（如Scheme）中不可以通过定义普通的函数（lambda表达式）来实现真正的<code>if</code>语句，否则<code>b</code>和<code>c</code>都会被求值，需要通过宏或其他方法来改变求值行为。</p>
</div></p>
<p>使用IF，我们可以定义基本布尔逻辑运算符：</p>
<p>$a , \text{AND} , b$ 等价于 $\lambda ab.IF, a ,b ,F$</p>
<p>$a , \text{OR} , b$ 等价于 $\lambda ab.IF ,a ,T ,b$</p>
<p>$a , \text{NOT} , b $ 等价于 $\lambda a.IF, a, F, T$</p>
<p><em>注意：$IF,  a , b , c$ 实质上是在说 $IF((a ,  b) ,  c)$</em></p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-comment&quot;&gt;&lt;/i&gt; 译者注</h4>
<p><code>NOT</code>是一元运算符，我怀疑这里原文写错了，应该是<code>NOT a</code>，当然后面lambda演算表达式是正确的。我已向该项目提交<a href="https://github.com/adambard/learnxinyminutes-docs/issues/3487#issue-415597570" target="_blank" rel="noopener">相应的issue</a>等待回应。</p>
</div></p>
<h2>数：</h2>
<p>虽然lambda演算没有数字，但我们可以用<a href="https://en.wikipedia.org/wiki/Church_encoding" target="_blank" rel="noopener">Church数</a>来对数字编码。</p>
<p>对于任意数n：$n = \lambda f.{f^n}$ 所以有</p>
<p>&lt;!-- 0 = λf.λx.x --&gt;</p>
<p>$ 0 = \lambda f.\lambda x.x $</p>
<p>&lt;!-- 1 = λf.λx.f x --&gt;</p>
<p>$ 1 = \lambda f.\lambda x.f,x $</p>
<p>&lt;!-- 2 = λf.λx.f(f x) --&gt;</p>
<p>$ 2 = \lambda f.\lambda x.f(f, x) $</p>
<p>&lt;!-- 3 = λf.λx.f(f(f x)) --&gt;</p>
<p>$ 3 = \lambda f.\lambda x.f(f(f, x)) $</p>
<p>为了增加一个Church数，我们用后继函数（successor function）$S(n)=n+1$ 即：</p>
<p>$S = \lambda n.\lambda f.\lambda x.f((n,f),x)$</p>
<p>使用后继，我们可以定义加法：</p>
<p>$ADD = \lambda ab.(a , S)b$</p>
<p><strong>挑战:</strong> 试着自己定义乘法函数</p>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-comment&quot;&gt;&lt;/i&gt; 译者注</h4>
<p>写完或者根本想不出来可以参考http://www.cse.unt.edu/~tarau/teaching/PL/docs/Church%20encoding.pdf Section 1.1定义的<code>mult</code>函数，我就不直接写出来干扰思考了。</p>
</div></p>
<h2>变得甚至更小：SKI, SK与Iota</h2>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-comment&quot;&gt;&lt;/i&gt; 译者注</h4>
<p>想快速入门lambda演算的看到这里已经足够，可以直接根据<a href="#%E6%9B%B4%E5%A4%9A%E8%BF%9B%E9%98%B6%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99%E8%A7%81">更多进阶阅读材料</a>的前三条参考链接开始进一步学习。而从这里开始和lambda演算的关系已经不是很大了，只是通过一系列化简计算来把它用“更小”的演算系统表示，假设用$A \to B$表示$A$语言的所有要素都可以用$B$语言来表示，即$A$可以被规约（化简）到$B$，那么接下来繁复的炫技演示了λ演算$\to$SKI演算$\to$SK演算$\to$ι演算的过程，语言的元素数量逐步减少。关于这些演算系统定义和发展的历史以及它们的关系，除了接下来的内容外，也可以见Wiki词条<a href="https://en.wikipedia.org/wiki/Combinatory_logic" target="_blank" rel="noopener">Combinatory logic</a></p>
</div></p>
<h3>SKI组合子演算</h3>
<p>令$S$,$K$和$I$为以下函数：</p>
<p>$I,x = x$</p>
<p>$K,x,y = x$</p>
<p>$S, x, y, z = x, z, (y, z)$</p>
<p>我们可以把lambda演算中的表达式转换为SKI组合子演算中的表达式：</p>
<ol>
<li>$\lambda x.x = I$</li>
<li>$\lambda x.c = Kc$</li>
<li>$\lambda x.(y, z) = S, (λx.y) ,(λx.z)$</li>
</ol>
<p>以church数2为例：</p>
<p>$ 2 = \lambda f.\lambda x.f(f, x) $</p>
<p>对于内部的$\lambda x.f(f, x) $部分：$$\begin{alignat}{2}
&amp; \lambda x.f(f,x) &amp;\\
= &amp; S , (\lambda x.f) , (\lambda x.(f,x))  &amp;  \quad      (case, 3) \\
= &amp; S, (K,f) , (S, (\lambda x.f) , (\lambda x.x)) &amp;  \quad  (case, 2, 3) \\
= &amp; S, (K, f) , (S ,(K, f) ,I)   ,    &amp; \quad   (case, 2, 1)
\end{alignat}$$所以$$\begin{align}
&amp; 2 \\
=&amp; \lambda f.\lambda x.f(f, x) \\
=&amp; \lambda f.(S ,(K, f) ,(S, (K, f), I)) \\
=&amp; \lambda f.((S, (K, f)) ,(S ,(K ,f) ,I)) \\
=&amp; S, (\lambda f.(S ,(K ,f))), (\lambda f.(S, (K ,f) ,I)) \quad (case 3)
\end{align}$$对于第一个参数$\lambda f.(S , (K, f))$ $$
\begin{alignat}{2}
&amp; \lambda f.(S , (K , f)) \\<br>
=&amp; S , (\lambda f.S) , (\lambda f.(K , f))   &amp;    \quad (case , 3) \\
=&amp; S , (K , S) (S , (\lambda f.K) , (\lambda f.f)) &amp;\quad (case  , 2, 3) \\
=&amp; S , (K , S) , (S , (K , K) , I)  \quad  &amp;   (case , 2, 3)
\end{alignat}$$对于第二个参数$\lambda f.(S ,(K  ,f) , I)$ $$
\begin{alignat}{2}
&amp;\lambda f.(S, (K ,f) ,I) &amp;\\
=&amp; \lambda f.((S ,(K ,f)), I) &amp;\\
=&amp; S ,(\lambda f.(S , (K , f))) (\lambda f.I)       &amp;  \quad    (case ,3) \\
=&amp; S ,(S, (\lambda f.S) (\lambda f.(K ,f))) (K ,I)  &amp;   \quad  (case ,2, 3) \\
=&amp; S ,(S ,(K, S) ,(S, (\lambda f.K) ,(\lambda f.f))) ,(K, I) &amp; \quad (case 1, 3) \\
=&amp; S ,(S ,(K ,S), (S ,(K ,K), I)), (K, I)    &amp; \quad   (case, 1, 2)
\end{alignat}$$把它们合并起来$$\begin{align}
&amp;2 \\
=&amp; S ,(\lambda f.(S ,(K, f))) ,(\lambda f.(S ,(K, f) ,I)) \\
=&amp; S ,(S, (K, S), (S, (K ,K) ,I)) ,(S, (S ,(K ,S) (S, (K ,K) ,I)) ,(K, I))
\end{align}$$ 展开它，我们最终会再次得到与Church数2相同的表达式。</p>
<h3>SK组合子演算</h3>
<p>SKI组合子演算还能被进一步化简，注意到$I=S,K,K$我们可以移除$I$组合子。我们把所有$I$替换为$S,K,K$</p>
<h3>Iota组合子</h3>
<p>SK组合子演算依然不是最小的，定义
$\iota = \lambda f.((f , S) , K)$
我们有$$
\begin{align}
I &amp; = \iota \iota \\
K &amp; = \iota (\iota I) = \iota (\iota (\iota \iota)) \\
S &amp; = \iota (K) = \iota (\iota (\iota (\iota \iota)))
\end{align}$$</p>
<h2>更多进阶阅读材料见</h2>
<ol>
<li><a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf" target="_blank" rel="noopener">A Tutorial Introduction to the Lambda Calculus</a></li>
<li><a href="http://www.cs.cornell.edu/courses/cs3110/2008fa/recitations/rec26.html" target="_blank" rel="noopener">Cornell CS 312 Recitation 26: The Lambda Calculus</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">Wikipedia - Lambda Calculus</a></li>
<li><a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus" target="_blank" rel="noopener">Wikipedia - SKI combinator calculus</a></li>
<li><a href="https://en.wikipedia.org/wiki/Iota_and_Jot" target="_blank" rel="noopener">Wikipedia - Iota and Jot</a></li>
</ol>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/lambda-calculus/learn-lambda-calculus-in-y-minutes/" data-id="cjuh9fxfu0059u0w3znmztvpb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-125" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-125/">LeetCode Weekly Contest 125</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-125/" class="article-date"><time datetime="2019-02-24T07:28:59.766Z" itemprop="datePublished">2019-02-24</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-125</p>
<p>&lt;!-- more --&gt;</p>
<h2>Find the Town Judge</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-125/problems/find-the-town-judge/</p>
<blockquote>
<p>In a town, there are <code>N</code> people labelled from <code>1</code> to <code>N</code>.  There is a rumor that one of these people is secretly the town judge.</p>
</blockquote>
<blockquote>
<p>If the town judge exists, then:</p>
</blockquote>
<ol>
<li>The town judge trusts nobody.</li>
<li>Everybody (except for the town judge) trusts the town judge.</li>
<li>There is exactly one person that satisfies properties 1 and 2.</li>
</ol>
<blockquote>
<p>You are given <code>trust</code>, an array of pairs <code>trust[i] = [a, b]</code> representing that the person labelled <code>a</code> trusts the person labelled <code>b</code>.</p>
</blockquote>
<blockquote>
<p>If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, trust = [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
<li><code>trust.length &lt;= 10000</code></li>
<li><code>trust[i]</code> are all different</li>
<li><code>trust[i][0] != trust[i][1]</code></li>
<li><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code></li>
</ol>
<p>根据边集构造有向图，找到入度为<code>N-1</code>且出度为<code>0</code>的结点作为town judge返回，如果没有则返回<code>-1</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findJudge</span><span class="params">(self, N, trust)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type trust: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        trusted = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        t = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> trust:</span><br><span class="line">            trusted[j - <span class="number">1</span>].append(i - <span class="number">1</span>)</span><br><span class="line">            t[i - <span class="number">1</span>].append(j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> len(trusted[i]) == N - <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> t[i]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2>Available Captures for Rook</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-125/problems/available-captures-for-rook/</p>
<blockquote>
<p>On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</p>
</blockquote>
<blockquote>
<p>The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</p>
</blockquote>
<blockquote>
<p>Return the number of pawns the rook can capture in one move.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/20/1253_example_1_improved.PNG" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">In this example the rook is able to capture all the pawns.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/19/1253_example_2_improved.PNG" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">Bishops are blocking the rook to capture any pawn.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/20/1253_example_3_improved.PNG" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The rook can capture the pawns at positions b5, d6 and f5.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>board.length == board[i].length == 8</code></li>
<li><code>board[i][j]</code> is either <code>'R'</code>, <code>'.'</code>, <code>'B'</code>, or <code>'p'</code></li>
<li>There is exactly one cell with <code>board[i][j] == 'R'</code></li>
</ol>
<p>找到<code>R</code>的位置，开始向四个方向搜索，如果第一个遇到的非空（<code>.</code>）物体是<code>p</code>则计数增加，遇到其他物体如<code>'B'</code>则终止该方向的搜索。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRookCaptures</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(board)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'R'</span>:</span><br><span class="line">                    x, y = i, j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            i, j = x + dx, y + dy</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= i &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'p'</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'B'</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i, j = i + dx, j + dy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Maximum Binary Tree II</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-125/problems/maximum-binary-tree-ii/</p>
<blockquote>
<p>We are given the <code>root</code> node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.</p>
</blockquote>
<blockquote>
<p>Just as in the <a href="https://leetcode.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">previous problem</a>, the given tree was constructed from an list A (<code>root = Construct(A)</code>) recursively with the following <code>Construct(A)</code> routine:</p>
</blockquote>
<ul>
<li>If <code>A</code> is empty, return <code>null</code>.</li>
<li>Otherwise, let <code>A[i]</code> be the largest element of <code>A</code>.  Create a <code>root</code> node with value <code>A[i]</code>.</li>
<li>The left child of root will be Construct(<code>[A[0], A[1], ..., A[i-1]]</code>)</li>
<li>The right child of root will be Construct(<code>[A[i+1], A[i+2], ..., A[A.length - 1]]</code>)
Return root.</li>
</ul>
<blockquote>
<p>Note that we were not given A directly, only a root node <code>root = Construct(A)</code>.</p>
</blockquote>
<blockquote>
<p>Suppose <code>B</code> is a copy of <code>A</code> with the value val appended to it.  It is guaranteed that <code>B</code> has unique values.</p>
</blockquote>
<blockquote>
<p>Return <code>Construct(B)</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-1-1.png" alt="">
<img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-1-2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,1,3,null,null,2], val = 5</span><br><span class="line">Output: [5,4,null,1,3,null,null,2]</span><br><span class="line">Explanation: A = [1,4,2,3], B = [1,4,2,3,5]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-2-1.png" alt="">
<img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-2-2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,4,null,1], val = 3</span><br><span class="line">Output: [5,2,4,null,1,null,3]</span><br><span class="line">Explanation: A = [2,1,5,4], B = [2,1,5,4,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-3-1.png" alt="">
<img src="https://assets.leetcode.com/uploads/2019/02/21/maximum-binary-tree-3-2.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,3,null,1], val = 4</span><br><span class="line">Output: [5,2,4,null,1,3]</span><br><span class="line">Explanation: A = [2,1,5,3], B = [2,1,5,3,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= B.length &lt;= 100</code></li>
</ol>
<p>要求保持最大堆性质以及中序遍历顺序与list一致，新增结点必须在树的最右，那么就需要从根结点开始不断向右支遍历，找到第一个<code>&lt;val</code>的结点，然后把这个结点放在用<code>val</code>构造的新结点的左子结点上，然后用这个新的子树取代该结点原来的位置。有两个特殊情况在写代码时可能需要留意一下：</p>
<ol>
<li>根结点小于<code>val</code>，那么新结点应该成为根结点，返回的应该是新结点</li>
<li>原来“最右”的结点也大于<code>val</code>，那么新结点直接放在“最右”结点的右结点上就可以了</li>
</ol>
<p>当然，2也可以在实现时合并到一般情况来处理</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoMaxTree</span><span class="params">(self, root, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = root</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        r = TreeNode(val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.val &lt; val:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pre = node</span><br><span class="line">            node = node.right</span><br><span class="line"></span><br><span class="line">        r.left = node</span><br><span class="line">        <span class="keyword">if</span> pre:</span><br><span class="line">            pre.right = r</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></p>
<h2>Grid Illumination</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-125/problems/grid-illumination/</p>
<blockquote>
<p>n a N x N grid of cells, each cell <code>(x, y)</code> with <code>0 &lt;= x &lt; N</code> and <code>0 &lt;= y &lt; N</code> has a lamp.</p>
</blockquote>
<blockquote>
<p>Initially, some number of lamps are on.  <code>lamps[i]</code> tells us the location of the <code>i</code>-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).</p>
</blockquote>
<blockquote>
<p>For the i-th query <code>queries[i] = (x, y)</code>, the answer to the query is 1 if the cell <code>(x, y)</code> is illuminated, else 0.</p>
</blockquote>
<blockquote>
<p>After each query <code>(x, y)</code> [in the order given by <code>queries</code>], we turn off any lamps that are at cell <code>(x, y)</code> or are adjacent 8-directionally (ie., share a corner or edge with cell <code>(x, y)</code>.)</p>
</blockquote>
<blockquote>
<p>Return an array of answers.  Each value <code>answer[i]</code> should be equal to the answer of the i-th query <code>queries[i]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation:</span><br><span class="line">Before performing the first query we have both lamps [0,0] and [4,4] on.</span><br><span class="line">The grid representing which cells are lit looks like this, where [0,0] is the top left corner, and [4,4] is the bottom right corner:</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 1 0 0 1</span><br><span class="line">1 0 1 0 1</span><br><span class="line">1 0 0 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">Then the query at [1, 1] returns 1 because the cell is lit.  After this query, the lamp at [0, 0] turns off, and the grid now looks like this:</span><br><span class="line">1 0 0 0 1</span><br><span class="line">0 1 0 0 1</span><br><span class="line">0 0 1 0 1</span><br><span class="line">0 0 0 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">Before performing the second query we have only the lamp [4,4] on.  Now the query at [1,0] returns 0, because the cell is no longer lit.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
<li><code>0 &lt;= lamps.length &lt;= 20000</code></li>
<li><code>0 &lt;= queries.length &lt;= 20000</code></li>
<li><code>lamps[i].length == queries[i].length == 2</code></li>
</ol>
<p>问题本身并不难，记录每个<code>(x,y)</code>位置的灯在四个方向的属性（<code>x</code>,<code>y</code>,<code>x-y</code>,<code>x+y</code>）放入计数，每次对<code>(i,j)</code>位置查询是否被照亮也只需要查找四个方向的坐标（<code>i</code>,<code>j</code>,<code>i-j</code>,<code>i+j</code>）是否有大于0的，如果有则改位置被照亮了，每次查询后需要以<code>(i,j)</code>为中心的九宫格位置寻找是否有未熄灭的灯（通过<code>set</code>），然后把该灯的四个方向属性从计数中减去1，并从集合中移除，作为“关灯”操作。</p>
<p>这里比较容易忽视的是<code>N</code>可能非常大，所有直接开数组或列表来存放四个方向的属性计数可能会发生内存错误，我第一次写的时候就因为没注意到这个问题发生了内存错误。但<code>lamps</code>的长度并不大，所以没必要用数组来存放这样稀疏的数值记录，用四个<code>dict</code>来记录就足够了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gridIllumination</span><span class="params">(self, N, lamps, queries)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type lamps: List[List[int]]</span></span><br><span class="line"><span class="string">        :type queries: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        x = &#123;&#125;</span><br><span class="line">        y = &#123;&#125;</span><br><span class="line">        diag1 = &#123;&#125;</span><br><span class="line">        diag2 = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        lamps_on = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> lamps:</span><br><span class="line">            x[i] = x.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            y[j] = y.get(j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            diag1[i - j] = diag1.get(i - j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            diag2[i + j] = diag2.get(i + j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            lamps_on.add((i, j))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">turn_off</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">1</span>), (<span class="number">-1</span>, <span class="number">-1</span>), (<span class="number">1</span>, <span class="number">1</span>)]:</span><br><span class="line">                nei_x, nei_y = i + dx, j + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nei_x &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= nei_y &lt; N <span class="keyword">and</span> (nei_x, nei_y) <span class="keyword">in</span> lamps_on:</span><br><span class="line">                    lamps_on.remove((nei_x, nei_y))</span><br><span class="line">                    x[nei_x] = x[nei_x] - <span class="number">1</span></span><br><span class="line">                    y[nei_y] = y[nei_y] - <span class="number">1</span></span><br><span class="line">                    diag1[nei_x - nei_y] = diag1[nei_x - nei_y] - <span class="number">1</span></span><br><span class="line">                    diag2[nei_x + nei_y] = diag2[nei_x + nei_y] - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> queries:</span><br><span class="line">            <span class="keyword">if</span> any([x.get(i, <span class="number">0</span>), y.get(j, <span class="number">0</span>), diag1.get(i - j, <span class="number">0</span>), diag2.get(i + j, <span class="number">0</span>)]):</span><br><span class="line">                res.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">            turn_off(i, j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-125/" data-id="cjuh9fx7g001vu0w39ffq98ly" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-124" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-124/">LeetCode Weekly Contest 124</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-124/" class="article-date"><time datetime="2019-02-17T06:39:33.652Z" itemprop="datePublished">2019-02-17</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-124</p>
<p>&lt;!-- more --&gt;</p>
<h2>Cousins in Binary Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-124/problems/cousins-in-binary-tree/</p>
<blockquote>
<p>In a binary tree, the root node is at depth <code>0</code>, and children of each depth <code>k</code> node are at depth <code>k+1</code>.</p>
</blockquote>
<blockquote>
<p>Two nodes of a binary tree are cousins if they have the same depth, but have <strong>different parents</strong>.</p>
</blockquote>
<blockquote>
<p>We are given the <code>root</code> of a binary tree with unique values, and the values <code>x</code> and <code>y</code> of two different nodes in the tree.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the nodes corresponding to the values <code>x</code> and <code>y</code> are cousins.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4], x = 2, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the tree will be between <code>2</code> and <code>100</code>.</li>
<li>Each node has a unique integer value from <code>1</code> to <code>100</code>.</li>
</ol>
<p>检查两个目标值所在结点是否深度相同，父结点不同。用<code>depth_and_parent</code>进行DFS返回深度和父结点。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCousins</span><span class="params">(self, root, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth_and_parent</span><span class="params">(cur, par, x, d)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == x:</span><br><span class="line">                <span class="keyword">return</span> d, par</span><br><span class="line">            d1, p1 = depth_and_parent(cur.left, cur, x, d + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> d1 &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> d1, p1</span><br><span class="line">            d2, p2 = depth_and_parent(cur.right, cur, x, d + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> d2, p2</span><br><span class="line"></span><br><span class="line">        dx, px = depth_and_parent(root, <span class="keyword">None</span>, x, <span class="number">0</span>)</span><br><span class="line">        dy, py = depth_and_parent(root, <span class="keyword">None</span>, y, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dx == dy <span class="keyword">and</span> px != py</span><br></pre></td></tr></table></figure></p>
<h2>Rotting Oranges</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-124/problems/rotting-oranges/</p>
<blockquote>
<p>In a given grid, each cell can have one of three values:</p>
</blockquote>
<ul>
<li>the value <code>0</code> representing an empty cell;</li>
<li>the value <code>1</code> representing a fresh orange;</li>
<li>the value <code>2</code> representing a rotten orange.</li>
</ul>
<blockquote>
<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return <code>-1</code> instead.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png" alt="">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,2]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> is only <code>0</code>, <code>1</code>, or <code>2</code>.</li>
</ol>
<p>用<code>fresh</code>先统计所有还未腐坏的橘子的数量，从第0分钟时就腐坏的结点开始进行BFS，遍历到最后一层深度时的时间就是最后一个橘子腐坏的时间，此时如果<code>fresh</code>被耗尽可以直接返回时间，如果还没有耗尽则不可能全部腐坏，返回<code>-1</code>。另外需要处理<code>[[0]]</code>这样特殊的情况，让它返回<code>0</code>。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orangesRotting</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fresh = <span class="number">0</span></span><br><span class="line">        rotten = []</span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    fresh += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] == <span class="number">2</span>:</span><br><span class="line">                    rotten.append((i, j, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, j, k <span class="keyword">in</span> rotten:</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> [(i - <span class="number">1</span>, j), (i + <span class="number">1</span>, j), (i, j - <span class="number">1</span>), (i, j + <span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; m <span class="keyword">and</span> grid[x][y] == <span class="number">1</span>:</span><br><span class="line">                    grid[x][y] = <span class="number">2</span></span><br><span class="line">                    fresh -= <span class="number">1</span></span><br><span class="line">                    rotten.append((x, y, k + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fresh:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rotten:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> rotten[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2>Minimum Number of K Consecutive Bit Flips</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-124/problems/minimum-number-of-k-consecutive-bit-flips/</p>
<blockquote>
<p>In an array <code>A</code> containing only 0s and 1s, a <em><code>K</code>-bit flip</em> consists of choosing a (contiguous) subarray of length <code>K</code> and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of <code>K</code>-bit flips required so that there is no 0 in the array.  If it is not possible, return <code>-1</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,1,0], K = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Flip A[0], then flip A[2].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1,0], K = 2</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: No matter how we flip subarrays of size 2, we can&apos;t make the array become [1,1,1].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,0,0,1,0,1,1,0], K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]</span><br><span class="line">Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]</span><br><span class="line">Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ol>
<p>顺序遍历每个<code>A[i]</code>，如果遇到值为<code>0</code>，就对<code>i</code>开始长度为<code>K</code>的子数组进行翻转，这样得到的就算最少的翻转次数，如果最后<code>K-1</code>个元素中有<code>0</code>那么无法被翻转，只能返回<code>-1</code>。但这样的方法时间复杂度为$O(nK)$，每次遇到0都会对<code>K</code>个元素翻转，积累了很多重复操作，会TLE，所以可以考虑用<code>acc</code>表示前面的元素累积到该元素上的翻转次数，<code>flip</code>表示遍历到当前元素时是否需要翻转，这样在遍历时只需要维护一个滑动窗口来积累前<code>K</code>个元素对后面元素的翻转影响，可以把复杂度降低到$O(n)$</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minKBitFlips</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        flip = [<span class="number">0</span>] * n</span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= K:</span><br><span class="line">                acc -= flip[i - K]</span><br><span class="line">            <span class="keyword">if</span> i &lt;= n - K:</span><br><span class="line">                <span class="keyword">if</span> acc % <span class="number">2</span> == A[i]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    acc += <span class="number">1</span></span><br><span class="line">                    flip[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> acc % <span class="number">2</span> == A[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Number of Squareful Arrays</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-124/problems/number-of-squareful-arrays/</p>
<blockquote>
<p>Given an array <code>A</code> of non-negative integers, the array is <em>squareful</em> if for every pair of adjacent elements, their sum is a perfect square.</p>
</blockquote>
<blockquote>
<p>Return the number of permutations of A that are squareful.  Two permutations <code>A1</code> and <code>A2</code> differ if and only if there is some index <code>i</code> such that <code>A1[i] != A2[i]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,17,8]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">[1,8,17] and [17,8,1] are the valid permutations.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 12</code></li>
<li><code>0 &lt;= A[i] &lt;= 1e9</code></li>
</ol>
<p>如果<code>A[i]</code>和<code>A[j]</code>的和是完全平方数，那么<code>i</code>和<code>j</code>可以表示为图上邻接的结点，在整个图上用<a href="https://en.wikipedia.org/wiki/Held%E2%80%93Karp_algorithm" target="_blank" rel="noopener">Held-Karp动态规划</a>算法找到所有的Hamilton路径，最后注意相同元素不作区分，因此最终结果需要除以结点上每个元素值的出现次数的阶乘。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquarefulPerms</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_square</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> int(math.sqrt(x) + <span class="number">0.5</span>)**<span class="number">2</span> == x</span><br><span class="line"></span><br><span class="line">        n = len(A)</span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span> &lt;&lt; n)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> is_square(A[i] + A[j]):</span><br><span class="line">                    graph[i].append(j)</span><br><span class="line">                    graph[j].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">1</span> &lt;&lt; n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i) &amp; path:</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">                        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j) &amp; path:</span><br><span class="line">                            dp[path][i] += dp[path - (<span class="number">1</span> &lt;&lt; i)][j]</span><br><span class="line"></span><br><span class="line">        res = sum(dp[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> A[i] == A[j]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">            res /= k</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-124/" data-id="cjuh9fx7c001tu0w357w70m58" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/10/">10</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
