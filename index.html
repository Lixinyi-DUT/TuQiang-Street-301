<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="正常人的正常笔记站">
<meta property="og:type" content="website">
<meta property="og:title" content="笔记仓库">
<meta property="og:url" content="notebook.xyli.me/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="正常人的正常笔记站">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笔记仓库">
<meta name="twitter:description" content="正常人的正常笔记站">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-LeetCode-Weekly-Contest-102" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-102/" class="article-date"><time datetime="2018-09-16T14:30:58.475Z" itemprop="datePublished">2018-09-16</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://leetcode.com/contest/weekly-contest-102" target="_blank" rel="noopener">https://leetcode.com/contest/weekly-contest-102</a></p>
        
          <p class="article-more-link">
            <a class="btn btn-primary" href="/LeetCode/LeetCode-Weekly-Contest-102/#more">Read More</a>
          </p>
        
      
    </div>

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-102/" data-id="cjm54yldl0006fkw332y7elv8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-101" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-101/" class="article-date"><time datetime="2018-09-09T14:19:15.418Z" itemprop="datePublished">2018-09-09</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-101</p>
<p>&lt;!-- more --&gt;</p>
<h2>RLE Iterator</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/rle-iterator/</p>
<blockquote>
<p>Write an iterator that iterates through a run-length encoded sequence.</p>
</blockquote>
<blockquote>
<p>The iterator is initialized by <code>RLEIterator(int[] A)</code>, where <code>A</code> is a run-length encoding of some sequence.  More specifically, for all even <code>i</code>, <code>A[i]</code> tells us the number of times that the non-negative integer value <code>A[i+1]</code> is repeated in the sequence.</p>
</blockquote>
<blockquote>
<p>The iterator supports one function: <code>next(int n)</code>, which exhausts the next <code>n</code> elements (<code>n &gt;= 1</code>) and returns the last element exhausted in this way.  If there is no element left to exhaust, <code>next</code> returns <code>-1</code> instead.</p>
</blockquote>
<blockquote>
<p>For example, we start with <code>A = [3,8,0,9,2,5]</code>, which is a run-length encoding of the sequence <code>[8,8,8,5,5]</code>.  This is because the sequence can be read as &quot;three eights, zero nines, two fives&quot;.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span><br><span class="line">Output: [null,8,8,5,-1]</span><br><span class="line">Explanation:</span><br><span class="line">RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).</span><br><span class="line">This maps to the sequence [8,8,8,5,5].</span><br><span class="line">RLEIterator.next is then called 4 times:</span><br><span class="line"></span><br><span class="line">.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].</span><br><span class="line"></span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].</span><br><span class="line"></span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].</span><br><span class="line"></span><br><span class="line">.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5,</span><br><span class="line">but the second term did not exist.  Since the last term exhausted does not exist, we return -1.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 1000</code></li>
<li><code>A.length</code> is an even integer.</li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
<li>There are at most <code>1000</code> calls to <code>RLEIterator.next(int n)</code> per test case.</li>
<li>Each call to <code>RLEIterator.next(int n)</code> will have <code>1 &lt;= n &lt;= 10^9</code>.</li>
</ol>
<p>直接展开成序列可能会占用很大的空间，因此可以给<code>RLEIterator</code>分配一个光标<code>cur</code>表示现在遍历到的位置，考虑到初始化以后就不再进行数据的添加操作，那么可以改变偶数<code>i</code>的<code>A[i]</code>计数以表示还有多少<code>A[i+1]</code>没被访问到。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLEIterator</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = A</span><br><span class="line">        self.cur = <span class="number">0</span></span><br><span class="line">        self.len = len(A)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> self.cur &lt; self.len:</span><br><span class="line">            <span class="keyword">if</span> self.A[self.cur] &gt;= n:</span><br><span class="line">                self.A[self.cur] -= n</span><br><span class="line">                <span class="keyword">return</span> self.A[self.cur + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n -= self.A[self.cur]</span><br><span class="line">                self.cur += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RLEIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RLEIterator(A)</span></span><br><span class="line"><span class="comment"># param_1 = obj.next(n)</span></span><br></pre></td></tr></table></figure></p>
<h2>Online Stock Span</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/online-stock-span/</p>
<blockquote>
<p>Write a class <code>StockSpanner</code> which collects daily price quotes for some stock, and returns the span of that stock's price for the current day.</p>
</blockquote>
<blockquote>
<p>The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price.</p>
</blockquote>
<blockquote>
<p>For example, if the price of a stock over the next 7 days were <code>[100, 80, 60, 70, 60, 75, 85]</code>, then the stock spans would be <code>[1, 1, 1, 2, 1, 4, 6]</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S = StockSpanner() is initialized.  Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br><span class="line"></span><br><span class="line">Note that (for example) S.next(75) returned 4, because the last 4 prices</span><br><span class="line">(including today&apos;s price of 75) were less than or equal to today&apos;s price.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Calls to <code>StockSpanner.next(int price)</code> will have <code>1 &lt;= price &lt;= 10^5</code>.</li>
<li>There will be at most <code>10000</code> calls to <code>StockSpanner.next</code> per test case.</li>
<li>There will be at most <code>150000</code> calls to <code>StockSpanner.next</code> across all test cases.</li>
<li>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</li>
</ol>
<p>对于每个<code>A[i]</code>，span即最近的大于<code>A[i]</code>的值到<code>A[i]</code>的距离。当然对于<code>A[0]</code>，这个最近的较大值可以看成在<code>-1</code>位置的一个虚拟的元素。如果是一次性给出一个序列，可以按照类似于<a href="http://notebook.xyli.me/LeetCode/LC891-alter/#%E5%8D%95%E8%B0%83%E6%A0%88">LC891的变体：求所有连续子集的极差之和</a>提到的做法维护一个单调栈，但这里的元素却是实时添加的，如果每次都为新添加的<code>price</code>遍历整个序列，会导致很大的时间开销。所以可以这样改进：维护一个<code>pre</code>列表，<code>pre[i]</code>在下标<code>i</code>之前超过<code>A[i]</code>的最近元素的坐标，当添加新的<code>price</code>前，先与<code>A[-1]</code>比较大小，如果<code>A[-1]&lt;=price</code>再把坐标从<code>len(A)-1</code>迭代为<code>pre[len(A)-1]</code>进行比较，直至第一次找到使得<code>A[i]&gt;price</code>的<code>i</code>，再把<code>price</code>放进列表，并把它的对应前驱<code>pre</code>设置为<code>i</code>放入<code>pre</code>列表。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A = []</span><br><span class="line">        self.pre = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, price)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type price: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(self.A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.A[i] &gt; price:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i = self.pre[i]</span><br><span class="line"></span><br><span class="line">        self.A.append(price)</span><br><span class="line">        self.pre.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(self.A) - i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = StockSpanner()</span></span><br><span class="line"><span class="comment"># param_1 = obj.next(price)</span></span><br></pre></td></tr></table></figure></p>
<h2>Numbers At Most N Given Digit Set</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/numbers-at-most-n-given-digit-set/</p>
<blockquote>
<p>We have a <strong>sorted</strong> set of digits <code>D</code>, a non-empty subset of <code>{'1','2','3','4','5','6','7','8','9'}</code>.  (Note that <code>'0'</code> is not included.)</p>
</blockquote>
<blockquote>
<p>Now, we write numbers using these digits, using each digit as many times as we want.  For example, if <code>D = {'1','3','5'}</code>, we may write numbers such as <code>'13'</code>, <code>'551'</code>, <code>'1351315'</code>.</p>
</blockquote>
<blockquote>
<p>Return the number of positive integers that can be written (using the digits of <code>D</code>) that are less than or equal to <code>N</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: D = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], N = 100</span><br><span class="line">Output: 20</span><br><span class="line">Explanation:</span><br><span class="line">The 20 numbers that can be written are:</span><br><span class="line">1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: D = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], N = 1000000000</span><br><span class="line">Output: 29523</span><br><span class="line">Explanation:</span><br><span class="line">We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,</span><br><span class="line">81 four digit numbers, 243 five digit numbers, 729 six digit numbers,</span><br><span class="line">2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.</span><br><span class="line">In total, this is 29523 integers that can be written using the digits of D.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>D</code> is a subset of digits <code>'1'-'9'</code> in sorted order.</li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<p>假设<code>N</code>是一个<code>n</code>位数，毫无疑问任意构造<code>1</code>到<code>n-1</code>位数一定满足<code>&lt;=N</code>，从<code>d</code>个数组合出的有<code>d^i</code>个。</p>
<p>接下来只需要考虑从<code>D</code>构造满足<code>&lt;=N</code>的<code>n</code>位数。首先找到有<code>D</code>有多数个数字是小于<code>N</code>的首位的，假设为<code>k</code>，都可以安排在首位，剩下的<code>n-1</code>位就可以随意组合，这里就可以找到<code>k*d^(n-1)</code>个数。如果<code>N</code>的首位也在<code>D</code>中，那么就可以递归的考虑可以由<code>D</code>组合出多少个小于去掉首位的<code>N</code>的<code>n-1</code>为数，这里特别注意一下，如果去掉首位后这个数字以<code>0</code>开头，那么不能从<code>D</code>构造出小于新数字的<code>n-1</code>位数，就可以直接跳到递归出口了，当然，另一个递归出口是<code>N</code>只有一位时，这个数字还存在于<code>D</code>，可以直接算作一个取到<code>=</code>的结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">atMostNGivenDigitSet</span><span class="params">(self, D, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type D: List[str]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = len(D)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Ndigits</span><span class="params">(x)</span>:</span> <span class="comment">#return amount of the nums &lt; x, where nums have equal digits with x</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            n = len(str(x))</span><br><span class="line">            i = bisect.bisect_left(D, str(x)[<span class="number">0</span>])</span><br><span class="line">            res += i * d**(n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> i &lt; d <span class="keyword">and</span> D[i] == str(x)[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> str(x)[<span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                        res += Ndigits(int(str(x)[<span class="number">1</span>:]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(d**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(str(N)))) + Ndigits(N)</span><br></pre></td></tr></table></figure></p>
<h2>Valid Permutations for DI Sequence</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-101/problems/valid-permutations-for-di-sequence/</p>
<blockquote>
<p>We are given <code>S</code>, a length <code>n</code> string of characters from the set <code>{'D', 'I'}</code>. (These letters stand for &quot;decreasing&quot; and &quot;increasing&quot;.)</p>
</blockquote>
<blockquote>
<p>A valid permutation is a permutation <code>P[0], P[1], ..., P[n]</code> of integers <code>{0, 1, ..., n}</code>, such that for all i:</p>
</blockquote>
<ul>
<li>If <code>S[i] == 'D'</code>, then <code>P[i] &gt; P[i+1]</code>, and;</li>
<li>If <code>S[i] == 'I'</code>, then <code>P[i] &lt; P[i+1]</code>.</li>
</ul>
<blockquote>
<p>How many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;DID&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The 5 valid permutations of (0, 1, 2, 3) are:</span><br><span class="line">(1, 0, 3, 2)</span><br><span class="line">(2, 0, 3, 1)</span><br><span class="line">(2, 1, 3, 0)</span><br><span class="line">(3, 0, 2, 1)</span><br><span class="line">(3, 1, 2, 0)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>S</code> consists only of characters from the set <code>{'D', 'I'}</code>.</li>
</ol>
<p>还是试着用动态规划去解决。<code>dp[i][j]</code>表示当<code>P</code>前排到第<code>i</code>位时，如果第<code>i</code>位元素的数值在剩下的所有元素中排到第<code>j</code>位，共有多少种排法。那么当你排到第<code>i+1</code>位时，如果<code>S[i]=='D'</code>，第<code>i+1</code>位必须小于第<code>i</code>位，如果第<code>i+1</code>位大小在之后的元素能排到第<code>j</code>位，那么第<code>i</code>位的值的大小在剩下的元素中必须至少排在第<code>j+1</code>位，因此<code>dp[i+1][j]</code>是<code>dp[i][j+1:]</code>的和；同理，当<code>S[i]=='I'</code>时，为了保证第<code>i+1</code>位大于第<code>i</code>为，第<code>i</code>位在之后的元素中也至多只能排到第<code>j</code>大，<code>dp[i+1][j]</code>是<code>dp[i][:j+1]</code>的和。排到最后一位时，这一位在剩下的元素中必然只能插入到第0位，因此最后结果就是<code>dp[-1][0]</code>的值。</p>
<p>以example 1的输入<code>&quot;DID&quot;</code>为例</p>
<table>
<thead>
<tr>
<th style="text-align:left">j\i</th>
<th style="text-align:left">0</th>
<th style="text-align:left">1</th>
<th style="text-align:left">2</th>
<th style="text-align:left">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1:<code>(0)</code></td>
<td style="text-align:left">3:<code>(30)</code>,<code>(20)</code>,<code>(10)</code></td>
<td style="text-align:left">3:<code>(301)</code>,<code>(201)</code>,<code>(102)</code></td>
<td style="text-align:left">5: <code>(3021)</code>,<code>(2031)</code>,<code>(1032)</code>,<code>(3120)</code>,<code>(2130)</code></td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1:<code>(1)</code></td>
<td style="text-align:left">2:<code>(31)</code>,<code>(21)</code></td>
<td style="text-align:left">5:<code>(302)</code>,<code>(203)</code>,<code>(103)</code>,<code>(312)</code>,<code>(213)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1:<code>(2)</code></td>
<td style="text-align:left">1:<code>(32)</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">1:<code>(3)</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>直球编程得到：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPermsDISequence</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(S) + <span class="number">1</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n] + [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i] == <span class="string">'D'</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n - i - <span class="number">1</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (sum(dp[i][j + <span class="number">1</span>:])) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n - i - <span class="number">1</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (sum(dp[i][:j + <span class="number">1</span>])) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>这样写虽然能通过，但众所周知这里存在着大量的重复计算和存储导致了$o(n^3)$的时间复杂度和$o(n^2)$的空间复杂度，我们可以稍作调整写成
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPermsDISequence</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'D'</span>:</span><br><span class="line">                dp = dp[<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                    dp[i - <span class="number">1</span>] = (dp[i - <span class="number">1</span>] + dp[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp = dp[:<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dp) - <span class="number">1</span>):</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>使得时间复杂度降低到$o(n^2)$同时空间复杂度降低到$o(n)$</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-101/" data-id="cjm54yldq0007fkw3wnx8byqc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-represent-digital-circuits-simulator" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/represent-digital-circuits-simulator/" class="article-date"><time datetime="2018-09-07T13:57:19.180Z" itemprop="datePublished">2018-09-07</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>最近闲暇时在阅读的<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a>一书&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，在介绍使用可变数据结构建模时，首先引入了队列（queue）和表（table）两个经典的数据结构实现作为基础，又在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_sec_3.3.4" target="_blank" rel="noopener">3.3.4  A Simulator for Digital Circuits</a>试图用scheme实现一个数字电路的仿真。</p>
<p>&lt;!-- more --&gt;</p>
<p>根据编书结构来看，3.3.4确实算不上什么重要的部分，对于此书的学习路线来说甚至无足轻重到可以直接跳过，只当是前文提到的可变的，复合的数据结构应用在建模中的一次实战；然而就<strong>数字电路模拟</strong>这个应用场景本身来说，也并不能称得上是一个贴切的例子，这里提供的实现与真实世界中硬件电路的做法几乎没有关系；更恼人的是，这个部分的内容很好的根据了抽象屏障（abstract barrier）进行了自顶而下（top-down）的讲解，对于部分像我这样喜欢从底层开始动手实验和理解的读者来说，如此的解释顺序无异于灾难。于是这个部分的内容对我来说，便成为了想读却下手困难且不值得，想放弃又心有不甘觉得可惜的鸡肋。</p>
<p>但其实这部分读懂了又觉得还是有点意思的，就像<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-16.html#%25_sec_2.3.2" target="_blank" rel="noopener">2.3.2  Example: Symbolic Differentiation</a>这个例子，虽然偏离实际但确实能极大提升对于递归的理解。从最底层开始亲自实现一遍数字电路也能很好的帮助我们去理解数据结构（data structure），求值环境（eval environment）和局部状态（local state）等概念。而且无论中英文网络上有关这部分的详解资料都不多，所以我决定自己动手写一篇短文带领所有可能在此遇到问题的人突破讲解材料的限制，拉住我伸出的手登上高处，看一看山下雄伟奇异的景色。理解这个有趣的例子，也同样是提升自信的一个途径，不像现实世界中其他优秀成功的人，我只是一个又丑又穷的底层失败者，所以读懂一个数字电路模拟实现已经是让我兴奋不已急于分享的喜事，当然对在座的优秀的，现实充实的读者们来说这可能只是微小的收获感，可哪怕只要有一个人能从我微小的贡献中受益，我也觉得是非常令我幸福的事了。</p>
<p>好了，接下来我们开始从零开始一层层往上用scheme实现一个完整的数字电路模拟器。</p>
<h2>Agenda</h2>
<p>我不知道该怎么翻译这个词比较合适，这里比较贴切的意思应该是<strong>议程</strong>，也有把这个对象形容成schedule的。因为我们最终要实现的是一个事件驱动的模拟（event-driven simulation）程序，通俗来说就是每当某个事件被添加到模拟过程时，才会触发电路的一些变化。创建一个<code>agenda</code>等于开始一个模拟过程，之后的任何操作都是对于这个<code>agenda</code>对象的操作。如果要你自己不限语言，而且不告诉你要实现的这个对象名叫<code>agenda</code>，凭着轮廓写这么一个东西，很多人大概会写成形如这样的（以C#为例）：</p>
<p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">simulation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Simulator</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> currentTime &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Simulator</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            Name = name;</span><br><span class="line">            currentTime= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">int</span> time, <span class="keyword">string</span> action</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="comment">/* ...add some events... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Other properties, methods, events...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title">simulation</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            Simulator s1=<span class="keyword">new</span> Simulator(<span class="string">"first_simulator"</span>);   <span class="comment">// start a simulation</span></span><br><span class="line">            s1.<span class="keyword">add</span>(<span class="number">1</span>,<span class="string">"shut down"</span>);</span><br><span class="line">            <span class="comment">//other operations</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为完成上述任务的数据结构，或者说对象，在很多人的直观理解中应该被称为simulator~~（笑）~~而agenda只是更具体的概括了这个simulator的类型，也就是这个simulator的内容到底是如何实现的，原来是通过存储和执行一系列时刻-动作对(time-action pair)来完成模拟的。请忘掉上面所写的残破的代码示例，接下来认真考虑该如何以scheme实现<code>agenda</code>：</p>
<p>首先考虑这个时刻-动作对应关系应该如何表示：如同我们现实生活中的日程表，会记录每个时刻需要完成的事务。这里直接定义数据结构<code>segment</code>是一个包含一个数字（<code>time</code>即时刻）和一个队列（<code>queue</code>即任务列表）的对。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-time-segment</span> time queue)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> time queue))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">segment-time</span> s) (<span class="name"><span class="builtin-name">car</span></span> s))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">segment-queue</span> s) (<span class="name"><span class="builtin-name">cdr</span></span> s))</span><br></pre></td></tr></table></figure></p>
<p>如此一来，<code>agenda</code>可以被定义为<code>segment</code>的一维表（one-dimensional table）结构，而且表中这些项会按照<code>time</code>排序，换个角度来看，<code>segement</code>这种结构本质就是一种key-value对。另外，<code>agenda</code>会存储现在的时间<code>current-time</code>(最后进行的事件的时间)作为表的头部，而不同于原书在之前介绍的用<code>&quot;*table*&quot;</code>之类的表的名字作为哑元表头。新建的<code>agenda</code>还没有被添加任何事件时，没有任何<code>segement</code>在内，<code>current-time</code>被初始化为<code>0</code>：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-agenda</span>) (<span class="name"><span class="builtin-name">list</span></span> <span class="number">0</span>)) <span class="comment">;returns a new empty agenda</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">current-time</span> agenda) (<span class="name"><span class="builtin-name">car</span></span> agenda))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-current-time!</span> agenda time)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-car!</span></span> agenda time))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">segments</span> agenda) (<span class="name"><span class="builtin-name">cdr</span></span> agenda))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-segments!</span> agenda segments)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-cdr!</span></span> agenda segments))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-segment</span> agenda) (<span class="name"><span class="builtin-name">car</span></span> (<span class="name">segments</span> agenda)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">rest-segments</span> agenda) (<span class="name"><span class="builtin-name">cdr</span></span> (<span class="name">segments</span> agenda)))</span><br></pre></td></tr></table></figure></p>
<p>那么用来检查<code>agenda</code>是否为<em>逻辑上</em>的空对象的<code>empty-agenda?</code>就可以通过检查表头之后的<code>segements</code>是否为空来实现了。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">empty-agenda?</span> agenda) <span class="comment">; is true if the specified agenda is empty</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">null?</span></span> (<span class="name">segments</span> agenda)))</span><br></pre></td></tr></table></figure></p>
<p>向<code>agenda</code>添加动作<code>action</code>需要检查是否为空：</p>
<ul>
<li>如果是，为这个<code>action</code>和<code>time</code>构造一个<code>segement</code>，并把这个<code>segement</code>放入<code>agenda</code>的<code>segements</code>部分。</li>
<li>否则，扫描表中每个<code>segement</code>的<code>time</code>值
<ul>
<li>如果发现指定时刻（<code>action</code>需要被添加的时刻）已经存在，那么把<code>action</code>直接添加到这个与<code>time</code>关联的<code>queue</code>中即可。</li>
<li>如果已经扫描到比指定时刻更晚的<code>time</code>值，说明指定时刻不在<code>segements</code>中，那么为这个<code>action</code>和指定<code>time</code>创建一个新的<code>segement</code>并插入到这个被扫描到的<code>segement</code>之前。</li>
<li>如果已经扫描到了<code>agenda</code>末尾，那么也说明指定时刻不在<code>segements</code>中，还是创建一个新的<code>segement</code>把这条记录放到<code>agenda</code>的末尾。</li>
</ul>
</li>
</ul>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-to-agenda!</span> time action agenda)</span><br><span class="line"><span class="comment">;modifies the agenda by adding the given action procedure to be run at the specified time.</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">belongs-before?</span> segments) <span class="comment">;return true if our appointed time **isn't** in segements</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">null?</span></span> segments)</span><br><span class="line">        (<span class="name"><span class="builtin-name">&lt;</span></span> time (<span class="name">segment-time</span> (<span class="name"><span class="builtin-name">car</span></span> segments)))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-new-time-segment</span> time action) <span class="comment">;create a new segment for our time and action</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">q</span> (<span class="name">make-queue</span>)))</span><br><span class="line">      (<span class="name">insert-queue!</span> q action)</span><br><span class="line">      (<span class="name">make-time-segment</span> time q)))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-to-segments!</span> segments)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">segment-time</span> (<span class="name"><span class="builtin-name">car</span></span> segments)) time)</span><br><span class="line">        (<span class="name">insert-queue!</span> (<span class="name">segment-queue</span> (<span class="name"><span class="builtin-name">car</span></span> segments))</span><br><span class="line">                       action) <span class="comment">;insert action into the queue our time associated</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">rest</span> (<span class="name"><span class="builtin-name">cdr</span></span> segments)))</span><br><span class="line">          (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">belongs-before?</span> rest)</span><br><span class="line">              (<span class="name"><span class="builtin-name">set-cdr!</span></span></span><br><span class="line">               segments</span><br><span class="line">               (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-new-time-segment</span> time action)</span><br><span class="line">                     (<span class="name"><span class="builtin-name">cdr</span></span> segments))) <span class="comment">;insert new segement before the later or just at the end of agenda</span></span><br><span class="line">              (<span class="name">add-to-segments!</span> rest)))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">segments</span> (<span class="name">segments</span> agenda)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">belongs-before?</span> segments) <span class="comment">;check if the agenda is null or just contains the later segements</span></span><br><span class="line">        (<span class="name">set-segments!</span></span><br><span class="line">         agenda</span><br><span class="line">         (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">make-new-time-segment</span> time action)</span><br><span class="line">               segments)) <span class="comment">;insert new segement at the head of segements</span></span><br><span class="line">        (<span class="name">add-to-segments!</span> segments))))</span><br></pre></td></tr></table></figure></p>
<p>可以明显的看出实现的细节上与上面描述的判定流程并不完全一致，比如最后两种情况的操作实际上是合并为<code>belongs-before?</code>，再比如检查<code>agenda</code>是否为空的操作也被合并到第一次调用<code>belongs-before?</code>中。当然，可能引起误解的部分我都已经在上面的代码中给了注释，有兴趣或者疑惑的朋友可以详细看一下。</p>
<p>删除<code>agenda</code>的第一项指删除第一个<code>segement</code>的<code>queue</code>的第一个<code>action</code>，并检查操作完成这个<code>segement</code>的<code>queue</code>是否为空，如果为空，则没有必要保留这个<code>segement</code>了。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">remove-first-agenda-item!</span> agenda) <span class="comment">;modifies the agenda by removing the first item</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">q</span> (<span class="name">segment-queue</span> (<span class="name">first-segment</span> agenda))))</span><br><span class="line">    (<span class="name">delete-queue!</span> q)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">empty-queue?</span> q)</span><br><span class="line">      (<span class="name">set-segments!</span> agenda (<span class="name">rest-segments</span> agenda)))))</span><br></pre></td></tr></table></figure></p>
<p>当我们在诸如开始处理模拟等程序中，取<code>agenda</code>的第一项时，除了要读出第一个<code>segement</code>的<code>queue</code>中第一个元素，还需要把当前时间<code>current-time</code>设置为这一项<code>action</code>发生的时间
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-agenda-item</span> agenda) <span class="comment">;returns the first item on the agenda</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">empty-agenda?</span> agenda)</span><br><span class="line">  (<span class="name">error</span> <span class="string">"Agenda is empty: FIRST-AGENDA-ITEM"</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">first-seg</span> (<span class="name">first-segment</span> agenda)))</span><br><span class="line">    (<span class="name">set-current-time!</span> agenda</span><br><span class="line">                      (<span class="name">segment-time</span> first-seg))</span><br><span class="line">    (<span class="name">front-queue</span> (<span class="name">segment-queue</span> first-seg)))))</span><br></pre></td></tr></table></figure></p>
<h3>The-agenda</h3>
<p>现在假设我们通过
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> the-agenda (<span class="name">make-agenda</span>))</span><br></pre></td></tr></table></figure></p>
<p>创建了一个新的，用于开始我们这次模拟的实例<code>the-agenda</code>，把所有需要完成的仿真行为添加到这个<code>the-agenda</code>中，所有的模拟都通过调用<code>the-agenda</code>相关程序实现。</p>
<p>很容易想象一个已经完成的数字电路应该具有这样的特性：</p>
<blockquote>
<p>给出一些输入信号，在一定<strong>延迟时间</strong>后得到输出信号</p>
</blockquote>
<p>&lt;a name=&quot;after-delay&quot;&gt;&lt;/a&gt;</p>
<p>而延迟时间因电路而异，这里暂时先不讨论，只讨论<strong>延迟</strong>的性质如何通过<code>the-agenda</code>模拟：利用带有时间参数<code>delay</code>和过程参数<code>action</code>的<code>after-delay</code>过程，使得<code>action</code>在<code>delay</code>时间后才被执行，那么直接的做法便是把<code>action</code>添加到<code>the-agenda</code>的当前时间延迟后的某个时间的执行队列：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">after-delay</span> delay action)</span><br><span class="line">  (<span class="name">add-to-agenda!</span> (<span class="name"><span class="builtin-name">+</span></span> delay (<span class="name">current-time</span> the-agenda))</span><br><span class="line">                  action</span><br><span class="line">                  the-agenda))</span><br></pre></td></tr></table></figure></p>
<p>开始我们的模拟进程需要一个<code>propagate</code>过程来按照时间和队列顺序执行<code>the-agenda</code>中的所有操作。当模拟运行时，不断的会有新的指令被添加到<code>the-agenda</code>，<code>propagate</code>就会一直持续进行直至没有未被执行的操作留在<code>the-agenda</code>为止。</p>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-exclamation-circle&quot;&gt;&lt;/i&gt; Note</h4>
<p>这里暂时还没能实现监听器来实时监听事件的添加，所以原文中虽然给的是很具有迷惑性的说法</p>
<blockquote>
<p>In general, as the simulation runs, new items will be added to the agenda, and <code>propagate</code> will continue the simulation as long as there are items on the agenda</p>
</blockquote>
<p>但实际上我们可以看到后面的实现中，每当有新的操作被添加，完成上述任务的方法是紧随其后再调用一次<code>(propagate)</code>的伪实时监听。</p>
</div></p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">propagate</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">empty-agenda?</span> the-agenda)</span><br><span class="line">      <span class="symbol">'done</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">first-item</span> (<span class="name">first-agenda-item</span> the-agenda)))</span><br><span class="line">        (<span class="name">first-item</span>)</span><br><span class="line">        (<span class="name">remove-first-agenda-item!</span> the-agenda)</span><br><span class="line">        (<span class="name">propagate</span>))))</span><br></pre></td></tr></table></figure></p>
<p>每个事件被执行后都被移出了<code>the-agenda</code>，防止多次调用<code>(propagate)</code>造成的重复执行。</p>
<h2>Wire</h2>
<p>整个数字电路模型的基本原件——导线是数字信号的载体，而数字信号只有两种可能的取值，高电平<code>1</code>和低电平<code>0</code>。除此之外，组成电路的还有我们之后会讨论的<a href="#Function-box">功能部件（function box）</a>，不同的导线可以接入这些部件作为输入，也可以作为输出。</p>
<p>我们先来构造一种计算对象<code>wire</code>来承载数字信号，用于表示导线。这种数据结构需要提供这些操作的接口：&lt;a name=&quot;wire-method&quot;&gt;&lt;/a&gt;</p>
<ul>
<li><code>(get-signal &lt;wire&gt;)</code> 得到这根导线现在承载的数字信号值</li>
<li><code>(set-signal! &lt;wire&gt; &lt;new value&gt;)</code> 改变它的值为指定值</li>
<li>&lt;a name=&quot;add-action!&quot;&gt;&lt;/a&gt;<code>(add-action! &lt;wire&gt; &lt;procedure of no arguments&gt;)</code>将某个过程绑定到这根导线上，使得每当这根导线上的信号值发生改变的同时触发这个过程的执行。这些无参数的过程也是非常特殊的过程，执行时会与其他导线发生通信。</li>
</ul>
<p>考虑如何设计数据结构<code>wire</code>时，我们可以像<code>agenda</code>一样把它想象成一个存储数据的结构，那么只需要存放两个局部状态变量</p>
<ul>
<li><code>signal-value</code> 一个取值为0或1的整数，表示这根导线上现在的数字信号值</li>
<li><code>action-procedures</code> 一个<code>list</code>，存放所有被绑定到这根导线上的过程</li>
</ul>
<p>直接的做法是把两个变量打包用<code>cons</code>打包成一个<code>pair</code>然后写一些把它作为参数的<code>get/set</code>操作，但原书中给出的实现示例是message-passing风格的，即构造完<code>wire</code>后返回一个带有本地局部状态变量的<code>dispatch</code>函数，它通过参数选择适当的局部函数返回。创建一个新的导线的命令<code>(make-wire)</code>可以写为如下过程：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-wire</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">signal-value</span> <span class="number">0</span>) (<span class="name">action-procedures</span> '()))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-my-signal!</span> new-value)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">=</span></span> signal-value new-value))</span><br><span class="line">          (<span class="name"><span class="builtin-name">begin</span></span> (<span class="name"><span class="builtin-name">set!</span></span> signal-value new-value)</span><br><span class="line">                 (<span class="name">call-each</span> action-procedures)) <span class="comment">;change value of signal will lead to the call of every procedures added to the wire</span></span><br><span class="line">          <span class="symbol">'done</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accept-action-procedure!</span> proc)</span><br><span class="line">      (<span class="name"><span class="builtin-name">set!</span></span> action-procedures (<span class="name"><span class="builtin-name">cons</span></span> proc action-procedures))</span><br><span class="line">      (<span class="name">proc</span>))</span><br><span class="line"></span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">dispatch</span> m)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">eq?</span></span> m <span class="symbol">'get-signal</span>) signal-value)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> m <span class="symbol">'set-signal!</span>) set-my-signal!)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> m <span class="symbol">'add-action!</span>) accept-action-procedure!)</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Unknown operation -- WIRE"</span> m))))</span><br><span class="line">    dispatch))</span><br></pre></td></tr></table></figure></p>
<p><code>set-my-signal!</code>会先检查当前的信号值是否需要被改变，如果需要才会重新设置<code>signal-value</code>并调用所有被绑定到导线上的无参过程。调用整个<code>action-procedures</code>用到的过程<code>call-each</code>定义如下：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">call-each</span> procedures)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> procedures)</span><br><span class="line">      <span class="symbol">'done</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">        ((<span class="name"><span class="builtin-name">car</span></span> procedures))</span><br><span class="line">        (<span class="name">call-each</span> (<span class="name"><span class="builtin-name">cdr</span></span> procedures)))))</span><br></pre></td></tr></table></figure></p>
<p>这个函数与scheme原语<code>for-each</code>以及common-lisp原语<code>mapc</code>的行为有部分相似之处，也可以这样定义为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">call-each</span> procedures)</span><br><span class="line">  (<span class="name"><span class="builtin-name">for-each</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (proc) (<span class="name">proc</span>)) procedures))</span><br></pre></td></tr></table></figure></p>
<p>另外需要特别注意的是，我们看到<code>accept-action-procedure!</code>每次在执行添加<code>proc</code>命令后，立刻又调用了一次新添加的过程<code>(proc)</code>，如果不进行这个操作而只是简单的写成
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">accept-action-procedure!</span> proc)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set!</span></span> action-procedures</span><br><span class="line">        (<span class="name"><span class="builtin-name">cons</span></span> proc action-procedures)))</span><br></pre></td></tr></table></figure></p>
<p>而不调用一下刚被添加的过程<code>proc</code>，那么<code>proc</code>永远不会被执行，<code>the-agenda</code>也永远不会不会被添加任何<code>action</code>，所有导线上的信号都始终为<code>0</code>，这个模拟毫无意义。</p>
<p>为了使对于<code>wire</code>的操作更加顺应用户的使用习惯，还需要再规定一些语法糖把返回<code>dispatch</code>函数进行一番包装得到我们<a href="#wire-method">上文</a>提出最终需要实现的三个函数：</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-signal</span> wire)</span><br><span class="line">  (<span class="name">wire</span> <span class="symbol">'get-signal</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-signal!</span> wire new-value)</span><br><span class="line">  ((<span class="name">wire</span> <span class="symbol">'set-signal!</span>) new-value))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-action!</span> wire action-procedure)</span><br><span class="line">  ((<span class="name">wire</span> <span class="symbol">'add-action!</span>) action-procedure))</span><br></pre></td></tr></table></figure></p>
<p>这种风格的函数原型会更加符合大多数程序设计者，尤其是经常接触面向对象编程者的思维习惯：比如当我们使用<code>(wire 'get-signal)</code>时会把<code>wire</code>想象成一个把<code>'get-signal</code>指令作为参数被调用的<strong>过程</strong>，而<code>(get-signal wire)</code>会让人更倾向于把<code>wire</code>当成一个<strong>数据对象</strong>，被当成输出传入到<code>get-signal</code>过程。当然如上文所言，这只是一个语法糖，两个过程实质没什么区别。如果在一种程序设计语言中过程可以被当成数据对象被处理，即函数式编程的一大特征：函数/过程也是一等公民，那么你完全可以根据自己的习惯，自由的选择编程风格使之更像过程或者对象。</p>
<p>现在再来想象一下我们需要完成的数字电路：每根导线上的信号会随着时间变化，会被添加进电路并，会不断的被连接到新设备。导线毫无疑问是可变的数据对象，我们用局部状态变量（<code>signal-value</code>和<code>action-procedures</code>）的赋值来模拟这种行为，每当有新的导线被创建，就会有一组新的局部状态变量被分配，通过导线构造时返回的接口过程<code>dispatch</code>可以对该导线进行操作，用来这些新的局部状态变量来捕获电路环境的变化。</p>
<p>一根导线可以同时被连接到不同的设备，多根导线也可以被连接到同一个设备。因此，一个设备交互而引发的某根导线上的信号变化，可能会引发设备上连接的其他导线上的信号变化，进而引起更多的导线信号变化。在连接建立完成后，导线通过调用<code>action-procedure</code>向邻接的导线通信，告知信号的变化。</p>
<h3>Probe</h3>
<p>为了观察模拟运行的全过程，我们需要一些辅助工具来显示导线上数字信号值的变化。为了达到这个目的，需要在导线上放置一个“探针”<code>probe</code>，可以把它想象成一个外接的电位表，每当示数发生变化时立刻发起一个通知，并显示此刻的新信号值，当前时间以及它自己的ID（为了区分这是放置在哪根导线上的<code>probe</code>），相当于一个监视器的角色&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">probe</span> name wire)</span><br><span class="line">  (<span class="name">add-action!</span> wire</span><br><span class="line">               (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                 (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> name)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> <span class="string">" "</span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> (<span class="name">current-time</span> the-agenda))</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"  New-value = "</span>)</span><br><span class="line">                 (<span class="name"><span class="builtin-name">display</span></span> (<span class="name">get-signal</span> wire))</span><br><span class="line">                 (<span class="name"><span class="builtin-name">newline</span></span>))))</span><br></pre></td></tr></table></figure></p>
<p>这个过程是给<code>wire</code>安排一个名为<code>name</code>的<code>probe</code>，其中的lambda表达式引导的可以看成一个格式化输出打印过程，通过<code>add-action!</code>被绑定到了<code>wire</code>上，<code>wire</code>的信号发生改变时会被调用以打印这个信号变化。这个打印过程也是我们到此为止第一次接触到的，前文所说的，可以被添加的<code>action-procedures</code>的特殊的无参过程。</p>
<p><code>probe</code>的使用场合为：模拟开始前，每次创建新的导线时，再新导线上绑定一个探针（通常与导线同名），用以观察信号的变化。当然，承载原始输入信号的导线没有太大必要被监视，但为了获取完整的模拟结果，也可以对它们放置探针。</p>
<h2>Function box</h2>
<p>功能部件的表现如它的名字function，将一些信号作为输入，并输出一些信号。不过有一点不同于数学中定义的函数概念：从接受输入到给出会存在一定的延迟，这倒是更像我们在编程中用到的函数实现，毕竟函数计算存在延迟，实质上也是因为电路信号的处理存在延迟。</p>
<p>因此不妨把这些部件和我们之前接触到的函数一样抽象成一个黑盒，我们不知道它是如何实现的，但是知道该怎么用，比如我们接下来要实现的<em>and运算器</em>在现实中就被做成一个74LS08芯片，虽然对芯片内部一无所知，但这并不妨碍我们根据手册知道哪几个针脚接输入，哪几个针脚接输出，然后直接使用。</p>
<p>但我们的模拟不满足于仅仅根据文档调用模拟function box的function，而是设计实现这些function，如同编程一样，从primitives开始进行实现，再用这些primitive function box去完成更复杂的box的定义。</p>
<h3>Primitive function box</h3>
<p>模拟器内所有的功能部件都可以基于这三种基本的部件实现：</p>
<ol>
<li><strong>非</strong>（inverter）：对一个输入信号取非，在延迟时间后返回</li>
<li><strong>与门</strong>（and-gate）: 对两个输入信号进行逻辑与运算，当且仅当两个输入都为1时，在延迟时间后返回1，否则为0</li>
<li><strong>或门</strong>（or-gate）: 对两个输入信号进行逻辑或运算，当且仅当两个输入都为0时，在延迟时间后返回0，否则为1</li>
</ol>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/primitive-functions.png?inline=false" alt="三种基本元件的符号表示"></p>
<p>我们可以先试着实现一个<code>inverter</code>。逻辑非运算<code>(logical-not s)</code>的定义不难编写，需要考虑的是<code>input</code>和<code>output</code>怎样体现这种通过<code>inverter</code>绑定的关联，即每当<code>input</code>导线上的信号值发生改变时，<code>output</code>也需要随之被改变，这也就是<a href="#add-action!"><code>add-action!</code></a>过程的用武之地了：在<code>input</code>导线上添加一个改变<code>output</code>为<code>input</code>的非值的过程</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inverter</span> input output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">invert-input</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">new-value</span> (<span class="name">logical-not</span> (<span class="name">get-signal</span> input))))</span><br><span class="line">      (<span class="name">after-delay</span> inverter-delay</span><br><span class="line">                   (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                     (<span class="name">set-signal!</span> output new-value))))) <span class="comment">;output signal changes after one inverter-delay</span></span><br><span class="line">  (<span class="name">add-action!</span> input invert-input)</span><br><span class="line">  <span class="symbol">'ok</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">logical-not</span> s)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">=</span></span> s <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">=</span></span> s <span class="number">1</span>) <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s))))</span><br></pre></td></tr></table></figure></p>
<p>被添加到<code>input</code>的实际上是一个<a href="#after-delay"><code>after-delay</code></a>过程，<code>inverter-delay</code>是个根据不同环境由用户自己定义的inverter电路的延迟数值，lambda表达式定义的命令，即设置<code>output</code>为新的结果通过<code>after-delay</code>被添加到<a href="#The-agenda"><code>the-agenda</code></a>。</p>
<p><code>and-gate</code>的实现稍微复杂一些，两个输入的信号值都会影响输出信号。同样这里规定<code>and-gate</code>本身的延迟为某个常数<code>and-gate-delay</code></p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">and-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">and-action-procedure</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">new-value</span></span><br><span class="line">          (<span class="name">logical-and</span> (<span class="name">get-signal</span> a1) (<span class="name">get-signal</span> a2))))</span><br><span class="line">      (<span class="name">after-delay</span></span><br><span class="line">        and-gate-delay</span><br><span class="line">        (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">set-signal!</span> output new-value)))))</span><br><span class="line">  (<span class="name">add-action!</span> a1 and-action-procedure)</span><br><span class="line">  (<span class="name">add-action!</span> a2 and-action-procedure)</span><br><span class="line">  <span class="symbol">'ok</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">logical-and</span> s1 s2)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">1</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">1</span>)) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">0</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">0</span>)) <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s1 s2))))</span><br></pre></td></tr></table></figure></p>
<p>类似地，可以定义<code>or-gate</code>为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">or-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">or-action-procedure</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">new-value</span></span><br><span class="line">           (<span class="name">logical-or</span> (<span class="name">get-signal</span> a1) (<span class="name">get-signal</span> a2))))</span><br><span class="line">      (<span class="name">after-delay</span></span><br><span class="line">       or-gate-delay</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">set-signal!</span> output new-value)))))</span><br><span class="line">  (<span class="name">add-action!</span> a1 or-action-procedure)</span><br><span class="line">  (<span class="name">add-action!</span> a2 or-action-procedure)</span><br><span class="line">  <span class="symbol">'ok</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">logical-or</span> s1 s2)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">0</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">0</span>)) <span class="number">0</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">=</span></span> s1 <span class="number">1</span>) (<span class="name"><span class="builtin-name">=</span></span> s2 <span class="number">1</span>)) <span class="number">1</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s1 s2))))</span><br></pre></td></tr></table></figure></p>
<hr>
<p>众所周知，根据De Morgan定律$$A+B= \overline{\bar A \cdot \bar B}$$<code>or-get</code>也同样可以利用已经定义好的<code>inverter</code>和<code>and-gate</code>进行构造，这同时也是<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-22.html#%25_thm_3.29" target="_blank" rel="noopener">习题3.29</a>要求完成的内容</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">or-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">a1-inv</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">a2-inv</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">temp</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">inverter</span> a1 a1-inv)</span><br><span class="line">    (<span class="name">inverter</span> a2 a2-inv)</span><br><span class="line">    (<span class="name">and-gate</span> a1-inv a2-inv temp)</span><br><span class="line">    (<span class="name">inverter</span> temp output)))</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们第一次利用两种primitives构造出一个“更复杂”的box，遵循如上定义的<code>or-gate</code>具有2<code>inverter-delay</code>+<code>and-delay</code>的延迟。接下来，我们还会用类似于组合出<code>or-gate</code>的思路，去构造一些更复杂的功能部件。</p>
<h3>Half-adder</h3>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/half-adder.png?inline=false" alt="一位半加器电路"></p>
<p>如图所示，半加器（half-adder）由一个<code>or-gate</code>，两个<code>and-gate</code>和一个<code>inverter</code>组成，它的功能是接受两个1位的数字信号$A$和$B$，产生两个输出$S$和$C$，$S$表示和（sum），$C$表示进位（carry），需要满足如下的逻辑关系：
$$ \begin{align}
S &amp;=A \cdot \bar B + \bar A \cdot B \\
C &amp;= A \cdot B
\end{align}$$直接按照图中电路搭建也是可行方案之一，这里的<code>a</code>,<code>b</code>,<code>s</code>,<code>c</code>均为图上相应符号位置的<code>wire</code>对象
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">half-adder</span> a b s c) <span class="comment">;input: a,b output:s,c</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">d</span> (<span class="name">make-wire</span>)) (<span class="name">e</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">or-gate</span> a b d) <span class="comment">;d=a+b</span></span><br><span class="line">    (<span class="name">and-gate</span> a b c) <span class="comment">;c=ab</span></span><br><span class="line">    (<span class="name">inverter</span> c e) <span class="comment">;e=c'=(ab)'=a'+b'</span></span><br><span class="line">    (<span class="name">and-gate</span> d e s) <span class="comment">;s=ed=(a+b)(a'+b')=ab'+a'b</span></span><br><span class="line">    <span class="symbol">'ok</span>))</span><br></pre></td></tr></table></figure></p>
<p>计算整个电路的延迟只需按照寻找关键路径的方法&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;找到使延迟最大的路径，拓扑排序后$C \to E \to S$，只要考虑得到$S$的路径：</p>
<ul>
<li>$A,B \to C$: <code>and-gate-delay</code></li>
<li>$A,B \to D$: <code>or-gate-delay</code></li>
<li>$A,B (\to C) \to E$: <code>and-gate-delay</code>+<code>inverter-gate-delay</code></li>
<li>$A,B (\to D)/(\to E) \to S$: <code>max</code>(<code>and-gate-delay</code>+<code>inverter-gate-delay</code>,<code>or-gate-delay</code>)+<code>and-gate-delay</code></li>
</ul>
<p>&lt;a name=&quot;half-adder-delay&quot;&gt;&lt;/a&gt;
总延迟<code>half-adder-delay</code>为<code>max</code>(<code>and-gate-delay</code>+<code>inverter-gate-delay</code>,<code>or-gate-delay</code>)+<code>and-gate-delay</code></p>
<h3>Full-adder</h3>
<p>前面我们把半加器封装成了类似于电路元件的<code>half-adder</code>，以便直接利用<code>half-adder</code>组装其他电路，比如接下来将介绍的一位全加器(full-adder)
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/full-adder.png?inline=false" alt="一位全加器电路">
就是由两个<code>half-adder</code>和一个<code>or-gate</code>组成的，是加法运算电路的基本原件。相比<code>half-adder</code>，增加一个输入位$C_{\text{in}}$表示上一位的进位，$A$和$B$依然表示此位的两个输入位，得到输出：和$SUM$与下一位的进位$C_{\text{out}}$，需要满足关系$$\begin{align}
SUM &amp;=A \cdot \bar B \cdot \bar C_{\text{in}} + \bar A \cdot B \cdot \bar C_{\text{in}} + \bar A \cdot \bar B \cdot C_{\text{in}} \\
C_{\text{out}} &amp; = A \cdot B + A  \cdot C_{\text{in}} +  B \cdot C_{\text{in}}
\end{align}$$同样我们直接按照图中的电路搭建<code>full-adder</code>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">full-adder</span> a b c-in sum c-out)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">s</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">c1</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">c2</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">half-adder</span> b c-in s c1)<span class="comment">; s=b(c-in)'+b'(c-in) c1=b(c_in)</span></span><br><span class="line">    (<span class="name">half-adder</span> a s sum c2)</span><br><span class="line">    <span class="comment">;sum=as'+a's=a(b(c-in)+b'(c-in)')+a'(b(c-in)'+b'(c-in))</span></span><br><span class="line">    <span class="comment">;sum=ab(c-in)+ab'(c-in)'+a'b(c-in)'+a'b'(c-in)</span></span><br><span class="line">    <span class="comment">;c2=as=ab(c-in)'+ab'(c-in)</span></span><br><span class="line">    (<span class="name">or-gate</span> c1 c2 c-out)</span><br><span class="line">    <span class="comment">;c-out=c1+c2=b(c_in)+ab(c-in)'+ab'(c-in)</span></span><br><span class="line">    <span class="comment">;c-out=b(c_in)+(ab(c_in)+ab(c-in)')+(ab(c_in)+ab'(c-in))</span></span><br><span class="line">    <span class="comment">;c-out=b(c_in)+ab+a(c_in)</span></span><br><span class="line">    <span class="symbol">'ok</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里不再详细给出总延迟的详细分析过程，感兴趣的读者可以仿照上文的方法计算，$C_{\text{out}}$的延迟为<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>,$SUM$的延迟为2<code>half-adder-delay</code>，那么全加器的总延迟<code>full-adder-delay</code>=2<a href="#half-adder-delay"><code>half-adder-delay</code></a></p>
<h3>Ripple-carry adder</h3>
<p>同样，接下来我们可以用<code>full-adder</code>组建更加复杂的电路，比如完成n位加法运算的电路——串行进位加法器（ripple-carry adder）
<img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/digital-circuits/ripple-carry.png?inline=false" alt="串行进位加法器电路，FA表示全加器（full adder）">
这是对两个n位二进制$A$和$B$进行平行加法运算的最简单的电路，n个全加器级联，将$A_1,A_2,\ldots,A_n$从高到低最为$A$的各位输入，$B_1,B_2,\ldots,B_n$从高到低最为$B$的各位输入，生成的$S_1,S_2,\ldots,S_n$组成加法运算的结果，当然还附带着进位$C$。我们设计的<code>ripple-carry-adder</code>的四个参数</p>
<ul>
<li><code>a</code>: 一个由<code>n</code>个<code>wire</code>组成的<code>list</code>，从高到低表示被加数$A$的每一位的值</li>
<li><code>b</code>: 一个由<code>n</code>个<code>wire</code>组成的<code>list</code>，从高到低表示加数$B$的每一位的值</li>
<li><code>s</code>: 一个由<code>n</code>个<code>wire</code>组成的<code>list</code>，从高到低表示和$S$的每一位的值</li>
<li><code>c</code>: <code>wire</code>，表示最终进位$C$的值</li>
</ul>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-adder</span> a b s c)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">c-in</span> (<span class="name">make-wire</span>)))</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> a)) <span class="comment">;if it is the last bit</span></span><br><span class="line">          (<span class="name">set-signal!</span> c-in <span class="number">0</span>) <span class="comment">;c-in is set to be 0</span></span><br><span class="line">          (<span class="name">ripple-carry-adder</span> (<span class="name"><span class="builtin-name">cdr</span></span> a) (<span class="name"><span class="builtin-name">cdr</span></span> b) (<span class="name"><span class="builtin-name">cdr</span></span> s) c-in))</span><br><span class="line">          <span class="comment">;otherwise,c-in should be the c-out from lower bits</span></span><br><span class="line">        (<span class="name">full-adder</span> (<span class="name"><span class="builtin-name">car</span></span> a) (<span class="name"><span class="builtin-name">car</span></span> b) c-in (<span class="name"><span class="builtin-name">car</span></span> s) c)))</span><br></pre></td></tr></table></figure></p>
<p>$C_{k}$的延迟只来自于$C_{k+1}$的输入延迟和半加器的继位运算结果，信号传播到达$C_{k}$的延迟<code>Ck-delay</code>可以写为<code>Ck+1-delay</code>+<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>，<code>Cn-delay</code>为0，累加得到到$C$（即$C_0$）的延迟为<code>n</code>*(<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>)</p>
<p>而每个$S_{k}$的延迟也只取决于$C_{k+1}$的输入延迟和半加器的和运算结果，信号传播到<code>$S\_{k}$</code>的延迟<code>Sk-delay</code>可以写为<code>Ck+1-delay</code>+<code>full-adder-delay</code>，最后传播到达$S_1$的延迟为<code>(n-1)</code>*(<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>)+<code>full-adder-delay</code></p>
<p>我们在分析全加器总延迟时已经得到<code>full-adder-delay</code>大于<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>的结论，那么这里也可以得出这样的结论：串行进位加法器的总延迟为<code>(n-1)</code>*(<code>or-gate-delay</code>+<code>and-gate-delay</code>+<code>half-adder-delay</code>)+<code>full-adder-delay</code></p>
<p>习题中也要求过用三种基本元件的延迟来表示这个电路的总延迟，按照上面的分析可以直观的写为
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> half-adder-delay</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">max</span></span> (<span class="name"><span class="builtin-name">+</span></span> and-gate-delay inverter-delay)</span><br><span class="line">          or-gate-delay)</span><br><span class="line">     and-gate-delay))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> full-adder-delay</span><br><span class="line">  (<span class="name"><span class="builtin-name">*</span></span> <span class="number">2</span> half-adder-delay))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-c</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-c-iter</span> k)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> k n)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">+</span></span> or-gate-delay</span><br><span class="line">           and-gate-delay</span><br><span class="line">           half-adder-delay</span><br><span class="line">           (<span class="name">ripple-carry-c-iter</span> (<span class="name"><span class="builtin-name">+</span></span> k <span class="number">1</span>)))))</span><br><span class="line">  (<span class="name">ripple-carry-c-iter</span> <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-s</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">ripple-carry-c</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>) full-adder-delay)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ripple-carry-adder-delay</span> n)</span><br><span class="line">  (<span class="name">ripple-carry-s</span> n))</span><br></pre></td></tr></table></figure></p>
<h2>A sample simulation</h2>
<p>通过前面的工作，我们已经搭建好了一个数字电路模拟的环境。接下来可以像我们在现实中的实验环境一样，自由的取用导线和元件搭建电路，改变输入，观测输出。我也已经把以上代码连同需要用到的更底层的queue定义打包写到了<a href="https://gist.github.com/Lixinyi-DUT/8a63a3005ae7814ece306e6dc12480f7" target="_blank" rel="noopener">digital-circuits-package.scm</a>，你可以使用一些可视化的在线scheme REPL工具如<a href="https://scheme-legacy.apps.cs61a.org/" target="_blank" rel="noopener">Scheme Interpreter and Visualizer</a>或<a href="https://scheme-legacy.apps.cs61a.org/editor.html" target="_blank" rel="noopener">Editor</a>，通过命令</p>
<p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">download</span> <span class="symbol">'8a63a3005ae7814ece306e6dc12480f7</span>)</span><br></pre></td></tr></table></figure></p>
<p>直接下载安装上文搭建的环境。在这个环境中，你可以通过<code>make-wire</code>增加导线，用<code>probe</code>进行监视，直接调用<code>inverter</code>,<code>and-gate</code>,<code>or-gate</code>，<code>half-adder</code>，<code>full-adder</code>连接出新的电路，用<code>set-signal!</code>改变输入信号值。除此之外，它们本来就是非常优秀的可视化工具，你还可以在一步步搭建电路的同时用
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">draw-pair</span> the-agenda)</span><br><span class="line">(<span class="name">visualize</span> (<span class="name">half-adder</span> a b s c))</span><br><span class="line">(<span class="name">diagram</span>)</span><br></pre></td></tr></table></figure></p>
<p>等命令去观察这个管理模拟进程的<code>agenda</code>本质上是一个什么样的数据结构，半加器电路的连接一步步会进行哪些操作，整个执行环境的变量又是如何被绑定的……更多用法还请根据需求自行开发。</p>
<p>当然，在国内有时可能会因为一些众所周知的原因无法使用上述工具，不过没关系，一步步跟着上面的解释慢慢写就可以了。接下来直接用原书上给出的一个简单的例子来结束本文，至此终于有始有终的带着大家看到我们辛辛苦苦写的模型第一次得到了应用。</p>
<p>首先根据你的需求设置三种基本元件的延迟时间，并初始化<code>the-agenda</code>：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> inverter-delay <span class="number">2</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> and-gate-delay <span class="number">3</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> or-gate-delay <span class="number">5</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> the-agenda (<span class="name">make-agenda</span>))</span><br></pre></td></tr></table></figure></p>
<p>我们准备模拟一个简单的半加器的行为，于是先新建四根导线
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> input-1 (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> input-2 (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> sum (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> carry (<span class="name">make-wire</span>))</span><br></pre></td></tr></table></figure></p>
<p>为了观察输出，在两个输出位安置<a href="#Probe"><code>probe</code></a>并随即打印示数
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">probe</span> <span class="symbol">'sum</span> sum)</span><br><span class="line"><span class="comment">;sum 0  New-value = 0</span></span><br><span class="line"></span><br><span class="line">(<span class="name">probe</span> <span class="symbol">'carry</span> carry)</span><br><span class="line"><span class="comment">;carry 0  New-value = 0</span></span><br></pre></td></tr></table></figure></p>
<p>把它们通过半加器连接
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">half-adder</span> input-1 input-2 sum carry)</span><br><span class="line"><span class="comment">;ok</span></span><br></pre></td></tr></table></figure></p>
<p>此时改变输入信号<code>input-1</code>的值为1，在一个<code>half-adder-delay</code>后不出所望，<code>sum</code>探针通知<code>sum</code>的值已经改变为1了
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-signal!</span> input-1 <span class="number">1</span>)</span><br><span class="line"><span class="comment">;done</span></span><br><span class="line">(<span class="name">propagate</span>)</span><br><span class="line"><span class="comment">;sum 8 New-value = 1</span></span><br><span class="line"><span class="comment">;done</span></span><br></pre></td></tr></table></figure></p>
<p>注意当前模拟时间为第8个单元，现在再改变输入信号<code>input-2</code>的值为1，可以看到在一个<code>or-gate-delay</code>后<code>carry</code>位发生了改变了，从输入改变开始一个<code>half-adder-delay</code>后<code>sum</code>位输出也发生了改变：
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-signal!</span> input-2 <span class="number">1</span>)</span><br><span class="line"><span class="comment">; done</span></span><br><span class="line"></span><br><span class="line">(<span class="name">propagate</span>)</span><br><span class="line"><span class="comment">; carry 11  New-value = 1</span></span><br><span class="line"><span class="comment">; sum 16  New-value = 0</span></span><br><span class="line"><span class="comment">; done</span></span><br></pre></td></tr></table></figure></p>
<h2>Summary</h2>
<p>至此，整个章节的内容可以说是全部覆盖了。在这篇文章中，我们定义了一个特殊的一维表<code>agenda</code>来管理整个模拟的进程，用封装了本地状态的<code>wire</code>模拟了信号载体导线的行为，根据逻辑实现了各种功能元件的连接模拟。</p>
<p>对于实际应用来说，我们至此所做的算不上什么有意义的工作，但通过一步步编写设计去思考它们的应用场景，也会开始逐渐感觉到编程是很有趣的事，用函数式编程语言去完成之前用面向对象编程语言实现的任务尤甚。</p>
<p>希望我的这篇文章能帮助正在困惑的你跨过可变数据建模理解上的障碍，带领正在无聊的你发现一个更有意思的世界。</p>
<blockquote>
<p>祝你早日找到住在计算机中的神灵</p>
</blockquote>
<p>也祝我。
&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;虽然MIT已经提供了html形式的全文开源，但为了获取更好的阅读体验，推荐下载&lt;a href=&quot;https://github.com/sarabander/sicp-pdf&quot;&gt;这个排版精美的非官方电子版&lt;/a&gt;或&lt;a href=&quot;https://xuanji.appspot.com/isicp/index.html&quot;&gt;在线交互版&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;SICP全书倾向于在display函数的第一个指令放置&lt;code&gt;(newline)&lt;/code&gt;但经常忽略在打印完成后使用&lt;code&gt;(newline)&lt;/code&gt;给其他命令空间，我们可以看到前面的&lt;code&gt;'done'&lt;/code&gt;之前都没有用&lt;code&gt;(newline)&lt;/code&gt;刷新，如果用原始版本的&lt;code&gt;probe&lt;/code&gt;定义，可能会造成显示混乱，为此我在最后一行添加了一个&lt;code&gt;(newline)&lt;/code&gt;使输出更符合读者的观感。&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;3.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;https://en.wikipedia.org/wiki/Critical_path_method&lt;/span&gt;&lt;a href=&quot;#fnref:3&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/represent-digital-circuits-simulator/" data-id="cjm54ylp3003lfkw3x2xxi4g7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数字电路/">数字电路</a></li></ul>


    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-100" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-100/" class="article-date"><time datetime="2018-09-02T12:17:41.957Z" itemprop="datePublished">2018-09-02</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-100</p>
<p>&lt;!-- more --&gt;</p>
<h2>Monotonic Array</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/monotonic-array/</p>
<blockquote>
<p>An array is <em>monotonic</em> if it is either monotone increasing or monotone decreasing.</p>
</blockquote>
<blockquote>
<p>An array <code>A</code> is monotone increasing if for all <code>i &lt;= j</code>, <code>A[i] &lt;= A[j]</code>.  An array <code>A</code> is monotone decreasing if for all <code>i &lt;= j</code>, <code>A[i] &gt;= A[j]</code>.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if the given array <code>A</code> is monotonic.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [6,5,4,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4,5]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ol>
<p>判断单调性，似乎没什么复杂的地方。我这里把单调增和减分为两种情况进行讨论，在遇到第一对相邻且不等的数时确定增减。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMonotonic</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mono = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> mono &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                mono = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> A[i] &lt; A[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> mono &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                mono = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Increasing Order Search Tree</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/increasing-order-search-tree/</p>
<blockquote>
<p>Given a tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \</span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given tree will be between <code>1</code> and <code>100</code>.</li>
<li>Each node will have a unique integer value from <code>0</code> to <code>1000</code>.</li>
</ol>
<p>中序遍历一次得到从左至右所有结点的值，再根据这个结果重新组装一个新的，只有右子树的二叉树，没办法，我们没文化的人就是这个样子。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">            <span class="keyword">return</span> in_order(r.left) + [r.val] + in_order(r.right)</span><br><span class="line"></span><br><span class="line">        vals = in_order(root)</span><br><span class="line">        res = TreeNode(vals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(vals) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        p = res</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> vals[<span class="number">1</span>:]:</span><br><span class="line">            p.right = TreeNode(v)</span><br><span class="line">            p = p.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Bitwise ORs of Subarrays</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/bitwise-ors-of-subarrays/</p>
<blockquote>
<p>We have an array <code>A</code> of non-negative integers.</p>
</blockquote>
<blockquote>
<p>For every (contiguous) subarray <code>B = [A[i], A[i+1], ..., A[j]]</code> (with <code>i &lt;= j</code>), we take the bitwise OR of all the elements in <code>B</code>, obtaining a result <code>A[i] | A[i+1] | ... | A[j]</code>.</p>
</blockquote>
<blockquote>
<p>Return the number of possible results.  (Results that occur more than once are only counted once in the final answer.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">There is only one possible result: 0.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].</span><br><span class="line">These yield the results 1, 1, 2, 1, 3, 3.</span><br><span class="line">There are 3 unique values, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">The possible results are 1, 2, 3, 4, 6, and 7.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10^9</code></li>
</ol>
<p>所有<code>A[i]</code>参与得到的或运算结果（包括<code>A[i]</code>），才可能继续和<code>A[i+1]</code>进行或运算并计入结果。那不妨用一个hashset保留在第<code>i</code>轮得到的结果，在<code>i+1</code>轮时直接计算<code>A[i+1]</code>与这些值的或运算结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarrayBitwiseORs</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = set()</span><br><span class="line">        new_res = set()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            new_res = &#123;x | y <span class="keyword">for</span> y <span class="keyword">in</span> new_res&#125;</span><br><span class="line">            new_res.add(x)</span><br><span class="line">            res |= new_res</span><br><span class="line">        <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure></p>
<h2>Orderly Queue</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-100/problems/orderly-queue/</p>
<blockquote>
<p>A string <code>S</code> of lowercase letters is given.  Then, we may make any number of moves.</p>
</blockquote>
<blockquote>
<p>In each move, we choose one of the first <code>K</code> letters (starting from the left), remove it, and place it at the end of the string.</p>
</blockquote>
<blockquote>
<p>Return the lexicographically smallest string we could have after any number of moves.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;cba&quot;, K = 1</span><br><span class="line">Output: &quot;acb&quot;</span><br><span class="line">Explanation:</span><br><span class="line">In the first move, we move the 1st character (&quot;c&quot;) to the end, obtaining the string &quot;bac&quot;.</span><br><span class="line">In the second move, we move the 1st character (&quot;b&quot;) to the end, obtaining the final result &quot;acb&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;baaca&quot;, K = 3</span><br><span class="line">Output: &quot;aaabc&quot;</span><br><span class="line">Explanation:</span><br><span class="line">In the first move, we move the 1st character (&quot;b&quot;) to the end, obtaining the string &quot;aacab&quot;.</span><br><span class="line">In the second move, we move the 3rd character (&quot;c&quot;) to the end, obtaining the final result &quot;aaabc&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= S.length &lt;= 1000</code></li>
<li><code>S</code> consists of lowercase letters only.</li>
</ol>
<p>当<code>K&gt;1</code>时，相邻元素<code>S[i]</code>和<code>S[i+1]</code>可以在调到首尾后通过两次操作交换相对位置，即有一字符串<code>xxxx[ab]xxx</code>可以通过如下几步改变为<code>xxxx[ba]xxx</code>:</p>
<ul>
<li><code>xxxx[ab]xxx</code></li>
<li><code>[ab]xxxxxxx</code> 不断把第一位调换到末尾</li>
<li><code>[a]xxxxxxx[b]</code> 把第二位调换到末尾</li>
<li><code>xxxxxxx[ba]</code> 把第一位调换到末尾</li>
<li><code>xxxx[ba]xxx</code> 不断把第一位调换到末尾</li>
</ul>
<p>即相邻元素之间可以任意调换，那么等效于字符串所有字符就可以以任意顺序打乱重排，进行一次排序即可找到最小的串。</p>
<p>当<code>K=1</code>时，对于每个<code>i</code>考虑<code>S[i:]+S[:i]</code>即当<code>S[i]</code>作为第一个字符的情况即可。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">orderlyQueue</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min([S[i:] + S[:i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S))])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S = list(S)</span><br><span class="line">            S.sort()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(S)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-100/" data-id="cjm54ylfg000nfkw3vlmdlve4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-99" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-99/" class="article-date"><time datetime="2018-08-26T10:22:58.908Z" itemprop="datePublished">2018-08-26</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-99</p>
<p>&lt;!-- more --&gt;</p>
<h2>Surface Area of 3D Shapes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/surface-area-of-3d-shapes/</p>
<blockquote>
<p>On a <code>N * N</code> grid, we place some <code>1 * 1 * 1</code> cubes.</p>
</blockquote>
<blockquote>
<p>Each value <code>v = grid[i][j]</code> represents a tower of <code>v</code> cubes placed on top of grid cell <code>(i, j)</code>.</p>
</blockquote>
<blockquote>
<p>Return the total surface area of the resulting shapes.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 34</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ol>
<p>这题与<a href="https://leetcode.com/problems/projection-area-of-3d-shapes/description/" target="_blank" rel="noopener">Projection Area of 3D Shapes</a>仅要求的求投影面积有所不同，因为存在凹的图形，所以依靠求投影的方法可能会失效。当然平行于<code>xy</code>平面部分的表面积还可以用原来的方法。我这里用一种比较直接的方法计算左侧露出的面积：对于每一排的tower，未被前排遮挡的高度即裸露出来形成表面积的部分。同理，一共需要从左到右，从右到左，从前到后，从后到前分别计算四次露出的面积：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surfaceArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        N = len(grid)</span><br><span class="line">        back = sum(v <span class="keyword">for</span> v <span class="keyword">in</span> grid[<span class="number">0</span>])</span><br><span class="line">        front = sum(v <span class="keyword">for</span> v <span class="keyword">in</span> grid[<span class="number">-1</span>])</span><br><span class="line">        left = sum(grid[j][<span class="number">0</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">        right = sum(grid[j][<span class="number">-1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">        base = sum(v &gt; <span class="number">0</span> <span class="keyword">for</span> r <span class="keyword">in</span> grid <span class="keyword">for</span> v <span class="keyword">in</span> r) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N - <span class="number">1</span>):</span><br><span class="line">            back += sum(max(grid[i + <span class="number">1</span>][j] - grid[i][j], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">            front += sum(max(grid[N - <span class="number">2</span> - i][j] -</span><br><span class="line">                             grid[N - <span class="number">1</span> - i][j], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">            left += sum(max(grid[j][i + <span class="number">1</span>] - grid[j][i], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line">            right += sum(max(grid[j][N - <span class="number">2</span> - i] - grid[j]</span><br><span class="line">                             [N - <span class="number">1</span> - i], <span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(N))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> front + back + left + right + base</span><br></pre></td></tr></table></figure></p>
<h2>Groups of Special-Equivalent Strings</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/groups-of-special-equivalent-strings/</p>
<blockquote>
<p>You are given an array <code>A</code> of strings.</p>
</blockquote>
<blockquote>
<p>Two strings <code>S</code> and <code>T</code> are <em>special-equivalent</em> if after any number of <em>moves</em>, <code>S == T</code>.</p>
</blockquote>
<blockquote>
<p>A move consists of choosing two indices <code>i</code> and <code>j</code> with <code>i % 2 == j % 2</code>, and swapping <code>S[i]</code> with <code>S[j]</code>.</p>
</blockquote>
<blockquote>
<p>Now, a group of <em>special-equivalent</em> strings from <code>A</code> is a non-empty subset of <code>A</code> such that any string not in <code>A</code> is not special-equivalent with any string in A.</p>
</blockquote>
<blockquote>
<p>Return the number of groups of special-equivalent strings from <code>A</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 groups [&quot;aa&quot;], [&quot;bb&quot;], [&quot;ab&quot;], [&quot;ba&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[i].length &lt;= 20</code></li>
<li>All <code>A[i]</code> have the same length.</li>
<li>All <code>A[i]</code> consist of only lowercase letters.</li>
</ol>
<p>这里的<em>special-equivalent</em>指<code>S</code>和<code>T</code>的奇数位字符组成的集合相同，偶数位字符组成的集合也相同。对于长度大于2的字符串，即<code>sorted(S[0::2])==sorted(T[0::2]) and sorted(S[1::2])==sorted(T[1::2])</code>，对于长度为<code>1</code>或<code>2</code>的字符串，直接检查是否为相等。通常的两层遍历开销太大，可以先删去重复元素，再建立一个<code>dict</code>存放偶数位字符集合相同的字符串，对每个字符串找到偶数位相同集合的字符串，检查其中是否还有奇数位相同的，如果有则该字符串不可能独立成新的组。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecialEquivGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d_even = &#123;&#125;</span><br><span class="line">        A = list(set(A))</span><br><span class="line">        res = len(A)</span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>] &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i, w <span class="keyword">in</span> enumerate(A):</span><br><span class="line">            even = tuple(sorted(A[i][<span class="number">0</span>::<span class="number">2</span>]))</span><br><span class="line">            <span class="keyword">if</span> even <span class="keyword">in</span> d_even:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> d_even[even]:</span><br><span class="line">                    <span class="keyword">if</span> sorted(A[i][<span class="number">1</span>::<span class="number">2</span>]) == sorted(A[j][<span class="number">1</span>::<span class="number">2</span>]):</span><br><span class="line">                        res -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                d_even[even].append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d_even[even] = [i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>All Possible Full Binary Trees</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/all-possible-full-binary-trees/</p>
<blockquote>
<p>A <em>full binary tree</em> is a binary tree where each node has exactly 0 or 2 children.</p>
</blockquote>
<blockquote>
<p>Return a list of all possible full binary trees with <code>N</code> nodes.  Each element of the answer is the root node of one possible tree.</p>
</blockquote>
<blockquote>
<p>Each <code>node</code> of each tree in the answer <strong>must</strong> have <code>node.val = 0</code>.</p>
</blockquote>
<blockquote>
<p>You may return the final list of trees in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br><span class="line">Explanation:</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 20</code></li>
</ol>
<p>很显然</p>
<ol>
<li>当<code>N</code>为偶数时，不存在满二叉树</li>
<li>当<code>N==1</code>时，独立的根结点可以形成一个满二叉树</li>
<li>当<code>N&gt;=3</code>时，根结点下有两棵子树，左子树的结点数可以为<code>&lt;N</code>的任意奇数<code>i</code>，右子树的结点数则为<code>N-1-i</code></li>
</ol>
<p>这个问题满足递归定义，比较值得注意的是左右子树相同时应该避免重复计入，以及<code>&lt;N</code>的子问题会被讨论多次所以需要暂时把结果存储起来访问。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    dp = &#123;<span class="number">1</span>: set([TreeNode(<span class="number">0</span>)])&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPossibleFBT</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[TreeNode]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [TreeNode(<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, N + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            self.dp[i] = set()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i, <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> self.dp[j]:</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> self.dp[i - <span class="number">1</span> - j]:</span><br><span class="line">                        r = TreeNode(<span class="number">0</span>)</span><br><span class="line">                        r.left = left</span><br><span class="line">                        r.right = right</span><br><span class="line">                        self.dp[i].add(r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(self.dp[N])</span><br></pre></td></tr></table></figure></p>
<h2>Maximum Frequency Stack</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-99/problems/maximum-frequency-stack/</p>
<blockquote>
<p>Implement <code>FreqStack</code>, a class which simulates the operation of a stack-like data structure.</p>
</blockquote>
<blockquote>
<p><code>FreqStack</code> has two functions:</p>
</blockquote>
<blockquote>
<ul>
<li><code>push(int x)</code>, which pushes an integer <code>x</code> onto the stack.</li>
</ul>
</blockquote>
<ul>
<li><code>pop()</code>, which <strong>removes</strong> and returns the most frequent element in the stack.
<ul>
<li>If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span><br><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span><br><span class="line">Output: [null,null,null,null,null,null,null,5,7,5,4]</span><br><span class="line">Explanation:</span><br><span class="line">After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 5, as 5 is the most frequent.</span><br><span class="line">The stack becomes [5,7,5,7,4].</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.</span><br><span class="line">The stack becomes [5,7,5,4].</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 5.</span><br><span class="line">The stack becomes [5,7,4].</span><br><span class="line"></span><br><span class="line">pop() -&gt; returns 4.</span><br><span class="line">The stack becomes [5,7].</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>Calls to <code>FreqStack.push(int x)</code> will be such that <code>0 &lt;= x &lt;= 10^9</code>.</li>
<li>It is guaranteed that <code>FreqStack.pop()</code> won't be called if the stack has zero elements.</li>
<li>The total number of <code>FreqStack.push</code> calls will not exceed <code>10000</code> in a single test case.</li>
<li>The total number of <code>FreqStack.pop</code> calls will not exceed <code>10000</code> in a single test case.</li>
<li>The total number of <code>FreqStack.push</code> and <code>FreqStack.pop</code> calls will not exceed 150000 across all test cases.</li>
</ol>
<p>因为时间原因，我做的比较草率，没有事实上在栈里面删除被弹出的元素。</p>
<p>这里维护了一个放置元素的列表<code>stack</code>，记录每个元素出现的频数的字典<code>fre</code>，和一个返回当前最大频数元素的堆<code>q</code>。</p>
<p>每次把元素<code>x</code>压入栈中，就把当前状态，即当前<code>x</code>出现的频数<code>fre[x]</code>和它最后一次出现的位置（列表尾部<code>i</code>）组成对压入一个最大堆中（因为<code>heapq</code>实现的是最小堆所以我这里给两个数值都取了负）。每次进行弹栈操作时，从堆中取出最大频数（下标）的元素弹出并在<code>fre</code>更新。一旦从堆中弹出，坐标<code>i</code>不会再次被压入，新压入的元素的下标也总与旧元素的相对顺序保持与栈内一致。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.fre = &#123;&#125;</span><br><span class="line">        self.q = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: void</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.fre[x] = self.fre.get(x, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        heapq.heappush(self.q, (-self.fre[x], -len(self.stack) + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(self.stack)</span><br><span class="line">        max_fre, i = heapq.heappop(self.q)</span><br><span class="line">        self.fre[self.stack[-i]] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = FreqStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br></pre></td></tr></table></figure></p>
<p>当然这题虽然看上去简单，但我一开始真的懒得动脑子就直球<code>pop()</code>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max_fre = max(range(n), key=<span class="keyword">lambda</span> x: (self.stack.count(self.stack[x]), x))</span><br><span class="line"><span class="keyword">return</span> self.stack.pop(max_fre)</span><br></pre></td></tr></table></figure></p>
<p>或者绞尽脑汁去维护相同元素组成的字典列表之类的，肯定是要TLE的，没办法，我们没文化的人就是这个样子.jpg</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-99/" data-id="cjm54ylna002ufkw3w1fan6ku" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LC891-alter" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LC891-alter/">LC891的变体：求所有连续子集的极差之和</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LC891-alter/" class="article-date"><time datetime="2018-08-21T10:42:08.213Z" itemprop="datePublished">2018-08-21</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在上周日的<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-98/">Weekly Contest 98 </a>中的压轴题<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-98/#Sum-of-Subsequence-Widths">Sum of Subsequence Widths</a>(以下简称母题)题解中我特意强调了这里的subsequence只是子集，并不要求所有元素之间的连续，所以做起来会更容易。今天志成<a href="https://weibo.com/5346379929" target="_blank" rel="noopener"><i class="fa fa-weibo"></i> @_FollowYourHeart_</a>问了个很好的问题：如果题目改成连续子集应该怎么做比较好？</p>
<p>&lt;!-- more --&gt;</p>
<h2>问题背景</h2>
<p>有一个整数数组<code>A</code>，其中的元素不保证不相同。对一个非空数组来说，宽度定义为该集合的最大值减去最小值的结果，求<code>A</code>的所有连续子数组的宽度之和。</p>
<p>这里的连续子数组指对于任意$1 \le i \le j \le n$，从<code>A</code>取下标从$i$到$j$的任意子数组，这里标记为$A[i:j]$（注意这个符号区别于部分编程语言的从0开始计数索引以及不包含上界的切片标记<code>A[i:j]</code>）</p>
<p>母题中给的Example 1输入<code>[2,1,3]</code>包含的连续子数组只有<code>[2],[1],[3],[2,1],[1,3],[2,1,3]</code>而没有原来的<code>[2,3]</code></p>
<p>整个问题要求的就是$$\sum\limits_{i = 1}^n {\sum\limits_{j = i}^n {\max (A[i:j]) - \min (A[i:j])} }$$众所周知，当$i=j$即子数组长度为1时，宽度（极差）为0，所以可以只考虑$i&lt;j$的情况，把上式进一步改写为$$\sum\limits_{i = 1}^{n-1} {\sum\limits_{j = i+1}^n {\max (A[i:j]) - \min (A[i:j])} }$$对于Example 1来说只需要考虑子数组<code>[2,1],[1,3],[2,1,3]</code>宽度，分别为<code>1,2,2</code>，最终结果为<code>5</code></p>
<h2>暴力搜索</h2>
<p>最直接的方法，根据上式的两个求和标记直接写一个二层循环进行求和：</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_naive</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">            res += max(A[i:j + <span class="number">1</span>]) - min(A[i:j + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>内层循环也分别求两次最值，所以时间复杂度很显然是$o(n^3)$</p>
<h2>直觉的改进</h2>
<p>因为内层循环的存在，子数组都是逐个扩大的，所以利用<code>min</code>和<code>max</code>函数对子数组进行求最值的操作是多余的，完全可以维护两个临时变量作为当前的最大值和最小值。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_improved</span><span class="params">(A)</span>:</span></span><br><span class="line">    n=len(A)</span><br><span class="line">    res=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">        min_num,max_num=A[i],A[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,n):</span><br><span class="line">            min_num,max_num=min(min_num,A[j]),max(max_num,A[j])</span><br><span class="line">            res+=max_num-min_num</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这样就可以把时间复杂度降低到$o(n^2)$了</p>
<h2>排序+缩小搜索范围</h2>
<p>和母题一样，接下来可以试着考虑一下每一对$A[i],A[j]$作为最小值和最大值的子数组有多少个，即$A[j]-A[i]$被加了多少次，正如我在母题的题解里面所说的它们扮演了什么角色？</p>
<p>首先我们来看整个<code>A</code>数组的最大值和最小值，记它们的下标分别为$x$和$y$，它们规定了多少个连续子数组的极差呢？为了方便讨论，我们假设$x&lt;y$，即同时包含这两个数的最小子数组为$A[x:y]$，而$A[y]-A[x]$已经是<code>A</code>的最大宽度了，所有包含$A[x:y]$的子数组的宽度也都是$A[y]-A[x]$，这些数组的起点最小为1最大为$x$，终点最小为$y$最大为$n$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/5.png" alt="绿色部分为上面提到的最小子数组，宽度为A[y]-A[x]的所有子数组必须包含全部的绿色部分，除此之外可以包含从x开始向左任意长度的灰色部分，也可以同时包含y开始向右任意长度的灰色部分"></p>
<p>那么一共有$x(n-y+1)$个连续子数组的宽度为$A[y]-A[x]$，接下来我们可以试着逐渐缩小目标宽度，不妨从减小最大值开始入手：</p>
<p>假设$A[y']$是<code>A</code>的第二大值，仅次于$A[y]$，有多少子数组是以$A[y]-A[x]$作为宽度的？</p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 1</h4>
<p>首先考虑一种比较简单的情况，$y'&gt;y$</p>
<p>这时所有同时包含$A[x]$和$A[y']$的连续子数组（即使是最小的$A[x:y']$）必然包括$A[y]$，那么这些数组的宽度则以$A[y]-A[x]$进行计算，所以宽度为$A[y']-A[x]$的连续子数组不存在。</p>
</div></p>
<p><div class="bs-callout bs-callout-warning"><h4>&lt;i class=&quot;fa fa-check-square-o&quot;&gt;&lt;/i&gt; Case 2</h4>
<p>当$y'&lt;y$时，我们继续沿用上面为了方便讨论的规定最大值的坐标大于最小值的坐标，即$y'&gt;x$</p>
<p>我们知道以二者的差为宽度的子数组一定同时包含这两个元素，但同时多了一个限制：数组的最大值不能超过$A[y']$，即数组的重点下标必须小于$y$，结合前文整理一下，这些数组的起点最小为1最大为$x$，重点最小为$y$最大为$y'-1$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/6.png" alt="子数组必须包含绿色部分的全部，从绿色部分开始延伸的任意长度的灰色部分，但不能延伸到任何红色的部分"></p>
<p>共有$x(y-y')$个连续子数组。</p>
</div></p>
<p>当$x$不变时，随着连续取更小的$A[y']$，为了保证$A[y']$是子数组中的最大值，子数组不能“横跨”的坐标值也越来越多。即使去掉$y_i&gt;x$的假设，也可以理解这个缩小范围的原理，无论是上界也好，下界也好，每次落到这个区间内的$y$都会带来一次边界的更新，使得下一个需要用来计算宽度的$y$所能落到的下标区间越来越狭窄。</p>
<p>不妨跳出上面的全局最值的局限，考虑对于任意满足$A[x]&lt;A[y]$的$x$和$y$，如何找出所有以$A[y]-A[x]$为宽度的连续子数组？那么上文对于全局最值的讨论其实也解决了这个问题的一部分，即当我们知道以$A[x]$为最小值，$A[y]$为最大值的最大长度连续数组时我们就可以用上面的方法计算了。假设这个最大数组的起点为$s+1$，终点为$e-1$（$s$和$e$分别在代码中变量名为<code>start</code>和<code>end</code>），也就是$A[s]$和$A[e]$一定是小于$A[x]$或大于$A[y]$的值，而$A[s+1:e-1]$一定落在$A[x]$与$A[y]$之间。那么以$A[y]-A[x]$为宽度的子数组下标的起点为$[s+1,x]$，终点为$[y,e-1]$</p>
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/7.png" alt="左右都不可以延伸到红色部分"></p>
<p>固定$x$不变时，根据上文的讨论，可以按照$A[y]$的降序取$y$，落在区间$[s+1,e-1]$时完成计算后，如果$y &lt; x$则更新$s$的值为$y$，如果$y&gt;x$则更新$e$的值为$y$。</p>
<p>&lt;a name=&quot;boundupdate&quot;&gt;&lt;/a&gt;
对每轮$x$取值开始之前，需要先找准边界保证$A[x]$就是这个最大长度区间的最小值，那么可以先按照$A[x]$升序排序，在之前取过的$x'$中小于当前$x$的最大$x'$即为$s$，大于当前$x$的最小$y'$即为$e$，直观上来说这是两个距离$x$ <strong>最近</strong> 的且满足$A[x']&lt;A[x]$的下标。</p>
<p>当然，$s$和$e$需要分别被初始化为比第一个下标更小1的值，以及比最后一个下标更大1的值，这样可以保证在还没有更新边界时，所有元素都被包含在了需要搜索的范围内。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    pos = sorted(range(n), key=<span class="keyword">lambda</span> i: A[i])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        x = pos[i]</span><br><span class="line">        start = max([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &lt; x] + [<span class="number">-1</span>])</span><br><span class="line">        end = min([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &gt; x] + [n])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">            y = pos[j]</span><br><span class="line">            <span class="keyword">if</span> y &gt; end <span class="keyword">or</span> y &lt; start:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; y:</span><br><span class="line">                res += (end - y) * (x - start) * (A[y] - A[x])</span><br><span class="line">                end = y</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (end - x) * (y - start) * (A[y] - A[x])</span><br><span class="line">                start = y</span><br><span class="line">            <span class="keyword">if</span> end - start == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为$o(n^2)$，空间复杂度为$o(n)$</p>
<h2>伪单遍遍历*</h2>
<p><div class="bs-callout bs-callout-success"><h4>&lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt; 8/22更新内容</h4>
<p>本小节为8/22看到志成回复给我他的想法：找到每个元素在哪些区间内是最大值/最小值，方法是对每个<code>A[i]</code>维护两个个单调栈，分别向左和向右找到第一个大于/小于<code>A[i]</code>的坐标<code>s</code>和<code>e</code>，那么<code>A[i]</code>就只在<code>(i-s)*(e-i)</code>个区间作为最大值/最小值。</p>
</div></p>
<p>其实这个找<code>A[i]</code>被加多少次和被减多少次的思路是最接近母题最终解法(sort + one pass)的，那就索性不用单调栈了，~~其实是我实在太懒了不想费脑子写，~~直接按照母题写单次遍历了。</p>
<p>在上文我们提到每轮外层循环开始对每个$x$更新$s$和$e$的<a href="#boundupdate">规则</a>，这是为了保证$x$在内层循环开始前是$[s+1,e-1]$内所有包含$x$的区间的最小值。其实这里如果要保证某个$x$是某个范围内所有包含$x$的子集的最大值也是同理，按$A[i]$照降序排序，对每个$A[i]$找到在$i$左边的小于$i$的最大值作为$s$，当然这里是为了保证$A[i]$为最大值$A[y]$所以为了区分前文把这个$s$记作$s_y$，前文的那个使得$A[i]$最小的$s$记作$s_x$；同理找到在$i$左边且大于$i$的最小值作为$e_y$，那么就容易计算$A[i]$一共被加了多少次和减了多少次。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_one_pass</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    pos = sorted(range(n), key=<span class="keyword">lambda</span> i: A[i])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(pos):</span><br><span class="line">        s_x = max([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &lt; v] + [<span class="number">-1</span>])</span><br><span class="line">        e_x = min([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[:i] <span class="keyword">if</span> p &gt; v] + [n])</span><br><span class="line">        s_y = max([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[i:] <span class="keyword">if</span> p &lt; v] + [<span class="number">-1</span>])</span><br><span class="line">        e_y = min([p <span class="keyword">for</span> p <span class="keyword">in</span> pos[i:] <span class="keyword">if</span> p &gt; v] + [n])</span><br><span class="line">        res += ((e_y - v) * (v - s_y) - (e_x - v) * (v - s_x)) * A[v]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>虽然看上去有点像母题优雅的one pass，但实际上循环体里面的求最值依然$o(n)$遍历不可避，所以最终还是$o(n^2)$的时间复杂度和$o(n)$的空间复杂度。</p>
<h2>单调栈</h2>
<p><div class="bs-callout bs-callout-danger"><h4>&lt;i class=&quot;fa fa-gift&quot;&gt;&lt;/i&gt; 8/24 重要更新</h4>
<p>志成已经在评论区给出了详细的解释和实现，<em><s>蠢萌，不</s></em> 蠢而不萌的废物本人我艰难地看完，后知后觉的感叹这确实是一个巧妙的$o(n)$方法。详细讨论见评论区，再次感谢志成大佬~</p>
</div></p>
<p>还是我们之前所说找<code>A[i]</code>在多大范围内是最小值。先看一侧，也就是在<code>A[i]</code>右边大于<code>A[i]</code>值的最小坐标。</p>
<p>单调栈是一个保证自顶而下单调递增或者递减的栈，维护这个栈只需要（假设自顶而下递减，即栈顶为最大元素）：</p>
<ol>
<li>如果当前元素小于栈顶，则弹出元素直至当前元素大于栈顶并进入<code>2</code></li>
<li>如果当前元素大于栈顶，则直接压入栈内</li>
</ol>
<p>当我们进行一次对<code>A</code>的正序遍历，对每个元素<code>A[i]</code>来说，弹栈至满足要求<code>2</code>的时候，当前栈顶的元素也是左边最近的大于<code>A[i]</code>的值，即前文使用的<code>s_x</code>，这个思路是志成的实现中所使用的，我在实现的写法上与他略有不同：对于所有这些被弹出的元素<code>A[j]</code>，令它们被弹出的<code>A[i]</code>是右边距离它们最近的比它们大的值，所以在弹栈操作时每弹出一个就可以更新<code>j</code>下标的<code>e_x</code>为<code>i</code>。当然不要忘记最后还没有被弹出的元素，他们右边最近的更小值不存在，可以统一更新为<code>n</code>。如此一来，每个元素至多被压入或者弹出一次，即每次遍历中维护整个<code>mono_stack</code>的总开销为$o(n)$。</p>
<p>通过遍历顺序和单调栈单调性的改变，四次$o(n)$的线性扫描就可以得到每个下标的<code>s_x</code>,<code>e_x</code>,<code>s_y</code>和<code>e_y</code>了。最后的再来第五次遍历，根据上文的公式计算每个<code>A[i]</code>在结果中被加减过了多少次。
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_widths_mono_stack</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    s_x, s_y, e_x, e_y = [<span class="number">-1</span>] * n, [<span class="number">-1</span>] * n, [n] * n, [n] * n</span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &gt;= A[i]:</span><br><span class="line">            e_x[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &gt; A[i]:</span><br><span class="line">            s_x[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &lt;= A[i]:</span><br><span class="line">            e_y[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    mono_stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> mono_stack <span class="keyword">and</span> A[mono_stack[<span class="number">-1</span>]] &lt; A[i]:</span><br><span class="line">            s_y[mono_stack.pop()] = i</span><br><span class="line">        mono_stack.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, v) <span class="keyword">in</span> enumerate(A):</span><br><span class="line">        res += ((e_y[i] - i) * (i - s_y[i]) - (e_x[i] - i) * (i - s_x[i])) * v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>除此以外，我在评论区的讨论也提到过，比较麻烦的一点就是不保证<code>A</code>内所有元素<strong>不重复</strong>，所以在单调栈弹栈时的比较运算是否该取等号这个问题上需要格外谨慎。在正序和逆序遍历中同时取等号或者同时不取会导致被重复计算或忽略，所以需要在同一个方向上保留等号，而在另一个方向上不保留，也就是说上面对于操纵<code>mono_stack</code>的四个<code>for</code>循环中<code>while</code>语句的符号只能是<code>&gt;=,&gt;,&lt;=,&lt;</code>或<code>&gt;,&gt;=,&lt;,&lt;=</code>。</p>
<h2>总结</h2>
<p>三种方法都可以保证输出正确的结果，比如使用随机测试用例&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">868</span>, <span class="number">1380</span>, <span class="number">63</span>, <span class="number">948</span>, <span class="number">1065</span>, <span class="number">796</span>, <span class="number">1130</span>, <span class="number">895</span>, <span class="number">1371</span>, <span class="number">1170</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以看到三个函数的输出结果都为<code>37672</code>，虽然花费了巨大的笔墨讲解第三种方法，但实际上从复杂度来看相较前两者似乎没有什么优势。不过这样的解法看上去比较舒服的地方，至少相对前两种方法里线性等宽的遍历，它可以仅在几次循环中就大幅度缩小下一轮需要遍历的范围，直觉上让人感觉轻松的多~~（有吗？笑）~~。</p>
<p>相比被更改前的母题，这个问题的处理其实麻烦的多，我试着和其他人讨论，搜索现有资料，都没有找到特别巧妙的方法，也很可能是我的能力太有限，总之有<strong>任何</strong>可能的想法欢迎在评论或者邮件提出。母题没有<strong>连续</strong>的限定，同样使用暴力搜索时需要的开销为$o(2^n)$看上去更复杂，但实际在没有连续这个限制时，数组元素之间的顺序是没有意义的，所以母题可以在排序后只考虑每个元素和哪些元素的组合是被加，哪些是被减，但在这里却必须考虑每个元素在原数组中的位置，它与任何一个元素的组合里面能不能含有其他元素，所以无法放开手脚去做，我只能这么畏畏缩缩地用了这样一个既不效率又不优雅的算法。</p>
<p>总之，谢谢志成提出的好问题。也希望这篇文章能够抛砖引玉，读者能提供出更漂亮的方法&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。</p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;使用 http://spojtoolkit.com/TestCaseGenerator/ 生成的随机数组&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;联动相关公众号推文&lt;a href=&quot;https://mp.weixin.qq.com/s/31cXvvpes4U4-qsAu7ZsgA&quot;&gt;睡前故事：从子数组到连续子数组，求极差之和变容易了吗？&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LC891-alter/" data-id="cjm54ylir001kfkw3y1v791s8" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-98" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-98/">LeetCode Weekly Contest 98</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-98/" class="article-date"><time datetime="2018-08-19T08:31:59.547Z" itemprop="datePublished">2018-08-19</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>睡眠太差6点惊醒过来，回笼觉有点睡过头外加有人临时约饭所以现场只做了3题，回来补完全部。整体算比较简单的一期题了。</p>
<p><s>所以说醒了就别睡了，早点起来看书搬砖，不然真耽误事</s></p>
<p>https://leetcode.com/contest/weekly-contest-98/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Fair Candy Swap</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-98/problems/fair-candy-swap/</p>
<blockquote>
<p>Alice and Bob have candy bars of different sizes: <code>A[i]</code> is the size of the <code>i</code>-th bar of candy that Alice has, and <code>B[j]</code> is the size of the <code>j</code>-th bar of candy that Bob has.</p>
</blockquote>
<blockquote>
<p>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)</p>
</blockquote>
<blockquote>
<p>Return an integer array <code>ans</code> where <code>ans[0]</code> is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.</p>
</blockquote>
<blockquote>
<p>If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1], B = [2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], B = [2,3]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2], B = [1,3]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,5], B = [2,4]</span><br><span class="line">Output: [5,4]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= B.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 100000</code></li>
<li><code>1 &lt;= B[i] &lt;= 100000</code></li>
<li>It is guaranteed that Alice and Bob have different total amounts of candy.</li>
<li>It is guaranteed there exists an answer.</li>
</ol>
<p>如果存在一个<code>A[i]</code>与<code>B[j]</code>交换后可以使得<code>A</code>和<code>B</code>的总数相等，那么有<code>sum(A)-A[i]+B[j]=sum(B)-B[j]+A[i]</code>，即<code>B[j]=(sum(B)-sum(A))/2+A[i]</code>，只需遍历<code>A[i]</code>寻找<code>B</code>是否包含<code>B[j]=(sum(B)-sum(A))/2+A[i]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fairCandySwap</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type B: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        S_A,S_B=sum(A),sum(B)</span><br><span class="line">        A,B=set(A),set(B)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            y=(S_B-S_A)/<span class="number">2</span>+x</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> B:</span><br><span class="line">                <span class="keyword">return</span> [x,y]</span><br></pre></td></tr></table></figure></p>
<h2>Find and Replace Pattern</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-98/problems/find-and-replace-pattern/</p>
<blockquote>
<p>You have a list of <code>words</code> and a <code>pattern</code>, and you want to know which <code>words</code> in words matches the pattern.</p>
</blockquote>
<blockquote>
<p>A word matches the pattern if there exists a permutation of letters <code>p</code> so that after replacing every letter <code>x</code> in the pattern with <code>p(x)</code>, we get the desired word.</p>
</blockquote>
<blockquote>
<p><em>(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)</em></p>
</blockquote>
<blockquote>
<p>Return a list of the <code>words</code> in words that match the given pattern.</p>
</blockquote>
<blockquote>
<p>You may return the answer in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;</span><br><span class="line">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class="line">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;.</span><br><span class="line">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class="line">since a and b map to the same letter.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= words.length &lt;= 50</code></li>
<li><code>1 &lt;= pattern.length = words[i].length &lt;= 20</code></li>
</ol>
<p>对于<code>words</code>中的每个<code>w</code>字符集，直接检查<code>w</code>和<code>p</code>之间是否为双射可能有些麻烦，但可以先检查<code>w-&gt;p</code>是否为映射/函数，再反过来检查<code>p-&gt;w</code>是否也为映射/函数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAndReplacePattern</span><span class="params">(self, words, pattern)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_map</span><span class="params">(w, p)</span>:</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> (i, s) <span class="keyword">in</span> enumerate(w):</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> d:</span><br><span class="line">                    <span class="keyword">if</span> d[s] != p[i]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[s] = p[i]</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> is_map(w, pattern) <span class="keyword">and</span> is_map(pattern, w)]</span><br></pre></td></tr></table></figure></p>
<h2>Construct Binary Tree from Preorder and Postorder Traversal</h2>
<p>原题地址  https://leetcode.com/contest/weekly-contest-98/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</p>
<blockquote>
<p>Return any binary tree that matches the given preorder and postorder traversals.</p>
</blockquote>
<blockquote>
<p>Values in the traversals <code>pre</code> and <code>post</code> are distinct positive integers.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li>
<li><code>pre[]</code> and <code>post[]</code> are both permutations of <code>1, 2, ..., pre.length</code>.</li>
<li>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</li>
</ol>
<p><s>给出任意两种遍历的顺序构造二叉树，应该是比父母的关切之语见得还要多的数据结构习题了</s></p>
<p>子树的根结点在<code>pre</code>中是第一个元素，在<code>post</code>中是最后一个元素，所以可以很轻松的分离出根结点，接下来只要分离出<code>pre[1:]</code>和<code>post[:-1]</code>中哪些内容是左子树，哪些内容是右子树，就可以递归构造整个二叉树了。</p>
<p>由于先遍历的特征，<code>pre[1:]</code>的第一个元素必然为第一个子树（默认为左子树）的根结点，这个元素在<code>post[:-1]</code>之前的所有元素则是整个子树的全部内容，这样就可以轻松分割出左右子树。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span><span class="params">(self, pre, post)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pre: List[int]</span></span><br><span class="line"><span class="string">        :type post: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) &gt; <span class="number">1</span>:</span><br><span class="line">            i = post.index(pre[<span class="number">1</span>])</span><br><span class="line">            root.left = self.constructFromPrePost(</span><br><span class="line">                pre[<span class="number">1</span>:(i + <span class="number">2</span>)], post[:(i + <span class="number">1</span>)])</span><br><span class="line">            root.right = self.constructFromPrePost(</span><br><span class="line">                pre[(i + <span class="number">2</span>):], post[(i + <span class="number">1</span>):<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2>Sum of Subsequence Widths</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-98/problems/sum-of-subsequence-widths/</p>
<blockquote>
<p>Given an array of integers <code>A</code>, consider all non-empty subsequences of <code>A</code>.</p>
</blockquote>
<blockquote>
<p>For any sequence S, let the width of S be the difference between the maximum and minimum element of S.</p>
</blockquote>
<blockquote>
<p>Return the sum of the widths of all subsequences of A.</p>
</blockquote>
<blockquote>
<p>As the answer may be very large, <strong>return the answer modulo 10^9 + 7</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,3]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].</span><br><span class="line">The corresponding widths are 0, 0, 0, 1, 1, 2, 2.</span><br><span class="line">The sum of these widths is 6.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>1 &lt;= A[i] &lt;= 20000</code></li>
</ol>
<p>我一开始误解了题意把subsequences当成了连续子集去做，做完以后WA了才发现只要把subsequences当成普通的子集去考虑就可以了，反正极差不会因为元素顺序改变，没有连续取值的要求，那么相对来说问题就简单多了。</p>
<p>对于每一对<code>A[i]&lt;A[j]</code>，找到所有<code>A[i]</code>为最小值，<code>A[j]</code>为最大值的子集：这个子集必须包含<code>A[i]</code>和<code>A[j]</code>，但不能包含任何小于<code>A[i]</code>或者大于<code>A[j]</code>的元素，不妨先将<code>A</code>进行降序排序，那么就容易得知有<code>j-i-1</code>个元素的大小在<code>A[i]</code>和<code>A[j]</code>之间，取这些元素全集的所有子集数即<code>2^(j-i-1)</code>，那么一共有这么多subsequences的宽度是<code>A[j]-A[i]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubseqWidths</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(A)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                res = (res + (<span class="number">2</span>**(j - i - <span class="number">1</span>)) * (A[j] - A[i])) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>这个$o(n^2)$的写法不出意外的TLE，因为存在比较运算，排序总是不可避免的，只能从那个循环下手看看能不能减小遍历开销。把上述的二层的循环展开写出来，观察每个<code>A[i]</code>出现的次数，换一个视角去从每个<code>A[i]</code>考虑：</p>
<p>对于<code>j&gt;i</code>的任意<code>A[j]</code>来说，<code>A[i]</code>是最值为<code>A[i],A[j]</code>的子集的最小值，在全局的返回值中扮演一个被减去的角色，更具体来说需要被减去<code>2^(n-1-i)</code>次，因为有<code>n-1-i</code>个元素大于<code>i</code>，并且它们都能和<code>i</code>构造出<code>2^(j-i-1)</code>个子集。当然更直观的解释是，只有在<code>A[i+1:]</code>的<code>2^(n-1-i)</code>个子集加入<code>A[i]</code>时，<code>A[i]</code>作为整个子集的最小值被减去。同理，<code>A[i]</code>也会被加<code>2^i</code>次，这样看来，很容易写出一个只遍历一次的解法，另外，为了提高计算效率，可以用1的位移代替底数为2的幂运算，否则仍然有TLE的风险。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubseqWidths</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            pos = (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">            neg = (i &lt;&lt; (n - <span class="number">1</span> - i))</span><br><span class="line">            res = (res + (pos - neg) * A[i]) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-98/" data-id="cjm54ylo70036fkw3ko8ts7tk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-97" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-97/">LeetCode Weekly Contest 97</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-97/" class="article-date"><time datetime="2018-08-12T14:16:00.129Z" itemprop="datePublished">2018-08-12</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-97</p>
<p>&lt;!-- more --&gt;</p>
<h2>Uncommon Words from Two Sentences</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/uncommon-words-from-two-sentences/</p>
<blockquote>
<p>We are given two sentences <code>A</code> and <code>B</code>.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.)</p>
</blockquote>
<blockquote>
<p>A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p>
</blockquote>
<blockquote>
<p>Return a list of all uncommon words.</p>
</blockquote>
<blockquote>
<p>You may return the list in any order.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">Output: [&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">Output: [&quot;banana&quot;]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= A.length &lt;= 200</code></li>
<li><code>0 &lt;= B.length &lt;= 200</code></li>
<li><code>A</code> and <code>B</code> both contain only spaces and lowercase letters.</li>
</ol>
<p>找到在<code>A+B</code>中只一共出现过一次的词</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncommonFromSentences</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        words = A.split() + B.split()</span><br><span class="line">        seen = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> words:</span><br><span class="line">            w = words.pop()</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(w)</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> words:</span><br><span class="line">                    res.append(w)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Spiral Matrix III</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/spiral-matrix-iii/</p>
<blockquote>
<p>On a 2 dimensional grid with <code>R</code> rows and <code>C</code> columns, we start at <code>(r0, c0)</code> facing east.</p>
</blockquote>
<blockquote>
<p>Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.</p>
</blockquote>
<blockquote>
<p>Now, we walk in a clockwise spiral shape to visit every position in this grid.</p>
</blockquote>
<blockquote>
<p>Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)</p>
</blockquote>
<blockquote>
<p>Eventually, we reach all <code>R * C</code> spaces of the grid.</p>
</blockquote>
<blockquote>
<p>Return a list of coordinates representing the positions of the grid in the order they were visited.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://image.ibb.co/b8y6zT/example_1.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 5, C = 6, r0 = 1, c0 = 4</span><br><span class="line">Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://image.ibb.co/bGVEm8/example_2.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
<p>注意一下螺旋线的方向向量顺序分别为<code>(0,1),(1,0),(0,-1),(-1,0)</code>，每转换两次方向步长增加1，这样可以保证不会重复访问，那么终止条件就是简单的访问到<code>R * C</code>个位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralMatrixIII</span><span class="params">(self, R, C, r0, c0)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type R: int</span></span><br><span class="line"><span class="string">        :type C: int</span></span><br><span class="line"><span class="string">        :type r0: int</span></span><br><span class="line"><span class="string">        :type c0: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        directions = [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>)]</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        steps = <span class="number">1</span></span><br><span class="line">        res = [(r0, c0)]</span><br><span class="line">        visited = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> visited &lt; R * C:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">                r0, c0 = r0 + directions[d][<span class="number">0</span>], c0 + directions[d][<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= r0 &lt; R <span class="keyword">and</span> <span class="number">0</span> &lt;= c0 &lt; C:</span><br><span class="line">                    visited += <span class="number">1</span></span><br><span class="line">                    res.append((r0, c0))</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            steps += ((d + <span class="number">1</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2>Possible Bipartition</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/possible-bipartition/</p>
<blockquote>
<p>Given a set of <code>N</code> people (numbered <code>1, 2, ..., N</code>), we would like to split everyone into two groups of any size.</p>
</blockquote>
<blockquote>
<p>Each person may dislike some other people, and they should not go into the same group.</p>
</blockquote>
<blockquote>
<p>Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered a and b into the same group.</p>
</blockquote>
<blockquote>
<p>Return <code>true</code> if and only if it is possible to split everyone into two groups in this way.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 2000</code></li>
<li><code>0 &lt;= dislikes.length &lt;= 10000</code></li>
<li><code>1 &lt;= dislikes[i][j] &lt;= N</code></li>
<li><code>dislikes[i][0] &lt; dislikes[i][1]</code></li>
<li>There does not exist <code>i != j</code> for which <code>dislikes[i] == dislikes[j].</code></li>
</ol>
<p>二分图问题也是k-coloring问题&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;的一个特殊形式，而且有相对更容易更直接的做法，将边<code>(i,j)</code>的两个端点染成不同的颜色并标记对立：如果<code>i</code>和<code>j</code>本来就同色则直接判断不可能；如果只有一个端点已经被标记过，则把另一个端点标记为与之相对的颜色；如果两个端点都已经被标记过，则分别将一个每个点的色集合并到另一个点对立的色集中。</p>
<p><s>以及其实这里的参数<code>N</code>没有什么用处</s></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span><span class="params">(self, N, dislikes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type dislikes: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        color = &#123;&#125;</span><br><span class="line">        counter = <span class="number">1</span></span><br><span class="line">        groups = collections.defaultdict(set)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dislikes:</span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">not</span> <span class="keyword">in</span> color) <span class="keyword">and</span> (b <span class="keyword">not</span> <span class="keyword">in</span> color):</span><br><span class="line">                color[a], color[b] = counter, -counter</span><br><span class="line">                groups[counter].add(a)</span><br><span class="line">                groups[-counter].add(b)</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">in</span> color:</span><br><span class="line">                c = color[a]</span><br><span class="line">                <span class="keyword">if</span> b <span class="keyword">in</span> color:</span><br><span class="line">                    <span class="keyword">if</span> c == color[b]:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">if</span> c + color[b] == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    groups[-color[b]].update(groups[c])</span><br><span class="line">                    groups[color[b]].update(groups[-c])</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> groups[c]:</span><br><span class="line">                        color[i] = -color[b]</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> groups[-c]:</span><br><span class="line">                        color[i] = color[b]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    color[b] = -c</span><br><span class="line">                    groups[-c].add(b)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                color[a] = -color[b]</span><br><span class="line">                groups[-color[b]].add(a)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Super Egg Drop</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-97/problems/super-egg-drop/</p>
<blockquote>
<p>You are given <code>K</code> eggs, and you have access to a building with <code>N</code> floors from <code>1</code> to <code>N</code>.</p>
</blockquote>
<blockquote>
<p>Each egg is identical in function, and if an egg breaks, you cannot drop it again.</p>
</blockquote>
<blockquote>
<p>You know that there exists a floor <code>F</code> with <code>0 &lt;= F &lt;= N</code> such that any egg dropped at a floor higher than <code>F</code> will break, and any egg dropped at or below floor <code>F</code> will not break.</p>
</blockquote>
<blockquote>
<p>Each move, you may take an egg (if you have an unbroken one) and drop it from any floor <code>X</code> (with <code>1 &lt;= X &lt;= N</code>).</p>
</blockquote>
<blockquote>
<p>Your goal is to know <strong>with certainty</strong> what the value of <code>F</code> is.</p>
</blockquote>
<blockquote>
<p>What is the minimum number of moves that you need to know with certainty what <code>F</code> is, regardless of the initial value of <code>F</code>?</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 1, N = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.</span><br><span class="line">Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.</span><br><span class="line">If it didn&apos;t break, then we know with certainty F = 2.</span><br><span class="line">Hence, we needed 2 moves in the worst case to know what F is with certainty.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 2, N = 6</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: K = 3, N = 14</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= K &lt;= 100</code></li>
<li><code>1 &lt;= N &lt;= 10000</code></li>
</ol>
<p>当<code>K=1</code>时，即只有一个鸡蛋，那只能老实一点从第0层开始一层一层试探着扔蛋，找到<code>F</code>前的最大次数为<code>N</code></p>
<p>当<code>K&gt;1</code>时，可以尝试着把问题分而治之：先在第<code>i</code>层扔一个鸡蛋，如果碎了用剩下的<code>K-1</code>个蛋在第0层到第i层间确定这个<code>F</code>；如果没碎，则用<code>K</code>个蛋在第<code>i+1</code>层到第<code>N</code>层之间确定这个<code>F</code>。</p>
<p>那么这里很明显存在一个可以适用动态规划的关系，假设<code>dp[n][k]</code>表示<code>K=k,N=n</code>时的确认<code>F</code>所需要的最小次数，<code>i</code>为满足<code>1&lt;i&lt;n-1</code>的所有可能取值，则有：$$dp[n][k]=1+\mathop {\min}\limits_i (\max(dp[i][k - 1] + dp[n - (i + 1)][k]))$$</p>
<p>这里很自然的根据上面的关系写出一个$o(N^2K)$的解法：
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[i] * (K + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                    dp[n][k] = min(</span><br><span class="line">                        dp[n][k], <span class="number">1</span> + max(dp[i][k - <span class="number">1</span>], dp[n - (i + <span class="number">1</span>)][k]))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>众所周知这是肯定会TLE的。接下来观察<code>dp</code>或者直接理解题意，会注意到一些关系：</p>
<ul>
<li><code>dp[i][2]==2</code></li>
<li>当<code>i&lt;j</code>时，<code>dp[i][k]&lt;=dp[j][k]</code></li>
</ul>
<p>随着<code>i</code>的增大，<code>dp[i][k-1]</code>增大，而<code>dp[n-(i+1)][k]</code>减小，所以令<code>dp[n][k]</code>最小的<code>i</code>一定是<code>[1,n-1]</code>中间使得两者大小相似的值。但<code>i</code>增加1时，<code>dp[i][k-1]</code>和<code>dp[n-(i+1)][k]</code>的值的变化都是不超过1的，所以找到第一个使得<code>dp[i][k-1]&gt;=dp[n-(i+1)][k]</code>的<code>i</code>即为这个最优取值。</p>
<p>而且随着<code>n</code>的增大，这个最优的<code>i</code>值也会增大。对于每一个<code>n</code>，<code>i</code>也可以从上一个<code>n</code>的最优<code>i</code>开始遍历，而不是再从0开始，这样使得对于每个<code>k</code>，至多完成一次<code>[0,N]</code>间的遍历就可以找到所有<code>n</code>的对应最优<code>i</code>，这样就可以把复杂度降到$o(NK)$了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[i] * (K + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>, K + <span class="number">1</span>):</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i][k - <span class="number">1</span>] &gt;= dp[n - (i + <span class="number">1</span>)][k]:</span><br><span class="line">                        dp[n][k] = <span class="number">1</span> + dp[i][k - <span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style:none; padding-left: 0;&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top;&quot;&gt;http://web.math.princeton.edu/math_alive/5/Notes2.pdf&lt;/span&gt;&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-97/" data-id="cjm54ylnd002wfkw3pqxhe1xe" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-96" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-96/">LeetCode Weekly Contest 96</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-96/" class="article-date"><time datetime="2018-08-05T13:38:39.578Z" itemprop="datePublished">2018-08-05</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>由于失眠过度熬夜，一不小心睡过了没去现场周赛，只能在这里补做题解了。已经尝试过褪黑素了，现在好像对我完全没作用了，没办法了，求治失眠。</p>
<p>https://leetcode.com/contest/weekly-contest-96</p>
<p>&lt;!-- more --&gt;</p>
<h2>Projection Area of 3D Shapes</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/projection-area-of-3d-shapes/</p>
<blockquote>
<p>On a <code>N * N</code> grid, we place some <code>1 * 1 * 1</code> cubes that are axis-aligned with the x, y, and z axes.</p>
</blockquote>
<blockquote>
<p>Each value <code>v = grid[i][j]</code> represents a tower of v cubes placed on top of grid cell <code>(i, j)</code>.</p>
</blockquote>
<blockquote>
<p>Now we view the projection of these cubes onto the xy, yz, and zx planes.</p>
</blockquote>
<blockquote>
<p>A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane.</p>
</blockquote>
<blockquote>
<p>Here, we are viewing the &quot;shadow&quot; when looking at the cubes from the top, the front, and the side.</p>
</blockquote>
<blockquote>
<p>Return the total area of all three projections.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation:</span><br><span class="line">Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 14</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 5</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ul>
<li><code>1 &lt;= grid.length = grid[0].length &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ul>
<p>不多说</p>
<ul>
<li>在xy平面的投影是所有非零<code>v</code>的个数</li>
<li>在xz平面的投影是每一个<code>x</code>值对应的最大<code>v</code>的和</li>
<li>在yz平面的投影是每一个<code>y</code>值对应的最大<code>v</code>的和</li>
</ul>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">projectionArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(grid)</span><br><span class="line">        xy,xz,yz=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            xy+=sum(v&gt;<span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> grid[i])</span><br><span class="line">            xz+=max(v <span class="keyword">for</span> v <span class="keyword">in</span> grid[i])</span><br><span class="line">            yz+=max(grid[j][i] <span class="keyword">for</span> j <span class="keyword">in</span> range(n))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xy+xz+yz</span><br></pre></td></tr></table></figure></p>
<h2>Boats to Save People</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/boats-to-save-people/</p>
<blockquote>
<p>The i-th person has weight <code>people[i]</code>, and each boat can carry a maximum weight of <code>limit</code>.</p>
</blockquote>
<blockquote>
<p>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p>
</blockquote>
<blockquote>
<p>Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [1,2], limit = 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,2,2,1], limit = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,5,3,4], limit = 5</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ul>
<li><code>1 &lt;= people.length &lt;= 50000</code></li>
<li><code>1 &lt;= people[i] &lt;= limit &lt;= 30000</code></li>
</ul>
<p>符合直觉的做法：先将<code>people</code>排序，试图组合最大的和最小的，如果超过<code>limit</code>则弹出当前最大的单独安排一条船，如果组合成功则弹出二者安排一条船，重复以上程序直至无法找出这样的组合。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span><span class="params">(self, people, limit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type people: List[int]</span></span><br><span class="line"><span class="string">        :type limit: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        people.sort()</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(people)&gt;<span class="number">1</span> <span class="keyword">and</span> people[<span class="number">0</span>]*<span class="number">2</span>&lt;=limit:</span><br><span class="line">            <span class="keyword">if</span> people[<span class="number">-1</span>]+people[<span class="number">0</span>]&lt;=limit:</span><br><span class="line">                people.pop(<span class="number">0</span>)</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">            people.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res+len(people)</span><br></pre></td></tr></table></figure></p>
<h2>Decoded String at Index</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/decoded-string-at-index/</p>
<blockquote>
<p>An encoded string <code>S</code> is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:</p>
</blockquote>
<blockquote>
<p>If the character read is a letter, that letter is written onto the tape.
If the character read is a digit (say <code>d</code>), the entire current tape is repeatedly written <code>d-1</code> more times in total.
Now for some encoded string <code>S</code>, and an index <code>K</code>, find and return the <code>K</code>-th letter (1 indexed) in the decoded string.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;leet2code3&quot;, K = 10</span><br><span class="line">Output: &quot;o&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.</span><br><span class="line">The 10th letter in the string is &quot;o&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ha22&quot;, K = 5</span><br><span class="line">Output: &quot;h&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The decoded string is &quot;hahahaha&quot;.  The 5th letter is &quot;h&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a2345678999999999999999&quot;, K = 1</span><br><span class="line">Output: &quot;a&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The decoded string is &quot;a&quot; repeated 8301530446056247680 times.  The 1st letter is &quot;a&quot;.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= S.length &lt;= 100</code></li>
<li><code>S</code> will only contain lowercase letters and digits <code>2</code> through <code>9</code>.</li>
<li><code>S</code> starts with a letter.</li>
<li><code>1 &lt;= K &lt;= 10^9</code></li>
<li>The decoded string is guaranteed to have less than <code>2^63</code> letters.</li>
</ol>
<p>按照规则还原原始字符串会有TLE的风险。那么可以遍历字符串，如果<code>K</code>恰好在某个重复的子串，则递归计算被重复的子串中<code>K</code>对应的位置。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeAtIndex</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> ord(<span class="string">'a'</span>) &lt;= ord(c) &lt;= ord(<span class="string">'z'</span>):</span><br><span class="line">                n+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> n==K: <span class="keyword">return</span> c</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> n &lt; K &lt;= int(c)*n:</span><br><span class="line">                    <span class="keyword">return</span> self.decodeAtIndex(S,(K<span class="number">-1</span>)%n+<span class="number">1</span>)</span><br><span class="line">                n*=int(c)</span><br></pre></td></tr></table></figure></p>
<h2>Reachable Nodes In Subdivided Graph</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-96/problems/reachable-nodes-in-subdivided-graph/</p>
<blockquote>
<p>Starting with an <strong>undirected</strong> graph (the &quot;original graph&quot;) with nodes from <code>0</code> to <code>N-1</code>, subdivisions are made to some of the edges.</p>
</blockquote>
<blockquote>
<p>The graph is given as follows: <code>edges[k]</code> is a list of integer pairs <code>(i, j, n)</code> such that <code>(i, j)</code> is an edge of the original graph,</p>
</blockquote>
<blockquote>
<p>and <code>n</code> is the total number of <strong>new</strong> nodes on that edge.</p>
</blockquote>
<blockquote>
<p>Then, the edge <code>(i, j)</code> is deleted from the original graph, <code>n</code> new nodes <code>(x_1, x_2, ..., x_n)</code>are added to the original graph,</p>
</blockquote>
<blockquote>
<p>and <code>n+1</code> new edges <code>(i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)</code> are added to the original graph.</p>
</blockquote>
<blockquote>
<p>Now, you start at node <code>0</code> from the original graph, and in each move, you travel along one edge.</p>
</blockquote>
<blockquote>
<p>Return how many nodes you can reach in at most <code>M</code> moves.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3</span><br><span class="line">Output: 13</span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are reachable in the final graph after M = 6 moves are indicated below.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png" alt=""></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>0 &lt;= edges.length &lt;= 10000</code></li>
<li><code>0 &lt;= edges[i][0] &lt; edges[i][1] &lt; N</code></li>
<li>There does not exist any <code>i != j</code> for which <code>edges[i][0] == edges[j][0]</code> and <code>edges[i][1] == edges[j][1]</code>.</li>
<li>The original graph has no parallel edges.</li>
<li><code>0 &lt;= edges[i][2] &lt;= 10000</code></li>
<li><code>0 &lt;= M &lt;= 10^9</code></li>
<li><code>1 &lt;= N &lt;= 3000</code></li>
</ol>
<p>一个可以接受的思路：从起始结点开始BFS，访问到结点<code>i</code>时，<code>seen[i]</code>记录到达<code>i</code>后最多可以剩下多少次<code>move</code>，如果足够到达下一个结点<code>j</code>则把<code>j</code>和<code>seen[j]</code>也放入队列，重复直至队列为空。最后遍历到的原结点（图中大的结点）数为<code>len(seen)</code>，边上新增结点（图中小的结点）数则计算每条边<code>(i,j,n)</code>的<code>min(seen[i]+seen[j],n)</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachableNodes</span><span class="params">(self, edges, M, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :type M: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        e=collections.defaultdict(dict)</span><br><span class="line">        <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges:</span><br><span class="line">            e[i][j]=e[j][i]=n</span><br><span class="line"></span><br><span class="line">        seen=&#123;<span class="number">0</span>:M&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,M)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,move <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> e[i]:</span><br><span class="line">                left=move<span class="number">-1</span>-e[i][j]</span><br><span class="line">                <span class="keyword">if</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> (j <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">or</span> seen[j]&lt;left):</span><br><span class="line">                    seen[j]=left</span><br><span class="line">                    q.append((j,left))</span><br><span class="line"></span><br><span class="line">        res=len(seen)+sum(min(seen.get(i,<span class="number">0</span>)+seen.get(j,<span class="number">0</span>),n) <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>当然为了避免重复刷新<code>seen[i]</code>的值以及多余的遍历，可以用Dijkstra算法找到到结点的最短路径然后更新<code>seen[i]</code></p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reachableNodes</span><span class="params">(self, edges, M, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type edges: List[List[int]]</span></span><br><span class="line"><span class="string">        :type M: int</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        e=collections.defaultdict(dict)</span><br><span class="line">        <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges:</span><br><span class="line">            e[i][j]=e[j][i]=n</span><br><span class="line"></span><br><span class="line">        seen=&#123;&#125;</span><br><span class="line">        q=[(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cost,i=heapq.heappop(q)</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen[i]=M-cost</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> e[i]:</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> cost+e[i][j]+<span class="number">1</span>&lt;=M:</span><br><span class="line">                    heapq.heappush(q,(cost+e[i][j]+<span class="number">1</span>,j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(seen)+sum(min(seen.get(i,<span class="number">0</span>)+seen.get(j,<span class="number">0</span>),n) <span class="keyword">for</span> i,j,n <span class="keyword">in</span> edges)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-96/" data-id="cjm54yln7002sfkw31y5f0y0p" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  
    <article id="post-LeetCode-Weekly-Contest-95" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/LeetCode/LeetCode-Weekly-Contest-95/">LeetCode Weekly Contest 95</a>
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/LeetCode/LeetCode-Weekly-Contest-95/" class="article-date"><time datetime="2018-07-29T08:46:31.908Z" itemprop="datePublished">2018-07-29</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>https://leetcode.com/contest/weekly-contest-95/</p>
<p>&lt;!-- more --&gt;</p>
<h2>Middle of the Linked List</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-95/problems/middle-of-the-linked-list/</p>
<blockquote>
<p>Given a non-empty, singly linked list with head node <code>head</code>, return a middle node of linked list.</p>
</blockquote>
<blockquote>
<p>If there are two middle nodes, return the second middle node.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&apos;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li>The number of nodes in the given list will be between <code>1</code> and <code>100</code>.</li>
</ol>
<p>用一快一慢两个指针遍历链表，快的走两步慢的走一步，快的完成遍历后慢的就在链表的中间了。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        fast,slow=head,head</span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast=fast.next</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>: slow=slow.next</span><br><span class="line">            n+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></p>
<h2>Stone Game</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-95/problems/stone-game/</p>
<blockquote>
<p>Alex and Lee play a game with piles of stones.  There are an even number of piles <strong>arranged in a row</strong>, and each pile has a positive integer number of stones <code>piles[i]</code>.</p>
</blockquote>
<blockquote>
<p>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.</p>
</blockquote>
<blockquote>
<p>Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.</p>
</blockquote>
<blockquote>
<p>Assuming Alex and Lee play optimally, return <code>True</code> if and only if Alex wins the game.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">Alex starts first, and can only take the first 5 or the last 5.</span><br><span class="line">Say he takes the first 5, so that the row becomes [3, 4, 5].</span><br><span class="line">If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.</span><br><span class="line">If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.</span><br><span class="line">This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>2 &lt;= piles.length &lt;= 500</code></li>
<li><code>piles.length</code> is even.</li>
<li><code>1 &lt;= piles[i] &lt;= 500</code></li>
<li><code>sum(piles)</code> is odd.</li>
</ol>
<p>注意这题有pile的长度为偶数的限定，那么Alex可以从头（偶数项）或者尾（奇数项）开始取走所有的奇数项或所有的偶数项，而总数又是奇数，奇数项和与偶数项和存在一个较大值，那么存在一个必胜的策略：Alex只要选择每轮都选择奇数项或者偶数项使得Lee被迫选剩下的，必然可以达到较大的和。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<h2>Nth Magical Number</h2>
<p>原题地址 https://leetcode.com/contest/weekly-contest-95/problems/nth-magical-number/</p>
<blockquote>
<p>A positive integer is magical if it is divisible by either A or B.</p>
</blockquote>
<blockquote>
<p>Return the N-th magical number.  Since the answer may be very large, return it <strong>modulo</strong> <code>10^9 + 7</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 1, A = 2, B = 3</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, A = 2, B = 3</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 3</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, A = 2, B = 4</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 4</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, A = 6, B = 4</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
<li><code>2 &lt;= A &lt;= 40000</code></li>
<li><code>2 &lt;= B &lt;= 40000</code></li>
</ol>
<p>每增加一个<code>lcm(A,B)</code>就会增加<code>lcm(A,B)/A+lcm(A,B)/B-1</code>个magical number，那么先对<code>N</code>除<code>lcm(A,B)/A+lcm(A,B)/B-1</code>，得到的商乘以<code>lcm(A,B)</code>，再按照余数一个个去找到剩下的余数。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthMagicalNumber</span><span class="params">(self, N, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type A: int</span></span><br><span class="line"><span class="string">        :type B: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        g=fractions.gcd(A,B)</span><br><span class="line">        m=A/g+B/g<span class="number">-1</span></span><br><span class="line">        r=N%m</span><br><span class="line">        res=((N/m)*A*B/g)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">        m_a,m_b,cur=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (m_a+<span class="number">1</span>)*A&gt;(m_b+<span class="number">1</span>)*B:</span><br><span class="line">                m_b+=<span class="number">1</span></span><br><span class="line">                cur=m_b*B</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                m_a+=<span class="number">1</span></span><br><span class="line">                cur=m_a*A</span><br><span class="line">            r-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (res+cur)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<h2>Profitable Schemes</h2>
<blockquote>
<p>There are G people in a gang, and a list of various crimes they could commit.</p>
</blockquote>
<blockquote>
<p>The <code>i</code>-th crime generates a <code>profit[i]</code> and requires <code>group[i]</code> gang members to participate.</p>
</blockquote>
<blockquote>
<p>If a gang member participates in one crime, that member can't participate in another crime.</p>
</blockquote>
<blockquote>
<p>Let's call a profitable scheme any subset of these crimes that generates at least <code>P</code> profit, and the total number of gang members participating in that subset of crimes is at most G.</p>
</blockquote>
<blockquote>
<p>How many schemes can be chosen?  Since the answer may be very large, <strong>return it modulo</strong> <code>10^9 + 7</code>.</p>
</blockquote>
<blockquote>
<p><strong>Example 1</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: G = 5, P = 3, group = [2,2], profit = [2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1.</span><br><span class="line">In total, there are 2 schemes.</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Example 2</strong>:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">To make a profit of at least 5, the gang could commit any crimes, as long as they commit one.</span><br><span class="line">There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><strong>Note</strong>:</p>
</blockquote>
<ol>
<li><code>1 &lt;= G &lt;= 100</code></li>
<li><code>0 &lt;= P &lt;= 100</code></li>
<li><code>1 &lt;= group[i] &lt;= 100</code></li>
<li><code>0 &lt;= profit[i] &lt;= 100</code></li>
<li><code>1 &lt;= group.length = profit.length &lt;= 100</code></li>
</ol>
<p>也是背包问题的变种，这里也用动态规划。<code>dp[i][j]</code>表示利润为<code>i</code>人员数为<code>j</code>的方案总数（除了<code>i=P</code>时表示利润<code>&gt;=P</code>），遍历犯罪列表，对于每次取到的利润为<code>p</code>人员数为<code>g</code>的犯罪，更新整个<code>dp</code>：</p>
<ol>
<li>如果<code>i+p&lt;P</code>，则<code>dp[i+p][j+g]+=dp[i][j]</code></li>
<li>如果<code>i+p&gt;=P</code>，则<code>dp[P][j+g]+=dp[i][j]</code></li>
</ol>
<p>当然注意第二维（人员数）不要超过<code>G</code>。这里用的还是类似于<a href="http://notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-93/#Minimum-Number-of-Refueling-Stops">Minimum Number of Refueling Stops</a>用到的自底而上的遍历<code>dp</code>，原理也相同。初始条件为<code>dp[0][0]=1</code>这样保证初次遍历的时候只有<code>dp[min(p,P)][g]</code>可以得到更新为<code>1</code>，之后加入的犯罪也只会以这二者为起点。最后返回<code>i=P</code>的所有<code>dp</code>的和作为结果。</p>
<p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span><span class="params">(self, G, P, group, profit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type G: int</span></span><br><span class="line"><span class="string">        :type P: int</span></span><br><span class="line"><span class="string">        :type group: List[int]</span></span><br><span class="line"><span class="string">        :type profit: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp=[[<span class="number">0</span>]*(G+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(P+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> g,p <span class="keyword">in</span> zip(group,profit):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(P,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(G-g,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    dp[min(i+p,P)][j+g]+=dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(dp[P])%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/LeetCode/LeetCode-Weekly-Contest-95/" data-id="cjm54ylmu002qfkw3kt6ujme2" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!--  -->
      

    </footer>
  </div>
  
</article>


<!--  -->


  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li class="disabled"><span class="page-space">&hellip;</span></li><li><a class="page-number" href="/page/6/">6</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p> <p>随着一次次的失败，一无所有的作者我已经别无所求了，只想安静的生活下去，不想再被打扰。谢谢大家的关心和照顾，可惜我已经无力回报，非常对不起。有事请联系<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">43</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-102/">LeetCode Weekly Contest 102</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-101/">LeetCode Weekly Contest 101</a>
        </li>
      
        <li>
          <a href="/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-100/">LeetCode Weekly Contest 100</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-99/">LeetCode Weekly Contest 99</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
