<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>词法寻址 | 笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="词法寻址是Scheme这样使用词法作用域（lexical scope）即函数被调用时以函数被定义时的环境来求值的语言的编译器过程中最常见的优化之一，这部分内容对应SICP原书5.5.6  Lexical Addressing部分，你可以看到原书只是大致提了一下优化的背景和思路，具体如何做都放在习题里面了，需要自己尝试着">
<meta name="keywords" content="编译器">
<meta property="og:type" content="article">
<meta property="og:title" content="词法寻址">
<meta property="og:url" content="notebook.xyli.me/SICP/lexical-addressing/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="词法寻址是Scheme这样使用词法作用域（lexical scope）即函数被调用时以函数被定义时的环境来求值的语言的编译器过程中最常见的优化之一，这部分内容对应SICP原书5.5.6  Lexical Addressing部分，你可以看到原书只是大致提了一下优化的背景和思路，具体如何做都放在习题里面了，需要自己尝试着去写实现，MIT 6.001等公开的资料更是完全没有提及。所以我参考了Schem">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/lexical-addressing/frame_enclosing.png?inline=false">
<meta property="og:updated_time" content="2019-01-16T15:25:13.653Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="词法寻址">
<meta name="twitter:description" content="词法寻址是Scheme这样使用词法作用域（lexical scope）即函数被调用时以函数被定义时的环境来求值的语言的编译器过程中最常见的优化之一，这部分内容对应SICP原书5.5.6  Lexical Addressing部分，你可以看到原书只是大致提了一下优化的背景和思路，具体如何做都放在习题里面了，需要自己尝试着去写实现，MIT 6.001等公开的资料更是完全没有提及。所以我参考了Schem">
<meta name="twitter:image" content="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/lexical-addressing/frame_enclosing.png?inline=false">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-lexical-addressing" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      词法寻址
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/lexical-addressing/" class="article-date"><time datetime="2019-01-15T15:31:57.702Z" itemprop="datePublished">2019-01-15</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>词法寻址是Scheme这样使用词法作用域（lexical scope）即函数被调用时以函数被定义时的环境来求值的语言的编译器过程中最常见的优化之一，这部分内容对应SICP原书<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-35.html#%_sec_5.5.6" target="_blank" rel="noopener">5.5.6  Lexical Addressing</a>部分，你可以看到原书只是大致提了一下优化的背景和思路，具体如何做都放在习题里面了，需要自己尝试着去写实现，MIT 6.001等公开的资料更是完全没有提及。所以我参考了SchemeWiki社区给出的一些解决方案来完整实现一下这部分内容的细节描述。当然更多资源和深入的关于词法寻址的讨论可以参考其他资料<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，我在这里不再多谈。</p>
<a id="more"></a>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>众所周知，Scheme在实现函数调用（包括<code>let</code>表达式这个lambda的语法糖）时是把形参与调用时的实参一一绑定成一个帧（frame），然后扩展到函数被定义时的环境。</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/lexical-addressing/frame_enclosing.png?inline=false" alt="Newton迭代法求平方根的变量环境模型图，帧的划分不完全准确，但可以看到函数sqrt-iter和good-enough?调用时会把形参和实参绑定成新的帧并指向被扩展的环境E2"></p>
<p>对变量进行寻址时使用<code>lookup-variable-value</code>一帧一帧找第一个该变量的绑定。</p>
<p>假设帧（frame），环境（env）都是沿用<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.3" target="_blank" rel="noopener">The Metacircular Evaluator</a>中规定的结构，即环境为多个帧按照绑定的优先级顺序构成的列表：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">enclosing-environment</span> env) (<span class="name"><span class="builtin-name">cdr</span></span> env))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">first-frame</span> env) (<span class="name"><span class="builtin-name">car</span></span> env))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> the-empty-environment '())</span><br></pre></td></tr></table></figure></p>
<p>而每个帧又是由一个变量列表<code>variables</code>和值列表<code>values</code>组成的对，相同索引位置的变量和值形成一对绑定：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-frame</span> variables values)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> variables values))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">frame-variables</span> frame) (<span class="name"><span class="builtin-name">car</span></span> frame))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">frame-values</span> frame) (<span class="name"><span class="builtin-name">cdr</span></span> frame))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">add-binding-to-frame!</span> var val frame)</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-car!</span></span> frame (<span class="name"><span class="builtin-name">cons</span></span> var (<span class="name"><span class="builtin-name">car</span></span> frame)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">set-cdr!</span></span> frame (<span class="name"><span class="builtin-name">cons</span></span> val (<span class="name"><span class="builtin-name">cdr</span></span> frame))))</span><br></pre></td></tr></table></figure></p>
<p>所以<code>lookup-variable-value</code>一帧一帧逐个对查找变量是否在环境中的过程表示为：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lookup-variable-value</span> var env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">env-loop</span> env)</span><br><span class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">scan</span> vars vals)</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">null?</span></span> vars)</span><br><span class="line">             (<span class="name">env-loop</span> (<span class="name">enclosing-environment</span> env)))</span><br><span class="line">            ((<span class="name"><span class="builtin-name">eq?</span></span> var (<span class="name"><span class="builtin-name">car</span></span> vars))</span><br><span class="line">             (<span class="name"><span class="builtin-name">car</span></span> vals))</span><br><span class="line">            (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">scan</span> (<span class="name"><span class="builtin-name">cdr</span></span> vars) (<span class="name"><span class="builtin-name">cdr</span></span> vals)))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> env the-empty-environment)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Unbound variable"</span> var)</span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">frame</span> (<span class="name">first-frame</span> env)))</span><br><span class="line">          (<span class="name">scan</span> (<span class="name">frame-variables</span> frame)</span><br><span class="line">                (<span class="name">frame-values</span> frame)))))</span><br><span class="line">  (<span class="name">env-loop</span> env))</span><br></pre></td></tr></table></figure></p>
<p>那么有一个突出的问题就是当编译器对一个包含多层定义的表达式求值时，会遇到使用的求值环境中包含多个帧嵌套的情况，用上述的<code>lookup-variable-value</code>对环境中的变量寻址时需要找很多帧很多变量才能找到第一个匹配的变量名。比如考虑<br><a name="example"></a><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">x</span> <span class="number">3</span>) (<span class="name">y</span> <span class="number">4</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (a b c d e)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">y</span> (<span class="name"><span class="builtin-name">*</span></span> a b x))</span><br><span class="line">          (<span class="name">z</span> (<span class="name"><span class="builtin-name">+</span></span> c d x)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> x y z))))</span><br></pre></td></tr></table></figure></p>
<p>或者它的等效展开<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (x y)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (a b c d e)</span><br><span class="line">     ((<span class="name"><span class="builtin-name">lambda</span></span> (y z) (<span class="name"><span class="builtin-name">*</span></span> x y z))</span><br><span class="line">      (<span class="name"><span class="builtin-name">*</span></span> a b x)</span><br><span class="line">      (<span class="name"><span class="builtin-name">+</span></span> c d x))))</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"> <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p>
<p>然而，没有相应优化的编译器对lambda表达式的函数体部分进行编译过程为：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-lambda-body</span> exp proc-entry)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">formals</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)))</span><br><span class="line">    (<span class="name">append-instruction-sequences</span></span><br><span class="line">     (<span class="name">make-instruction-sequence</span> '(env proc argl) '(env)</span><br><span class="line">      `(,proc-entry</span><br><span class="line">        (assign env (op compiled-procedure-env) (reg proc))</span><br><span class="line">        (assign env</span><br><span class="line">                (op extend-environment)</span><br><span class="line">                (const ,formals)</span><br><span class="line">                (reg argl)</span><br><span class="line">                (reg env))))</span><br><span class="line">     (<span class="name">compile-sequence</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>) <span class="symbol">'val</span> <span class="symbol">'return</span>))))</span><br></pre></td></tr></table></figure></p>
<p>所生产的机器指令代码并未考虑函数体中出现的变量应该如何在新环境中被寻址，因此每次运行时执行指令都需要使用<code>lookup-variable-value</code>操作对变量从头开始找绑定，可能需要经过很“深”的遍历，如上文的<code>(* x y z)</code>的三个变量，<code>x</code>会出现在被<code>lookup-variable-value</code>查找的第3帧的第1个变量的位置。多次调用一个函数时，虽然每个变量在环境中的位置已经<strong>固定</strong>了，还是需要一板一眼按顺序去寻址，如此冗余的寻址操作带来很大的开销。</p>
<p>词法寻址将编译结果中对变量的寻址用<strong>一个固定的值</strong>表示，即该变量在环境中的位置，每次执行寻址时只需要根据这个位置再去环境中取出相应的值，经过这样的优化后，不必再做笨重的遍历了。</p>
<h2 id="索引寻址"><a href="#索引寻址" class="headerlink" title="索引寻址"></a>索引寻址</h2><p>为了实现上述机制，需要重新定义一个在环境<code>env</code>中寻址的函数<code>lexical-address-lookup</code>，不同于前面直接传入变量名的<code>lookup-variable-value</code>，新的寻址函数用一个词法地址（lexical address）参数来代表需要被寻址的变量。词法地址有两个部分，第一部分<code>addr-frame</code>表示变量所在的帧在环境中的序号，即寻址需要遍历多少帧，第二部分<code>addr-offset</code>表示变量在相应帧中的序号，在该帧的位置。当该位置的变量值为<code>*unassigned*</code>时表示变量未被初始化。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lexical-address</span> addr-frame addr-offset)</span><br><span class="line"> (<span class="name"><span class="builtin-name">cons</span></span> addr-frame addr-offset))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">addr-frame</span> address) (<span class="name"><span class="builtin-name">car</span></span> address))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">addr-offset</span> address) (<span class="name"><span class="builtin-name">cdr</span></span> address))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lexical-address-lookup</span> env address)</span><br><span class="line"> (<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">frame</span> (<span class="name"><span class="builtin-name">list-ref</span></span> env (<span class="name">addr-frame</span> address)))</span><br><span class="line">        (<span class="name">value</span> (<span class="name"><span class="builtin-name">list-ref</span></span> (<span class="name">frame-values</span> frame) (<span class="name">addr-offset</span> address))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> value <span class="symbol">'*unassigned*</span>)</span><br><span class="line">      (<span class="name">error</span> <span class="string">"the variable is unassigned -- LEXICAL-ADDRESS-LOOKUP"</span></span><br><span class="line">             address)))</span><br><span class="line">      value)</span><br></pre></td></tr></table></figure>
<p>相似的，我们也可以以这个方式定义一个赋值过程：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">lexical-address-set!</span> env address value)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">frame</span> (<span class="name">addr-frame</span> address))</span><br><span class="line">        (<span class="name">offset</span> (<span class="name">addr-offset</span> address)))</span><br><span class="line">   (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">set-value!</span> f pos)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> f <span class="number">0</span>)</span><br><span class="line">        (<span class="name"><span class="builtin-name">set-car!</span></span> f value)</span><br><span class="line">        (<span class="name">set-value!</span> (<span class="name"><span class="builtin-name">cdr</span></span> f (<span class="name"><span class="builtin-name">-</span></span> pos <span class="number">1</span>)))))</span><br><span class="line">   (<span class="name">set-value!</span> frame offset value)))</span><br></pre></td></tr></table></figure></p>
<p>直接通过词法地址来改变变量在环境中的值绑定。</p>
<h2 id="编译时环境"><a href="#编译时环境" class="headerlink" title="编译时环境"></a>编译时环境</h2><p>为了能够在每个lambda表达式编译时维护准确的词法地址，还需要定义一种被称为编译时环境（compile-time environment）的数据结构，来追踪每个变量会在真实的求值环境中处于哪一帧的哪一个位置。不同于运行时求值环境，编译时环境只需要按照函数的嵌套顺序将形参按照正确的顺序扩展变量，使它保持和真实求值环境的变量部分一致即可，不需要在编译期关注这些变量具体的值。</p>
<p>比如前文提到的<a href="#example">例子</a>中<code>(* x y z)</code>的编译时环境为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">y</span> z) (<span class="name">a</span> b c d e) (<span class="name">x</span> y))</span><br></pre></td></tr></table></figure></p>
<p>通过在这个环境中寻址，就可以在编译期间直接找到变量在环境中的位置。</p>
<p>这样编译器<code>compile</code>需要传入一个额外的参数编译时环境<code>ct-env</code>来生成优化的机器指令代码。顶层<code>compile</code>被传入一个空的编译时环境，当处理lambda表达式时用<code>compile-lambda-body</code>把过程的形参扩展到当前的编译时环境。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-lambda-body</span> exp proc-entry ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">formals</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)))</span><br><span class="line">    (<span class="name">append-instruction-sequences</span></span><br><span class="line">      (<span class="name">make-instruction-sequence</span> '(env proc argl) '(env)</span><br><span class="line">        `(,proc-entry</span><br><span class="line">          (assign env (op compiled-procedure-env) (reg proc))</span><br><span class="line">          (assign env</span><br><span class="line">                  (op extend-environment)</span><br><span class="line">                  (const ,formals)</span><br><span class="line">                  (reg argl)</span><br><span class="line">                  (reg env))))</span><br><span class="line">      (<span class="name">compile-sequence</span></span><br><span class="line">        (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>)</span><br><span class="line">        <span class="symbol">'val</span> <span class="symbol">'return</span></span><br><span class="line">        (<span class="name">extend-ct-env</span> ct-env formals))))) <span class="comment">;modified here, extend formal list to ct-env</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">extend-ct-env</span> env frame)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> frame env))</span><br></pre></td></tr></table></figure>
<p>相比优化前的lambda表达式处理，这是增加了一步在函数体中通过参数传递了编译时环境。而这个编译时环境的用法在于我们可以通过这个预处理的编译时环境，找到需要被编译的变量在环境中的地址，定义一个<code>find-variable</code>来完成变量<code>var</code>在<code>ct-env</code>的定位，返回它的词法地址，即帧数和变量数组成的序对，如果没有找到就返回<code>&#39;not-found</code><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">find-variable</span> var ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search-variable</span> v l n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name"><span class="builtin-name">null?</span></span> l) false)</span><br><span class="line">          ((<span class="name"><span class="builtin-name">eq?</span></span> v (<span class="name"><span class="builtin-name">car</span></span> l)) n)</span><br><span class="line">          (<span class="name"><span class="builtin-name">else</span></span> (<span class="name">search-variable</span> v (<span class="name"><span class="builtin-name">cdr</span></span> l) (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>)))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">search-frame</span> frames f)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> frames)</span><br><span class="line">        <span class="symbol">'not-found</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">o</span> (<span class="name">search-variable</span> var (<span class="name"><span class="builtin-name">car</span></span> frames) <span class="number">0</span>)))</span><br><span class="line">             (<span class="name"><span class="builtin-name">if</span></span> o</span><br><span class="line">                 (<span class="name"><span class="builtin-name">cons</span></span> f o)</span><br><span class="line">                 (<span class="name">search-frame</span> (<span class="name"><span class="builtin-name">cdr</span></span> frames) (<span class="name"><span class="builtin-name">+</span></span> f <span class="number">1</span>))))))</span><br><span class="line">  (<span class="name">search-frame</span> ct-env <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p>
<p>借助<code>find-variable</code>，在对变量表达式和赋值表达式编译时，可以先对所需变量定位得到词法地址，再生成直接去这个词法地址在环境中的位置进行读写，也就是我们上面定义完成的<code>lexical-address-lookup</code>和<code>lexical-address-set!</code>作为原始操作指令生成可直接执行的代码。</p>
<p>有一种情况需要特殊注意，排除源语言代码编写出错的情况，在编译期间，对一个变量的编译过程中如果在编译时环境中用<code>find-variable</code>返回<code>&#39;not found</code>，那么说明变量现在还没有被放入绑定环境，但这个变量却可以提前使用，那么说明它是一个全局变量，可以用<code>get-global-environment</code>命令查找。而且全局变量也并不适合用词法地址来定位，因为它们一直在被交互地定义和重定义着，不适应这样静态的方法。</p>
<p>对变量表达式求值编译为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-variable</span> exp target linkage ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">lexical-addr</span> (<span class="name">find-variable</span> exp ct-env)))</span><br><span class="line">    (<span class="name">end-with-linkage</span></span><br><span class="line">    linkage</span><br><span class="line">    (<span class="name">make-instruction-sequence</span></span><br><span class="line">     '(env) (<span class="name"><span class="builtin-name">list</span></span> target)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> <span class="symbol">'not-found</span> lexical-addr)</span><br><span class="line">         `((assign ,target</span><br><span class="line">                   (op get-global-environment)</span><br><span class="line">                   (const ,exp)</span><br><span class="line">                   (reg env)))</span><br><span class="line">         `((assign ,target</span><br><span class="line">                   (op lexical-address-lookup)</span><br><span class="line">                   (const ,lexical-addr)</span><br><span class="line">                   (reg env))))))))</span><br></pre></td></tr></table></figure>
<p>赋值操作的编译过程为：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-assignment</span> exp target linkage ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">assignment-variable</span> exp))</span><br><span class="line">        (<span class="name">get-value-code</span></span><br><span class="line">         (<span class="name">compile</span> (<span class="name">assignment-value</span> exp) <span class="symbol">'val</span> <span class="symbol">'next</span> ct-env)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">lexical-addr</span> (<span class="name">find-variable</span> var ct-env)))</span><br><span class="line">      (<span class="name">end-with-linkage</span></span><br><span class="line">       linkage</span><br><span class="line">       (<span class="name">preserving</span></span><br><span class="line">        '(env)</span><br><span class="line">        get-value-code</span><br><span class="line">        (<span class="name">make-instruction-sequence</span></span><br><span class="line">         '(env val) (<span class="name"><span class="builtin-name">list</span></span> target)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> lexical-addr <span class="symbol">'not-found</span>)</span><br><span class="line">             `((perform (op set-variable-value!)</span><br><span class="line">                        (const ,var)</span><br><span class="line">                        (reg val)</span><br><span class="line">                        (reg env))</span><br><span class="line">               (assign ,target (const ok)))</span><br><span class="line">             `((perform (op lexical-address-set!)</span><br><span class="line">                        (const ,lexical-addr)</span><br><span class="line">                        (reg val)</span><br><span class="line">                        (reg env))</span><br><span class="line">               (assign ,target (const ok))))))))))</span><br></pre></td></tr></table></figure></p>
<h2 id="内部定义"><a href="#内部定义" class="headerlink" title="内部定义"></a>内部定义</h2><p>我在<a href="http://notebook.xyli.me/SICP/local-bindings-and-internal-definitions/#internal-define">局部绑定和内部定义</a>一文中详细解释过内部<code>define</code>命令应该如何被求值，因为无法使用全局环境但需要保持“同时定义”的假象来完成变量直接的顺序或递归定义，所以一般做法是先对整个body部分扫描一遍找到所有内部定义语句，并把被内部定义的变量初始化为<code>&#39;*unassigned*</code>扩展当当前环境，再按照语句的定义顺序把这些变量绑定到真正的变量值。即把<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">&lt;vars&gt;</span></span><br><span class="line">  (define u &lt;e1&gt;)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> v &lt;e2&gt;)</span><br><span class="line">  &lt;e3&gt;)</span><br></pre></td></tr></table></figure></p>
<p>当作<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> <span class="name">&lt;vars&gt;</span></span><br><span class="line">  (let ((u '*unassigned*)</span><br><span class="line">        (<span class="name">v</span> <span class="symbol">'*unassigned*</span>))</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> u &lt;e1&gt;)</span><br><span class="line">    (<span class="name"><span class="builtin-name">set!</span></span> v &lt;e2&gt;)</span><br><span class="line">    &lt;e3&gt;))</span><br></pre></td></tr></table></figure></p>
<p>来处理。扫描出这些内部定义变量转换为<code>let</code>表达式和一系列赋值操作的过程<code>scan-out-defines</code>可以实现为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">scan-out-defines</span> body)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">append</span></span> x y)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> x) y (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) (<span class="name"><span class="builtin-name">append</span></span> (<span class="name"><span class="builtin-name">cdr</span></span> x) y))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">let*</span></span> ((<span class="name">definitions</span></span><br><span class="line">           (<span class="name">filter</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                     (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">pair?</span></span> x) (<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) <span class="symbol">'define</span>))) body))</span><br><span class="line">         (<span class="name">non-definitions</span></span><br><span class="line">          (<span class="name">filter</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                    (<span class="name"><span class="builtin-name">or</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">pair?</span></span> x))</span><br><span class="line">                        (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> (<span class="name"><span class="builtin-name">car</span></span> x) <span class="symbol">'define</span>)))) body))</span><br><span class="line">         (<span class="name">let-vars</span> (<span class="name"><span class="builtin-name">map</span></span> definition-variable definitions))</span><br><span class="line">         (<span class="name">let-vals</span> (<span class="name"><span class="builtin-name">map</span></span> definition-value definitions))</span><br><span class="line">         (<span class="name">let-bindings</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">list</span></span> x '<span class="symbol">'*unassigned*</span>)) let-vars))</span><br><span class="line">         (<span class="name">assignments</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (x y) (<span class="name"><span class="builtin-name">list</span></span> <span class="symbol">'set!</span> x y)) let-vars let-vals)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> let-bindings)</span><br><span class="line">        body</span><br><span class="line">        (<span class="name"><span class="builtin-name">list</span></span> (<span class="name">make-let</span> let-bindings (<span class="name"><span class="builtin-name">append</span></span> assignments non-definitions))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-let</span> bindings body)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cons</span></span> <span class="symbol">'let</span> (<span class="name"><span class="builtin-name">cons</span></span> bindings body)))</span><br></pre></td></tr></table></figure>
<p>那么编译带有内部绑定的lambda表达式的函数体部分时，只需要把函数体部分用<code>scan-out-defines</code>转换成相应的<code>let</code>表达式：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">compile-lambda-body</span> exp proc-entry ct-env)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">formals</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>)))</span><br><span class="line">    (<span class="name">append-instruction-sequences</span></span><br><span class="line">      (<span class="name">make-instruction-sequence</span> '(env proc argl) '(env)</span><br><span class="line">        `(,proc-entry</span><br><span class="line">          (assign env (op compiled-procedure-env) (reg proc))</span><br><span class="line">          (assign env</span><br><span class="line">                  (op extend-environment)</span><br><span class="line">                  (const ,formals)</span><br><span class="line">                  (reg argl)</span><br><span class="line">                  (reg env))))</span><br><span class="line">      (<span class="name">compile-sequence</span></span><br><span class="line">        (<span class="name">scan-out-defines</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>)) <span class="comment">;just modified here; translate lambda-body into correct let expression.</span></span><br><span class="line">        <span class="symbol">'val</span> <span class="symbol">'return</span></span><br><span class="line">        (<span class="name">extend-ct-env</span> ct-env formals)))))</span><br></pre></td></tr></table></figure></p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>到此为止，词法寻址的实现基本完成。</p>
<p>有人可能观察到了编译时环境的维护除了辅助词法寻址以外还有别的用处，比如在搭载了open-coding的编译器中，虽然把一些简单的原始操作（如<code>+-*\</code>）直接处理为编译器的保留字可以省略对运算符的求值计算，但相应的也限制了程序的灵活编写，无法对这些运算符按照编写者的需求重载。如传入六个参数计算线性组合的过程<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">linear-combine</span> + * a b x y)</span><br><span class="line">  (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> a x) (<span class="name"><span class="builtin-name">*</span></span> b y)))</span><br></pre></td></tr></table></figure></p>
<p>无论以怎样的实参调用它，函数体的<code>+</code>和<code>*</code>始终会被当成原始的四则运算操作，当我们已经定义好的矩阵加法和乘法运算，想用这个函数来算矩阵的线性组合时会发现无法使用。</p>
<p>而有了编译时环境的帮助，就可以先在编译时环境中检查环境中是否有关于运算符的定义，如果没有再考虑open-coding的，结合两种优化可以极大提高效率。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">overwrite?</span> operator ct-env)</span><br><span class="line"> (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">r</span> (<span class="name">find-variable</span> operator ct-env)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">eq?</span></span> r <span class="symbol">'not-found</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">open-code?</span> exp ct-env)</span><br><span class="line"> (<span class="name"><span class="builtin-name">and</span></span> (<span class="name"><span class="builtin-name">memq</span></span> (<span class="name"><span class="builtin-name">car</span></span> exp) '(+ - * /))</span><br><span class="line">      (<span class="name">overwrite?</span> (<span class="name"><span class="builtin-name">car</span></span> exp) ct-env)))</span><br></pre></td></tr></table></figure>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://course.ccs.neu.edu/cs7400/lectures/lecture04.pdf" target="_blank" rel="noopener">https://course.ccs.neu.edu/cs7400/lectures/lecture04.pdf</a> NEU的Principles of Programming Languages关于词法寻址部分的讲义，注意它还提到了可以参考<a href="https://mitpress.mit.edu/books/essentials-programming-languages-third-edition" target="_blank" rel="noopener">EOPL</a>3.6-3.8，但EOPL第三版已经没有3.8小节了，3.6描述了编译器如何用环境地址中的索引替代掉真正的变量名。3.7给出了词法寻址的具体实现。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/lexical-addressing/" data-id="cjuh9y1ue0059jcw3gp9z5pqu" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!-- 
        <a href="#disqus_thread" class="article-comment-link">
        <i class="fa fa-comment"></i> Comments
        </a>
       -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译器/">编译器</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-119/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">LeetCode Weekly Contest 119</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-120/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">LeetCode Weekly Contest 120</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>


<!-- 
<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
 -->

  <div id="comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
    owner: 'Lixinyi-DUT',
    repo: 'TuQiang-Street-301',
    oauth: {
      client_id: '0a613b11d9140b2629e0',
      client_secret: 'b6ee57129a892f87bbac149167a90cf1a8035a47',
      id: 'Tue Jan 15 2019 23:31:57 GMT+0800',
    },
  })
  gitment.render('comments')
  </script>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-toc">
    <h4>概览</h4>
    <ol class="sidebar-module-list"><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#问题背景"><span class="sidebar-module-list-number">1.</span> <span class="sidebar-module-list-text">问题背景</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#索引寻址"><span class="sidebar-module-list-number">2.</span> <span class="sidebar-module-list-text">索引寻址</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#编译时环境"><span class="sidebar-module-list-number">3.</span> <span class="sidebar-module-list-text">编译时环境</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#内部定义"><span class="sidebar-module-list-number">4.</span> <span class="sidebar-module-list-text">内部定义</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#尾声"><span class="sidebar-module-list-number">5.</span> <span class="sidebar-module-list-text">尾声</span></a></li></ol>
  </div>



  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>找工作中。简历见<a href="http://resume.xyli.me/" style="text-decoration:none;">resume.xyli.me</a>，现在到2019年8月前均可入职，有任何算法/开发/研究岗短期工作机会的内推请不要犹豫的联系我，非常感谢！</p>
<p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>

</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">73</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-132/">LeetCode Weekly Contest 132</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-131/">LeetCode Weekly Contest 131</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-130/">LeetCode Weekly Contest 130</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  var disqus_url = 'notebook.xyli.me/SICP/lexical-addressing/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
