<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>函数的函数 | 笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="article">
<meta property="og:title" content="函数的函数">
<meta property="og:url" content="notebook.xyli.me/SICP/function-of-function/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:image" content="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true">
<meta property="og:updated_time" content="2017-11-16T14:20:17.884Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="函数的函数">
<meta name="twitter:image" content="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-function-of-function" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      函数的函数
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/function-of-function/" class="article-date"><time datetime="2017-10-25T07:57:19.464Z" itemprop="datePublished">2017-10-25</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true" alt="对魔法略知一二"></p>
<a id="more"></a>
<h2 id="头等函数-First-class-Function"><a href="#头等函数-First-class-Function" class="headerlink" title="头等函数 (First-class Function)"></a>头等函数 (First-class Function)</h2><p>一般来说，程序设计语言（编程语言）会在计算元素的使用上推行一些限制，限制最少的函数拥有最高的特权，被称为一等公民，它们有包括但不限于以下特权<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<ul>
<li>可以以变量命名</li>
<li>可以作为过程（函数）的参数传入</li>
<li>可以作为过程（函数）的结果返回</li>
<li>可以被包含在数据结构中</li>
</ul>
<p>无疑是该语言下的成功元素了。函数式编程语言(<em>functional languages</em>)的重要特征之一是将函数视为头等成功人士，赋予这些特权。函数的名字在此仅仅是一个函数类型的变量，这些函数能和其他变量一样被计算、存储、传递，被称为头等函数。匿名函数也可以作为这样的一等公民，正如匿名用户也可以享受其他用户一样的权利，但当你怀疑这些用户在分享刚编的故事时，又想再次引用他们的经历作为参数时往往很难再找到他们。在函数式编程语言中，我们日常接触到的函数都是头等函数比如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">        (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p>借助这个函数进行定义的<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square-sum</span> x y)</div><div class="line">        (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">square</span> x) (<span class="name">square</span> y))</div></pre></td></tr></table></figure></p>
<p>也是头等函数。</p>
<h2 id="高阶函数-Higher-order-Function"><a href="#高阶函数-Higher-order-Function" class="headerlink" title="高阶函数 (Higher-order Function)"></a>高阶函数 (Higher-order Function)</h2><p>与头等函数相对的一个概念为高阶函数，但这并不能说是对立的（与之对立的函数称为一阶函数）。或许应该说引入头等函数这个名词，是为了引出理解高阶函数的存在。</p>
<p>上面说到函数和其他数值变量在应用时可以做到某种意义上的一视同仁，函数名即函数变量的名字，那么也可以被当成实参变量传入另一个过程。高阶函数至少满足以下一个条件：</p>
<ol>
<li>至少参数中有一个是函数</li>
<li>返回的是一个函数</li>
</ol>
<p>在几乎所有语言中都会定义一些idiom来方便应用，比较有代表性的有<code>map</code>，<code>fold</code>和<code>filter</code>这三个高阶函数，暂时先无视命名冲突问题，为了直观理解这些函数的意义，可以自己这样定义一遍</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">map</span></span> f xs)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</div><div class="line">      null</div><div class="line">      (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name"><span class="builtin-name">map</span></span> f (<span class="name"><span class="builtin-name">cdr</span></span> xs)))))</div></pre></td></tr></table></figure>
<p><code>map</code>将一个函数<code>f</code>和一个list<code>xs</code>作为参数，<code>xs</code>中的每个元素作为<code>f</code>的参数返回的结果组成一个新的<code>list</code>作为<code>map</code>的返回结果。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fold</span> f acc xs)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</div><div class="line">      acc</div><div class="line">      (<span class="name">fold</span> f (<span class="name">f</span> acc (<span class="name"><span class="builtin-name">car</span></span> xs)) (<span class="name"><span class="builtin-name">cdr</span></span> xs))))</div></pre></td></tr></table></figure>
<p><code>fold</code>将一个函数<code>f</code>，初始值<code>acc</code>，和一个list<code>xs</code>作为参数，取<code>xs</code>中每个值<code>x</code>与当前的<code>acc</code>计算<code>f(acc,x)</code>作为下一个<code>acc</code>依次传递，如多米诺骨牌，与函数名的意义“折叠”不谋而合。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">filter</span> f xs)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</div><div class="line">      null</div><div class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">car</span></span> xs))</div><div class="line">          (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">car</span></span> xs) (<span class="name">filter</span> f (<span class="name"><span class="builtin-name">cdr</span></span> xs)))</div><div class="line">          (<span class="name">filter</span> f (<span class="name"><span class="builtin-name">cdr</span></span> xs)))))</div></pre></td></tr></table></figure>
<p><code>filter</code>使用函数<code>f</code>对list<code>xs</code>中的每个元素进行筛选，当且仅当返回值为真（<code>#t</code>）时把这个元素放入作为返回结果的新list</p>
<p>这三个高阶函数都是把一个函数作为了自己的参数，但返回的并不一定是一个函数（<code>map</code>和<code>filter</code>返回的必然不是，<code>fold</code>看具体情况）,它们也可以作为头等函数成为其他函数的参数。这些函数的参数<code>f</code>可以用函数的变量名传入，也可以用匿名函数，实际应用时匿名函数的使用情况也非常常见，甚至可以说匿名函数的一个重要作用就是临时地定义一个高阶函数中的过程参数，如计算一个常数<code>c</code>和行向量<code>xs</code>的乘积可表示为</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">*</span></span> c x)) xs)</div></pre></td></tr></table></figure>
<p>再如在Python中经常问的一个基础问题：如何将<code>dict</code>中的元素按<code>value</code>的大小排序？</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sorted(mydict.iteritems(), key=<span class="keyword">lambda</span> (k,v): v)</div></pre></td></tr></table></figure>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>当我们说一个函数有几个参数的时候我们在说什么？很多语言（如ML）中形如<code>f(arg1,arg2,...,argn)</code>的函数定义，看似使用了好几个参数，实际上这些参数只是作为一个长度为<code>n</code>的<code>list</code>或<code>tuple</code>传入，本质上还是一个单参数的函数。</p>
<p>有时我们并不需要或者来不及等所有参数都准备齐全才能使用函数，这种所有参数塞进一个数据结构的用法让人很恼火。curry正是这样一种方法：把这样的函数转化成只有真正意义上一个参数的函数的链。</p>
<p>如果每个参数<code>arg</code>都有一个类型<code>t</code>，那么在currying操作之前，<code>f(arg1,arg2,...,argn)</code>整个函数的类型为<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(t1 * t2 * ... * tn) -&gt; r<span class="keyword">type</span></div></pre></td></tr></table></figure></p>
<p>即取<code>(t1 * t2 * ... * tn)</code>类型的值<code>(arg1 * arg2 * ... *argn)</code>作为参数，返回<code>rtype</code>的值作为结果的函数。Currying操作之后的函数我们记为<code>f arg1 arg2 ... argn</code>，这个函数的类型为<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">t1</span> -&gt; (t2 -&gt; (... -&gt;(tn -&gt; r<span class="keyword">type</span>)...))</div></pre></td></tr></table></figure></p>
<p>此时<code>f</code>仅使用一个<code>t1</code>类型的参数，返回一个<code>t2 -&gt; (... -&gt;(tn -&gt; rtype)...)</code>类型的函数作为结果。当我们仅以一个参数去调用<code>f arg1</code>时，返回一个取<code>t2</code>类型数据为参数返回<code>t3-&gt; (... -&gt;(tn -&gt; rtype)...)</code>类型函数的函数，就像洋葱一样一层层地调用函数才能剥出最后的返回结果，当然<code>f(arg1,arg2,...,argn)</code>和<code>f arg1 arg2 ... argn</code>运算最后得到的结果是一致的。</p>
<p>按照这种思路可以重写<code>map</code>函数为<code>curried-map</code>：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">curried-map</span> f)</div><div class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (xs)</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> xs)</div><div class="line">        null</div><div class="line">        (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name">f</span> (<span class="name"><span class="builtin-name">car</span></span> xs)) ((<span class="name">curried-map</span> f) (<span class="name"><span class="builtin-name">cdr</span></span> xs)) ))))</div></pre></td></tr></table></figure></p>
<p>当我们要写一个对<code>list</code>中每个元素的值进行乘2操作的函数时，可以直接写作<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> double-list (<span class="name">curried-map</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">*</span></span> x <span class="number">2</span>))))</div></pre></td></tr></table></figure></p>
<p>这个<code>(curried-map (lambda (x) (* x 2)))</code>就是这样一个函数，是<code>curried-map</code>的一个部分应用（<em>partial application</em>）实例，currying使得这样的用法更为便捷。当然，我不是说部分应用必须依靠curry函数，完全没有那样的意思，实际上一定要用原来的<code>map</code>函数也可以达到目的<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">double-list2</span> xs)</div><div class="line">  (<span class="name"><span class="builtin-name">map</span></span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">*</span></span> x <span class="number">2</span>)) xs))</div></pre></td></tr></table></figure></p>
<p>差不多就是绑定了参数<code>y</code>的值然后定义<code>g(x)=f(x,y)</code>的意思，<code>map</code>只有两个参数，所以固定其中一个，然后把其他形参照着“抄写”一遍在定义里走个过场也不费事，但参数一多的时候不用curry函数就显得麻烦了。</p>
<h2 id="部分应用-Partial-Application"><a href="#部分应用-Partial-Application" class="headerlink" title="*部分应用 (Partial Application)"></a>*部分应用 (Partial Application)</h2><div class="bs-callout bs-callout-info"><h4 id="Optional"><a href="#Optional" class="headerlink" title=" Optional"></a><i class="fa fa-info-circle"></i> Optional</h4><p>这部分并非必须内容，我只是以自己的理解给出一个概念的实例实现，直接跳过不影响全文的内容脉络，仅供感兴趣的读者加深印象和交流改进。</p>
</div>
<p>部分应用的作用在于，将抽象的模型的<strong>一部分</strong>具体转化成为一个常见，实用的<strong>不那么</strong>抽象的模型。众所周知，Maclaurin公式（省略余项）<br>$$f\left( x \right) \approx f\left( 0 \right) + \frac{f’\left( 0 \right)}{1!}x + \frac{f^{\left(2 \right)}\left( 0 \right)}{2!}{x^2} +  \ldots  + \frac{f^{\left( n \right)}\left( 0 \right)}{n!}{x^n}$$<br>是Taylor公式（省略余项）$$f\left( x \right) \approx f\left( {x_0} \right) + \frac{f’\left( {x_0} \right)}{1!}\left( x - {x_0} \right) + \frac{f^{\left( 2 \right)}\left( x_0 \right)}{2!}{\left(x - x_0\right)^2} +  \ldots  + \frac{f^{\left( n \right)}\left( x_0 \right)}{n!}{\left( x - x_0\right)^n}$$在$x_0=0$处的特例，换言之也是绑定了参数<code>x0</code>的一个部分应用，两个公式给出的也都是包含参数<code>x</code>的函数作为返回结果，即一个<code>f</code>的近似函数。对于毫无编程基础或者像我这样编程基础薄弱的人来说，理解这个“部分应用”不需要借助任何代码，借助这个例子可以很好地感受“部分应用”概念本身的含义。</p>
<p>但是为了完整性，我还是试图从最基础的部分开始一步步给出它们的实现。</p>
<p>首先利用导数的定义$$f’\left( x \right) = \mathop {\lim }\limits_{dx \to 0} \frac{f\left( x + dx \right) - f\left( x \right)}{dx}$$写出导函数的定义</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> dx <span class="number">0.000001</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">deriv</span> f)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</div><div class="line">    (<span class="name">/</span> (<span class="name">-</span> (<span class="name">f</span> (<span class="name">+</span> x dx)) (<span class="name">f</span> x)) dx)))</div></pre></td></tr></table></figure>
<p><code>deriv</code>函数是部分curry化的，调用<code>(deriv f)</code>返回的是<code>f</code>的导函数，如果你想求<code>f</code>在某点<code>(x0,f(x0))</code>的导数<code>f&#39;(x0)</code>，还需要再调用一次这个结果，即<code>((deriv f) x0)</code>，当然因为我只是取了一个数值上接近无穷小的<code>dx</code>常量，所以最后的结果也只会是一个近似值，但这也够用了。</p>
<p>接下来实现Taylor公式中各项的表达。一般来说，Taylor公式中的求和项数越多结，这个近似的结果越接近函数的真实值，当$n \to \infty$时可认为等号成立。但这个真正的“无穷”是编写程序的人无法实现的，如果要写出无限长的Taylor数列$\frac{f^{\left( n \right)}\left( x_0 \right)}{n!}{\left(x - x_0\right)^n}$，那么可以利用惰性计算（<em>lazy evaluation</em>）的特征去模拟一个无限的“流（<em>stream</em>）”</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">taylor-stream</span> f)</div><div class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x0)</div><div class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x)</div><div class="line">      (<span class="name"><span class="builtin-name">letrec</span></span> ([<span class="name">taylor-series</span> (<span class="name"><span class="builtin-name">lambda</span></span> (n cof func base)</div><div class="line">                                (<span class="name"><span class="builtin-name">cons</span></span> ( / (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">func</span> x0) base) cof)</div><div class="line">                                      (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">taylor-series</span> (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>)</div><div class="line">                                                                (<span class="name"><span class="builtin-name">*</span></span> cof (<span class="name"><span class="builtin-name">+</span></span> n <span class="number">1</span>))</div><div class="line">                                                                (<span class="name">deriv</span> func)</div><div class="line">                                                                (<span class="name"><span class="builtin-name">*</span></span> base (<span class="name"><span class="builtin-name">-</span></span> x x0))))))])</div><div class="line">        (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">taylor-series</span> <span class="number">0</span> <span class="number">1</span> f <span class="number">1</span>))))))</div></pre></td></tr></table></figure>
<p><code>(taylor-stream f)</code>不仅是一个无限的流，也是关于<code>x</code>和<code>x0</code>的curry函数，仅当<code>x</code>和<code>x0</code>参数都传入时才进行真正的函数值计算，仅调用<code>(taylor-stream f)</code>时得到的只是如上罗列的公式。</p>
<p>然后然后针对这个数列（流）写一个前<code>n</code>项求和函数，没什么特别讲究的只需要随便写写就行<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-sum</span> n s)</div><div class="line">   (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> n <span class="number">0</span>)</div><div class="line">          <span class="number">0</span></div><div class="line">          (<span class="name"><span class="builtin-name">let</span></span> ([p (<span class="name">s</span>)])</div><div class="line">            (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">car</span> p)</div><div class="line">               (<span class="name">stream-sum</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>) (<span class="name">cdr</span> p))))))</div></pre></td></tr></table></figure></p>
<p>那么根据Taylor展开公式（取2阶导数），函数<code>f(x)</code>在<code>x0</code>点的近似多项式函数为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> order <span class="number">2</span>)</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">taylor-approx</span> x)</div><div class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x0)</div><div class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (f)</div><div class="line">      (<span class="name">stream-sum</span> (<span class="name"><span class="builtin-name">+</span></span> order <span class="number">1</span>)</div><div class="line">                  (((<span class="name">taylor-stream</span> f) x0) x)))))</div></pre></td></tr></table></figure></p>
<p>接下来作为固定了取值点<code>x0</code>为0的特例Maclaurin公式可以按照上文的部分应用写法写为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">maclaurin-approx</span> x) ((<span class="name">taylor-approx</span> x) <span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<p>然后就可以同时地，方便地去用这两个近似公式求多项式近似函数的值了。比如$2^x$在$x=0$时的Taylor近似函数在$x=2$处的值<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="name">maclaurin-approx</span> <span class="number">2</span>) (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">expt</span></span> <span class="number">2</span> x))) <span class="comment">;;3.347303891703234</span></div></pre></td></tr></table></figure></p>
<div class="bs-callout bs-callout-warning"><h4 id="Warning"><a href="#Warning" class="headerlink" title=" Warning"></a><i class="fa fa-exclamation-circle"></i> Warning</h4><p>注意这里的求导方法也是数值近似的，因此对于低阶函数，高阶近似，所求近似的自变量与取值点相距较远时，会产生巨大的误差。如果想提高微分的精确度，可以考虑用类似<code>eval</code>函数或解释器的方法递归地对表达式结果编写求导函数（参阅<a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/node39.html" target="_blank" rel="external">SICP: 2.3.2 Example: Symbolic Differentiation P197-199</a>）</p>
</div>
<h2 id="词法作用域-Lexical-Scope"><a href="#词法作用域-Lexical-Scope" class="headerlink" title="词法作用域 (Lexical Scope)"></a>词法作用域 (Lexical Scope)</h2><p>众所周知，为变量命名是件非常苦手的事，一般我们不提倡在一个程序内多次使用一个变量名，但这是个正确的废话，现实中总是无法避免的。而重复使用同一个变量名带来的问题就是不知道这个变量名到底和什么绑定了，我调用这个变量（包括函数）的时候，这个变量绑定的是哪个表达式，这个表达式中出现的变量绑定的又是哪个？好在程序设计语言的语法中对作用域（<em>scope</em>）都作出了相应的规定。</p>
<p>词法作用域是现在大多数语言采用的作用域类型，或者被称为静态作用域（<em>static scope</em>） 也是相对容易实现的类型。在这种规定下，函数体中的变量根据函数被定义的环境进行计算，而不是放在被调用的环境中计算。</p>
<p>有的教材在解释这个概念的时候会用到形如这样的例子<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><br><figure class="highlight ml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x = <span class="number">1</span></div><div class="line"><span class="keyword">fun</span> f y = x + y</div><div class="line"><span class="keyword">val</span> x = <span class="number">2</span></div><div class="line"><span class="keyword">val</span> y = <span class="number">3</span></div><div class="line"><span class="keyword">val</span> z = f (x+y)</div></pre></td></tr></table></figure></p>
<p>这里<code>z</code>的值为6。<code>f</code>的函数体在被计算时，在<code>f</code>被定义的环境中查找变量<code>x</code>的绑定，所以不管后面<code>x</code>怎样被shadow了，<code>f</code>执行的都是<code>+1</code>操作，不会出现<code>z==7</code>的结果。函数的参数<code>x+y</code>在被调用的新环境计算后传入函数体，但函数体却在被定义的旧环境中进行计算。</p>
<p>如果想要这个使<code>f</code>中的<code>x</code>更新为2，那么语言的作用域法则需要更改为动态作用域（<em>dynamic scope</em>）。在这种语法下，函数被调用时，函数体的求值过程中可以访问到现在的环境中的变量，而在词法作用域中，函数体的求值除了传入的参数之外，调用时的环境是被完全隔离开的，也就是不透明的。</p>
<p>Racket不允许top-level的变量重复定义，所以在top-level上重复使用一个变量名造成的混论可以避免。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. <a href="https://mitpress.mit.edu/sicp/" target="_blank" rel="external"><em>Structure and interpretation of computer programs.</em></a> Justin Kelly, 1996.</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/function-of-function/" data-id="cja2fpl5z0008i8w39bdevxu5" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!-- 
        <a href="#disqus_thread" class="article-comment-link">
        <i class="fa fa-comment"></i> Comments
        </a>
       -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/Deutsche101/Deutsche-101-1/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">失败人士的专属语言——德语</span>
    </a>
  </li>
  
  
</ul>


  
</article>


<!-- 
<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
 -->

  <div id="comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
    owner: 'Lixinyi-DUT',
    repo: 'TuQiang-Street-301',
    oauth: {
      client_id: '0a613b11d9140b2629e0',
      client_secret: 'b6ee57129a892f87bbac149167a90cf1a8035a47',
    },
  })
  gitment.render('comments')
  </script>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          


  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>请善用网络查阅资料，对于不知其真实身份的博客写作者（比如我），莫轻易付费，实在有心就请支持一下作者的另一个博客<a href="https://www.yangzhou301.com" style="text-decoration:none;">扬州计划</a> 本站欢迎读者无门槛投稿，投稿或其他事项的交流可联系作者<em><a href="mailto:i@xyli.me" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/SICP/function-of-function/">函数的函数</a>
        </li>
      
        <li>
          <a href="/Deutsche101/Deutsche-101-1/">失败人士的专属语言——德语</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-39/">LeetCode Weekly Contest 39</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-38/">LeetCode Weekly Contest 38</a>
        </li>
      
        <li>
          <a href="/Introduction/illustrations/">灵魂画手的插画集</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2017 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  // 
  // var disqus_url = 'notebook.xyli.me/SICP/function-of-function/';
  // 
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
