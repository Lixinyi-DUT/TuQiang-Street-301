<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>函数的函数 | 笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="函数的函数">
<meta property="og:url" content="notebook.xyli.me/SICP/function-of-function/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true">
<meta property="og:updated_time" content="2017-11-25T10:40:35.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="函数的函数">
<meta name="twitter:image" content="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-function-of-function" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      函数的函数
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/function-of-function/" class="article-date"><time datetime="2017-10-25T07:57:19.464Z" itemprop="datePublished">2017-10-25</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <!-- toc -->
<p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/blob/master/notebook/func_of_func/know_a_little_to_magic.jpg?raw=true" alt="知らないわ そんな魔法"></p>
<a id="more"></a>
<h2 id="头等函数-First-class-Function"><a href="#头等函数-First-class-Function" class="headerlink" title="头等函数 (First-class Function)"></a>头等函数 (First-class Function)</h2><p>一般来说，程序设计语言（编程语言）会在计算元素的使用上推行一些限制，限制最少的函数拥有最高的特权，被称为一等公民，它们有包括但不限于以下特权<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>
<ul>
<li>可以以变量命名</li>
<li>可以作为过程（函数）的参数传入</li>
<li>可以作为过程（函数）的结果返回</li>
<li>可以被包含在数据结构中</li>
</ul>
<p>无疑是该语言下的成功元素了。函数式编程语言(<em>functional languages</em>)的重要特征之一是将函数视为头等成功人士，赋予这些特权。函数的名字在此仅仅是一个函数类型的变量，这些函数能和其他变量一样被计算、存储、传递，被称为头等函数。匿名函数也可以作为这样的一等公民，正如匿名用户也可以享受其他用户一样的权利，但当你怀疑这些用户在分享刚编的故事时，又想再次引用他们的经历作为参数时往往很难再找到他们。在函数式编程语言中，我们日常接触到的函数都是头等函数比如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x)</span><br><span class="line">        (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure>
<p>借助这个函数进行定义的<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square-sum</span> x y)</span><br><span class="line">        (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y))</span><br></pre></td></tr></table></figure></p>
<p>也是头等函数。</p>
<h2 id="高阶函数-Higher-order-Function"><a href="#高阶函数-Higher-order-Function" class="headerlink" title="高阶函数 (Higher-order Function)"></a>高阶函数 (Higher-order Function)</h2><p>与头等函数相对的一个概念为高阶函数，但这并不能说是对立的（与之对立的函数称为一阶函数）。或许应该说引入头等函数这个名词，是为了引出理解高阶函数的存在。</p>
<p>上面说到函数和其他数值变量在应用时可以做到某种意义上的一视同仁，函数名即函数变量的名字，那么也可以被当成实参变量传入另一个过程。高阶函数至少满足以下一个条件：</p>
<ol>
<li>至少参数中有一个是函数</li>
<li>返回的是一个函数</li>
</ol>
<p>在几乎所有语言中都会定义一些idiom来方便应用，比较有代表性的有<code>map</code>，<code>fold</code>和<code>filter</code>这三个高阶函数，暂时先无视命名冲突问题，为了直观理解这些函数的意义，可以自己这样定义一遍</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">map</span> f xs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">      null</span><br><span class="line">      (<span class="name">cons</span> (<span class="name">f</span> (<span class="name">car</span> xs)) (<span class="name">map</span> f (<span class="name">cdr</span> xs)))))</span><br></pre></td></tr></table></figure>
<p><code>map</code>将一个函数<code>f</code>和一个list<code>xs</code>作为参数，<code>xs</code>中的每个元素作为<code>f</code>的参数返回的结果组成一个新的<code>list</code>作为<code>map</code>的返回结果。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">fold</span> f acc xs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">      acc</span><br><span class="line">      (<span class="name">fold</span> f (<span class="name">f</span> acc (<span class="name">car</span> xs)) (<span class="name">cdr</span> xs))))</span><br></pre></td></tr></table></figure>
<p><code>fold</code>将一个函数<code>f</code>，初始值<code>acc</code>，和一个list<code>xs</code>作为参数，取<code>xs</code>中每个值<code>x</code>与当前的<code>acc</code>计算<code>f(acc,x)</code>作为下一个<code>acc</code>依次传递，如多米诺骨牌，与函数名的意义“折叠”不谋而合。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">filter</span> f xs)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">      null</span><br><span class="line">      (<span class="name">if</span> (<span class="name">f</span> (<span class="name">car</span> xs))</span><br><span class="line">          (<span class="name">cons</span> (<span class="name">car</span> xs) (<span class="name">filter</span> f (<span class="name">cdr</span> xs)))</span><br><span class="line">          (<span class="name">filter</span> f (<span class="name">cdr</span> xs)))))</span><br></pre></td></tr></table></figure>
<p><code>filter</code>使用函数<code>f</code>对list<code>xs</code>中的每个元素进行筛选，当且仅当返回值为真（<code>#t</code>）时把这个元素放入作为返回结果的新list</p>
<p>这三个高阶函数都是把一个函数作为了自己的参数，但返回的并不一定是一个函数（<code>map</code>和<code>filter</code>返回的必然不是，<code>fold</code>看具体情况）,它们也可以作为头等函数成为其他函数的参数。这些函数的参数<code>f</code>可以用函数的变量名传入，也可以用匿名函数，实际应用时匿名函数的使用情况也非常常见，甚至可以说匿名函数的一个重要作用就是临时地定义一个高阶函数中的过程参数，如计算一个常数<code>c</code>和行向量<code>xs</code>的乘积可表示为</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> c x)) xs)</span><br></pre></td></tr></table></figure>
<p>再如在Python中经常问的一个基础问题：如何将<code>dict</code>中的元素按<code>value</code>的大小排序？</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(mydict.iteritems(), key=<span class="keyword">lambda</span> (k,v): v)</span><br></pre></td></tr></table></figure>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>当我们说一个函数有几个参数的时候我们在说什么？很多语言（如ML）中形如<code>f(arg1,arg2,...,argn)</code>的函数定义，看似使用了好几个参数，实际上这些参数只是作为一个长度为<code>n</code>的<code>list</code>或<code>tuple</code>传入，本质上还是一个单参数的函数。</p>
<p>有时我们并不需要或者来不及等所有参数都准备齐全才能使用函数，这种所有参数塞进一个数据结构的用法让人很恼火。curry正是这样一种方法：把这样的函数转化成只有真正意义上一个参数的函数的链。</p>
<p>如果每个参数<code>arg</code>都有一个类型<code>t</code>，那么在currying操作之前，<code>f(arg1,arg2,...,argn)</code>整个函数的类型为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(t1 * t2 * ... * tn) -&gt; rtype</span><br></pre></td></tr></table></figure></p>
<p>即取<code>(t1 * t2 * ... * tn)</code>类型的值<code>(arg1 * arg2 * ... *argn)</code>作为参数，返回<code>rtype</code>的值作为结果的函数。Currying操作之后的函数我们记为<code>f arg1 arg2 ... argn</code>，这个函数的类型为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1 -&gt; (t2 -&gt; (... -&gt;(tn -&gt; rtype)...))</span><br></pre></td></tr></table></figure></p>
<p>此时<code>f</code>仅使用一个<code>t1</code>类型的参数，返回一个<code>t2 -&gt; (... -&gt;(tn -&gt; rtype)...)</code>类型的函数作为结果。当我们仅以一个参数去调用<code>f arg1</code>时，返回一个取<code>t2</code>类型数据为参数返回<code>t3-&gt; (... -&gt;(tn -&gt; rtype)...)</code>类型函数的函数，就像洋葱一样一层层地调用函数才能剥出最后的返回结果，当然<code>f(arg1,arg2,...,argn)</code>和<code>f arg1 arg2 ... argn</code>运算最后得到的结果是一致的。</p>
<p>按照这种思路可以重写<code>map</code>函数为<code>curried-map</code>：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">curried-map</span> f)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">xs</span>)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">null</span>? xs)</span><br><span class="line">        null</span><br><span class="line">        (<span class="name">cons</span> (<span class="name">f</span> (<span class="name">car</span> xs)) ((<span class="name">curried-map</span> f) (<span class="name">cdr</span> xs)) ))))</span><br></pre></td></tr></table></figure></p>
<p>当我们要写一个对<code>list</code>中每个元素的值进行乘2操作的函数时，可以直接写作<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> double-list (<span class="name">curried-map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x <span class="number">2</span>))))</span><br></pre></td></tr></table></figure></p>
<p>这个<code>(curried-map (lambda (x) (* x 2)))</code>就是这样一个函数，是<code>curried-map</code>的一个部分应用（<em>partial application</em>）实例，currying使得这样的用法更为便捷。当然，我不是说部分应用必须依靠curry函数，完全没有那样的意思，实际上一定要用原来的<code>map</code>函数也可以达到目的<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">double-list2</span> xs)</span><br><span class="line">  (<span class="name">map</span> (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x <span class="number">2</span>)) xs))</span><br></pre></td></tr></table></figure></p>
<p>差不多就是绑定了参数<code>y</code>的值然后定义<code>g(x)=f(x,y)</code>的意思，<code>map</code>只有两个参数，所以固定其中一个，然后把其他形参照着“抄写”一遍在定义里走个过场也不费事，但参数一多的时候不用curry函数就显得麻烦了。</p>
<h2 id="部分应用-Partial-Application"><a href="#部分应用-Partial-Application" class="headerlink" title="*部分应用 (Partial Application)"></a>*部分应用 (Partial Application)</h2><div class="bs-callout bs-callout-info"><h4 id="Optional"><a href="#Optional" class="headerlink" title=" Optional"></a><i class="fa fa-info-circle"></i> Optional</h4><p>这部分并非必须内容，我只是以自己的理解给出一个概念的实例实现，直接跳过不影响全文的内容脉络，仅供感兴趣的读者加深印象和交流改进。</p>
</div>
<p>部分应用的作用在于，将抽象的模型的<strong>一部分</strong>具体转化成为一个常见，实用的<strong>不那么</strong>抽象的模型。众所周知，Maclaurin公式（省略余项）<br>$$f\left( x \right) \approx f\left( 0 \right) + \frac{f’\left( 0 \right)}{1!}x + \frac{f^{\left(2 \right)}\left( 0 \right)}{2!}{x^2} +  \ldots  + \frac{f^{\left( n \right)}\left( 0 \right)}{n!}{x^n}$$<br>是Taylor公式（省略余项）$$f\left( x \right) \approx f\left( {x_0} \right) + \frac{f’\left( {x_0} \right)}{1!}\left( x - {x_0} \right) + \frac{f^{\left( 2 \right)}\left( x_0 \right)}{2!}{\left(x - x_0\right)^2} +  \ldots  + \frac{f^{\left( n \right)}\left( x_0 \right)}{n!}{\left( x - x_0\right)^n}$$在$x_0=0$处的特例，换言之也是绑定了参数<code>x0</code>的一个部分应用，两个公式给出的也都是包含参数<code>x</code>的函数作为返回结果，即一个<code>f</code>的近似函数。对于毫无编程基础或者像我这样编程基础薄弱的人来说，理解这个“部分应用”不需要借助任何代码，借助这个例子可以很好地感受“部分应用”概念本身的含义。</p>
<p>但是为了完整性，我还是试图从最基础的部分开始一步步给出它们的实现。</p>
<p>首先利用导数的定义$$f’\left( x \right) = \mathop {\lim }\limits_{dx \to 0} \frac{f\left( x + dx \right) - f\left( x \right)}{dx}$$写出导函数的定义</p>
<p><a name="deriv"></a><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> dx <span class="number">0.000001</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">deriv</span> f)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x</span>)</span><br><span class="line">    (<span class="name">/</span> (<span class="name">-</span> (<span class="name">f</span> (<span class="name">+</span> x dx)) (<span class="name">f</span> x)) dx)))</span><br></pre></td></tr></table></figure></p>
<p><code>deriv</code>函数是部分curry化的，调用<code>(deriv f)</code>返回的是<code>f</code>的导函数，如果你想求<code>f</code>在某点<code>(x0,f(x0))</code>的导数<code>f&#39;(x0)</code>，还需要再调用一次这个结果，即<code>((deriv f) x0)</code>，当然因为我只是取了一个数值上接近无穷小的<code>dx</code>常量，所以最后的结果也只会是一个近似值，但这也够用了。</p>
<p>接下来实现Taylor公式中各项的表达。一般来说，Taylor公式中的求和项数越多结，这个近似的结果越接近函数的真实值，当$n \to \infty$时可认为等号成立。但这个真正的“无穷”是编写程序的人无法实现的，如果要写出无限长的Taylor数列$\frac{f^{\left( n \right)}\left( x_0 \right)}{n!}{\left(x - x_0\right)^n}$，那么可以利用惰性计算（<em>lazy evaluation</em>）的特性去模拟一个无限的“流（<em>stream</em>）”</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">taylor-stream</span> f)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x0</span>)</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">x</span>)</span><br><span class="line">      (<span class="name">letrec</span> ([taylor-series (<span class="name">lambda</span> (<span class="name">n</span> cof func base)</span><br><span class="line">                                (<span class="name">cons</span> ( <span class="name">/</span> (<span class="name">*</span> (<span class="name">func</span> x0) base) cof)</span><br><span class="line">                                      (<span class="name">lambda</span> () (<span class="name">taylor-series</span> (<span class="name">+</span> n <span class="number">1</span>)</span><br><span class="line">                                                                (<span class="name">*</span> cof (<span class="name">+</span> n <span class="number">1</span>))</span><br><span class="line">                                                                (<span class="name">deriv</span> func)</span><br><span class="line">                                                                (<span class="name">*</span> base (<span class="name">-</span> x x0))))))])</span><br><span class="line">        (<span class="name">lambda</span> () (<span class="name">taylor-series</span> <span class="number">0</span> <span class="number">1</span> f <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure>
<p><code>(taylor-stream f)</code>不仅是一个无限的流，也是关于<code>x</code>和<code>x0</code>的curry函数，仅当<code>x</code>和<code>x0</code>参数都传入时才进行真正的函数值计算，仅调用<code>(taylor-stream f)</code>时得到的只是如上罗列的公式。</p>
<p>然后然后针对这个数列（流）写一个前<code>n</code>项求和函数，没什么特别讲究的只需要随便写写就行<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">stream-sum</span> n s)</span><br><span class="line">   (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (<span class="name">let</span> ([p (<span class="name">s</span>)])</span><br><span class="line">            (<span class="name">+</span> (<span class="name">car</span> p)</span><br><span class="line">               (<span class="name">stream-sum</span> (<span class="name">-</span> n <span class="number">1</span>) (<span class="name">cdr</span> p))))))</span><br></pre></td></tr></table></figure></p>
<p>那么根据Taylor展开公式（取2阶导数），函数<code>f(x)</code>在<code>x0</code>点的近似多项式函数为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> order <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">taylor-approx</span> x)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x0</span>)</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">f</span>)</span><br><span class="line">      (<span class="name">stream-sum</span> (<span class="name">+</span> order <span class="number">1</span>)</span><br><span class="line">                  (((<span class="name">taylor-stream</span> f) x0) x)))))</span><br></pre></td></tr></table></figure></p>
<p>接下来作为固定了取值点<code>x0</code>为0的特例Maclaurin公式可以按照上文的部分应用写法写为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">maclaurin-approx</span> x) ((<span class="name">taylor-approx</span> x) <span class="number">0</span>))</span><br></pre></td></tr></table></figure></p>
<p>然后就可以同时地，方便地去用这两个近似公式求多项式近似函数的值了。比如$2^x$在$x=0$时的Taylor近似函数在$x=2$处的值<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">maclaurin-approx</span> <span class="number">2</span>) (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">expt</span> <span class="number">2</span> x))) <span class="comment">;;3.347303891703234</span></span><br></pre></td></tr></table></figure></p>
<div class="bs-callout bs-callout-warning"><h4 id="Warning"><a href="#Warning" class="headerlink" title=" Warning"></a><i class="fa fa-exclamation-circle"></i> Warning</h4><p>注意这里的求导方法也是数值近似的，因此对于低阶函数，高阶近似，所求近似的自变量与取值点相距较远时，会产生巨大的误差。如果想提高微分的精确度，可以考虑用类似<code>eval</code>函数或解释器的方法递归地对表达式结果编写求导函数（参阅<a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/node39.html" target="_blank" rel="noopener">SICP: 2.3.2 Example: Symbolic Differentiation P197-199</a>）</p>
</div>
<h2 id="词法作用域-Lexical-Scope"><a href="#词法作用域-Lexical-Scope" class="headerlink" title="词法作用域 (Lexical Scope)"></a>词法作用域 (Lexical Scope)</h2><p>众所周知，为变量命名是件非常苦手的事，一般我们不提倡在一个程序内多次使用一个变量名，但这是个正确的废话，现实中总是无法避免的。而重复使用同一个变量名带来的问题就是不知道这个变量名到底和什么绑定了，我调用这个变量（包括函数）的时候，这个变量绑定的是哪个表达式，这个表达式中出现的变量绑定的又是哪个？好在程序设计语言的语法中对作用域（<em>scope</em>）都作出了相应的规定。</p>
<p>词法作用域是现在大多数语言采用的作用域类型，或者被称为静态作用域（<em>static scope</em>） 也是相对容易实现的类型。在这种规定下，函数体中的变量根据函数被定义的环境进行计算，而不是放在被调用的环境中计算。</p>
<p>有的教材在解释这个概念的时候会用到形如这样的例子<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>
<p><a name="ex1"></a><br><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line"><span class="keyword">fun</span> f y = x + y</span><br><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> z = f (x+y)</span><br></pre></td></tr></table></figure></p>
<p>这里<code>z</code>的值为6。<code>f</code>的函数体在被计算时，在<code>f</code>被定义的环境中查找变量<code>x</code>的绑定，所以不管后面<code>x</code>怎样被shadow了，<code>f</code>执行的都是<code>+1</code>操作，不会出现<code>z==7</code>的结果。函数的参数<code>x+y</code>在被调用的新环境计算后传入函数体，但函数体却在被定义的旧环境中进行计算。</p>
<p>如果想要这个使<code>f</code>中的<code>x</code>更新为2，那么语言的作用域法则需要更改为动态作用域（<em>dynamic scope</em>）。在这种语法下，函数被调用时，函数体的求值过程中可以访问到现在的环境中的变量，而在词法作用域中，函数体的求值除了传入的参数之外，调用时的环境是被完全隔离开的，也就是不透明的。</p>
<p>上面是一个关于ML的例子，用同样的思路去写一个Python的例子<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">x=<span class="number">2</span></span><br><span class="line">y=<span class="number">3</span></span><br><span class="line">z=f(x+y)</span><br></pre></td></tr></table></figure></p>
<p><code>z</code>的值为7，但这并不意味着Python是使用动态作用域的语言。Python是静态作用域的，但缺少类似于<code>val</code>关键字引导的类型声明。ML的<code>val x=2</code>所做的是重新声明了一个绑定为2的变量<code>x</code>shadow掉了原来的<code>val x=1</code>，实质上这是两个变量，虽然名字都是<code>x</code>，但作用域不同。而Python中<code>x=2</code>则是对已有的变量<code>x</code>的值的修改，即引用（<em>reference</em>）的更新。由于函数体<code>f</code>中并没有本地变量<code>x</code>的声明，遵循LEGB原则（<em>Local, Enclosing, Global, Built-in</em>），函数的定义环境中<code>x</code>即为全局变量<code>x</code>，函数体计算时使用的是<code>x</code>的引用。Python也支持前向引用（<em>forward reference</em>），换言之即使这个<code>x</code>在函数被定义时还没有被声明或者更新，函数值计算时<code>x</code>也是使用该全局变量最新的值。虽然整个过程看上去别扭，但始终遵循函数被放到了定义的环境中去计算的原则，只是在这个定义的环境中函数里面出现的变量被定义为一个可变的引用。<del>Python不是函数式编程语言，但有部分函数式编程语言的特性，然而函数式编程认为使用可修改的变量（引用）是很不优雅的坏文明。</del></p>
<p>这样写就不会出现上面的困扰了<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(y)</span>:</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f(x+y)</span><br><span class="line"></span><br><span class="line">z=f(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里<code>x=2</code>是在函数<code>g</code>中声明了一个值为2的局部变量<code>x</code>去shadow掉了值为1的全局变量，然而根据词法作用域的原则，在<code>g</code>中调用的<code>f</code>并不会用这个新环境被求值，还是使用被定义时<code>x</code>为全局变量的旧环境，所以<code>z</code>的值为6。</p>
<p>Racket不允许top-level的变量重复定义，所以在top-level上重复使用一个变量名造成的混乱可以避免。但是，在函数（过程）中被调用的函数的定义里如果出现了和外界同名的变量，还是遵循词法作用域的原则，外面的过程中的局部变量对调用的函数不可见。这可以体现在用<code>let</code>引导的局部变量定义，比如这个与<a href="#ex1">ML表示的例子</a>完全相同的逻辑，毫不意外地，<code>z</code>的值为6<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">f</span> y)</span><br><span class="line">  (<span class="name">+</span> x y))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> z</span><br><span class="line">  (<span class="name">let</span> ([x <span class="number">2</span>]</span><br><span class="line">        [y <span class="number">3</span>])</span><br><span class="line">    (<span class="name">f</span> (<span class="name">+</span> x y)))) <span class="comment">;;z=6</span></span><br></pre></td></tr></table></figure></p>
<p>也可以体现在一个函数定义时使用的形参名字，与该函数代码内调用的另一个函数中的变量名冲突时的情况：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">disp-deriv</span> f x1 x2 dx)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> x1 x2)</span><br><span class="line">      null</span><br><span class="line">      (<span class="name">cons</span> ((<span class="name">deriv</span> f) x1) (<span class="name">disp-deriv</span> f (<span class="name">+</span> x1 dx) x2 dx))))</span><br></pre></td></tr></table></figure></p>
<p><code>disp-deriv</code>是一个求<code>[x1,x2]</code>区间内按<code>dx</code>为步长取点的<code>f(x)</code>的导数列表的函数，我们知道之前在<a href="#deriv">deriv</a>函数的定义里已经有了其中常数<code>dx</code>的指定，这里再用<code>dx</code>来当代表步长的形参，这种做法确实挺不好的，但人难免会有一拍大腿想不出什么好名字理性蒸发瞎写的时候。词法作用域保证了在调用<code>deriv</code>给取值点挨个求导的时候，<code>deriv</code>内部的极小增量<code>dx</code>的取值不会受到外部步长<code>dx</code>的干扰，所以当你调用<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">disp-deriv</span> square <span class="number">0</span> <span class="number">4</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>时，可以正确得到这5个整数点上的导数值。</p>
<h3 id="环境（Environmnet）与闭包-（Closure）"><a href="#环境（Environmnet）与闭包-（Closure）" class="headerlink" title="环境（Environmnet）与闭包 （Closure）"></a>环境（<em>Environmnet</em>）与闭包 （<em>Closure</em>）</h3><p>所谓环境，通俗来说就是记录变量名绑定的字典。作用域法则已经在大方向上规定了应该怎么去分类这些字典，在哪个情形下我们应该去翻哪本字典，新“注册”了一个绑定又应该往哪本字典里去添加“词条”。至于具体在去一个指定的字典查找一个变量的定义，可以用这样的写法<a name="envlookup"></a><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">envlookup</span> env str)</span><br><span class="line">  (<span class="name">cond</span> [(<span class="name">null</span>? env) (<span class="name">error</span> <span class="string">"unbound variable during evaluation"</span> str)]</span><br><span class="line">        [(<span class="name">equal</span>? (<span class="name">car</span> (<span class="name">car</span> env)) str) (<span class="name">cdr</span> (<span class="name">car</span> env))]</span><br><span class="line">        [#t (<span class="name">envlookup</span> (<span class="name">cdr</span> env) str)]))</span><br></pre></td></tr></table></figure></p>
<p>环境<code>env</code>是一个由<code>(str,exp)</code>对表示（变量名，表达式）组成的列表，<code>str</code>是一个字符串类型的变量名字，<code>exp</code>则是该变量名所绑定的，在该语言中的一个表达式。</p>
<p>当表达式需要在指定环境<code>env</code>下进行“解释”（求值）的时候，把<code>env</code>作为求值过程的一个参数传进去就可以了，再在过程内部调用<code>envlookup</code>函数。</p>
<p>既然词法作用域严格地强调了定义与调用两种环境的隔离，那就需要用一种方法去把函数定义的环境和函数本身进行“打包封装”作为一个整体传入其他过程或函数，再等到调用时就地“拆包”进行求值。闭包就是为此而诞生的技术。如果函数体中有一些变量本身并没有在函数体中被定义，需要依赖函数被定义的环境确定这些变量的具体指代，那么这些变量的定义环境就需要连同函数代码本身一起被放进这样一个被称为闭包的数据结构<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> closure (<span class="name">env</span> fun) #<span class="symbol">:transparent</span>)</span><br></pre></td></tr></table></figure></p>
<p>闭包就是函数被“解释”的结果，它就是一个可以被用来传递的值。在这里闭包的实现方法实际是一个偷懒的trick，直接把函数定义时的环境和函数一起放进了<code>closure</code></p>
<h3 id="自由变量-（Free-variable）"><a href="#自由变量-（Free-variable）" class="headerlink" title="*自由变量 （Free variable）"></a>*自由变量 （<em>Free variable</em>）</h3><p>上面简单的“打包”将函数定义存在的所有绑定，无论函数体求值时是否用到，一并封装到了<code>closure</code>，当然仅根据词法作用域的定义也不能说这种做法存在什么错误，也完全可以通过<a href="#call">下文中实现的方法</a>正常地运行这个机制。但是把不必要的绑定放到<code>closure</code>里确实也会造成冗余，实践中的闭包实现也基本不会容忍这种低效的方法，一个可行的改进的思路就是仅在<code>closure</code>中引用与函数“相关”的变量名的绑定，这些变量就是所谓的自由变量。</p>
<p>和数学中所使用的“自由变量”和“约束变量”含义相似，自由变量是指仅在函数体代码中直接占位使用，却没有在函数体中给出定义（约束）的变量，它的定义在函数体外，不同的作用域法则争议的是对这些自由变量的“解释权”。在<a href="#ex1">上面的例子</a>中<code>x</code>就是函数<code>f</code>的自由变量，在词法作用域下需要做的就是在闭包的环境中把<code>x</code>与整数值<code>1</code>对应，另外还有一些判断函数中那些变量是自由变量的例子<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">lambda</span> () (<span class="name">+</span> x y z)) <span class="comment">; &#123;x, y, z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> x y z)) <span class="comment">; &#123;y, z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">if</span> x y z)) <span class="comment">; &#123;y, z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">let</span> ([y <span class="number">0</span>]) (<span class="name">+</span> x y z))) <span class="comment">; &#123;z&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span> y z) (<span class="name">+</span> x y z)) <span class="comment">; &#123;&#125;</span></span><br><span class="line">(<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">+</span> y (<span class="name">let</span> ([y z]) (<span class="name">+</span> y y)))) <span class="comment">; &#123;y, z&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>实际上会一点编程的人都能敏锐地凭借直感找出自由变量，仅凭自然语言描述怎么去找一堆代码里面有几个自由变量也有些困难，如果有兴趣可以看后文中的<a href="#更轻的环境">代码实现</a>。</p>
<h2 id="简易解释器"><a href="#简易解释器" class="headerlink" title="*简易解释器"></a>*简易解释器</h2><div class="bs-callout bs-callout-info"><h4 id="Optional"><a href="#Optional" class="headerlink" title=" Optional"></a><i class="fa fa-info-circle"></i> Optional</h4><p>本部分内容和实践中的解释器（<em>Interpreter</em>）存在巨大的差异，给出实现仅为帮助理解以上概念所写。内容基本直接参考<a href="https://www.coursera.org/learn/programming-languages/home/welcome" target="_blank" rel="noopener">Programming Languages</a>中给出的指导进行实现。</p>
</div>
<p>现在我们要定义一种由如下表达式表示出来的语言，可以命名该语言为MUPL (Make Up Programming Language)<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> var  (<span class="name">string</span>) #<span class="symbol">:transparent</span>)  <span class="comment">;; 变量，例如(var "foo")</span></span><br><span class="line">(<span class="name">struct</span> int  (<span class="name">num</span>)    #<span class="symbol">:transparent</span>)  <span class="comment">;; 常数,  例如(int 17)</span></span><br><span class="line">(<span class="name">struct</span> add  (<span class="name">e1</span> e2)  #<span class="symbol">:transparent</span>)  <span class="comment">;; 加法表达式</span></span><br><span class="line">(<span class="name">struct</span> ifgreater (<span class="name">e1</span> e2 e3 e4)    #<span class="symbol">:transparent</span>) <span class="comment">;; 如果 e1 &gt; e2 则结果为 e3 否则为 e4</span></span><br><span class="line">(<span class="name">struct</span> fun  (<span class="name">nameopt</span> formal body) #<span class="symbol">:transparent</span>) <span class="comment">;; 单参数函数，如果nameopt域即函数名为#f则为匿名函数</span></span><br><span class="line">(<span class="name">struct</span> call (<span class="name">funexp</span> actual)       #<span class="symbol">:transparent</span>) <span class="comment">;; 函数调用</span></span><br><span class="line">(<span class="name">struct</span> mlet (<span class="name">var</span> e body) #<span class="symbol">:transparent</span>) <span class="comment">;;本地绑定 (let var = e in body)</span></span><br><span class="line">(<span class="name">struct</span> apair (<span class="name">e1</span> e2)     #<span class="symbol">:transparent</span>) <span class="comment">;; 定义一个(e1,e2)对</span></span><br><span class="line">(<span class="name">struct</span> fst  (<span class="name">e</span>)    #<span class="symbol">:transparent</span>) <span class="comment">;; 取对的第一个数</span></span><br><span class="line">(<span class="name">struct</span> snd  (<span class="name">e</span>)    #<span class="symbol">:transparent</span>) <span class="comment">;; 取对的第二个数</span></span><br><span class="line">(<span class="name">struct</span> aunit ()    #<span class="symbol">:transparent</span>) <span class="comment">;; unit，list的“休止符”</span></span><br><span class="line">(<span class="name">struct</span> isaunit (<span class="name">e</span>) #<span class="symbol">:transparent</span>) <span class="comment">;; 判断e是不是unit，是则为1否则为0</span></span><br></pre></td></tr></table></figure></p>
<p>我们的最终目的是写一个Racket程序（函数）来解释和MUPL语言给出的表达式，那么要做的就是用Racket模拟MUPL中各表达式的求值过程，对于复合的语义结构，无疑应该使用递归一层层去进行求值。首先列出一个框架：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">eval-under-env</span> e env)</span><br><span class="line">  (<span class="name">cond</span> [...]</span><br><span class="line">        [...]</span><br><span class="line">        ....</span><br><span class="line">        [#t (<span class="name">error</span> (<span class="name">format</span> <span class="string">"bad (MUPL expression: ~v"</span> e))]))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">eval-exp</span> e)</span><br><span class="line">  (<span class="name">eval-under-env</span> e null))</span><br></pre></td></tr></table></figure></p>
<p>最终实现的结果就是<code>eval-exp</code>函数，用于解释MUPL程序。<code>eval-under-env</code>则是用于不同环境进行递归的辅助函数，可以说是这个解释器的“单元”，<code>cond</code>语句对不同类型的表达式做出了<code>eval</code>方面不同操作的规定，接下来我们要做的只有一步步按照MUPL的语义填充这些<code>[...]</code>从句。</p>
<p>首先，所有的变量都被当成变量本身（包括<code>closure</code>）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(int? e) e]</span><br><span class="line">[(closure? e) e]</span><br><span class="line">[(aunit? e) e]</span><br></pre></td></tr></table></figure></p>
<p>接下来，遇到某个<code>var &quot;name&quot;</code>形式的变量的时候，利用<a href="#envlookup">envlookup</a>函数找到在当前环境下这个变量名绑定的值<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(var? e)</span><br><span class="line"> (envlookup env (var-string e))]</span><br></pre></td></tr></table></figure></p>
<p>对于加法运算，先对两个操作数（子表达式）进行求值，然后相加得到一个整数<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(add? e)</span><br><span class="line"> (<span class="name">let</span> ([v1 (<span class="name">eval-under-env</span> (<span class="name">add-e1</span> e) env)]</span><br><span class="line">       [v2 (<span class="name">eval-under-env</span> (<span class="name">add-e2</span> e) env)])</span><br><span class="line">   (<span class="name">if</span> (<span class="name">and</span> (<span class="name">int</span>? v1)</span><br><span class="line">            (<span class="name">int</span>? v2))</span><br><span class="line">       (<span class="name">int</span> (<span class="name">+</span> (<span class="name">int-num</span> v1)</span><br><span class="line">               (<span class="name">int-num</span> v2)))</span><br><span class="line">       (error "MUPL addition applied to non-number")))]</span><br></pre></td></tr></table></figure></p>
<p>采用词法作用域规则，把函数与其被定义的环境打包成一个<code>closure</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(fun? e) (closure env e)]</span><br></pre></td></tr></table></figure></p>
<p><code>ifgreater</code>的情况和<code>add</code>差不多，但注意<code>e3</code>和<code>e4</code>只能根据条件选一个计算一次<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(ifgreater? e)</span><br><span class="line"> (<span class="name">let</span> ([v1 (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e1</span> e) env)]</span><br><span class="line">       [v2 (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e2</span> e) env)])</span><br><span class="line">   (<span class="name">if</span> (<span class="name">and</span> (<span class="name">int</span>? v1) (<span class="name">int</span>? v2))</span><br><span class="line">       (<span class="name">if</span> (<span class="name">&gt;</span> (<span class="name">int-num</span> v1) (<span class="name">int-num</span> v2))</span><br><span class="line">           (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e3</span> e) env)</span><br><span class="line">           (<span class="name">eval-under-env</span> (<span class="name">ifgreater-e4</span> e) env))</span><br><span class="line">       (error "MUPL ifgreater applied to non-number")))]</span><br></pre></td></tr></table></figure></p>
<p><code>mlet</code>先将表达式<code>e</code>进行求值并与变量名<code>var</code>绑定，再把这个绑定添加到现在的环境，在这个环境中去<code>body</code>进行求值<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(mlet? e) (let ([v (eval-under-env (mlet-e e) env)])</span><br><span class="line">           (<span class="name">eval-under-env</span> (<span class="name">mlet-body</span> e)</span><br><span class="line">                           (cons (cons (mlet-var e) v) env)))]</span><br></pre></td></tr></table></figure></p>
<p>当遇到函数调用语句<code>call</code>时，按如下步骤进行求值</p>
<ol>
<li>对第一个域<code>funexp</code>在当前环境下进行求值，是否为一个<code>closure</code>，即这个域本来是不是一个<code>func</code>或<code>closure</code>或函数名，如果不是则直接报错跳出</li>
<li>如果对<code>funexp</code>求值产生的<code>closure</code>中，函数部分<code>fun</code>的函数名<code>optname</code>不是<code>#f</code>，则把函数名和在<code>closure</code>的<code>env</code>环境下对函数体的求值结果绑定，并把这个绑定添加到这个<code>closure</code>的<code>env</code>环境</li>
<li>对第二个域<code>actual</code>在当前环境下求值，把这个值与函数的参数名<code>formal</code>绑定，添加到上面的<code>closure</code>的<code>env</code>环境。</li>
<li>在这个被添加了函数名绑定和参数绑定的旧<code>env</code>下对函数体进行求值作为返回结果</li>
</ol>
<p><a name="call"></a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[(call? e) (let ([c (eval-under-env (call-funexp e) env)])</span><br><span class="line">             (<span class="name">if</span> (<span class="name">closure</span>? c)</span><br><span class="line">               (<span class="name">letrec</span> ([parameter (<span class="name">eval-under-env</span> (<span class="name">call-actual</span> e) env)]</span><br><span class="line">                 [f (<span class="name">closure-fun</span> c)]</span><br><span class="line">                 [fbody (<span class="name">fun-body</span> f)]</span><br><span class="line">                 [fname (<span class="name">fun-nameopt</span> f)]</span><br><span class="line">                 [old-env (<span class="name">cons</span> (<span class="name">cons</span> (<span class="name">fun-formal</span> f) parameter) (<span class="name">closure-env</span> c))]</span><br><span class="line">                 [new-env (<span class="name">if</span> fname (<span class="name">cons</span> (<span class="name">cons</span> fname c) old-env) old-env)])</span><br><span class="line">                 (<span class="name">eval-under-env</span> fbody new-env))</span><br><span class="line">               (error "MUPL call applied to non-closure")))]</span><br></pre></td></tr></table></figure>
<p>对<code>apair</code>中的两个表达式分别进行求值，再把结果重组成一个<code>apair</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(apair? e) (apair (eval-under-env (apair-e1 e) env)</span><br><span class="line">                   (eval-under-env (apair-e2 e) env))]</span><br></pre></td></tr></table></figure></p>
<p>至于<code>fst</code>和<code>snd</code>就更与上面的做法大同小异了，先对子表达式求值再取其中的一个域，按照语义随便写就行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[(fst? e) (let ([subexp (eval-under-env (fst-e e) env)])</span><br><span class="line">            (<span class="name">if</span> (<span class="name">apair</span>? subexp)</span><br><span class="line">                (<span class="name">apair-e1</span> subexp)</span><br><span class="line">                (error "not a pair")))]</span><br><span class="line">[(snd? e) (let ([subexp (eval-under-env (snd-e e) env)])</span><br><span class="line">            (<span class="name">if</span> (<span class="name">apair</span>? subexp)</span><br><span class="line">                (<span class="name">apair-e2</span> subexp)</span><br><span class="line">                (error "not a pair")))]</span><br></pre></td></tr></table></figure></p>
<p><code>isaunit</code>也是如此，先对表达式求值再判断是不是<code>aunit</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(isaunit? e) (let ([subexp (eval-under-env (isaunit-e e) env)])</span><br><span class="line">                (if (aunit? subexp) (int 1) (int 0)))]</span><br></pre></td></tr></table></figure></p>
<p>当然我们还可以为了使用方便再去“创造”一个<code>(ifaunit e1 e2 e3)</code>语句，也可以说是这个语言的idiom，也可以把它当成一个使用前预处理的“宏（<em>macro</em>）”，当我们用我们写的“解释器”即<code>eval-exp</code>函数去求这个语句的值时，如果e1是<code>aunit</code>则对<code>e2</code>求值作为结果，否则对<code>e3</code>求值<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">ifaunit</span> e1 e2 e3)</span><br><span class="line">  (<span class="name">ifgreater</span> (<span class="name">isaunit</span> e1) (<span class="name">int</span> <span class="number">0</span>) e2 e3))</span><br></pre></td></tr></table></figure></p>
<p>接下来用MUPL语言写一个<code>map</code>函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> mupl-map</span><br><span class="line">  (<span class="name">fun</span> #f <span class="string">"func"</span></span><br><span class="line">       (<span class="name">fun</span> <span class="string">"loop"</span> <span class="string">"mlst"</span></span><br><span class="line">            (<span class="name">ifaunit</span> (<span class="name">var</span> <span class="string">"mlst"</span>)</span><br><span class="line">                     (<span class="name">aunit</span>)</span><br><span class="line">                     (<span class="name">apair</span> (<span class="name">call</span> (<span class="name">var</span> <span class="string">"func"</span>) (<span class="name">fst</span> (<span class="name">var</span> <span class="string">"mlst"</span>)))</span><br><span class="line">                            (<span class="name">call</span> (<span class="name">var</span> <span class="string">"loop"</span>) (<span class="name">snd</span> (<span class="name">var</span> <span class="string">"mlst"</span>))))))))</span><br></pre></td></tr></table></figure></p>
<p>以及它的部分应用，对MUPL列表中所有整数元素进行自增操作的函数<code>mupl-mapAddOne</code><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> mupl-mapAddOne</span><br><span class="line">  (<span class="name">mlet</span> <span class="string">"map"</span> mupl-map</span><br><span class="line">      (<span class="name">call</span> (<span class="name">var</span> <span class="string">"map"</span>) (<span class="name">fun</span> #f <span class="string">"j"</span> (<span class="name">add</span> (<span class="name">int</span> <span class="number">1</span>) (<span class="name">var</span> <span class="string">"j"</span>))))))</span><br></pre></td></tr></table></figure></p>
<p>当我们用<code>eval-exp</code>对<code>mupl-mapAddOne</code>的如下调用实例求值时可以得到预期的结果<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">eval-exp</span> (<span class="name">call</span> mupl-mapAddOne</span><br><span class="line">          (<span class="name">apair</span> (<span class="name">int</span> <span class="number">3</span>) (<span class="name">apair</span> (<span class="name">int</span> <span class="number">4</span>) (<span class="name">apair</span> (<span class="name">int</span> <span class="number">9</span>) (<span class="name">aunit</span>))))))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; (apair (int 4) (apair (int 5) (apair (int 10) (aunit))))</span></span><br></pre></td></tr></table></figure></p>
<h3 id="更轻的环境"><a href="#更轻的环境" class="headerlink" title="更轻的环境"></a>更轻的环境</h3><div class="bs-callout bs-callout-info"><h4 id="Optional"><a href="#Optional" class="headerlink" title=" Optional"></a><i class="fa fa-info-circle"></i> Optional</h4><p>本部分直接使用<a href="https://www.coursera.org/learn/programming-languages/home/welcome" target="_blank" rel="noopener">Programming Languages</a>中给出的样例代码。</p>
</div>
<p>基于<a href="#自由变量-（Free-variable）">自由变量</a>部分所提的优化思路，把函数的结构<code>(struct fun (nameopt formal body))</code>重写为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> fun-challenge (<span class="name">nameopt</span> formal body freevars) #<span class="symbol">:transparent</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>freevars</code>域用于存储函数用到的自由变量名，是一个字符串类型的list</p>
<p>接下来需要定义一个函数<code>compute-free-vars</code>去找到原函数<code>fun</code>的所有自由变量，直接得到新函数<code>fun-challenge</code>的<code>freevars</code>域，在此之前可以先定义<code>compute-free-vars</code>用到的返回类型为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">struct</span> res (<span class="name">e</span> fvs))</span><br></pre></td></tr></table></figure></p>
<p><code>e</code>域为MUPL表达式，<code>fvs</code>域即freevars列表的一种形式，这里用的是<code>set</code>，避免同一个自由变量多次被算到里面。接下来和<code>eval</code>的思路相似，也是使用递归一层层去找函数中每个结构含有哪些自由变量<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">compute-free-vars</span> e)</span><br><span class="line">  (<span class="name">struct</span> res (<span class="name">e</span> fvs)) <span class="comment">; result type of f (could also use a pair)</span></span><br><span class="line">    (<span class="name">define</span> (<span class="name">f</span> e)</span><br><span class="line">      (<span class="name">cond</span> [(<span class="name">var</span>? e) (<span class="name">res</span> e (<span class="name">set</span> (<span class="name">var-string</span> e)))]</span><br><span class="line">            [...]))</span><br><span class="line">    (<span class="name">res-e</span> (<span class="name">f</span> e)))</span><br></pre></td></tr></table></figure>
<p>这里的<code>f</code>就是用于递归的辅助函数，<code>res</code>的<code>e</code>存储着表达式本身，当然在后文我们可以看到，除了<code>fun</code>的情况这个<code>e</code>域会成为一个新的携带着<code>freevars</code>结果的<code>fun-challenge</code>变量，其余情况输出<code>res-e</code>都与输入<code>e</code>一致。实际上真正涉及到自由变量集合的增删的操作只会在<code>var</code>，<code>fun</code>，<code>mlet</code>语句中出现，其他语句只是把子表达式中的自由变量集合进行合并。<code>var</code>的情况已经给出了，只需要构造一个仅包含其变量名的自由向量集合即可，接下来我们又要按着这样的想法去填充这些<code>[...]</code>了：</p>
<p>先看数值类型的数据结构<code>int</code>和<code>aunit</code>，它们不可能包含任何自由变量，直接返回空集<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(int? e) (res e (set))]</span><br><span class="line">[(aunit? e) (res e (set))]</span><br></pre></td></tr></table></figure></p>
<p><code>add</code>和<code>ifgreater</code>语句本身不创造自由变量，对其所有的操作数（子表达式）逐个寻找出现过的自由变量，然后返回它们的并集<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[(add? e) (let ([r1 (f (add-e1 e))]</span><br><span class="line">                [r2 (f (add-e2 e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">add</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                 (set-union (res-fvs r1) (res-fvs r2))))]</span><br><span class="line">[(ifgreater? e) (let ([r1 (f (ifgreater-e1 e))]</span><br><span class="line">                      [r2 (f (ifgreater-e2 e))]</span><br><span class="line">                      [r3 (f (ifgreater-e3 e))]</span><br><span class="line">                      [r4 (f (ifgreater-e4 e))])</span><br><span class="line">                  (<span class="name">res</span> (<span class="name">ifgreater</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2) (<span class="name">res-e</span> r3)  (<span class="name">res-e</span> r4))</span><br><span class="line">                       (set-union (res-fvs r1) (res-fvs r2) (res-fvs r3) (res-fvs r4))))]</span><br></pre></td></tr></table></figure></p>
<p>举一反三，接下来要处理的情况中，<code>fun</code>和<code>mlet</code>以外的语句都是与上面相似的情况，直接写就行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[(call? e) (let ([r1 (f (call-funexp e))]</span><br><span class="line">                 [r2 (f (call-actual e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">call</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                 (set-union (res-fvs r1) (res-fvs r2))))]</span><br><span class="line">[(apair? e) (let ([r1 (f (apair-e1 e))]</span><br><span class="line">                  [r2 (f (apair-e2 e))])</span><br><span class="line">              (<span class="name">res</span> (<span class="name">apair</span> (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                 (set-union (res-fvs r1) (res-fvs r2))))]</span><br><span class="line">[(fst? e) (let ([r (f (fst-e e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">fst</span> (<span class="name">res-e</span> r))</span><br><span class="line">                 (res-fvs r)))]</span><br><span class="line">[(snd? e) (let ([r (f (snd-e e))])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">snd</span> (<span class="name">res-e</span> r))</span><br><span class="line">                 (res-fvs r)))]</span><br><span class="line">[(isaunit? e) (let ([r (f (isaunit-e e))])</span><br><span class="line">                (<span class="name">res</span> (<span class="name">isaunit</span> (<span class="name">res-e</span> r))</span><br><span class="line">                     (res-fvs r)))]</span><br></pre></td></tr></table></figure></p>
<p>在考虑<code>fun</code>的情况时，需要注意的是函数的形参虽然在函数体中出现过，但它并不是一个自由变量，所以要从函数体的自由变量集合中去除这个变量；另外，当函数还具有函数名时，如果这个函数名又在函数体中出现了，也就是发生了递归，显然这个函数本身并不是自由变量，那么函数名也需要从自由变量列表<code>fvs</code>中去除。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[(fun? e) (let* ([r (f (fun-body e))]</span><br><span class="line">                 [fvs (set-remove (res-fvs r) (fun-formal e))]</span><br><span class="line">                 [fvs (if (fun-nameopt e)</span><br><span class="line">                          (<span class="name">set-remove</span> fvs (<span class="name">fun-nameopt</span> e))</span><br><span class="line">                          fvs)])</span><br><span class="line">            (<span class="name">res</span> (<span class="name">fun-challenge</span> (<span class="name">fun-nameopt</span> e) (<span class="name">fun-formal</span> e)</span><br><span class="line">                (<span class="name">res-e</span> r) fvs)</span><br></pre></td></tr></table></figure>
<p><code>mlet</code>的处理稍简单一些，只需把<code>var</code>这个局部变量名从<code>body</code>的自由变量列表中去除，再合并<code>e</code>的自由变量列表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[(mlet? e) (let* ([r1 (f (mlet-e e))]</span><br><span class="line">                  [r2 (f (mlet-body e))])</span><br><span class="line">             (<span class="name">res</span> (<span class="name">mlet</span> (<span class="name">mlet-var</span> e) (<span class="name">res-e</span> r1) (<span class="name">res-e</span> r2))</span><br><span class="line">                  (set-union (res-fvs r1) (set-remove (res-fvs r2) (mlet-var e)))))]</span><br></pre></td></tr></table></figure>
<p>完成<code>compute-free-vars</code>函数后，可以重写<code>eval-under-env</code>为<code>eval-under-env-c</code>，只需要添加<code>fun-challenge</code>的情况，其余部分与原函数一致</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">eval-under-env-c</span> e env)</span><br><span class="line">  (<span class="name">cond</span></span><br><span class="line">        [(<span class="name">fun-challenge</span>? e)</span><br><span class="line">         (<span class="name">closure</span> (<span class="name">set-map</span> (<span class="name">fun-challenge-freevars</span> e)</span><br><span class="line">                           (<span class="name">lambda</span> (<span class="name">s</span>) (<span class="name">cons</span> s (<span class="name">envlookup</span> env s))))</span><br><span class="line">                  e)]</span><br><span class="line">        <span class="comment">; call case uses fun-challenge as appropriate</span></span><br><span class="line">        <span class="comment">; all other cases the same</span></span><br><span class="line">        [...] ))</span><br></pre></td></tr></table></figure>
<p>对于fun-challenge的闭包封装指令为找到<code>freevars</code>中所有变量名在<code>env</code>的对应（绑定），这里的<code>set-map</code>是作用于<code>set</code>类型的高阶函数<code>map</code>。再把这些绑定关系构成的列表作为<code>closure</code>中的环境。最后改写这个解释函数的函数：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">eval-exp-c</span> e)</span><br><span class="line">  (<span class="name">eval-under-env-c</span> (<span class="name">compute-free-vars</span> e) null))</span><br></pre></td></tr></table></figure></p>
<p>在更轻的环境负担下发挥和原来的解释器一样的作用。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. <a href="https://mitpress.mit.edu/sicp/" target="_blank" rel="noopener"><em>Structure and interpretation of computer programs.</em></a> Justin Kelly, 1996.</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">样例代码来源于University of Washington在Coursera的公开课<a href="https://www.coursera.org/learn/programming-languages/home/welcome" target="_blank" rel="noopener">Programming Languages</a>讲义<a href="https://d3c33hcgiwev3.cloudfront.net/_34a95c9c790777fb7c103349682d7691_section3sum.pdf?Expires=1511049600&amp;Signature=FrFVyG0glBPM-Mh8uuAgdgOmHnaV7Aq7Hk5SEj3pejrdeFVZck71OtEzx3YzOSz~CUTOoze5Ffpp0Z6djKbLXQ-00Vi4Lxu5U3hrVxZ8Z4oBNxwpKQSn37FostE8px9bIrWS8QAFKOYSWIHYPosQBTm3TXJFurZTwZSriU08sNQ_&amp;Key-Pair-Id=APKAJLTNE6QMUY6HBC5A" target="_blank" rel="noopener">section3sum.pdf</a>和<a href="https://d3c33hcgiwev3.cloudfront.net/_36330b45ef211f77a0547a38665a954f_114_closures_efficient.pdf?Expires=1511481600&amp;Signature=bY5~armSTpcFkwLAk3CfjMctTIEo0y7jvc1HCeZAw53FdCYk8xHbnG6IxDyt3~JOjYnEU~cExRDtN7cBO05SAmUWLI1puj2XcS5pJqh4aJE00f0fUAs2~fi8cP5~Gt3q9Pbjoe~70OtLD4WScNJBHe3h8LKImvUCbW9FHZwr6gs_&amp;Key-Pair-Id=APKAJLTNE6QMUY6HBC5A" target="_blank" rel="noopener">slides</a>等</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">这里对应的源代码第六行是<code>(res-fvs (f e)))</code>，我认为这是一个typo，根据逻辑应该是<code>(res-e (f e)))</code>，我已经向该材料的制作者反映过这个问题，且也有其他人认为这里有问题，正在等候回复。</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/function-of-function/" data-id="cje48moz80017eww3r1bcqffj" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!-- 
        <a href="#disqus_thread" class="article-comment-link">
        <i class="fa fa-comment"></i> Comments
        </a>
       -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数式编程/">函数式编程</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/Deutsche101/Deutsche-101-1/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">失败人士的专属语言——德语</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-63/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">LeetCode Weekly Contest 63</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>


<!-- 
<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
 -->

  <div id="comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
    owner: 'Lixinyi-DUT',
    repo: 'TuQiang-Street-301',
    oauth: {
      client_id: '0a613b11d9140b2629e0',
      client_secret: 'b6ee57129a892f87bbac149167a90cf1a8035a47',
    },
  })
  gitment.render('comments')
  </script>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-toc">
    <h4>概览</h4>
    <ol class="sidebar-module-list"><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#头等函数-First-class-Function"><span class="sidebar-module-list-number">1.</span> <span class="sidebar-module-list-text">头等函数 (First-class Function)</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#高阶函数-Higher-order-Function"><span class="sidebar-module-list-number">2.</span> <span class="sidebar-module-list-text">高阶函数 (Higher-order Function)</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#Currying"><span class="sidebar-module-list-number">3.</span> <span class="sidebar-module-list-text">Currying</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#部分应用-Partial-Application"><span class="sidebar-module-list-number">4.</span> <span class="sidebar-module-list-text">*部分应用 (Partial Application)</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#词法作用域-Lexical-Scope"><span class="sidebar-module-list-number">5.</span> <span class="sidebar-module-list-text">词法作用域 (Lexical Scope)</span></a><ol class="sidebar-module-list-child"><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#环境（Environmnet）与闭包-（Closure）"><span class="sidebar-module-list-number">5.1.</span> <span class="sidebar-module-list-text">环境（Environmnet）与闭包 （Closure）</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#自由变量-（Free-variable）"><span class="sidebar-module-list-number">5.2.</span> <span class="sidebar-module-list-text">*自由变量 （Free variable）</span></a></li></ol></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#简易解释器"><span class="sidebar-module-list-number">6.</span> <span class="sidebar-module-list-text">*简易解释器</span></a><ol class="sidebar-module-list-child"><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#更轻的环境"><span class="sidebar-module-list-number">6.1.</span> <span class="sidebar-module-list-text">更轻的环境</span></a></li></ol></li></ol>
  </div>



  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>本站作者是失败人士，另一个博客已关闭详情见<a href="http://notebook.xyli.me/Introduction/broken-project-yangzhou/" style="text-decoration:none;">失败的扬州计划</a> 投稿或其他事项的交流可联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 20px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-73/">LeetCode Weekly Contest 73</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-72/">LeetCode Weekly Contest 72</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-71/">LeetCode Weekly Contest 71</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-70/">LeetCode Weekly Contest 70</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-69/">LeetCode Weekly Contest 69</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  var disqus_url = 'notebook.xyli.me/SICP/function-of-function/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
