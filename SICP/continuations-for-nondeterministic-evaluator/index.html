<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>用continuation实现非确定计算 | 笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="刚拿到Structure and Interpretation of Computer Programs 的时候我扫了一眼没看见全书有提到过call/cc，所以天真的以为continuation相关的内容不会出现，就暂时放心的把书扔在了一边等以后有空慢慢看，毕竟continuation真是让我头疼不已的内容。现在发现在">
<meta name="keywords" content="continuation">
<meta property="og:type" content="article">
<meta property="og:title" content="用continuation实现非确定计算">
<meta property="og:url" content="notebook.xyli.me/SICP/continuations-for-nondeterministic-evaluator/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="刚拿到Structure and Interpretation of Computer Programs 的时候我扫了一眼没看见全书有提到过call/cc，所以天真的以为continuation相关的内容不会出现，就暂时放心的把书扔在了一边等以后有空慢慢看，毕竟continuation真是让我头疼不已的内容。现在发现在4.3.3  Implementing the Amb Evaluator 实现">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-09T16:23:11.509Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="用continuation实现非确定计算">
<meta name="twitter:description" content="刚拿到Structure and Interpretation of Computer Programs 的时候我扫了一眼没看见全书有提到过call/cc，所以天真的以为continuation相关的内容不会出现，就暂时放心的把书扔在了一边等以后有空慢慢看，毕竟continuation真是让我头疼不已的内容。现在发现在4.3.3  Implementing the Amb Evaluator 实现">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-continuations-for-nondeterministic-evaluator" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      用continuation实现非确定计算
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/continuations-for-nondeterministic-evaluator/" class="article-date"><time datetime="2018-11-05T11:03:34.150Z" itemprop="datePublished">2018-11-05</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>刚拿到<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="noopener"><em>Structure and Interpretation of Computer Programs</em></a> 的时候我扫了一眼没看见全书有提到过<code>call/cc</code>，所以天真的以为continuation相关的内容不会出现，就暂时放心的把书扔在了一边等以后有空慢慢看，毕竟continuation真是让我头疼不已的内容。现在发现在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3.3" target="_blank" rel="noopener">4.3.3  Implementing the Amb Evaluator</a> 实现非确定求值器（nondeterministic evaluator）时，continuation作为参数过程，成功时可以推进进一步求值，失败时可以回滚到上一个选择分支。所以到这个时候了continuation还是绕不开的话题，没办法也只能硬着头皮强行理解了，再加上整个<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3" target="_blank" rel="noopener">4.3  Variations on a Scheme – Nondeterministic Computing</a> 的内容编排顺序也很容易让人（其实只有我）困惑，所以写这篇笔记按照自己的理解写一下如何实现Scheme的非确定求值系统。</p>
<a id="more"></a>
<p>有能力的人我建议还是先看原书，虽然个人感觉原书内容排的极其不友好，但硬啃下来还是没有问题的，只是文字材料太多很容易精力分散不知所云，而且代码内容距离比较远，不能通过实例体会到文字叙述的重点，所以如果看书最好先从代码密集的地方开始看实现，看不懂的地方再看上下文的文字解释，差不多感觉有点意思了再去看长篇的文字描述。另外，这小节的内容与<a href="http://notebook.xyli.me/SICP/represent-digital-circuits-simulator/">数字电路模拟</a>那篇相反，一开始太专注于描绘底层实现，会让人产生为什么底层要怎么写的疑问，实际上都是为了top-level的特性有意写成这些奇怪的形式的，先去了解Evaluating <code>amb</code> expressions和top-level的Driver loop部分会好很多。如果还是觉得看书很辛苦，可以试试来读我这篇消化后的笔记，或许可以有所帮助。</p>
<h2 id="amb表达式和非确定返回值"><a href="#amb表达式和非确定返回值" class="headerlink" title="amb表达式和非确定返回值"></a><code>amb</code>表达式和非确定返回值</h2><p>在确定计算（deterministic computing）中，当输入一定时，输出的结果也是确定的。在纯函数式语言（不允许变量的变值操作）中体现为用相同的参数调用同一个函数，一定会返回相同的结果。这个返回结果不一定是标量的（scalar）值，可以是一个tuple，可以是一个list，可以是规模很大的矩阵，甚至可以是长度无限的流……当然也可以是这些复杂数据结构之间的多层复合，但我们仍然视之为单个的确定值。与此相反，如果每次返回的结果即使是并不复杂的小规模的数据，但相同的调用返回不同的结果，就是非确定的计算。</p>
<p>一个不怎么函数式的例子就是随机数生成函数<code>rand</code>，每次使用<code>(rand)</code>都会返回一个不同的随机数。当然，众所周知，这只是伪随机数生成函数<code>rand-update</code>的包装<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，隐藏了用于生成下一个随机数的种子参数。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> random-init <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">rand-update</span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">remainder</span></span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">*</span></span> <span class="number">23</span> x) <span class="number">19</span>) <span class="number">101</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> rand (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">x</span> random-init))</span><br><span class="line">                (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                  (<span class="name"><span class="builtin-name">set!</span></span> x (<span class="name">rand-update</span> x))</span><br><span class="line">                  x)))</span><br></pre></td></tr></table></figure>
<p>这里实现非确定性的方法是通过每次计算后再更新<code>rand</code>的局部变量<code>x</code>的赋值，即通过调用函数的副作用（side effect）来改变每一次的返回结果。</p>
<p>非确定的计算可以用于得到满足一组约束的任一可行结果。当然在计算资源充足的前提下，计算出所有可行结果把它们复合成一个数据对象（如list）返回，显然是一种更充分的做法，但很多情况下我们未必需要得到所有可行的结果（比如伪随机数的生成），很可能每次只需要一个结果；而且可行结果可能有无数个，或许可以把它们作为流（stream）返回，每次取用只计算一个需要的结果，后面可以看到，在确定求值的解释器上实现非确定求值器确实也使用了类似延迟计算的思想，但表现为每次只返回一个干净的结果。</p>
<p><code>amb</code>是实现非确定求值需要用到的重要的特殊表达式，名字来源于ambiguously<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">amb</span> &lt;e1&gt; &lt;e2&gt; ... &lt;en&gt;)</span><br></pre></td></tr></table></figure></p>
<p>表示可以取任<code>&lt;e1&gt;</code>到<code>&lt;en&gt;</code>的任一表达式作为返回值。比如<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">list</span></span> (<span class="name">amb</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) (<span class="name">amb</span> <span class="symbol">'a</span> <span class="symbol">'b</span>))</span><br></pre></td></tr></table></figure></p>
<p>可以产生6种<strong>可能</strong>的返回结果<code>(1 a)    (1 b)    (2 a)    (2 b)    (3 a)    (3 b)</code>，每次调用返回的只能是6个结果之一。当<code>amb</code>只有一个参数时，只有一种确定的返回结果；当<code>amb</code>没有参数时，即调用<code>(amb)</code>时，我们的程序“走投无路”，不得不中止返回。因此我们可以把约束<code>p</code>写为这样的形式：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">require</span></span> p)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">not</span></span> p) (<span class="name">amb</span>)))</span><br></pre></td></tr></table></figure></p>
<p>在其他程序中就可以指令式的使用<code>(require p)</code>检查当前情况是否满足约束，如果不满足就直接跳回。从一个list中取任一元素的过程<code>an-element-of</code>可以写成这样<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">an-element-of</span> items)</span><br><span class="line">  (<span class="name"><span class="builtin-name">require</span></span> (<span class="name"><span class="builtin-name">not</span></span> (<span class="name"><span class="builtin-name">null?</span></span> items)))</span><br><span class="line">  (<span class="name">amb</span> (<span class="name"><span class="builtin-name">car</span></span> items) (<span class="name">an-element-of</span> (<span class="name"><span class="builtin-name">cdr</span></span> items))))</span><br></pre></td></tr></table></figure></p>
<p>初见这个写法的时候可能有人会和我一样困惑，如果<code>amb</code>是等概率随机选择那么<code>items</code>靠前的元素被选到的概率岂不是远大于后面的？按照应用序（applicative order）模型计算函数调用，会先计算函数的所有参数再把它们代入函数体求值，那么接下来会不断的计算最后一行的第二个参数，直至不满足<code>require</code>导致求值失败为止，但<code>amb</code>本身却一次也没被计算，这样不是没有达到预期效果吗？</p>
<p>首先解释第二个问题，<code>amb</code>表达式不是普通过程（ordinary procedure），不遵循一般函数的求值规则，它和<code>if</code>表达式，<code>cons</code>表达式等都是一种特殊形式（special form），不需要等所有参数都完成求值后才传入进行求值，这一点可以在后文解释器对<code>amb</code>语句的分析和求值中看到具体是如何实现的，现在只需要知道，它每次只计算<strong>被选中</strong>的参数的值。</p>
<p>回到第一个问题，等于触及本质的提问，<code>amb</code>到底是怎么做的？</p>
<p>我们可以把确定程序（实质就是某个函数的调用）想象成一个顺序执行的路径，哪怕存在<code>if</code>或<code>cond</code>的分支，因为某次调用的参数的固定的，所以接下来进行哪个分支也是确定的，而<code>amb</code>语句则被视为开始不同分支的选择结点，每个参数都会延伸出一条独立的路径。当遇到没有参数的<code>(amb)</code>或者其他错误时表示“此路不通”。<code>amb</code>执行的其实是我们熟悉的深度优先搜索（depth-first search, DFS），并当遇到失败时回溯（backtrack）到最近的选择结点选择另一条路径，直至找到第一个成功的结果返回。至于选择是依靠什么做出的，可以在后面的实现中看到，就是简单的按照参数的顺序依次去尝试，这也是BFS通常的做法，这样的做法确实会倾向于先返回参数顺序靠前的可行结果，需要下一个可行结果的时候也可以通过调用<code>try-again</code>得到，概率上的“公平”对于这个问题又有什么现实意义呢？</p>
<p>一个用于找和为质数的整数对的例子：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">(<span class="name">prime-sum-pair</span> '(<span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span>) '(<span class="number">20</span> <span class="number">35</span> <span class="number">110</span>))</span><br><span class="line"><span class="comment">;;; Starting a new problem</span></span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">3</span> <span class="number">20</span>)</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">try-again</span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">3</span> <span class="number">110</span>)</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">try-again</span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">8</span> <span class="number">35</span>)</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">try-again</span><br><span class="line"><span class="comment">;;; There are no more values of</span></span><br><span class="line">(<span class="name">prime-sum-pair</span> (<span class="name"><span class="builtin-name">quote</span></span> (<span class="name">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span>)) (<span class="name"><span class="builtin-name">quote</span></span> (<span class="name">20</span> <span class="number">35</span> <span class="number">110</span>)))</span><br><span class="line"><span class="comment">;;; Amb-Eval input:</span></span><br><span class="line">(<span class="name">prime-sum-pair</span> '(<span class="number">19</span> <span class="number">27</span> <span class="number">30</span>) '(<span class="number">11</span> <span class="number">36</span> <span class="number">58</span>))</span><br><span class="line"><span class="comment">;;; Starting a new problem</span></span><br><span class="line"><span class="comment">;;; Amb-Eval value:</span></span><br><span class="line">(<span class="name">30</span> <span class="number">11</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>非确定求值器是在<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1.7" target="_blank" rel="noopener">4.1.7  Separating Syntactic Analysis from Execution</a>实现的，预先完成语法分析再代入环境执行计算的求值器的基础上改造完成的，因为两种求值器的框架十分相似。</p>
<p>为了提高求值的效率，对表达式的求值可以被分为用<code>analyze</code>分析表达式，返回一个只有环境作为参数的过程。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">eval</span></span> exp env)</span><br><span class="line">  ((<span class="name">analyze</span> exp) env))</span><br></pre></td></tr></table></figure>
<p><code>analyze</code>是结构与<code>eval</code>相似的dispatch函数，对不同表达式分析出不同的结果，实现细节可以直接去看源码，这里仅观察对于lambda表达式的分析</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-lambda</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">vars</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>))</span><br><span class="line">        (<span class="name">bproc</span> (<span class="name">analyze-sequence</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env) (<span class="name">make-procedure</span> vars bproc env))))</span><br></pre></td></tr></table></figure>
<p>如果这个lambda表达式被绑定到了某个函数名，以函数名反复多次调用这个函数时，lambda表达式的函数体<code>bproc</code>只需要被分析一次，可以极大提高求值效率。</p>
<p>在非确定求值器中，也是这样先对表达式进行语法，再把环境<code>env</code>作为参数之一传入分析结果得到最终结果，不同的是增加了另外两个参数，也就是两个续延（continuation）过程，成功续延（success continuation）<code>succeed</code>表示如果对这个表达式求值成功，接下来应该做什么，失败续延（failure continuation）<code>fail</code>表示如果当对这个表达式的求值陷入死路或者其他失败情况（如再次调用<code>try-again</code>）时需要被调用的过程。总之，求值写为</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">ambeval</span> exp env succeed fail)</span><br><span class="line">  ((<span class="name">analyze</span> exp) env succeed fail))</span><br></pre></td></tr></table></figure>
<h3 id="续延的结构"><a href="#续延的结构" class="headerlink" title="续延的结构"></a>续延的结构</h3><p>上文提到的success continuation更接近于我们在<code>call/cc</code>接触到的current continuation，不过这话说的很没意义，这里实现的continuation无论哪种和实践中的<code>call/cc</code>使用起来差别都不小。</p>
<p>success continuation负责接收表达式的求值结果并开始进一步的计算（这一点可以在后文对简单表达式的分析中看到典型的例子），除了这个值，还需要另一个failure continuation过程作为参数，来处理接下来在success continuation中如果遇到求值失败的情况。</p>
<p>而failure continuation是一个没有参数的过程，当对当前分支的求值失败时会被调用，从当前对这个错误的分支跳出，从而开始对另一个分支的求值。</p>
<p>所以对一个表达式的语法分析结果是这样的一个lambda表达式：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">  <span class="comment">;; succeed is (lambda (value fail) ...)</span></span><br><span class="line">  <span class="comment">;; fail is (lambda () ...)</span></span><br><span class="line">  ...)</span><br></pre></td></tr></table></figure>
<p>当对某个表达式求值时，如果用如下的实参</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">ambeval</span> &lt;exp&gt;</span><br><span class="line">         the-global-environment</span><br><span class="line">         (<span class="name"><span class="builtin-name">lambda</span></span> (value fail) value)</span><br><span class="line">         (<span class="name"><span class="builtin-name">lambda</span></span> () <span class="symbol">'failed</span>))</span><br></pre></td></tr></table></figure>
<p>如果计算<code>&lt;exp&gt;</code>顺利得到了结果，将会执行success continuation，直接返回求值结果；如果求值失败，将执行failure continuation返回<code>&#39;failed</code>。</p>
<p>在这个非确定求值器的设计中，success continuation并不怎么需要费心去构造，在driver-loop中已经规定过对一个表达式最终求值成功只需要返回求值结果并开始下一轮输入，所以在大部分场景中<code>succeed</code>只是用来调用或者传递，少数需要重新构造的难点也不在逻辑本身。</p>
<p>比较麻烦的是failure continuation，首先要注意在每个新的success continuation的构造中都会使用一个新的failure continuation作为形参；其次是它的构造和调用场景的限制。</p>
<p>它的构造由只由以下操作完成：</p>
<ul>
<li><code>amb</code>表达式： 具体来说是在对<code>amb</code>表达式的分析和求值时，会构造新的failure continuation，这个failure continuation的内容是再去尝试当前<code>amb</code>中的其他选择。</li>
<li>top-level的<code>driver loop</code>：声明了如果对输入表达式的求值失败，即没有剩下的可行解，应该做什么，failure continuation的内容可以是打印提示信息然后再开始一个loop</li>
<li>赋值： 当选择了一个错误的分支，并进行了这个分支内对变量的变值操作时，如果想放弃对这个分支的继续计算，跳到其他分支，那么必须消除赋值等副作用。</li>
</ul>
<p>它的调用在以下情况发生：</p>
<ul>
<li>执行<code>(amb)</code>时：除了像<code>require</code>那样特意为了失败而失败以外，还有可能只是因为耗尽了<code>amb</code>表达式中所有的选择</li>
<li>用户在top-level输入了try-again迫使程序返回下一个可行结果，那么必须使用failure continuation跳到最近选择点的另一个分支。</li>
</ul>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>接下来从driver-loop和对<code>amb</code>表达式的分析开始，来看我们的分析器和求值器怎样处理各种语句。</p>
<h3 id="amb表达式"><a href="#amb表达式" class="headerlink" title="amb表达式"></a><code>amb</code>表达式</h3><p>首先来看对<code>amb</code>表达式的分析</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">amb?</span> exp) (<span class="name">tagged-list?</span> exp <span class="symbol">'amb</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">amb-choices</span> exp) (<span class="name"><span class="builtin-name">cdr</span></span> exp))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-amb</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">cprocs</span> (<span class="name"><span class="builtin-name">map</span></span> analyze (<span class="name">amb-choices</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try-next</span> choices)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> choices)</span><br><span class="line">            (<span class="name">fail</span>)</span><br><span class="line">            ((<span class="name"><span class="builtin-name">car</span></span> choices) env</span><br><span class="line">                           succeed</span><br><span class="line">                           (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                             (<span class="name">try-next</span> (<span class="name"><span class="builtin-name">cdr</span></span> choices))))))</span><br><span class="line">      (<span class="name">try-next</span> cprocs))))</span><br></pre></td></tr></table></figure>
<p>当没有选择（<code>(amb)</code>语句或者已经耗尽了所有选项）时，直接执行<code>fail</code>，否则执行当前第一个选择<code>(car choices)</code>，并把尝试剩下的选择<code>(try-next (cdr choices)</code>作为当前这项选择失败后需要进入的failure continuation。这就是非确定选择实现的核心部分，由分析<code>amb</code>语句构造出来的failure continuation会一直<strong>传递</strong>下去，直至当前选择遭遇失败时才会执行它跳到最近选择点的下一个选择。</p>
<p>简单总结一下，当还有可选项时，执行可选项并把尝试剩下的选项作为failure continuation，当没有可选项时直接调用这个语句本身的failure continuation即跳回上一个选择点。这种做法是符合DFS的逻辑的。</p>
<h3 id="Driver-loop"><a href="#Driver-loop" class="headerlink" title="Driver loop"></a>Driver loop</h3><p>driver-loop直接接受用户的输入并输出求值结果，维持着一个循环接受新的表达式或者<code>try-again</code>命令。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> input-prompt <span class="string">";;; Amb-Eval input:"</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> output-prompt <span class="string">";;; Amb-Eval value:"</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">driver-loop</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">internal-loop</span> try-again)</span><br><span class="line">    (<span class="name">prompt-for-input</span> input-prompt)</span><br><span class="line">    (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">input</span> (<span class="name"><span class="builtin-name">read</span></span>)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">eq?</span></span> input <span class="symbol">'try-again</span>)</span><br><span class="line">          (<span class="name">try-again</span>)</span><br><span class="line">          (<span class="name"><span class="builtin-name">begin</span></span></span><br><span class="line">            (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">            (<span class="name"><span class="builtin-name">display</span></span> <span class="string">";;; Starting a new problem "</span>)</span><br><span class="line">            (<span class="name">ambeval</span> input</span><br><span class="line">                     the-global-environment</span><br><span class="line">                     <span class="comment">;; ambeval success</span></span><br><span class="line">                     (<span class="name"><span class="builtin-name">lambda</span></span> (val next-alternative)</span><br><span class="line">                       (<span class="name">announce-output</span> output-prompt)</span><br><span class="line">                       (<span class="name">user-print</span> val)</span><br><span class="line">                       (<span class="name">internal-loop</span> next-alternative))</span><br><span class="line">                     <span class="comment">;; ambeval failure</span></span><br><span class="line">                     (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">                       (<span class="name">announce-output</span></span><br><span class="line">                        <span class="string">";;; There are no more values of"</span>)</span><br><span class="line">                       (<span class="name">user-print</span> input)</span><br><span class="line">                       (<span class="name">driver-loop</span>)))))))</span><br><span class="line">  (<span class="name">internal-loop</span></span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> ()</span><br><span class="line">     (<span class="name"><span class="builtin-name">newline</span></span>)</span><br><span class="line">     (<span class="name"><span class="builtin-name">display</span></span> <span class="string">";;; There is no current problem"</span>)</span><br><span class="line">     (<span class="name">driver-loop</span>))))</span><br></pre></td></tr></table></figure>
<p>这里的内部过程<code>internal-loop</code>会接受一个参数过程，作为收到<code>try-again</code>命令时需要执行的内容。在internal-loop初始化时，这个参数过程被设置成了提示”;;; There is no current problem”并再次发起循环；当计算新的表达式时，整个<code>ambeval</code>的success continuation被初始化为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (val next-alternative)</span><br><span class="line">  (<span class="name">announce-output</span> output-prompt)</span><br><span class="line">  (<span class="name">user-print</span> val)</span><br><span class="line">  (<span class="name">internal-loop</span> next-alternative))</span><br></pre></td></tr></table></figure></p>
<p>全局的计算得到结果以后，把值作为<code>val</code>参数传递给这个success continuation，继而打印显示给用户；而<code>next-alternative</code>参数对照上文一般的<a href="#续延的结构">success continuation结构</a>应该是另一个用于处理后续求值失败的failure continuation，到达调用这个全局success continuation时，除了已经计算出的表达式结果，还有从最近的选择点构造出的failure continuation（内容是尝试剩下的选择）一直传递下直到被当成<code>next-alternative</code>传入，那么当打印完求值结果后，还会把<code>next-alternative</code>作为参数再调用一次<code>internal-loop</code>，当用户输入<code>try-again</code>时便可以直接调用<code>next-alternative</code>过程，即由上次求值附带的failure continuation进入最近选择点的另一个分支开始寻找另一个可行的求值结果，另外，即使是调用的<code>next-alternative</code>的success continuation也还是这个全局的success continuation，只是再调用时参数发生了变化，所以返回另一个结果后又开始开始一轮循环，这是很微妙的设计。</p>
<p>以上全是我已经假设了最后的failure continuation是由最近的<code>amb</code>选择点构造的情况，现实情况会更复杂一些，比如一直没有遇到<code>amb</code>语句，那么就会使用最初传入的failure continuation，提示”;;; There are no more values of”并重置循环。</p>
<p>更多情况需要参见求值器对语言中其他常见表达式的处理。</p>
<h3 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h3><p>对简单表达式的求值在执行过程只需要把求值结果和failure continuation都传递给success continuation执行即可，相比普通的求值器，只需要增加continuation的维护。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-self-evaluating</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">    (<span class="name">succeed</span> exp fail)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-quoted</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">qval</span> (<span class="name">text-of-quotation</span> exp)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">succeed</span> qval fail))))</span><br></pre></td></tr></table></figure>
<p>self-evaluating对象（如数值常量）和quotation的求值结果与<code>env</code>无关，也不会发生求值失败，直接计算出交给<code>succeed</code>进行后续操作即可。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-variable</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">    (<span class="name">succeed</span> (<span class="name">lookup-variable-value</span> exp env)</span><br><span class="line">             fail)))</span><br></pre></td></tr></table></figure>
<p>变量绑定的值需要在<code>env</code>查找，如果无法找到也是因为用户的程序编写问题而不是因为非确定计算的问题，因此可以直接把结果和<code>fail</code>传入<code>succeed</code>继续求值。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-lambda</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">vars</span> (<span class="name">lambda-parameters</span> <span class="name"><span class="builtin-name">exp</span></span>))</span><br><span class="line">        (<span class="name">bproc</span> (<span class="name">analyze-sequence</span> (<span class="name">lambda-body</span> <span class="name"><span class="builtin-name">exp</span></span>))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">succeed</span> (<span class="name">make-procedure</span> vars bproc env)</span><br><span class="line">               fail))))</span><br></pre></td></tr></table></figure>
<p>对lambda表达式的求值结果也是一个封装了形参，函数体和定义环境的过程对象，直接传入<code>succeed</code>。</p>
<h3 id="条件和顺序语句"><a href="#条件和顺序语句" class="headerlink" title="条件和顺序语句"></a>条件和顺序语句</h3><p>现在开始接触到一些有执行顺序的语句，这时，仅当对表达式的某一部分求值成功后，才可以开始下一部分的求值。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-if</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">pproc</span> (<span class="name">analyze</span> (<span class="name">if-predicate</span> exp)))</span><br><span class="line">        (<span class="name">cproc</span> (<span class="name">analyze</span> (<span class="name">if-consequent</span> exp)))</span><br><span class="line">        (<span class="name">aproc</span> (<span class="name">analyze</span> (<span class="name">if-alternative</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">pproc</span> env</span><br><span class="line">             <span class="comment">;; success continuation for evaluating the predicate</span></span><br><span class="line">             <span class="comment">;; to obtain pred-value</span></span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (pred-value fail2)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">true?</span> pred-value)</span><br><span class="line">                   (<span class="name">cproc</span> env succeed fail2)</span><br><span class="line">                   (<span class="name">aproc</span> env succeed fail2)))</span><br><span class="line">             <span class="comment">;; failure continuation for evaluating the predicate</span></span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure>
<p>if条件语句需要先执行它的predicate部分的求值，如果求值成功才可以根据predicate的值决定执行接下来哪个语句。因此整个表达式的分析结果是这样的函数，执行predicate的分析结果<code>pproc</code>，即对predicate求值，构造了一个新的success continuation，它的意思是：如果predicate求值成功，接下来根据它的值选择执行<code>cproc</code>或<code>aproc</code>，求值成功后再进入原来的<code>succeed</code>。</p>
<p>顺序语句，即<code>cond</code>或lambda表达式内可能出现多个连续语句，或者<code>begin</code>表达式，执行其中的每个表达式，但只返回最后一个表达式的求值结果作为最终结果。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-sequence</span> exps)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sequentially</span> a b)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">a</span> env</span><br><span class="line">         <span class="comment">;; success continuation for calling a</span></span><br><span class="line">         (<span class="name"><span class="builtin-name">lambda</span></span> (a-value fail2)</span><br><span class="line">           (<span class="name">b</span> env succeed fail2))</span><br><span class="line">         <span class="comment">;; failure continuation for calling a</span></span><br><span class="line">         fail)))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">loop</span> first-proc rest-procs)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> rest-procs)</span><br><span class="line">        first-proc</span><br><span class="line">        (<span class="name">loop</span> (<span class="name">sequentially</span> first-proc (<span class="name"><span class="builtin-name">car</span></span> rest-procs))</span><br><span class="line">              (<span class="name"><span class="builtin-name">cdr</span></span> rest-procs))))</span><br><span class="line"></span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">procs</span> (<span class="name"><span class="builtin-name">map</span></span> analyze exps)))</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> procs)</span><br><span class="line">        (<span class="name">error</span> <span class="string">"Empty sequence -- ANALYZE"</span>))</span><br><span class="line">    (<span class="name">loop</span> (<span class="name"><span class="builtin-name">car</span></span> procs) (<span class="name"><span class="builtin-name">cdr</span></span> procs))))</span><br></pre></td></tr></table></figure></p>
<p>这里的内部过程<code>(sequentially a b)</code>很好的解释了顺序语句的执行，和if语句类似，先对分析结果<code>a</code>进行求值，构造新的success continuation表示如果成功继续对<code>b</code>求值。</p>
<h3 id="定义和赋值"><a href="#定义和赋值" class="headerlink" title="定义和赋值"></a>定义和赋值</h3><p>定义时需要先计算变量被定义的表达式，那就同样要考虑如果这个表达式求值不成功应该怎么办。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-definition</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">definition-variable</span> exp))</span><br><span class="line">        (<span class="name">vproc</span> (<span class="name">analyze</span> (<span class="name">definition-value</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">vproc</span> env                        </span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (val fail2)</span><br><span class="line">               (<span class="name">define-variable!</span> var val env)</span><br><span class="line">               (<span class="name">succeed</span> <span class="symbol">'ok</span> fail2))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure>
<p>这也是与上面的做法类似的过程，先对被表达式求值，构造新的success continuation调用它的分析结果，使成功的求值结果再进入success continuation完成绑定并把绑定操作的结果<code>&#39;ok</code>传入原来的<code>succeed</code>继续接下来的操作。</p>
<p>这里不用担心如果完成定义后陷入思路重新开始时是否需要撤回定义，为了方便，我们假设这些内部定义语句是转化成let表达式的scan out操作完成的（可以见前篇<a href="http://notebook.xyli.me/SICP/local-bindings-and-internal-definitions/">局部绑定和内部定义</a>）。</p>
<p>但赋值操作就必须考虑在失败后消除它的副作用。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-assignment</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">var</span> (<span class="name">assignment-variable</span> exp))</span><br><span class="line">        (<span class="name">vproc</span> (<span class="name">analyze</span> (<span class="name">assignment-value</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">vproc</span> env</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (val fail2)        <span class="comment">; *1*</span></span><br><span class="line">               (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">old-value</span></span><br><span class="line">                      (<span class="name">lookup-variable-value</span> var env)))</span><br><span class="line">                 (<span class="name">set-variable-value!</span> var val env)</span><br><span class="line">                 (<span class="name">succeed</span> <span class="symbol">'ok</span></span><br><span class="line">                          (<span class="name"><span class="builtin-name">lambda</span></span> ()    <span class="comment">; *2*</span></span><br><span class="line">                            (<span class="name">set-variable-value!</span> var</span><br><span class="line">                                                 old-value</span><br><span class="line">                                                 env)</span><br><span class="line">                            (<span class="name">fail2</span>)))))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure>
<p>首先还是像定义语句那样，对被绑定的表达式求值，如果求值成功，进入新的success continuation（即代码中<code>*1*</code>开始的位置），在这里先保存变量原来的值<code>old-value</code>，再对变量进行变值操作，赋值操作的结果<code>&#39;ok</code>传递给<code>succeed</code>进行后续计算，注意<code>succeed</code>的第二个实参也是重新构造的failure continuation（<code>*2*</code>开始的位置），在赋值操作完成之后的后续计算中，如果遇到了求值失败会调用这个failure continuation，在执行原计划的<code>(fail2)</code>之前会先把变量恢复成改变之前的值。</p>
<h3 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h3><p>函数调用更为复杂一点。首先需要考虑函数被调用时还需要对所有实参求值，对每个实参求值时都可能遭遇求值失败，导致中断，因此不能用原来的<code>map</code>直接算出实参列表，需要写一个新的<code>get-args</code>对实参的分析结果列表<code>aprocs</code>进行<strong>依次</strong>求值：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">get-args</span> aprocs env succeed fail)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> aprocs)</span><br><span class="line">      (<span class="name">succeed</span> '() fail)</span><br><span class="line">      ((<span class="name"><span class="builtin-name">car</span></span> aprocs) env</span><br><span class="line">                    <span class="comment">;; success continuation for this aproc</span></span><br><span class="line">                    (<span class="name"><span class="builtin-name">lambda</span></span> (arg fail2)</span><br><span class="line">                      (<span class="name">get-args</span> (<span class="name"><span class="builtin-name">cdr</span></span> aprocs)</span><br><span class="line">                                env</span><br><span class="line">                                <span class="comment">;; success continuation for recursive</span></span><br><span class="line">                                <span class="comment">;; call to get-args</span></span><br><span class="line">                                (<span class="name"><span class="builtin-name">lambda</span></span> (args fail3)</span><br><span class="line">                                  (<span class="name">succeed</span> (<span class="name"><span class="builtin-name">cons</span></span> arg args)</span><br><span class="line">                                           fail3))</span><br><span class="line">                                fail2))</span><br><span class="line">                    fail)))</span><br></pre></td></tr></table></figure>
<p>有些像顺序语句的求值，但不同的是需要返回列表中所有实参的求值结果。在对第一个参数的分析结果求值成功后，这个值<code>arg</code>会进入line 6开始的success continuation，对剩下的参数分析结果用<code>get-args</code>递归求值得到参数列表<code>args</code>，完成后进入下一个从line 11开始的success continuation，再把它们<code>cons</code>起来返回给最终的<code>succeed</code>。除了维护continuation有些麻烦，把<code>aprocs</code>一层层<code>cdr</code>下来求值再通过构造新的<code>succeed</code>把结果一层层<code>cons</code>起来，这种做法和<code>map</code>的递归逻辑别无二致。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">analyze-application</span> exp)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">fproc</span> (<span class="name">analyze</span> (<span class="name">operator</span> exp)))</span><br><span class="line">        (<span class="name">aprocs</span> (<span class="name"><span class="builtin-name">map</span></span> analyze (<span class="name">operands</span> exp))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (env succeed fail)</span><br><span class="line">      (<span class="name">fproc</span> env</span><br><span class="line">             (<span class="name"><span class="builtin-name">lambda</span></span> (proc fail2)</span><br><span class="line">               (<span class="name">get-args</span> aprocs</span><br><span class="line">                         env</span><br><span class="line">                         (<span class="name"><span class="builtin-name">lambda</span></span> (args fail3)</span><br><span class="line">                           (<span class="name">execute-application</span></span><br><span class="line">                            proc args succeed fail3))</span><br><span class="line">                         fail2))</span><br><span class="line">             fail))))</span><br></pre></td></tr></table></figure>
<p>对调用语句分析也是需要小心的按照顺序来，先对函数名（操作符）的分析结果<code>fproc</code>执行求值，成功后再开始用<code>get-args</code>对实参列表求值，最后用<code>execute-application</code>去计算调用结果。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">execute-application</span> proc args succeed fail)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">primitive-procedure?</span> proc)</span><br><span class="line">         (<span class="name">succeed</span> (<span class="name">apply-primitive-procedure</span> proc args)</span><br><span class="line">                  fail))</span><br><span class="line">        ((<span class="name">compound-procedure?</span> proc)</span><br><span class="line">         ((<span class="name">procedure-body</span> proc)</span><br><span class="line">          (<span class="name">extend-environment</span> (<span class="name">procedure-parameters</span> proc)</span><br><span class="line">                              args</span><br><span class="line">                              (<span class="name">procedure-environment</span> proc))</span><br><span class="line">          succeed</span><br><span class="line">          fail))</span><br><span class="line">        (<span class="name"><span class="builtin-name">else</span></span></span><br><span class="line">         (<span class="name">error</span></span><br><span class="line">          <span class="string">"Unknown procedure type -- EXECUTE-APPLICATION"</span></span><br><span class="line">          proc))))</span><br></pre></td></tr></table></figure>
<p><code>execute-application</code>的定义和在普通求值器中除了管理continuation以外没有什么大的区别，调用是一步操作，因此没有前文那样反复构造新的success continuation的需求。对于primitive来说，不存在调用过程本身引起的求值失败，直接把调用结果作为参数传递给<code>succeed</code>就可以了；对于用户自己编写的复合过程，在当前两个continuation和添加实参绑定的定义环境下对函数体的分析结果进行调用计算，求值完成后，无论成功或失败，对于的continuation会作为实参被传入函数体的分析结果，用以执行下一步操作。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">使用种子$x$生成伪随机的一种常见做法是： 挑选合适的大整数$a$,$b$,$N$，返回$ax+b \bmod N$，我所给出的实现里面三个整数的挑选实际上都并不是很合适，仅为了演示，这里不再详细讨论怎样去生成统计性质良好的随机序列。</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/continuations-for-nondeterministic-evaluator/" data-id="cjty80j4g0047qww3o4r65s8x" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!-- 
        <a href="#disqus_thread" class="article-comment-link">
        <i class="fa fa-comment"></i> Comments
        </a>
       -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/continuation/">continuation</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-109/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">LeetCode Weekly Contest 109</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-110/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">LeetCode Weekly Contest 110</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>


<!-- 
<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
 -->

  <div id="comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
    owner: 'Lixinyi-DUT',
    repo: 'TuQiang-Street-301',
    oauth: {
      client_id: '0a613b11d9140b2629e0',
      client_secret: 'b6ee57129a892f87bbac149167a90cf1a8035a47',
      id: 'Mon Nov 05 2018 19:03:34 GMT+0800',
    },
  })
  gitment.render('comments')
  </script>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-toc">
    <h4>概览</h4>
    <ol class="sidebar-module-list"><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#amb表达式和非确定返回值"><span class="sidebar-module-list-number">1.</span> <span class="sidebar-module-list-text">amb表达式和非确定返回值</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#语法分析"><span class="sidebar-module-list-number">2.</span> <span class="sidebar-module-list-text">语法分析</span></a><ol class="sidebar-module-list-child"><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#续延的结构"><span class="sidebar-module-list-number">2.1.</span> <span class="sidebar-module-list-text">续延的结构</span></a></li></ol></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#实现细节"><span class="sidebar-module-list-number">3.</span> <span class="sidebar-module-list-text">实现细节</span></a><ol class="sidebar-module-list-child"><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#amb表达式"><span class="sidebar-module-list-number">3.1.</span> <span class="sidebar-module-list-text">amb表达式</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#Driver-loop"><span class="sidebar-module-list-number">3.2.</span> <span class="sidebar-module-list-text">Driver loop</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#简单表达式"><span class="sidebar-module-list-number">3.3.</span> <span class="sidebar-module-list-text">简单表达式</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#条件和顺序语句"><span class="sidebar-module-list-number">3.4.</span> <span class="sidebar-module-list-text">条件和顺序语句</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#定义和赋值"><span class="sidebar-module-list-number">3.5.</span> <span class="sidebar-module-list-text">定义和赋值</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#过程调用"><span class="sidebar-module-list-number">3.6.</span> <span class="sidebar-module-list-text">过程调用</span></a></li></ol></li></ol>
  </div>



  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>失败作者的另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p><p>谢谢各位长久以来的关怀。</p><p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">70</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">11</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/TAPL/">TAPL</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/lambda-calculus/">lambda calculus</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/编译器/">编译器</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/编译器/" style="font-size: 10px;">编译器</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/04/">四月 2019</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/03/">三月 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/02/">二月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/01/">一月 2019</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-129/">LeetCode Weekly Contest 129</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-128/">LeetCode Weekly Contest 128</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-127/">LeetCode Weekly Contest 127</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-126/">LeetCode Weekly Contest 126</a>
        </li>
      
        <li>
          <a href="/lambda-calculus/learn-lambda-calculus-in-y-minutes/">Y分钟入门lambda演算</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  var disqus_url = 'notebook.xyli.me/SICP/continuations-for-nondeterministic-evaluator/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
