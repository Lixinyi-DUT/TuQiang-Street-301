<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>垃圾回收 | 笔记仓库</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在前面的寄存机器模型的基础上，Storage Allocation and Garbage Collection简单描述了数据在存储中的分配表示，以及不断分配空间给新数据必然带来的问题：存储耗尽，因此需要一个垃圾收集机制维护整个存储系统正常运转。这部分内容不是很多也不难理解，但文字内容比较密集叙述有点乏味，因此我另外简">
<meta name="keywords" content="内存分配,垃圾回收">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收">
<meta property="og:url" content="notebook.xyli.me/SICP/garbage-collection/index.html">
<meta property="og:site_name" content="笔记仓库">
<meta property="og:description" content="在前面的寄存机器模型的基础上，Storage Allocation and Garbage Collection简单描述了数据在存储中的分配表示，以及不断分配空间给新数据必然带来的问题：存储耗尽，因此需要一个垃圾收集机制维护整个存储系统正常运转。这部分内容不是很多也不难理解，但文字内容比较密集叙述有点乏味，因此我另外简单写一篇重点看算法的代码实现。此外，可能因为原文一直都是在假设已经知道内存中哪些">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/vector.png?inline=false">
<meta property="og:image" content="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/before-gc.png?inline=false">
<meta property="og:image" content="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/after-gc.png?inline=false">
<meta property="og:updated_time" content="2018-12-15T16:47:52.716Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="垃圾回收">
<meta name="twitter:description" content="在前面的寄存机器模型的基础上，Storage Allocation and Garbage Collection简单描述了数据在存储中的分配表示，以及不断分配空间给新数据必然带来的问题：存储耗尽，因此需要一个垃圾收集机制维护整个存储系统正常运转。这部分内容不是很多也不难理解，但文字内容比较密集叙述有点乏味，因此我另外简单写一篇重点看算法的代码实现。此外，可能因为原文一直都是在假设已经知道内存中哪些">
<meta name="twitter:image" content="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/vector.png?inline=false">
<meta name="twitter:creator" content="@yangzhou301">
  
    <link rel="alternate" href="/atom.xml" title="笔记仓库" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83527033-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2215e0ea4875ead3c44e8c3e379722a4";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">笔记仓库</h1>
  
    <p class="lead blog-description">正常人的正常笔记集</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-garbage-collection" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      垃圾回收
    </h1>
  


    <meta name="ujianVerification" content="542ffd85bb968154b1190d5d92d59cef" />
  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/SICP/garbage-collection/" class="article-date"><time datetime="2018-12-13T09:20:53.752Z" itemprop="datePublished">2018-12-13</time></a>
</div>

    <div class="article-author">Xinyi Li</div>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/SICP/">SICP</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在前面的<a href="http://notebook.xyli.me/SICP/the-structure-and-interpretation-of-register-machine/">寄存机器模型</a>的基础上，<a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-33.html#%_sec_5.3" target="_blank" rel="noopener">Storage Allocation and Garbage Collection</a>简单描述了数据在存储中的分配表示，以及不断分配空间给新数据必然带来的问题：存储耗尽，因此需要一个垃圾收集机制维护整个存储系统正常运转。这部分内容不是很多也不难理解，但文字内容比较密集叙述有点乏味，因此我另外简单写一篇重点看算法的代码实现。此外，可能因为原文一直都是在假设已经知道内存中哪些部分放的数据是需要被清理的垃圾，而哪些是还需要继续使用的数据，所以只需要在空间耗尽前通过一定的算法清理掉垃圾释放空间，但并没有解释怎样去区分垃圾和有用的数据，所以看着会有些困惑。这里同样不再讨论这个问题，有兴趣的自己找相关文本材料阅读。</p>
<a id="more"></a>
<h2 id="序对和其他数据的向量表示"><a href="#序对和其他数据的向量表示" class="headerlink" title="序对和其他数据的向量表示"></a>序对和其他数据的向量表示</h2><p>传统的计算机内存可以被想象成一些排列规划好的格子，用于存放数据，而每个格子都有一个唯一的名字或者说序号，可以通过它来访问和更改格子里的内容。而这个唯一的标识符就是它的地址/位置，地址也可以被当作普通的数据来对待，进行一些算术运算得到新的地址，再通过新的地址去访问其他数据，这也令诸如pair，list这样的树状数据结构可以在线性的内存中很好的被表达。</p>
<p>对这种存储结构的建模可以用向量来模拟，和C++ STL的<code>vector</code>相似，把它当成一种像数组一样可以直接用索引访问的容器，通过下面两个基本操作对向量中的元素进行访问和修改：</p>
<ul>
<li><code>(vector-ref &lt;vector&gt; &lt;n&gt;)</code>: 读取向量<code>&lt;vector&gt;</code>的第<code>n</code>个元素并返回</li>
<li><code>(vector-set! &lt;vector&gt; &lt;n&gt; &lt;value&gt;)</code>: 把向量<code>&lt;vector&gt;</code>的第<code>n</code>个元素的值设置为<code>&lt;value&gt;</code></li>
</ul>
<p>而这些操作的效率都是与<code>n</code>本身大小无关的，可以认为是$o(1)$，通过对<code>n</code>参数的算术运算可以连续取值。索引计数默认从0开始。</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>我们用两个向量来存储所有的序对（pair）结构，<code>the-cars</code>向量表示用来存放所有序对的<code>car</code>部分，<code>the-cdrs</code>用来存放所有序对的<code>cdr</code>部分。指向一个序对的指针表示可以暂时想象成某个索引值<code>n</code>，<code>the-cars</code>的第<code>n</code>个元素是这个序对的<code>car</code>部分，<code>the-cdrs</code>的第<code>n</code>个元素是这个序对的<code>cdr</code>部分。</p>
<p>放在向量中的元素实际上都可以被看成指针，有些是指向其他序对（即索引值），有些则指向数值或symbol等常量。指针的内涵可以被扩展为类型指针（typed pointer），除了它指向什么的数据地址外，还需要在标识出它指向的东西的类型，一般实现这种结构的方法是在把指针的固定长度的前几位作为类型域（type field），在此不再多作讨论。</p>
<p>当指针指向不同类型的数据时，假设它的第一个部分用来标识数据的类型，如整数4被标识为<code>n4</code>，指向<code>nil</code>被标识为<code>e0</code>，指向另一个序对时，标识类型为<code>p</code>而后面的表示符表示那个序对在向量中对应的索引。</p>
<p>列表<code>((1 2) 3 4)</code>可以表示为</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/vector.png?inline=false" alt="每个序对左下角的数字表示在向量中的索引"></p>
<p>在寄存机器语言中，可以用两个同名寄存器<code>the-cars</code>和<code>the-cdrs</code>来表示这两个向量，利用前面提到的向量操作<code>vector-ref</code>和<code>vector-set!</code>把序对相关操作转换成对于寄存器的操作。</p>
<p>比如<code>car</code>和<code>cdr</code><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> car) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> cdr) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p>可以写为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p><code>reg2</code>即该序对在向量中对应的索引值</p>
<p>更改操作<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">perform</span> (<span class="name">op</span> set-car!) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">perform</span> (<span class="name">op</span> set-cdr!) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p>可以写为<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> &lt;reg1&gt;) (<span class="name">reg</span> &lt;reg2&gt;))</span><br></pre></td></tr></table></figure></p>
<p><code>free</code>是一个特殊的寄存器，指向下一个可用索引。使用<code>cons</code>来构造一个新的序对<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">op</span> cons) (<span class="name">reg</span> &lt;reg2&gt;) (<span class="name">reg</span> &lt;reg3&gt;))</span><br></pre></td></tr></table></figure></p>
<p>可以用这样的实现：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> free) (<span class="name">reg</span> &lt;reg2&gt;))</span><br><span class="line">(<span class="name">perform</span></span><br><span class="line"> (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> free) (<span class="name">reg</span> &lt;reg3&gt;))</span><br><span class="line">(<span class="name">assign</span> &lt;reg1&gt; (<span class="name">reg</span> free))</span><br><span class="line">(<span class="name">assign</span> free (<span class="name">op</span> +) (<span class="name">reg</span> free) (<span class="name">const</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈*"></a>栈*</h3><p>用上述写法展开一些栈操作，比如对<code>the-stack</code>的压栈<code>(save &lt;reg&gt;)</code>操作可以实现为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> the-stack (<span class="name">op</span> cons) (<span class="name">reg</span> &lt;reg&gt;) (<span class="name">reg</span> the-stack))</span><br></pre></td></tr></table></figure>
<p>同样弹栈操作<code>(restore &lt;reg&gt;)</code>实现为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> &lt;reg&gt; (<span class="name">op</span> car) (<span class="name">reg</span> the-stack))</span><br><span class="line">(<span class="name">assign</span> the-stack (<span class="name">op</span> cdr) (<span class="name">reg</span> the-stack))</span><br></pre></td></tr></table></figure>
<p>初始化命令<code>(perform (op initialize-stack))</code>实现为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">assign</span> the-stack (<span class="name">const</span> ()))</span><br></pre></td></tr></table></figure>
<p>这些内容也没什么可细说的，之前把栈作为list来实现，现在了解了list如何实现后再从底层重新写一遍而已。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>程序运行中会产生一些临时数据，使用过一次或几次后不需要再被使用。如果在内存中始终为它们保留这些空间，可能会导致内存耗尽，因为我们暂时做不到物理上的无限大小的内存。因此需要一个合适的垃圾收集（garbage collection）来回收处理这些<strong>对未来的计算不会产生任何影响</strong>（即不会有后续的<code>car</code> <code>cdr</code>等针对它的读写操作），给其他有用的数据让出更多的空间。</p>
<p>一种经典的，被用于Scheme的高速垃圾收集方法名为stop-and-copy算法，也就是通常所说的Minsky-Fenichel-Yochelson算法，接下来主要描述这种算法。另一种常见的方法mark-sweep方法可以见<a href="https://www.bilibili.com/video/av8515129/?p=20" target="_blank" rel="noopener">MIT6.001</a>相关课程材料中给出的实现和讨论，或直接阅读Allen原文<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的完整讨论。</p>
<h3 id="Stop-and-copy"><a href="#Stop-and-copy" class="headerlink" title="Stop-and-copy"></a>Stop-and-copy</h3><p>基本思想是先把内存划分成两半：一半被称为工作内存（working memory），另一半为空闲内存（free memory）。</p>
<p>我们首先从当前的工作内存中分配空间来构造新的序对，这个过程中通过<code>free</code>指针的自增操作不断指引下一个可用的空间位置。当工作内存满了的时候，会混杂着垃圾和有用的数据。</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/before-gc.png?inline=false" alt=""></p>
<p>这时都该进行垃圾收集了。</p>
<p>垃圾收集过程中我们定位所有在工作内存中有用的数据，并把它们复制到空闲内存中的连续空间中。这里寻找有用的数据（序对）是通过追踪机器寄存器中的所有<code>car</code>和<code>cdr</code>指针，能通过它们访问到的数据就是有用的。因为我们没有复制垃圾，所以空闲内存被使用的空间是小于原工作内存的，那么空闲区域可以继续分配空间给新的序对。而工作内存现在的数据都已经没有继续保留的价值了，反正有用的数据也已经被复制了。所以，现在可以直接交换这两部分内存的角色，让原来的空闲内存从此成为当前的工作内存，而原来的工作内存也成了现在的空闲内存。至此，本次垃圾收集完成。</p>
<p><img src="https://gitlab.com/xyli/SICP-learning-notes/raw/master/notes/register-machine/after-gc.png?inline=false" alt=""></p>
<p>当工作内存再次用完时，再进行如上操作并交替。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>接下来试图用寄存机器语言指令实现一个垃圾收集器（garbage collector），首先假设存在一个<code>root</code>寄存器，相当于其他树形数据结构的根结点的角色，通过它开始的遍历可以访问到所有机器中可访问的数据，维护<code>root</code>可以通过在垃圾收集前，把所有机器中的寄存器的内容存放到<code>root</code>指向的list。</p>
<p>当调用<code>cons</code>时发现<code>free</code>指针指向一个超出当前工作内存的位置，就说明内存已经耗尽，可以开始进行垃圾收集了。收集的过程中除了原来的<code>free</code>，还需要一个<code>scan</code>作为指针记录在工作空间中扫描到的位置。算法中，<code>root</code>用于指示新内存的起点，序对被复制过来后，<code>root</code>也会调整到新的位置，<code>free</code>也会相应增加。</p>
<p>旧位置的序对被复制完成后，内容会被更改为相应的标记来指示这个位置的内容已经转移了。这种标记表示为：在<code>car</code>位置放置一个特殊的标签（传统上我们叫它broken heart标签），在<code>cdr</code>位置放置指向这个数据被复制到新内存的位置的转发地址（forwarding address），可以直接通过这个地址达到它在新内存的位置进行取值访问。</p>
<p>首先来看最后交换工作内存和空闲内存的<code>gc-flip</code>部分，<code>new-cars</code>和<code>new-cdrs</code>是垃圾收集完成前的空闲内存，<code>the-cars</code>和<code>the-cdrs</code>是垃圾收集完成前的工作内存。简单的进行交换内容即可：</p>
<p><a name="gc-flip"></a><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gc-flip</span><br><span class="line">  (<span class="name">assign</span> temp (<span class="name">reg</span> the-cdrs))</span><br><span class="line">  (<span class="name">assign</span> the-cdrs (<span class="name">reg</span> new-cdrs))</span><br><span class="line">  (<span class="name">assign</span> new-cdrs (<span class="name">reg</span> temp))</span><br><span class="line">  (<span class="name">assign</span> temp (<span class="name">reg</span> the-cars))</span><br><span class="line">  (<span class="name">assign</span> the-cars (<span class="name">reg</span> new-cars))</span><br><span class="line">  (<span class="name">assign</span> new-cars (<span class="name">reg</span> temp))</span><br></pre></td></tr></table></figure></p>
<p>核心操作<code>relocate-old-result-in-new</code>可以看成一个函数，以工作内存中被扫描到的内容<code>old</code>作为参数，返回它在空闲内存中被复制到的内容<code>new</code></p>
<p>如果<code>old</code>不是指向序对结构的指针，也就是说它指向数值符号等常量，这里假设常量被存储在另外一片不可更改只能被引用的空间，那么不需要另外开辟空间来存储它，<code>new</code>只需要沿用<code>old</code>的值。</p>
<p>如果<code>old</code>指向了一个已经被复制转移到新内存的序对（通过检查<code>old</code>指向的序对的<code>car</code>是否有broken heart标签），那么只需要从<code>cdr</code>读取原序对的新位置，就可以作为<code>new</code>的内容。</p>
<p>如果<code>old</code>指向的序对还没有被转移，那就需要我们来对它完成复制转移。先把它们复制到新内存的第一个可用位置(<code>free</code>指向的内容)记为<code>new</code>，增加<code>free</code>使之指向下一个可用位置，再在原来的<code>car</code>部分打上broken heart标签，并在原来的<code>cdr</code>位置设置<code>new</code>为转发地址。</p>
<p><a name="relocate-old-result-in-new"></a><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">relocate-old-result-in-new</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> pointer-to-pair?) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> pair))</span><br><span class="line">  (<span class="name">assign</span> new (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> relocate-continue))</span><br><span class="line"></span><br><span class="line">pair</span><br><span class="line">  (<span class="name">assign</span> oldcr (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cars) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> broken-heart?) (<span class="name">reg</span> oldcr))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> already-moved))</span><br><span class="line">  (<span class="name">assign</span> new (<span class="name">reg</span> free)) <span class="comment">; new location for pair</span></span><br><span class="line">  <span class="comment">;; Update free pointer.</span></span><br><span class="line">  (<span class="name">assign</span> free (<span class="name">op</span> +) (<span class="name">reg</span> free) (<span class="name">const</span> <span class="number">1</span>))</span><br><span class="line">  <span class="comment">;; Copy the car and cdr to new memory.</span></span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> vector-set!)</span><br><span class="line">           (<span class="name">reg</span> new-cars) (<span class="name">reg</span> new) (<span class="name">reg</span> oldcr))</span><br><span class="line">  (<span class="name">assign</span> oldcr (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> vector-set!)</span><br><span class="line">           (<span class="name">reg</span> new-cdrs) (<span class="name">reg</span> new) (<span class="name">reg</span> oldcr))</span><br><span class="line">  <span class="comment">;; Construct the broken heart.</span></span><br><span class="line">  (<span class="name">perform</span> (<span class="name">op</span> vector-set!)</span><br><span class="line">           (<span class="name">reg</span> the-cars) (<span class="name">reg</span> old) (<span class="name">const</span> broken-heart))</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> vector-set!) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> old) (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> relocate-continue))</span><br><span class="line"></span><br><span class="line">already-moved</span><br><span class="line">  (<span class="name">assign</span> new (<span class="name">op</span> vector-ref) (<span class="name">reg</span> the-cdrs) (<span class="name">reg</span> old))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">reg</span> relocate-continue))</span><br></pre></td></tr></table></figure></p>
<p>中间寄存器<code>oldcr</code>用于分别在不同时间存放<code>old</code>指向的序对的<code>car</code>内容和<code>cdr</code>内容。</p>
<p>整个垃圾收集的过程开始时，先初始化<code>free</code>和<code>scan</code>，并找到旧内存的<code>root</code>迁移到新内存后的位置作为新的<code>root</code><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">begin-garbage-collection</span><br><span class="line">  (<span class="name">assign</span> free (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">  (<span class="name">assign</span> scan (<span class="name">const</span> <span class="number">0</span>))</span><br><span class="line">  (<span class="name">assign</span> old (<span class="name">reg</span> root))</span><br><span class="line">  (<span class="name">assign</span> relocate-continue (<span class="name">label</span> reassign-root))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> relocate-old-result-in-new))</span><br><span class="line">reassign-root</span><br><span class="line">  (<span class="name">assign</span> root (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> gc-loop))</span><br></pre></td></tr></table></figure></p>
<p>然后开启<code>gc-loop</code>的循环。</p>
<p>在这个主循环中，如果<code>free</code>和<code>scan</code>指针相遇，则说明已经扫描完了新内存中所有数据，没有还需要复制转移的，那么直接跳转到最后的<a href="#gc-flip"><code>gc-flip</code></a>即可。</p>
<p>而如果还有没扫描完的数据，说明有些指针的内容在第一次被遇到后就复制到了，这些内容包含指向旧内存的指针，因此需要通过<a href="#relocate-old-result-in-new"><code>relocate-old-result-in-new</code></a>把这些被指向的旧内存内容复制转移到新内存，或者对于已经转移过来的，直接指向新内存。对每个<code>scan</code>指向的<code>new-cars</code>和<code>new-cdrs</code>两个部分都需要进行一次这样重新定位内容的操作。</p>
<p>所以主循环是这样的：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gc-loop</span><br><span class="line">  (<span class="name">test</span> (<span class="name">op</span> =) (<span class="name">reg</span> scan) (<span class="name">reg</span> free))</span><br><span class="line">  (<span class="name">branch</span> (<span class="name">label</span> gc-flip))</span><br><span class="line">  (<span class="name">assign</span> old (<span class="name">op</span> vector-ref) (<span class="name">reg</span> new-cars) (<span class="name">reg</span> scan))</span><br><span class="line">  (<span class="name">assign</span> relocate-continue (<span class="name">label</span> update-car))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> relocate-old-result-in-new))</span><br></pre></td></tr></table></figure>
<p>先对<code>scan</code>扫描到的<code>car</code>部分进行重定位，并修改<code>car</code>部分内容。再对<code>scan</code>指向的<code>cdr</code>部分重新定位并修改内容，完成后对<code>scan</code>进行自增操作扫描下一个位置重复入手操作，直至<code>scan</code>与<code>free</code>相遇为止。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">update-car</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> vector-set!) (<span class="name">reg</span> new-cars) (<span class="name">reg</span> scan) (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">assign</span> old (<span class="name">op</span> vector-ref) (<span class="name">reg</span> new-cdrs) (<span class="name">reg</span> scan))</span><br><span class="line">  (<span class="name">assign</span> relocate-continue (<span class="name">label</span> update-cdr))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> relocate-old-result-in-new))</span><br><span class="line"></span><br><span class="line">update-cdr</span><br><span class="line">  (<span class="name">perform</span></span><br><span class="line">   (<span class="name">op</span> vector-set!) (<span class="name">reg</span> new-cdrs) (<span class="name">reg</span> scan) (<span class="name">reg</span> new))</span><br><span class="line">  (<span class="name">assign</span> scan (<span class="name">op</span> +) (<span class="name">reg</span> scan) (<span class="name">const</span> <span class="number">1</span>))</span><br><span class="line">  (<span class="name">goto</span> (<span class="name">label</span> gc-loop))</span><br></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇算是我写过的比较短的内容了，介绍了一个至今还在服役的算法的基本思想。垃圾收集器无法被调试，且必须保证很高的效率，因此又必须写的小巧精致。后来有人把这个算法改进成了不用停下程序计算也能同时完成垃圾收集的实时垃圾回收机制<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，如果对垃圾回收很感兴趣，不妨可以先从大一统理论<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>开始看起来（笑）。</p>
<p>上面介绍的算法实现上可能会有时想不过来为什么需要复制后不断扫描修改和分配新地址，这也算不上什么巧妙高端的技术，你写二叉树复制或者更宽泛的深拷贝场景的时候肯定遇到过相似的问题，多回去写写自然会明白。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Allen, John. 1978. <a href="https://dl.acm.org/citation.cfm?id=542865" target="_blank" rel="noopener">Anatomy of Lisp</a>. New York: McGraw-Hill</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">Baker Jr, Henry G. <a href="https://dspace.mit.edu/bitstream/handle/1721.1/41976/AI_WP_139.pdf?sequ" target="_blank" rel="noopener">&quot;List processing in real time on a serial computer.&quot;</a> <em>Communications of the ACM</em> 21.4 (1978): 280-294.</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">Bacon, David F., Perry Cheng, and V. T. Rajan. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.439.1202&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">&quot;A unified theory of garbage collection.&quot;</a> ACM SIGPLAN Notices 39.10 (2004): 50-68.</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div>
      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="notebook.xyli.me/SICP/garbage-collection/" data-id="cjq0vbiqv00417cw3m464crwd" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      <!-- 
        <a href="#disqus_thread" class="article-comment-link">
        <i class="fa fa-comment"></i> Comments
        </a>
       -->
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/内存分配/">内存分配</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/垃圾回收/">垃圾回收</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-114/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">LeetCode Weekly Contest 114</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/LeetCode/LeetCode-Weekly-Contest-115/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">LeetCode Weekly Contest 115</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>


<!-- 
<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
 -->

  <div id="comments"></div>
  <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
  <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
  <script>
  var gitment = new Gitment({
    owner: 'Lixinyi-DUT',
    repo: 'TuQiang-Street-301',
    oauth: {
      client_id: '0a613b11d9140b2629e0',
      client_secret: 'b6ee57129a892f87bbac149167a90cf1a8035a47',
      id: 'Thu Dec 13 2018 17:20:53 GMT+0800',
    },
  })
  gitment.render('comments')
  </script>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-toc">
    <h4>概览</h4>
    <ol class="sidebar-module-list"><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#序对和其他数据的向量表示"><span class="sidebar-module-list-number">1.</span> <span class="sidebar-module-list-text">序对和其他数据的向量表示</span></a><ol class="sidebar-module-list-child"><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#列表"><span class="sidebar-module-list-number">1.1.</span> <span class="sidebar-module-list-text">列表</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#栈"><span class="sidebar-module-list-number">1.2.</span> <span class="sidebar-module-list-text">栈*</span></a></li></ol></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#垃圾收集"><span class="sidebar-module-list-number">2.</span> <span class="sidebar-module-list-text">垃圾收集</span></a><ol class="sidebar-module-list-child"><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#Stop-and-copy"><span class="sidebar-module-list-number">2.1.</span> <span class="sidebar-module-list-text">Stop-and-copy</span></a></li><li class="sidebar-module-list-item sidebar-module-list-level-3"><a class="sidebar-module-list-link" href="#实现细节"><span class="sidebar-module-list-number">2.2.</span> <span class="sidebar-module-list-text">实现细节</span></a></li></ol></li><li class="sidebar-module-list-item sidebar-module-list-level-2"><a class="sidebar-module-list-link" href="#小结"><span class="sidebar-module-list-number">3.</span> <span class="sidebar-module-list-text">小结</span></a></li></ol>
  </div>



  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p>失败作者的另一个博客<a href="http://yangzhou301.xyli.me/" style="text-decoration:none;">扬州计划</a> </p><p>谢谢各位长久以来的关怀。</p><p>微信公众号</p><img src="https://github.com/Lixinyi-DUT/Project-Yangzhou/raw/master/notebook/LeetCode/qrcode.png"  style="width:215px;height:215px;" align="middle"><p>联系作者<em><a href="mailto:wolixinyi@gmail.com" style="text-decoration:none;"><i class="fa fa-envelope-o"></i>wolixinyi@gmail.com</a></em></p>
</div>


  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/CS161/">CS161</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Deutsche101/">Deutsche101</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Introduction/">Introduction</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LeetCode/">LeetCode</a><span class="sidebar-module-list-count">57</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/MIT6-042/">MIT6.042</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/SICP/">SICP</a><span class="sidebar-module-list-count">9</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-tags">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/DrRacket/">DrRacket</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LaTeX/">LaTeX</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/continuation/">continuation</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/书评/">书评</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/内存分配/">内存分配</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/函数式编程/">函数式编程</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/动态规划/">动态规划</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/失败/">失败</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/德语/">德语</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/数字电路/">数字电路</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/约束编程/">约束编程</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/组合数学/">组合数学</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/规划问题/">规划问题</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/语种介绍/">语种介绍</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/贪心算法/">贪心算法</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/DrRacket/" style="font-size: 15px;">DrRacket</a> <a href="/tags/LaTeX/" style="font-size: 10px;">LaTeX</a> <a href="/tags/continuation/" style="font-size: 10px;">continuation</a> <a href="/tags/书评/" style="font-size: 10px;">书评</a> <a href="/tags/内存分配/" style="font-size: 10px;">内存分配</a> <a href="/tags/函数式编程/" style="font-size: 20px;">函数式编程</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/垃圾回收/" style="font-size: 10px;">垃圾回收</a> <a href="/tags/失败/" style="font-size: 10px;">失败</a> <a href="/tags/德语/" style="font-size: 10px;">德语</a> <a href="/tags/数字电路/" style="font-size: 10px;">数字电路</a> <a href="/tags/约束编程/" style="font-size: 10px;">约束编程</a> <a href="/tags/组合数学/" style="font-size: 10px;">组合数学</a> <a href="/tags/规划问题/" style="font-size: 10px;">规划问题</a> <a href="/tags/语种介绍/" style="font-size: 10px;">语种介绍</a> <a href="/tags/贪心算法/" style="font-size: 15px;">贪心算法</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/12/">十二月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/11/">十一月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/10/">十月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/09/">九月 2018</a><span class="sidebar-module-list-count">8</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/08/">八月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">七月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">六月 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">五月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">四月 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">三月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/02/">二月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/01/">一月 2018</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/12/">十二月 2017</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/10/">十月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/08/">八月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/07/">七月 2017</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2017/06/">六月 2017</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/10/">十月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2016/09/">九月 2016</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/1990/05/">五月 1990</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module sidebar-recents">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-116/">LeetCode Weekly Contest 116</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-115/">LeetCode Weekly Contest 115</a>
        </li>
      
        <li>
          <a href="/SICP/garbage-collection/">垃圾回收</a>
        </li>
      
        <li>
          <a href="/LeetCode/LeetCode-Weekly-Contest-114/">LeetCode Weekly Contest 114</a>
        </li>
      
        <li>
          <a href="/SICP/the-structure-and-interpretation-of-register-machine/">寄存机器的构造与解释</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018 Xinyi Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  
<script>
  var disqus_shortname = 'notebook-xyli-me';
  
  var disqus_url = 'notebook.xyli.me/SICP/garbage-collection/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/github.min.css" integrity="sha384-WtUWHyk39lfUpZQVgokNfSKCJaKAeD6adgLduBLrKTMUuPzFhLtL23y1guFy6lZn" crossorigin="anonymous">
  <script src="/highlight/highlight.pack.js"></script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
